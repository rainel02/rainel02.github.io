<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>软院大二上复习资料</title>
    <link href="/2025/01/10/LE-ThirdSemester/"/>
    <url>/2025/01/10/LE-ThirdSemester/</url>
    
    <content type="html"><![CDATA[<p>一些本学期的笔记 ##### 算法 <ahref="/downloads/SUANFA.pdf">复习笔记</a></p><h5 id="co">CO</h5><p><a href="/downloads/CO.pdf">复习笔记</a></p><h5 id="oop">OOP</h5><p><a href="/downloads/OOP-easy.pdf">复习笔记-简洁版</a> <ahref="/downloads/OOP.pdf">复习笔记-完整版</a></p><h5 id="概统">概统</h5><p><a href="/downloads/GAITONG.pdf">复习笔记</a></p><h5 id="离散">离散</h5><p><a href="/downloads/LISAN-easy.pdf">复习笔记-简洁版</a> <ahref="/downloads/LISAN-KNOWLEDGE.pdf">复习笔记-知识点</a> <ahref="/downloads/LISAN-QUESTION.pdf">复习笔记-问题</a></p><h5 id="基物实验">基物实验</h5><p><a href="/downloads/JWSY.pdf">复习笔记</a></p>]]></content>
    
    
    <categories>
      
      <category>学习经验</category>
      
      <category>大二上</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习经验</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【学习经验】OOP复习</title>
    <link href="/2025/01/10/LE-OOP1/"/>
    <url>/2025/01/10/LE-OOP1/</url>
    
    <content type="html"><![CDATA[<h2 id="java基础-23">1 java基础 23</h2><h3 id="关键字和保留字">1.1 关键字和保留字</h3><p><img src="/img/LE-OOP1/1.png" /></p><h3 id="浅拷贝深拷贝引用">1.2 浅拷贝、深拷贝、引用</h3><ul><li><strong>基本数据类型</strong>（如 <code>int</code><code>long long</code> <code>boolean</code>）都是<strong>深拷贝</strong>：复制内容</li><li><strong>类</strong>的拷贝默认是<strong>浅拷贝</strong>（拷贝引用），需要深拷贝可以使用 <code>clone()</code> 方法、序列化机制或手动创建新的对象。<img src="/img/LE-OOP1/2.png" /> 【输出】5 <imgsrc="/img/LE-OOP1/3.png" /> 【输出】10</li></ul><h3 id="构造与垃圾回收">1.3 构造与垃圾回收</h3><h5 id="构造函数">构造函数</h5><ul><li>特点：与类同名，无返回值（也不是 void）、多数情况要重载</li><li><strong>new</strong>的作用：<strong>分配空间；调用构造；返回引用</strong></li></ul><h6 id="不带参数构造函数默认构造函数">不带参数构造函数/默认构造函数</h6><ul><li>如果类的定义者<strong>没有显式的定义任何构造方法</strong>，系统将自动提供一个<strong>默认的构造方法（无参无方法）</strong>；如果定义了构造函数，则不会创建默认构造方法。</li><li>无参构造函数创建对象时，成员变量的值被赋予了数据类型的<strong>隐含初值</strong>。</li></ul><h6 id="带参数构造函数">带参数构造函数</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Teacher6</span> &#123;<br><span class="hljs-keyword">private</span> String name;<span class="hljs-comment">// 教员姓名</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<span class="hljs-comment">// 年龄   </span><br><span class="hljs-keyword">private</span> String education;<span class="hljs-comment">// 学历</span><br><span class="hljs-keyword">private</span> String position;<span class="hljs-comment">// 职位</span><br><span class="hljs-comment">// 带参数的构造方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Teacher6</span><span class="hljs-params">(String pName,<span class="hljs-type">int</span> pAge,String pEducation,String pPosition)</span> &#123;<br>        name = pName;<br>        age = pAge;    <span class="hljs-comment">// 可以增加对age等属性的存取限制条件</span><br>        education = pEducation;<br>        position = pPosition;<br>    &#125;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">introduction</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;大家好！我是&quot;</span> + name + <span class="hljs-string">&quot;，我今年&quot;</span> + age + <span class="hljs-string">&quot;岁，学历&quot;</span> + education + <span class="hljs-string">&quot;，目前职位是&quot;</span>+position;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Teacher6Test</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Teacher6</span> <span class="hljs-variable">teacher</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Teacher6</span>(<span class="hljs-string">&quot;Mary&quot;</span>, <span class="hljs-number">23</span>, <span class="hljs-string">&quot;本科&quot;</span>, <span class="hljs-string">&quot;咨询师&quot;</span>);<br>        System.out.println(teacher.introduction());<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="垃圾内存自动回收机制">垃圾内存自动回收机制</h5><ul><li>垃圾自动回收机制（Garbage Collection）：Java 虚拟机后台线程负责</li><li>System.gc() 和 Runtime.gc()</li><li>判断存储单元是否为垃圾的依据：<strong>引用计数为 0</strong></li></ul><h3 id="匿名对象">1.4 匿名对象</h3><ul><li>匿名对象：无管理者（无栈内存引用指向它）</li><li>使用场景：<strong>只需要进行一次方法调用</strong> /<strong>作为参数</strong>传递给函数 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Student</span> <span class="hljs-variable">stu</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<span class="hljs-comment">//stu是对象，名字是stu</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<span class="hljs-comment">//这个也是一个对象，但是没有名字，称为匿名对象</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>().show(); <span class="hljs-comment">//匿名对象方法调用</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="类的定义">1.5 <spanstyle="background:rgba(140, 140, 140, 0.12)">类的定义</span></h3><h6 id="类的定义-1">类的定义</h6><ul><li>类的定义格式 <img src="/img/LE-OOP1/4.png" /></li><li>访问控制符：<code>public</code>或默认（即没有访问控制符）<code>public</code>类一般含有<code>main</code>方法</li><li>类型说明符：<code>final</code>和<code>abstract</code></li></ul><h6 id="成员变量定义">成员变量定义</h6><ul><li>定义格式：<code>[修饰符] 变量的数据类型 变量名[=初始值]</code></li><li>常用的修饰符：<code>this</code>、<code>static</code>、<code>public</code>、<code>private</code>、<code>protected</code>、默认</li></ul><h6 id="成员方法的定义">成员方法的定义</h6><ul><li>定义格式 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"> [修饰符] 返回值类型 方法名([形参说明])[thorws 例外名<span class="hljs-number">1</span>，例外名<span class="hljs-number">2.</span>..]&#123;<br>局部变量声明;<br>执行语句组;<br> &#125;<br></code></pre></td></tr></table></figure></li><li>常用的修饰符：<code>public</code>、<code>private</code>、<code>protected</code>、<code>static</code>、<code>final</code></li></ul><h6 id="成员变量vs局部变量">成员变量vs局部变量</h6><ul><li>初始化不同：<strong>自动初始化只用于成员变量</strong>；方法体中的局部变量不能被自动初始化，必须赋值后才能使用。</li><li>定义的位置不同：定义在类中的变量是成员变量；定义在方法中或者{}语句里面的变量是局部变量。</li><li>在内存中的位置不同：<strong>成员变量</strong>存储在<strong>堆</strong>内存的对象中；<strong>局部变量</strong>存储在<strong>栈</strong>内存的方法中。</li><li>声明周期不同：成员变量<strong>随着对象</strong>的出现而出现在堆中，随着对象的消失而从堆中消失；局部变量<strong>随着方法</strong>的运行而出现在栈中，随着方法的弹栈而消失。</li></ul><h6 id="方法的重载">方法的重载</h6><ol type="1"><li>方法的重载是指一个类中可以定义有<strong>相同的名字</strong>，但<strong>参数不同</strong>的多个方法，调用时会根据不同的参数表选择对应的方法。</li><li>重载方法必须满足以下条件：<ul><li>方法名相同。</li><li>方法的<strong>参数类型、个数、顺序</strong>至少有一项不相同。</li><li>方法的<strong>返回类型可以</strong>不相同。</li><li>方法的<strong>修饰符可以</strong>不相同。</li></ul></li><li>调用重载方法时，Java使用参数的类型和数量决定实际调用重载方法的哪个版本。</li></ol><h3 id="tostring方法">1.6 <spanstyle="background:rgba(140, 140, 140, 0.12)">toString()方法</span></h3><ul><li>在java中，所有对象都有默认的<code>toString()</code>这个方法</li><li>创建类时没有定义<code>toString()</code>方法，输出对象时会输出对象的哈希码值（<strong>对象的内存地址</strong>）</li><li>它通常只是为了方便输出，比如<code>System.out.println(xx)</code>，（xx是对象），括号里面的”xx”如果不是String类型的话，就自动调用xx的<code>toString()</code>方法</li><li><code>toString()</code>的定义格式 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-keyword">return</span> 字符串;<span class="hljs-comment">// 方法体</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="静态属性和静态方法">1.7 静态属性和静态方法</h3><p><img src="/img/LE-OOP1/5.png" /> + 用 <code>static</code> 修饰 +不创建具体对象也存在，此时可以通过 <code>类名.类变量</code> 或<code>类名.类方法</code> + 静态方法与非静态方法的区别 +静态方法是在类中使用staitc修饰的方法，在<strong>类定义</strong>的时候已经被<strong>装载和分配</strong>(早加载)。而非静态方法是不加static关键字的方法，在类定义时没有占用内存，只有在类被<strong>实例化成对象时</strong>，对象调用该方法才被<strong>分配内存</strong>（晚加载）。+<strong>静态方法</strong>中<strong>只能直接调用静态成员或者方法</strong>，不能直接调用非静态方法或者非静态成员（非静态方法要被实例化才能被静态方法调用），而非静态方法既可以调用静态成员或者方法又可以调用其他的非静态成员或者方法。</p><ul><li>静态代码块<ul><li>静态代码块只能定义在类里面，它独立于任何方法，<strong>不能定义在方法里面</strong>。</li><li>静态代码块里面声明的变量都是局部变量，只在<strong>本块内有效</strong>。</li><li>静态代码块会在<strong>类被加载时自动执行</strong>，而无论加载者是JVM还是其他的类。</li><li>一个类中允许定义多个静态代码块，<strong>执行的顺序根据定义的顺序进行</strong>。</li><li>静态代码块只能访问类的<strong>静态成员</strong>，而不允许访问实例成员。</li></ul></li><li>静态代码块与非静态代码块的不同点：<ul><li>静态代码块在非静态代码块之前执行：静态代码块—&gt;非静态代码块—&gt;构造方法</li><li>静态代码块<strong>只在第一次new执行一次</strong>，之后不再执行，而非静态代码块在每new一次就执行一次</li></ul></li></ul><h6 id="例静态方法">例：静态方法</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span>&#123;    <span class="hljs-comment">// 非静态方法</span><br><span class="hljs-keyword">return</span> a+b;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> (sum1, <span class="hljs-number">2</span>);    <span class="hljs-comment">// 静态方法调用非静态方法，报错</span><br>System.out.println(<span class="hljs-string">&quot;result=&quot;</span>+result);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="例静态代码块">例：静态代码块</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PuTong</span>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">PuTong</span><span class="hljs-params">()</span>&#123;<br>System.out.println(<span class="hljs-string">&quot;默认构造方法！--&gt;&quot;</span>);<br>&#125;<br><span class="hljs-comment">// 非静态代码块</span><br>&#123;<br>System.out.println(<span class="hljs-string">&quot;非静态代码块！--&gt;&quot;</span>);<br>&#125;<br><span class="hljs-comment">// 静态代码块</span><br><span class="hljs-keyword">static</span>&#123;<br>System.out.println(<span class="hljs-string">&quot;静态代码块！--&gt;&quot;</span>);<br>&#125;<br><span class="hljs-comment">// 静态成员方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br>System.out.println(<span class="hljs-string">&quot;普通方法中的代码块！--&gt;&quot;</span>);<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br><span class="hljs-type">PuTong</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PuTong</span>();<br>c1.test();<br><span class="hljs-type">PuTong</span> <span class="hljs-variable">c2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PuTong</span>();<br>c2.test();<br>&#125;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">【输出】</span><br><span class="hljs-comment">静态代码块！--&gt;</span><br><span class="hljs-comment">非静态代码块！--&gt;</span><br><span class="hljs-comment">默认构造方法！--&gt;</span><br><span class="hljs-comment">普通方法中的代码块！--&gt;</span><br><span class="hljs-comment">非静态代码块！--&gt;</span><br><span class="hljs-comment">默认构造方法！--&gt;</span><br><span class="hljs-comment">普通方法中的代码块！--&gt;</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h3 id="equals-和">1.8 <code>equals</code> 和 <code>==</code></h3><ul><li>比较<strong>对象</strong>的equals和==是等价的，判断<strong>是不是引用的同一个对象</strong>。</li><li><strong>String</strong>的<strong>equals</strong>只看<strong>字符串内容</strong>是否相等，而==还得看是不是<strong>同一个对象</strong>。（覆盖了Object类的equals()方法，java.io.File、java.util.Date、包装类（如java.lang.Integer和java.lang.Double类等）同理）<img src="/img/LE-OOP1/6.png" /></li></ul><blockquote><p><code>Integer a = 1;</code> <code>Integer b = 1;</code><code>System.out.println(a == b); // 输出 true</code>这行输出 <code>true</code> 是因为 <code>Integer</code> 有一个缓存机制，对于 <code>-128</code> 到 <code>127</code> 之间的整数，<code>Integer</code> 会缓存这些值的实例。当你使用 <code>Integer a = 1;</code> 和 <code>Integer b = 1;</code> 这样的方式创建对象时，<code>a</code> 和 <code>b</code> 实际上指向了缓存中的同一个 <code>Integer</code> 实例。因此，<code>a == b</code> 比较的是同一个实例的引用，结果为 <code>true</code>。1.<strong>Byte</strong>：由于Byte的值范围在-128到127之间，所以所有的Byte值都被缓存。2.<strong>Short</strong>和<strong>Integer</strong>：这两个类的缓存机制类似，都有默认的缓存范围，通常是-128到127。但是这个范围是可以调整的，通过JVM参数可以设置缓存的最大值。3.<strong>Long</strong>：Long类型也有缓存机制，但是默认的缓存范围比较小，通常是-128到127。同样，这个范围也可以通过JVM参数进行调整。4.<strong>Character</strong>：Character类型缓存了ASCII字符，即0到127的字符。5.<strong>Boolean</strong>：Boolean类型比较特殊，它只有两个值true和false，这两个值都是缓存好的。6.<strong>Float</strong>和<strong>Double</strong>：这两个类型没有缓存机制，因为浮点数的取值范围非常大，缓存所有的值是不现实的## 2 封装 4 ### 2.1 封装的含义</p></blockquote><ol type="1"><li>一层含义是<strong>把对象的属性和行为看成为一个密不可分的整体</strong>，将这两者封装在一个不可分割的独立单位（即对象）中。</li><li>另一层含义指<strong>信息隐藏</strong>，把不需要让外界知道的信息隐藏起来，有些对象的属性及行为允许外界用户知道或使用，但不允许更改，而另一些属性和行为则不允许外界知晓或只允许使用对象的功能，而尽可能隐藏对象的功能实现细节。</li></ol><h3 id="信息隐藏的必要性">2.2 信息隐藏的必要性</h3><p>成员变量封装加上<code>private</code>，对外提供公开的用于设置对象属性的<code>public</code> 方法，并在方法中加上逻辑判断，过滤掉非法数据，从而：+ <strong>隐藏了类的具体实现</strong> + <strong>操作简单</strong> +<strong>提高对象数据的安全性</strong> +<strong>减少了冗余代码</strong>，数据校验等写在方法里，可以复用</p><h3 id="访问控制修饰符">2.3 <spanstyle="background:#ff4d4f">访问控制修饰符</span></h3><p>访问控制分四种类别： + 公开 <code>public</code> 对外公开。 + 受保护<code>protected</code>向<strong>子类</strong>以及<strong>同一个包中的类</strong>公开。 + 默认向<strong>同一个包中的类</strong>公开。 + 私有 <code>private</code>只有类本身可以访问，不对外公开</p><table><thead><tr class="header"><th>修饰符</th><th>同一个类</th><th>同一个包</th><th>子类</th><th>整体</th></tr></thead><tbody><tr class="odd"><td><code>private</code></td><td>yeah</td><td></td><td></td><td></td></tr><tr class="even"><td><code>default</code></td><td>yeah</td><td>yeah</td><td></td><td></td></tr><tr class="odd"><td><code>protected</code></td><td>yeah</td><td>yeah</td><td>yeah</td><td></td></tr><tr class="even"><td><code>public</code></td><td>yeah</td><td>yeah</td><td>yeah</td><td>yeah</td></tr></tbody></table><h4 id="protected">2.3.1 <code>protected</code></h4><h6 id="包内可见">1 包内可见</h6><h6id="子类可见子类和父类在同一个包通过自己访问通过父类访问在不同包仅可通过自己访问">2子类可见（子类和父类在同一个包：通过自己访问、通过父类访问。在不同包：仅可通过自己访问。）</h6><p>若子类与父类<strong>不在同一包</strong>中，那么在子类中 +<strong>子类实例</strong>可以访问其从父类继承而来的<code>protected</code>方法+ 不能访问<strong>父类实例</strong>的<code>protected</code>方法 +不能通过<strong>另一个子类引用</strong>访问共同基类的<code>protected</code>方法。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 父类</span><br><span class="hljs-keyword">package</span> com.protectedaccess.parentpackage;  <br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Parent</span>&#123;  <br><span class="hljs-keyword">protected</span> <span class="hljs-type">String</span> <span class="hljs-variable">protect</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;protect field&quot;</span>;  <br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getMessages</span><span class="hljs-params">()</span>&#123;  <br>System.out.println(<span class="hljs-string">&quot;i am parent&quot;</span>);  <br>&#125;  <br>&#125;<br></code></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 不同包下，可以访问其从父类继承而来的`protected`方法</span><br><span class="hljs-keyword">package</span> com.protectedaccess.parentpackage.sonpackage1;  <br><span class="hljs-keyword">import</span> com.protectedaccess.parentpackage.Parent;  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">son1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Parent</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>        <span class="hljs-type">Son1</span> <span class="hljs-variable">son1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Son1</span>();  <br>        son1.getMessage();  <span class="hljs-comment">// 输出：i am parent  </span><br>    &#125;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">message</span><span class="hljs-params">()</span> &#123;  <br>        getMessage();  <span class="hljs-comment">// 如果子类重写了该方法，则输出重写方法中的内容  </span><br>        <span class="hljs-built_in">super</span>.getMessage();  <span class="hljs-comment">// 输出父类该方法中的内容  </span><br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 不同包下，不能访问**父类实例**的`protected`方法</span><br><span class="hljs-keyword">package</span> com.protectedaccess.parentpackage.sonpackage1;  <br><span class="hljs-keyword">import</span> com.protectedaccess.parentpackage.Parent;  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">son1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Parent</span> &#123;  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br><span class="hljs-type">Parent</span> <span class="hljs-variable">parent1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Parent</span>();  <br><span class="hljs-comment">// parent1.getMessage(); // 错误  </span><br><span class="hljs-type">Parent</span> <span class="hljs-variable">parent2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Parent</span>();  <br><span class="hljs-comment">// parent2.getMessage(); // 错误  </span><br>&#125;  <br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 不同包下，不能通过**另一个子类引用**访问共同基类的`protected`方法。</span><br><span class="hljs-keyword">package</span> com.protectedaccess.parentpackage.sonpackage2;  <br><span class="hljs-keyword">import</span> com.protectedaccess.parentpackage.Parent;  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">son2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Parent</span> &#123;  <br>  <br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.protectedaccess.parentpackage.sonpackage1;  <br><span class="hljs-keyword">import</span> com.protectedaccess.parentpackage.Parent;  <br><span class="hljs-keyword">import</span> com.protectedaccess.parentpackage.sonpackage2.Son2;  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">son1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Parent</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>        <span class="hljs-type">Son2</span> <span class="hljs-variable">son2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Son2</span>();  <br>        <span class="hljs-comment">// son2.getMessage();  // 错误  </span><br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><h6 id="protected-的-static-成员对所有子类可见">3 protected 的 static成员对所有子类可见。</h6><p>对于<code>protected</code>修饰的静态变量，无论是否同一个包，在子类中均可直接访问；在不同包的非子类中则不可访问。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 父类</span><br><span class="hljs-keyword">package</span> com.protectedaccess.parentpackage;  <br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Parent</span>&#123;  <br><span class="hljs-keyword">protected</span> <span class="hljs-type">String</span> <span class="hljs-variable">protect</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;protect field&quot;</span>;  <br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getMessages</span><span class="hljs-params">()</span>&#123;  <br>System.out.println(<span class="hljs-string">&quot;i am parent&quot;</span>);  <br>&#125;  <br>&#125;<br></code></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 无论是否同一个包，在子类中均可直接访问</span><br><span class="hljs-keyword">package</span> com.protectedaccess.parentpackage.sonpackage1;  <br><span class="hljs-keyword">import</span> com.protectedaccess.parentpackage.Parent;  <br>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">son3</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Parent</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>        Parent.getMessage();    <span class="hljs-comment">// 输出：i am parent  </span><br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 在不同包的非子类中则不可访问</span><br><span class="hljs-keyword">package</span> com.protectedaccess.parentpackage.sonpackage1;  <br><span class="hljs-keyword">import</span> com.protectedaccess.parentpackage.Parent;  <br>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">son4</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>        <span class="hljs-comment">// Parent.getMessage();    // 错误  </span><br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="继承-5">3 继承 5</h2><ul><li><strong>定义</strong>:继承是允许创建新的类（子类）来继承现有类（父类）的属性和行为的能力。</li><li><strong>目的</strong>:<ul><li><strong>代码复用</strong>:子类可以继承父类的所有属性和方法，无需重复编写代码，提高代码的可重用性。</li><li><strong>扩展功能</strong>:子类可以添加新的属性和方法，或重写父类的方法，扩展父类的功能。</li><li><strong>层次结构</strong>:继承可以创建类层次结构，清晰地表达类之间的关系，使代码更易于理解和维护。</li></ul></li><li><strong>类型</strong>:<ul><li><strong>单继承</strong>: 一个子类只有一个父类。</li><li><strong>多继承</strong>: 一个子类可以有多个父类（Java不支持多继承）。</li><li><strong>接口继承</strong>:子接口可以继承父接口的方法，并添加新的方法。 <imgsrc="/img/LE-OOP1/7.png" /> <img src="/img/LE-OOP1/8.png" /> <imgsrc="/img/LE-OOP1/9.png" /></li></ul></li></ul><h2 id="多态-6">4 多态 6</h2><ul><li><p><strong>定义</strong>:多态是指同一个行为具有多个不同表现形式或形态的能力。</p></li><li><p><strong>目的</strong>:</p><ul><li><strong>灵活性</strong>:允许以统一的方式处理不同类型的对象，提高代码的灵活性和可扩展性。</li><li><strong>抽象性</strong>:可以隐藏对象的实际类型，只关注其共同的行为，提高代码的抽象性。</li></ul></li><li><p><strong>实现方式</strong>:</p><ul><li><strong>方法重载</strong>:在同一个类中，可以有多个同名但参数类型或数量不同的方法。</li><li><strong>方法重写</strong>:子类可以重写父类的方法，提供不同的实现。</li><li><strong>接口</strong>:接口定义了一组方法，不同的类可以实现同一个接口，并提供不同的实现。 ###4.1 多态</li></ul></li><li><p>多态：<strong>用相同的名称来表示不同的含义</strong></p></li><li><p><strong>静多态</strong>：在<strong>编译</strong>时决定调用哪个方法；<strong>方法重载、方法隐藏</strong></p><ul><li><strong>方法重载(Overloading)</strong><ul><li>方法名相同，<strong>参数个数</strong>、<strong>参数类型</strong>及<strong>参数顺序</strong>至少有一个不同</li><li>返回值类型与访问权限修饰符可以相同也可以不同 <imgsrc="/img/LE-OOP1/10.png" /></li></ul></li><li><strong>方法隐藏</strong>：子类定义了一个与父类<strong>同名同参数列表</strong>的<strong>静态/私有</strong>方法（相当于一个新方法）<img src="/img/LE-OOP1/11.png" /></li></ul></li><li><p><strong>动多态</strong>：在<strong>运行</strong>时才能确定调用哪个方法；<strong>方法覆盖</strong></p><ul><li>3个条件：<strong>继承、覆盖、向上转型</strong>（必须由父类的引用指向派生类的实例，并且通过父类的引用调用被覆盖的方法）</li><li><strong>方法覆盖(Override)</strong><ul><li>方法名、参数个数、参数类型及参数顺序必须一致</li><li><strong>异常抛出范围</strong>：子类 <spanclass="math inline">\(\le\)</span> 父类</li><li><strong>访问权限</strong>：子类 <spanclass="math inline">\(\ge\)</span> 父类</li><li><strong>私有方法、静态方法不能被覆盖</strong>，如果在子类出现了同签名的方法，那是方法隐藏；</li></ul></li></ul></li><li><p><strong>多态中成员变量编译运行看左边，多态中成员方法编译看左边，运行看右边</strong><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// **多态中成员变量编译运行看左边**</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Parent</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Child</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Parent</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Parent</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child</span>();<br>        System.out.println(p.value); <span class="hljs-comment">// 输出 10，因为编译和运行时都看左边（Parent类）</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// **多态中成员方法编译看左边，运行看右边**</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Parent</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">display</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Parent display&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Child</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Parent</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">display</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Child display&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Parent</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child</span>();<br>        p.display(); <span class="hljs-comment">// 编译时看左边（Parent类），运行时看右边（Child类），输出 &quot;Child display&quot;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p></li><li><p>抽象类</p><ul><li><code>abstract</code> 语义为“尚未实现”</li><li>如果一个类继承自某个抽象父类，而没有具体实现抽象父类中的抽象方法，则必须定义为抽象类</li><li>抽象类引用：虽然<strong>不能实例化抽象类</strong>，但可以<strong>创建它的引用</strong>。因为Java支持多态性，允许通过父类引用来引用子类的对象。</li><li>如果一个类里有抽象的方法，则这个类就必须声明成抽象的。<strong>但一个抽象类中却可以没有抽象方法</strong>。</li></ul></li><li><p>抽象方法</p><ul><li>无函数体</li><li>必须在抽象类中</li><li>必须在子类中实现，除非子类也是抽象的</li><li>不能被<strong>private、final或static</strong>修饰。</li></ul></li></ul><h3 id="接口">4.2 接口</h3><h4 id="定义">4.2.1 定义</h4><ul><li>接口：不相关类的功能继承。<ul><li>只包含<strong>常量</strong>（所有变量默认<code>public static final</code>）和<strong>方法</strong>（默认<code>public abstract</code>）的定义，没有方法的实现。（但一般不包含变量）</li><li><strong>没有构造方法</strong></li><li>一个类可以实现多个接口；如果类没有实现接口的全部方法。需要被定义成<code>abstract</code> 类</li><li>接口的方法体还可以由其他语言写，此时接口方法需要用<code>native</code> 修饰</li><li>接口可以继承，而且可以多重继承<ul><li>同一个函数只能实现一次</li><li>不同接口的同名变量相互隐藏</li><li>接口变量和类中成员同名时，存在作用域问题</li></ul></li></ul></li><li>关键词 <code>interface</code> <code>implements</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">[<span class="hljs-keyword">public</span>] [interface] 接口名称 [extends 父接口名列表]&#123;<br><span class="hljs-comment">// 静态常量</span><br>[<span class="hljs-keyword">public</span>][<span class="hljs-keyword">static</span>][<span class="hljs-keyword">final</span>]数据类型 变量名=常量名；<br><span class="hljs-comment">//抽象方法</span><br>[<span class="hljs-keyword">public</span>][<span class="hljs-keyword">abstract</span>][<span class="hljs-keyword">native</span>]返回值类型 方法名（参数列表）；<br>&#125;<br><br>[修饰符] class类名 [extends父类名] [implements接口A,接口B,…]&#123;<br>类的成员变量和成员方法；<br>为接口A中的所有方法编写方法体，实现接口A;<br>为接口B中的所有方法编写方法体，实现接口B;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Flyer</span>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">takeOff</span><span class="hljs-params">()</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">land</span><span class="hljs-params">()</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fly</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Bird</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Flyer</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">takeOff</span><span class="hljs-params">()</span> &#123; <span class="hljs-comment">/* take- off implementation */</span> &#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">land</span><span class="hljs-params">()</span> &#123; <span class="hljs-comment">/* landing implementation */</span> &#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fly</span><span class="hljs-params">()</span> &#123; <span class="hljs-comment">/* fly implementation */</span> &#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">buildNest</span><span class="hljs-params">()</span> &#123; <span class="hljs-comment">/* nest building behavior */</span> &#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">layEggs</span><span class="hljs-params">()</span> &#123; <span class="hljs-comment">/* egg laying behavior */</span> &#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span> &#123; <span class="hljs-comment">/* override eating behavior */</span> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 不同接口的同名变量相互隐藏</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">legs</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 假设动物默认没有腿</span><br>&#125;<br><br>interface 昆虫 &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">legs</span> <span class="hljs-operator">=</span> <span class="hljs-number">6</span>; <span class="hljs-comment">// 昆虫有6条腿</span><br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Spider</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Animal</span>,昆虫 &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printLegs</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Animal legs: &quot;</span> + Animal.legs); <span class="hljs-comment">// 调用Animal接口中的legs变量</span><br>        System.out.println(<span class="hljs-string">&quot;昆虫 legs: &quot;</span> +昆虫.legs); <span class="hljs-comment">// 调用昆虫接口中的legs变量</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Spider</span> <span class="hljs-variable">spider</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Spider</span>();<br>        spider.printLegs();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 接口变量和类中成员同名时，存在作用域问题</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Animal&quot;</span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Dog&quot;</span>; <span class="hljs-comment">// Dog类中定义了与接口同名的变量</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printName</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(name); <span class="hljs-comment">// 这将打印&quot;Dog&quot;</span><br>        System.out.println(Animal.name); <span class="hljs-comment">// 这将打印&quot;Animal&quot;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="使用接口">4.2.2 使用接口</h4><ul><li>接口用作类型<ul><li>声明格式：<code>接口 变量名</code> (又称为引用)</li><li>接口做参数：如果一个方法的参数是接口类型，就可以将任何实现该接口的类的实例的引用传递给接口参数，那么接口参数就可以回调类实现的接口方法。</li></ul></li><li>接口回调<ul><li>把实现某一接口的类创建的<strong>对象引用</strong>赋给该接口声明的<strong>接口变量</strong></li><li>该接口变量就可以<strong>调用被类实现的接口中的方法</strong>。</li><li>即： <code>接口变量 = 实现该接口的类所创建的对象；</code><code>接口变量.接口方法([参数列表])</code>；</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Runner</span> &#123;<br><span class="hljs-comment">//接口１</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Swimmer</span> &#123;<br><span class="hljs-comment">//接口２</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swim</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runner</span>,Swimmer &#123; <span class="hljs-comment">//继承类，实现接口</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;我是飞毛腿,跑步速度极快!&quot;</span>);<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swim</span><span class="hljs-params">()</span>&#123;<br>System.out.println(<span class="hljs-string">&quot;我游泳技术很好,会蛙泳、自由泳、仰泳、蝶泳...&quot;</span>);<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span>&#123;<br>System.out.println(<span class="hljs-string">&quot;我牙好胃好,吃啥都香!&quot;</span>);<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InterfaceTest</span>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">m1</span><span class="hljs-params">(Runner r)</span> &#123; r.run(); &#125; <span class="hljs-comment">//接口作参数</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">m2</span><span class="hljs-params">(Swimmer s)</span> &#123;s.swim();&#125; <span class="hljs-comment">//接口作参数</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">m3</span><span class="hljs-params">(Animal a)</span> &#123;a.eat();&#125; <span class="hljs-comment">//抽象类引用</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String args[])</span>&#123;<br><span class="hljs-type">InterfaceTest</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterfaceTest</span>();<br><span class="hljs-type">Person</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>t.m1(p); <span class="hljs-comment">//接口回调</span><br>t.m2(p); <span class="hljs-comment">//接口回调</span><br>t.m3(p); <span class="hljs-comment">//接口回调</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="抽象类与接口">4.2.4 抽象类与接口</h4><ul><li>区别<ul><li>接口中的成员<strong>变量和方法</strong>只能是 <code>public</code>类型的，而抽象类中的成员变量和方法可以处于各种访问级别。</li><li>接口中的<strong>成员变量</strong>只能是<code>public</code>、<code>static</code> 和 <code>final</code>类型的，而在抽象类中可以定义各种类型的实例变量和静态变量。</li><li>接口中没有<strong>构造方法</strong>，抽象类中有构造方法。接口中所有方法都是抽象方法，抽象类中可以有，也可以没有抽象方法。抽象类比接口包含了更多的实现细节。</li><li>抽象类是某一类事物的一种抽象，而接口不是类，它<strong>只定义了某些行为</strong>；例如，“生物”类虽然抽象，但有“狗”类的雏形，接口中的run方法可以由狗类实现，也可以由汽车实现。</li><li>在语义上，接口表示更高层次的抽象，声明系统对外提供的服务。而抽象类则是各种具体类型的抽象。</li></ul></li></ul><h4 id="native关键字">4.2.5 <spanstyle="background:rgba(92, 92, 92, 0.2)">Native关键字</span></h4><ul><li>Native用来声明一个方法是由机器相关的语言（如C/C++语言）实现的。通常，native方法用于一些比较消耗资源的方法，该方法用c或其他语言编写，可以提高速度。</li><li>native定义符说明该方法是一个使用本地其他语言编写的非java类库的方法，它是调用的本地（也就是当前操作系统的方法或动态连接库）。最常见的就是c/c++封装的DLL里面的方法，这是java的JNI技术。它在类中的声明和抽象方法一样没有方法体。</li></ul><h3 id="upcasting-和-downcasting">4.3 upcasting 和 downcasting</h3><h4 id="向上转型-upcasting">4.3.1 向上转型 upcasting</h4><ul><li><p>向上转型：当有<strong>子类对象赋值给一个父类引用</strong>时，便是向上转型，多态本身就是向上转型的过程。</p></li><li><p>使用格式： 父类类型 变量名 = new 子类类型(); 如：Person p = newStudent();</p></li><li><p>上转型对象的使用(父类有的就能访问，没有的不能访问，且儿子的优先级更高)</p><ul><li>上转型对象可以<strong>访问子类继承或隐藏的成员变量</strong>，也可以<strong>调用子类继承的方法或子类重写的实例方法</strong>。</li><li>如果子类重写了父类的某个实例方法后，当用上转型对象调用这个实例方法时一定是<strong>调用了子类重写的实例方法</strong>。</li><li>上转型对象<strong>不能操作子类新增</strong>的成员变量；<strong>不能调用子类新增</strong>的方法。</li></ul></li></ul><h4 id="向下转型-downcasting">4.3.2 向下转型 downcasting</h4><ul><li>向下转型(映射)：一个<strong>已经向上转型的子类对象</strong>可以使用强制类型转换的格式，<strong>将父类引用转为子类引用</strong>，这个过程是向下转型。</li><li>使用格式： <code>子类类型 变量名 = (子类类型) 父类类型的变量;</code>如：Person p = new Student(); Student stu = (Student) p</li><li>如果是<strong>直接创建父类对象，是无法向下转型的</strong>，能过编译，但运行时会产生异常 如：Person p = new Peron(); Student stu =(Student) p</li></ul><h5 id="instanceof-操作符">instanceof 操作符</h5><ul><li><code>instanceof</code>操作符用于判断一个引用类型所<strong>引用的对象是否是一个类的实例</strong>。<code>instanceof</code>运算符是Java独有的双目运算符</li><li><code>instanceof</code>操作符左边的操作元是一个引用类型的对象（可以是null），右边的操作元是一个类名或接口名。</li><li>形式如下：<code>obj instanceof ClassName</code> 或者<code>obj instanceof InterfaceName</code></li><li><code>a instanceof X</code>，当 X 是<strong>A类/A类的直接或间接父类/A类实现的接口</strong>时，表达式的值为true</li></ul><h2 id="object类最终类内部类匿名类-10">5Object类、最终类、内部类、匿名类 10</h2><h3 id="object类">5.1 Object类</h3><ul><li>基于多态的特性，该类可以用来代表任何一个类，因此允许<strong>把任何类型的对象赋给Object类型的变量</strong>，也可以作为方法的参数、方法的返回值</li></ul><h5id="public-final-class-getclass"><code>public final Class&lt;?&gt; getClass()&#123;&#125;</code></h5><ul><li>该方法用于获取对象运行时的字节码类型，得到该对象的<strong>运行时的真实类型</strong>。</li><li>通常用于判断<strong>两个引用中实际存储对象类型</strong>是否一致。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br>    <span class="hljs-comment">// 类的成员变量和方法</span><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AnotherClass</span> &#123;<br>    <span class="hljs-comment">// 另一个类的成员变量和方法</span><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TypeComparisonExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">MyClass</span> <span class="hljs-variable">obj1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyClass</span>();<br>        <span class="hljs-type">MyClass</span> <span class="hljs-variable">obj2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyClass</span>();<br>        <span class="hljs-type">AnotherClass</span> <span class="hljs-variable">obj3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AnotherClass</span>();<br><br>        <span class="hljs-comment">// 比较obj1和obj2是否指向相同类型的对象</span><br>        <span class="hljs-keyword">if</span> (obj1.getClass() == obj2.getClass()) &#123;<br>            System.out.println(<span class="hljs-string">&quot;obj1和obj2指向相同类型的对象&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;obj1和obj2指向不同类型的对象&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">// 比较obj1和obj3是否指向相同类型的对象</span><br>        <span class="hljs-keyword">if</span> (obj1.getClass() == obj3.getClass()) &#123;<br>            System.out.println(<span class="hljs-string">&quot;obj1和obj3指向相同类型的对象&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;obj1和obj3指向不同类型的对象&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// obj1和obj2指向相同类型的对象</span><br><span class="hljs-comment">// obj1和obj3指向不同类型的对象</span><br></code></pre></td></tr></table></figure></li><li>最主要应用：该方法属于Java的反射机制，其返回值是Class类型，例如Class c = obj.getClass();。通过对象c，<ul><li>获取所有<strong>成员方法</strong>，<strong>每个成员方法都是一个Method对象</strong>。<code>Method[] methods = cls.getDeclaredMethods();</code></li><li>获取所有<strong>成员变量</strong>，<strong>每个成员变量都是一个Field对象</strong>。<code>Field[] fields = cls.getDeclaredFields();</code></li><li>获取所有<strong>构造函数</strong>，<strong>构造函数则是一个Constructor对象</strong>。<code>Constructor&lt;?&gt;[] constructors = cls.getDeclaredConstructors();</code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 用getClass来获得该对象的类名、所有成员方法、所有成员变量、所有构造函数</span><br><span class="hljs-keyword">import</span> java.lang.reflect.Constructor;<br><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> myField;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyClass</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 默认构造函数</span><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyClass</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> &#123;<br>        <span class="hljs-comment">// 带参数的构造函数</span><br>        myField = value;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">myMethod</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 成员方法</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReflectionExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">MyClass</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyClass</span>();<br><br>        <span class="hljs-comment">// 获取Class对象</span><br>        Class&lt;?&gt; cls = obj.getClass();<br><br>        <span class="hljs-comment">// 获取类名</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">className</span> <span class="hljs-operator">=</span> cls.getName();<br>        System.out.println(<span class="hljs-string">&quot;类名: &quot;</span> + className);<br><br>        <span class="hljs-comment">// 获取所有成员方法</span><br>        Method[] methods = cls.getDeclaredMethods();<br>        System.out.println(<span class="hljs-string">&quot;成员方法:&quot;</span>);<br>        <span class="hljs-keyword">for</span> (Method method : methods) &#123;<br>            System.out.println(method.getName());<br>        &#125;<br><br>        <span class="hljs-comment">// 获取所有成员变量</span><br>        Field[] fields = cls.getDeclaredFields();<br>        System.out.println(<span class="hljs-string">&quot;成员变量:&quot;</span>);<br>        <span class="hljs-keyword">for</span> (Field field : fields) &#123;<br>            System.out.println(field.getName());<br>        &#125;<br><br>        <span class="hljs-comment">// 获取所有构造函数</span><br>        Constructor&lt;?&gt;[] constructors = cls.getDeclaredConstructors();<br>        System.out.println(<span class="hljs-string">&quot;构造函数:&quot;</span>);<br>        <span class="hljs-keyword">for</span> (Constructor&lt;?&gt; constructor : constructors) &#123;<br>            System.out.println(constructor.getName());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h5 id="public-int-hashcode"><code>public int hashCode()&#123;&#125;</code></h5><ul><li>返回该对象的<strong>哈希码值</strong>。哈希值为根据对象的<strong>地址或字符串或数字</strong>使用hash算法计算出来的<strong>int</strong>类型的数值。</li><li>在Object类中，hashCode的默认实现通常会返回对象的<strong>内存地址的某种形式</strong>（不能完全将哈希值等价于地址），具体的实现依赖JVM。</li><li>提高具有哈希结构的容器的效率。</li><li>如果<strong>两个对象相等</strong>（即equals返回true），那么它们的<strong>hashCode值也必须相等</strong>。</li></ul><h5id="public-boolean-equalsobject-obj"><code>public boolean equals(Object obj)</code></h5><ul><li>比较两个对象是否相等。仅当被比较的两个<strong>引用变量指向同一对象</strong>时（即两个对象地址相同，也即hashCode值相同），equals()方法返回true</li><li>可进行<strong>覆盖</strong>，<strong>比较两个对象的内容是否相同</strong>。</li></ul><h5id="equals与hashcode"><code>equals()</code>与<code>hashCode</code></h5><p><strong>equals为true与hashCode相同的关系？</strong> +如果两个对象的equals()结果为<strong>true</strong>，那么这两个对象的<strong>hashCode()一定相同</strong>；+两个对象的<strong>hashCode()结果相同</strong>，并<strong>不能代表</strong>两个对象的equals()一定为true（Hash散列值有冲突的情况，虽然概率很低，只能够说明这两个对象在一个散列存储结构中）</p><p><strong>为什么要重写hashCode和equals？</strong> + equals()⽅法⽤于⽐较两个对象的内容是否相等。在Java中，默认实现是⽐较对象的引⽤，即⽐较两个对象是否指向内存中的相同位置。但<strong>通常，我们希望⽐较对象的内容是否相等</strong>。+ 鉴于这种情况，Object类中 equals()方法的默认实现是没有实⽤价值的，所以<strong>通常都要重写</strong>。 +而由于hashCode()与equals()具有<strong>联动关系</strong>（如果两个对象相等，则它们必须有相同的哈希码），所以equals()方法重写时，通常也要将hashCode()进⾏重写，使得这两个方法始终保持⼀致性。</p><p><strong>重写equals一定要重写hashCode吗？</strong> +如果仅仅是为了<strong>比较两个对象是否相等</strong>只重写<strong>equals</strong>就可以；+如果你使用了<strong>hashSet、hashMap</strong>等容器，为了避免加入重复元素，或者查找元素，就一定要同时重写两个方法。+ 如果<strong>自定义对象作为 Map 的键</strong>，那么必须重写 hashCode 和equals 。</p><h5id="public-string-tostring"><code>public String toString()&#123;&#125;</code></h5><p>默认的 <code>toString()</code>输出<strong>包名</strong>加<strong>类名</strong>和<strong>堆上的首地址</strong></p><h5 id="finalize方法"><code>finalize()方法</code></h5><p>不存在对该对象的其他引用时，由对象的垃圾器调用此方法</p><h5 id="线程中常用的方法">线程中常用的方法</h5><ul><li><code>public final void wait()</code>: 多线程中等待功能</li><li><code>public final native void notify()</code> :多线程中唤醒功能</li><li><code>public final native void notifyAll()</code>:多线程中唤醒所有等待线程的功能</li></ul><h5 id="例">例</h5><p><img src="/img/LE-OOP1/12.png" /> <imgsrc="/img/LE-OOP1/13.png" /></p><h5 id="objects-与-object-区别"><code>Objects</code> 与<code>Object</code> 区别</h5><ul><li>Objects 【public final class Objects extends Object】是Object的工具类，位于java.util包。它从jdk1.7开始才出现，被final修饰不能被继承，拥有私有的构造函数。此类包含static实用程序方法，用于<strong>操作对象或在操作前检查某些条件</strong>。<ul><li><strong>null</strong> 或 null方法 ；</li><li>用于计算<strong>一堆对象的混合哈希代码</strong>；</li><li>返回对象的<strong>字符串</strong>（会对null进行处理）；</li><li>比较两个对象，以及检查索引或子范围值是否超出范围</li></ul></li></ul><h3 id="最终类最终方法常量">5.2 最终类、最终方法、常量</h3><h4 id="最终类最终方法">5.2.1 最终类、最终方法</h4><ul><li><p><strong>最终类</strong>：如果一个类<strong>没有必要再派生子类</strong>，通常可以用final关键字修饰，表明它是一个最终类</p></li><li><p><strong>最终方法</strong>：用关键字final修饰的方法称为最终方法。最终方法既不能被覆盖，也不能被重载，它是一个最终方法，其方法的定义永远不能改变</p></li><li><p>final类中的方法可以不声明为final方法，但实际上<strong>final类中的方法都是隐式的final方法</strong></p></li><li><p>final修饰的方法不一定要存在于final类中。</p></li><li><p>定义类头时，<strong>abstract和final不能同时使用</strong></p></li><li><p>访问权限为<strong>private的方法默认为final</strong>的</p></li></ul><h4 id="常量">5.2.2 常量</h4><ul><li><p>Java中的常量使用关键字 <code>final</code> 修饰。</p></li><li><p>final既可以修饰<strong>简单数据</strong>类型，也可以修饰<strong>复合数据</strong>类型。</p><ul><li>简单数据类型：值不能再变</li><li>符合数据类型：引用不能再变，值可以改变</li></ul></li><li><p>final常量可以在<strong>声明的同时赋初值</strong>，也可以在<strong>构造函数</strong>中</p></li><li><p>常量既可以是<strong>局部常量</strong>，也可以是<strong>类常量和实例常量</strong>。如果是类常量，在<strong>数据类型前加static修饰</strong>（由所有对象共享）。如果是实例常量，就<strong>不加static修饰</strong>。</p></li><li><p>常量名一般大写，多个单词之间用下划线连接。</p></li></ul><h5 id="局部常量类常量实例常量">局部常量、类常量、实例常量</h5><ol type="1"><li><p>局部常量（LocalConstant）： 局部常量是在<strong>方法、构造器或代码块内部</strong>定义的常量。它们只在定义它们的代码块内部有效，一旦代码块执行完毕，局部常量就不再存在。局部常量通常使用 <code>final</code> 关键字来声明，表示其值在初始化后不能被改变。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">myMethod</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">LOCAL_CONSTANT</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>; <span class="hljs-comment">// 局部常量</span><br>    <span class="hljs-comment">// 这里可以使用 LOCAL_CONSTANT</span><br>&#125;<br><span class="hljs-comment">// 这里不能使用 LOCAL_CONSTANT，因为它只在 myMethod 方法内部有效</span><br></code></pre></td></tr></table></figure></p></li><li><p>类常量（ClassConstant）： 类常量是在<strong>类的静态初始化块或静态成员变量</strong>中定义的常量。它们属于类本身，而不是类的实例。类常量也通常使用 <code>final</code> 关键字来声明，并且是 <code>static</code> 的，这意味着它们是类的所有实例共享的。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">CLASS_CONSTANT</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>; <span class="hljs-comment">// 类常量</span><br>    <span class="hljs-comment">// 这里可以使用 CLASS_CONSTANT</span><br>&#125;<br></code></pre></td></tr></table></figure></p></li><li><p>实例常量（InstanceConstant）： 实例常量是在类的<strong>非静态成员变量</strong>中定义的常量。它们属于类的每个实例，每个实例都有自己的实例常量副本。实例常量同样使用 <code>final</code> 关键字来声明，表示一旦被初始化，其值就不能改变。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">INSTANCE_CONSTANT</span> <span class="hljs-operator">=</span> <span class="hljs-number">30</span>; <span class="hljs-comment">// 实例常量</span><br>    <span class="hljs-comment">// 这里可以使用 INSTANCE_CONSTANT</span><br>&#125;<br></code></pre></td></tr></table></figure> <img src="/img/LE-OOP1/14.png" /> <imgsrc="/img/LE-OOP1/15.png" /></p></li></ol><h5 id="例-1">例</h5><p><img src="/img/LE-OOP1/16.png" /> <img src="/img/LE-OOP1/17.png" /><img src="/img/LE-OOP1/18.png" /> <strong>输出</strong> <figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">PersonNNNNNNNNNNNNNNNN</span><br><span class="hljs-attribute">StudentTTTTTTTTTTTTTTTTTTTTT</span><br><span class="hljs-attribute">PersonNNNNNNNNNNNNNNNN</span><br></code></pre></td></tr></table></figure><strong>解释</strong><code>p.priFinalMethod()</code> 和 <code>p2.priFinalMethod()</code> 调用的是 <code>Parent</code> 类的 <code>priFinalMethod</code> 方法，因为 <code>priFinalMethod</code> 是 <code>Parent</code> 类的<strong>私有方法</strong>，无法在 <code>Parent</code> 类的<strong>外部通过 <code>Parent</code> 类的引用调用 <code>Child</code> 类的 <code>priFinalMethod</code> 方法</strong>。### 5.3 内部类</p><h4 id="内部类的基本语法">5.3.1 内部类的基本语法</h4><h5 id="内部类的分类">内部类的分类</h5><p><img src="/img/LE-OOP1/19.png" /></p><h5 id="实例内部类">实例内部类</h5><h6 id="创建实例内部类的实例">创建实例内部类的实例</h6><p><strong>在创建实例内部类的实例时，外部类的实例必须已经存在</strong>，例如要创建InnerTool类的实例，必须先创建Outer外部类的实例两种语法： +<code>Outer.InnerTool tool=new Outer().new InnerTool();</code> +<code>Outer outer=new Outer();</code><code>Outer.InnerTool tool =outer.new InnerTool();</code>以下代码会导致编译错误：<code>Outer.InnerTool tool=new Outer.InnerTool();</code></p><h6 id="实例内部类访问外部类的成员">实例内部类访问外部类的成员</h6><ul><li>在内部类中，可以<strong>直接访问外部类的所有成员</strong>，包括成员变量和成员方法。</li><li>实例内部类的实例<strong>自动持有外部类的实例的引用</strong>。</li></ul><h5 id="静态内部类">静态内部类</h5><ul><li>静态内部类的实例<strong>不会自动持有外部类的特定实例的引用</strong></li><li>在创建内部类的实例时，<strong>不必创建外部类的实例</strong>。</li><li>客户类可以通过<strong>完整的类名直接访问静态内部类的静态成员</strong>。</li></ul><h5 id="局部内部类">局部内部类</h5><ul><li>局部内部类只能在<strong>当前方法</strong>中使用。</li><li>局部内部类和实例内部类一样，可以<strong>访问外部类的所有成员</strong></li><li>此外，局部内部类还可以访问<strong>函数中的最终变量或参数</strong>(final)</li></ul><h4 id="内部类的用途">5.3.2 内部类的用途</h4><ul><li>封装类型：如果<strong>一个类只能由系统中的某一个类访问</strong>，可以定义为该类的内部类。</li><li>直接访问外部类的成员</li><li>回调外部类的方法</li></ul><h5 id="内部类封装类型">5.3.2.1 内部类封装类型</h5><ul><li><p>顶层类只能处于<strong>public和默认</strong>访问级别</p></li><li><p>而成员内部类可以处于public、protected、默认和private四个访问级别。</p></li><li><p>此外，如果一个<strong>内部类仅仅为特定的方法提供服务</strong>，那么可以把这个<strong>内部类定义在方法之内</strong>。</p></li><li><p>虽然 <code>InnerTool</code> 是 <code>Test</code> 的私有内部类，但它仍然可以在 <code>Test</code> 类的内部被访问。在 <code>main</code> 方法中，<code>new Test().new InnerTool()</code> 是在 <code>Test</code> 类的内部创建 <code>InnerTool</code> 的实例，因此这是允许的。</p></li><li><p>在客户类中不能访问Outer.InnerTool类，但是可以通过Outer类的getTool()方法获得InnerTool的实例##### 5.3.2.2 内部类访问外部类的成员</p></li><li><p>内部类的一个特点是能够<strong>访问外部类的各种访问级别的成员</strong>。</p></li><li><p>假定有类A和类B，类B的reset()方法负责重新设置类A的实例变量count的值。一种实现方式是把类A和类B都定义为外部类</p></li><li><p>假如需求中<strong>要求类A的count属性不允许被除类B以外的其他类读取或设置</strong>，那么以上实现方式就不能满足这一需求。</p></li><li><p>在这种情况下，把类B定义为内部类就可以解决这一问题，而且会使程序代码更加简洁</p></li></ul><h5 id="回调">5.3.2.3 回调</h5><p><img src="/img/LE-OOP1/20.png" /> <img src="/img/LE-OOP1/21.png" />故考虑使用回调方法</p><p>回调实质上是指<strong>一个类(Sub)尽管实际上实现了某种功能(调节温度)，但是没有直接提供相应的接口，客户类可以通过这个类的内部类(Closure)的接口(Adjustable)来获得这种功能。而这个内部类本身并没有提供真正的实现，仅仅调用外部类的实现(adjustTemperature)</strong>。可见，回调充分发挥了内部类具有访问外部类的实现细节的优势。 <imgsrc="/img/LE-OOP1/22.png" /><img src="/img/LE-OOP1/23.png" /></p><h4 id="内部类的文件命名">5.3.3 内部类的文件命名</h4><p>对于每个内部类，Java编译器会生成独立的.class文件。这些类文件的命名规则如下：+ 成员内部类：外部类的名字$内部类的名字 +局部内部类：外部类的名字$数字和内部类的名字 +匿名类：外部类的名字$数字</p><h3 id="匿名类">5.4 匿名类</h3><ul><li>匿名类就是没有名字的类，是将类和类的方法定义在一个表达式范围里。</li><li>匿名类本身<strong>没有构造方法</strong>，但是会<strong>调用父类的构造方法</strong>。</li><li>匿名内部类将内部类的定义与生成实例的语句合在一起，并省去了类名以及关键字“class”,”extends”和“implements”等</li><li>匿名类必须继承自一个具体的<strong>类</strong>或实现一个<strong>接口</strong>。</li></ul><h2 id="其他-9-11-14">其他 9 11-14</h2><h3 id="异常处理-9">异常处理 9</h3><p><img src="/img/LE-OOP1/24.png" /> #### 1 异常概述</p><ul><li>3类错误<ul><li>编译错误</li><li>逻辑错误</li><li><strong>运行时错误</strong>：在程序运行过程中如果发生了一个不可能执行的操作，就会出现运行时错误。</li></ul></li><li><strong>异常</strong>：一个<strong>可以正确运行</strong>的程序在<strong>运行中</strong>可能发生的错误。</li><li>异常特点：偶然性、可预见性、严重性</li><li><strong>异常处理 ( Exception Handling)</strong>：提出或者是研究一种机制，能够较好的处理程序不能正常运行的问题。</li></ul><h4 id="java异常类异常的层次结构">2 java异常类/异常的层次结构</h4><h5 id="java异常类">java异常类</h5><p><img src="/img/LE-OOP1/25.png" /> +Throwable：所有异常类的父类，是Object的直接子类。 +Error：由Java虚拟机生成并抛出，Java程序不做处理 +Exception：所有的Throwable类的子孙类所产生的对象都是异常 + RuntimeException：<strong>编译时不可监测的异常</strong>，由系统检测,用户的Java程序可不做处理，系统将它们交给缺省的异常处理程序。 +<strong>非RuntimeException</strong>：<strong>编译时可以监测的异常</strong>，Java编译器要求Java程序<strong>必须</strong>捕获或声明所有的非运行时异常，可以通过try-catch或throws处理。+ throw：用户自己产生异常。</p><h5 id="常见的异常">常见的异常</h5><ol type="1"><li>ArithmeticException</li><li>ArrayIndexOutOfBoundsException</li><li>ArrayStoreException</li><li>IOException</li><li>FileNotFoundException</li><li>NullPointerException</li><li>MalformedURLException</li><li>NumberFormatException</li><li>OutOfMemoryException</li></ol><h5 id="异常分类">异常分类</h5><ul><li>非受检异常 ( unchecked exception ) ：Runtime Exception及其子类、Error 及其子类。<ul><li>只能在程序执行时被检测到，<strong>不能在编译时被检测到</strong>；</li><li>程序可不处理，交由系统处理。</li></ul></li><li>受检异常 ( checked exception)：除了非受检异常之外的异常（即其他的异常类都是可检测的类）<ul><li>这些异常在<strong>编译时</strong>就能被java编译器所检测到异常。</li><li>必须采用 <strong>throws 语句</strong>或者 <strong>try-catch</strong>方式处理异常</li></ul></li></ul><h4 id="java异常处理机制">3 java异常处理机制</h4><ul><li>抓抛模型<ul><li>抛出(throw)异常：Java程序在正常的执行过程中，一旦出现异常，就会在异常代码处生成一个对应<strong>异常类的对象</strong>，并将此对象抛出，且其后代码就<strong>不再执行</strong>。<ul><li>关于异常对象的产生<ul><li>系统<strong>自动</strong>生成异常对象</li><li><strong>手动</strong>生成一个异常对象，并抛出（<strong>throw</strong>）</li></ul></li></ul></li><li>捕获(catch)异常：可以理解为异常处理方式。<ul><li>try-catch-finally</li><li>throws</li></ul></li></ul></li><li>Java语言按照面向对象的思想来处理异常：<ul><li>把各种不同类型的异常情况进行分类，用Java类来表示异常情况，这种类被称为异常类。</li><li>用throws语句在方法声明处声明抛出特定异常。（<strong>只抛出不处理，交给调用该方法的方法进行处理，若一直不处理，则交给系统处理</strong>）</li><li>用try-catch语句来捕获并处理异常。（<strong>处理</strong>）</li><li>用throw语句在方法中抛出具体的异常。（<strong>自定义异常</strong>）</li></ul></li></ul><h4 id="try-catch-finally">4 try-catch-finally</h4><h6id="finally无条件执行的语句"><code>finally</code>：无条件执行的语句</h6><ul><li><code>try&#123;&#125;</code> 中执行 <code>return</code> ，<code>finally</code>语句仍然执行，在 <code>return</code> 前执行</li><li><code>try&#123;&#125;</code> 中执行<code>exist(0)</code>，<code>finally</code> 语句不执行</li></ul><h6 id="try-catch-finally-语句格式"><code>try-catch-finally</code>语句格式</h6><ul><li><p>一个try一个catch可以，一个try一堆catch也可以，try-catch-finally也可以，try-fianlly也可以</p></li><li><p><code>try-catch-finally</code> 语句的语法格式</p><ul><li>一般 <code>finally</code>写<strong>释放资源</strong>的部分（打开水龙头后无论水龙头能不能使最后都要关上水龙头）</li><li>如果一个异常类和其子类都出现在catch子句中，应把<strong>子类放在前面</strong>，否则将永远不会到达子类。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-comment">// 接受监视的程序块,在此区域内发生的异常,由catch中指定的程序处理;</span><br>&#125;<br><span class="hljs-keyword">catch</span> (ExceptionType1 e) &#123;<br><span class="hljs-comment">// 抛出ExceptionType1异常时要执行的代码</span><br>&#125;<br><span class="hljs-keyword">catch</span> (ExceptionType2 e) &#123;<br><span class="hljs-comment">// 抛出ExceptionType2异常时要执行的代码</span><br>&#125;……<br>[<span class="hljs-keyword">finally</span> &#123;<br><span class="hljs-comment">// 无条件执行的语句</span><br>&#125;]<br></code></pre></td></tr></table></figure></li></ul></li><li><p><code>try-finally</code> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//try-finally</span><br><span class="hljs-keyword">try</span>&#123;<br><span class="hljs-comment">// 对文件进行处理的程序</span><br>&#125;<br><span class="hljs-keyword">finally</span>&#123;<br><span class="hljs-comment">// 不论是否发生异常，都关闭文件</span><br>&#125;<br></code></pre></td></tr></table></figure></p></li><li><p><code>catch(异常名1|异常名2|异常名3 变量)</code> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span>&#123;<br><br>&#125;<span class="hljs-keyword">catch</span>(异常名<span class="hljs-number">1</span> |异常名<span class="hljs-number">2</span> |异常名<span class="hljs-number">3</span>… 变量）&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure>方法虽简洁，但是也不是特别完美</p></li><li><p>上述异常必须是<strong>同级</strong>关系；</p></li><li><p><strong>处理方式是一样</strong>的（针对同类型的问题，给出同一个处理）</p></li></ul><h6 id="try-with-resourse"><code>try-with-resourse</code></h6><ul><li>资源：所有实现Closeable的类，如流操作，socket操作，httpclient等</li><li>打开的资源越多，finally中嵌套的将会越深，所以引入了Try-with-resourse</li><li>带资源的try语句（try-with-resource）的最简形式为：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span>(<span class="hljs-type">Resource</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> xxx)&#123; <span class="hljs-comment">// 可指定多个资源</span><br>work with res<br>&#125;<br></code></pre></td></tr></table></figure></li><li>处理规则<ul><li>凡是实现了AutoCloseable接口的类，在try()里声明该类实例的时候，在try结束后，<strong>close方法都会被调用</strong>，这个动作会<strong>早于finally里调用的方法</strong>。</li><li>不管是否出现异常，try()里的实例都会被调用；</li><li>close方法<strong>越晚声明</strong>的对象，会<strong>越早被close</strong>掉。</li></ul></li></ul><h6 id="例1">例1</h6><p>先声明的后关闭 <img src="/img/LE-OOP1/26.png" /> <figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">do</span> something<br><span class="hljs-keyword">do</span> other things<br>other resource <span class="hljs-keyword">is</span> closed<br><span class="hljs-keyword">some</span> resource <span class="hljs-keyword">is</span> closed<br></code></pre></td></tr></table></figure></p><h4 id="throws">5 Throws</h4><p>用于<strong>声明异常</strong>。 +声明异常：一个方法<strong>不处理</strong>它产生的异常，而是<strong>沿着调用层次向上传递</strong>，由调用它的方法来处理这些异常，叫声明异常。若最终方法也没有处理异常，异常将<strong>交给系统处理</strong>+Throws语句用来表明一个方法可能抛出的各种异常，并说明该方法会<strong>抛出但不捕获</strong>异常</p><ul><li>声明异常的格式 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;访问权限修饰符&gt;&lt;返回值类型&gt;&lt;方法名&gt;(参数列表) <span class="hljs-keyword">throws</span> 异常列表&#123;&#125;<br></code></pre></td></tr></table></figure></li><li><strong>当父类中的方法没有throws，则子类重写此方法时也不可以throws</strong>。若重写方法中出异常，必须采用try结构处理。</li><li>重写方法不能抛出比被重写方法<strong>范围更大</strong>的异常类型，子类重写方法也<strong>可以不抛出</strong>异常。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 方法**不处理**它产生的异常，而是**沿着调用层次向上传递**，由调用它的方法来处理这些异常</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ThrowsTest4</span> &#123;<br>    <span class="hljs-comment">// 声明异常，但不处理异常</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IllegalAccessException &#123;<br>        System.out.println(<span class="hljs-string">&quot;\n在 method 中抛出一个异常&quot;</span>);<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalAccessException</span>();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            method();<br>        &#125; <span class="hljs-keyword">catch</span> (IllegalAccessException e) &#123;<br>            System.out.println(<span class="hljs-string">&quot;在 main 中捕获异常：&quot;</span> + e);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 在 method 中抛出一个异常</span><br><span class="hljs-comment">// 在 main 中捕获异常：java.lang.IllegalAccessException</span><br></code></pre></td></tr></table></figure></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 若最终方法也没有处理异常，异常将交给系统处理</span><br><span class="hljs-keyword">import</span> java.io.FileInputStream;  <br><span class="hljs-keyword">import</span> java.io.IOException;  <br>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;  <br>        <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;myfile.txt&quot;</span>);  <br>        <span class="hljs-type">int</span> b;  <br>        <span class="hljs-keyword">while</span> ((b = in.read()) != -<span class="hljs-number">1</span>) &#123;  <br>            System.out.print((<span class="hljs-type">char</span>) b);  <br>        &#125;  <br>        in.close();  <br>    &#125;  <br>&#125;<br><span class="hljs-comment">// Exception in thread &quot;main&quot; java.io.FileNotFoundException: myfile.txt (系统找不到指定的文件。)</span><br><span class="hljs-comment">//at java.base/java.io.FileInputStream.open0(Native Method)</span><br><span class="hljs-comment">//at java.base/java.io.FileInputStream.open(FileInputStream.java:213)</span><br><span class="hljs-comment">//at java.base/java.io.FileInputStream.&lt;init&gt;(FileInputStream.java:152)</span><br><span class="hljs-comment">//at java.base/java.io.FileInputStream.&lt;init&gt;(FileInputStream.java:106)</span><br><span class="hljs-comment">//at Test.main(Test.java:6)</span><br></code></pre></td></tr></table></figure><h4 id="throw与创建自定义异常类">6 throw与创建自定义异常类</h4><ul><li>throw抛出<strong>用户自定义异常</strong>。</li><li>用户定义的异常必须由<strong>用户自己抛出</strong><code>&lt;throw&gt;&lt;异常对象&gt;</code><code>throw new MyException</code></li><li>程序会在throw语句处立即终止，转向 try…catch 寻找异常处理方法。</li><li>语句格式 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;class&gt;&lt;自定义异常名&gt;extends&lt;Exception&gt;&#123;<br><span class="hljs-keyword">public</span> String to <span class="hljs-title function_">string</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;myException&quot;</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p><img src="/img/LE-OOP1/27.png" /> <img src="/img/LE-OOP1/28.png" /><img src="/img/LE-OOP1/29.png" /></p><h3 id="图形界面-11">图形界面 11</h3><p>看PPT去</p><h3 id="java-io-12">Java IO 12</h3><h5 id="scanner">scanner</h5><ul><li><p>Scanner的作用：通过分隔符模式将输入分解为标记，默认情况下该分隔符模式与空白匹配。</p></li><li><p>通过Scanner 类的 <code>next()</code> 与 <code>nextLine()</code>方法获取输入的字符串，在读取前我们一般需要使用 <code>hasNext</code> 与<code>hasNextLine</code> 判断是否还有输入的数据</p></li><li><p><strong>Scanner</strong> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);  <br><span class="hljs-keyword">while</span>(scanner.hasNextDouble())&#123;  <br>    <span class="hljs-type">double</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> scanner.nextDouble();  <br>&#125;<br></code></pre></td></tr></table></figure></p></li><li><p><strong>转换大小写</strong>： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">original</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello, World!&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">uppercase</span> <span class="hljs-operator">=</span> original.toUpperCase();<br><span class="hljs-type">String</span> <span class="hljs-variable">lowercase</span> <span class="hljs-operator">=</span> original.toLowerCase();<br></code></pre></td></tr></table></figure></p></li><li><p><strong>替换字符串</strong>： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">original</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello, World!&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">replaced</span> <span class="hljs-operator">=</span> original.replace(<span class="hljs-string">&quot;World&quot;</span>, <span class="hljs-string">&quot;Java&quot;</span>);<br></code></pre></td></tr></table></figure></p></li><li><p><strong>分割字符串</strong>： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">original</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;one,two,three&quot;</span>;<br>String[] parts = original.split(<span class="hljs-string">&quot;,&quot;</span>);<br></code></pre></td></tr></table></figure></p></li><li><p><strong>连接字符串</strong>： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">part1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello, &quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">part2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;World!&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">combined</span> <span class="hljs-operator">=</span> part1 + part2;<br></code></pre></td></tr></table></figure></p></li><li><p><strong>格式化字符串</strong>： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">number</span> <span class="hljs-operator">=</span> <span class="hljs-number">42</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">formatted</span> <span class="hljs-operator">=</span> String.format(<span class="hljs-string">&quot;The answer is %d&quot;</span>, number);<br></code></pre></td></tr></table></figure></p></li><li><p>输入流：输入数据流只能读,不能写</p><ul><li>字节流：Java中的输入数据流(字节流)都是抽象类<strong>InputStream</strong>的子类；</li><li>字符流：Java中的输入数据流(字符流)都是抽象类<strong>Reader</strong>的子类；</li></ul></li><li><p>输出流：输出数据流只能写,不能读</p><ul><li>字节流:java中的输出数据流(字节流)都是抽象类<strong>OutputStream</strong>的子类；</li><li>字符流:java中的输出数据流(字符流)都是抽象类<strong>Writer</strong>的子类；</li></ul></li><li><p>字节流可以操作所有类型的文件；</p></li><li><p>字符流只能操作<strong>纯文本文件</strong>；</p></li></ul><p><img src="/img/LE-OOP1/42.png" /> <img src="/img/LE-OOP1/43.png" /><img src="/img/LE-OOP1/44.png" /> <img src="/img/LE-OOP1/45.png" /></p><h4 id="其他-io-nio-nio2">其他 IO NIO NIO2</h4><ul><li>IO流（同步、阻塞）</li><li>NIO（同步、非阻塞）:NIO(NEW IO)用到块，效率比IO高很多 三个组件：<ul><li>Channels（通道）：<strong>流是单向的，Channel是双向的</strong>，既可以读又可以写，Channel可以进行异步的读写，对Channel的读写必须通过<strong>buffer</strong>对象</li><li>Buffer（缓冲区）</li><li>Selector（选择器）：Selector是一个对象，它可以注册到很多个Channel上，监听各个Channel上发生的事件，并且能够根据事件情况决定Channel读写。这样，通过一个线程管理多个Channel，就可以处理大量网络连接了</li></ul></li><li>NIO2(异步、非阻塞)：AIO(Asynchronous IO) ###### 同步与异步</li><li>同步:是一种可靠的有序运行机制，进行同步操作时，后续的任务须<strong>等待当前调用返回</strong>，才会进行下一步；</li><li>异步：后续任务<strong>不需要等待当前调用返回</strong>，通常依靠事件、回调等机制来实现任务间次序关系；###### 阻塞与非阻塞</li><li>阻塞：在进行读写操作时，当前线程会处于阻塞状态，<strong>无法从事其他任务</strong>。只有当条件就绪才能继续；</li><li>非阻塞：不管IO操作是否结束，<strong>直接返回</strong>，相应操作在后台继续处理</li></ul><h4 id="字节流">字节流</h4><h5 id="inputstream">InputStream</h5><p><img src="/img/LE-OOP1/46.png" /> <strong>简介</strong> +InputStream是<strong>抽象类</strong>，所以不能通过“newInputStream()”的方法构造InputStream的实例。但它声明了输入流的基本操作，<strong>包括读取数据(read)、关闭输入流(close)、获取流中可读的字节数(available)、移动读取指针(skip)、标记流中的位置(mark)和重置读取指针(reset)</strong>等,它的子类一般都重写这些方法。 +通过构造InputStream子类的实例方式可以获得InputStream类型的实例。</p><p><strong>相关函数介绍</strong> +方法read()提供了三种从流中读数据的方法. + intread():一次只能读一个字节,抽象方法。 + int read(byteb[]):一次读多个字节到数组中 + int read(byte[],int off,int len); +一般available和read()混合使用，这样在读操作前可以知道有多少字符需要读入。+ mark通常与reset()方法配合使用，可重复读取输入流所指定的字节数据。</p><p><strong>分类</strong> +FileInputStream：用于<strong>从本地文件</strong>中读出数据。 +ObjectInputStream：用来读取<strong>对象</strong>；要保证对象是<strong>串行化</strong>(Serializable)的（指<strong>对象</strong>通过把自己<strong>转化为一系列字节</strong>，记录字节的<strong>状态数据</strong>，以便再次利用的这个过程；<strong>对不希望串行化的对象要用关键字transient修饰</strong>）+PipedIntputStream：用于管道输入/输出时从<strong>管道</strong>中读取数据；管道数据流的两个类一定是<strong>成对</strong>的，<strong>同时使用并相互连接</strong>的，这样才形成一个数据通信管道；管道数据流主要用于<strong>线程间的通信</strong>。+SequencedInputStream：用来把<strong>两个或更多</strong>的InputStream输入流对象转换为单个inputStream输入流对象使用。+FilterInputStream：提供<strong>将流连接在一起</strong>的能力；<strong>某一时刻只能一个线程访问</strong>它；其子类PushbackInputStream(<strong>读过的一个或几个字节数据退回到输入流中</strong>/<strong>回压别的字节数据</strong>)和BufferedInputStream读取数据时可以对数据进行<strong>缓冲</strong>，这样可以<strong>提高效率</strong>和<strong>增加特殊功能</strong>。+DataInputStream实现了java.io包中的DataInput接口，读取数据的同时，可以对数据进行<strong>格式处理</strong>。因此，能用来读取java中的<strong>基本数据类型</strong>。+ ByteArrayInputStream：包含一个内存缓冲区，用于从内存中读取数据。 +AudioInputStream：Audio的输入输出 <img src="/img/LE-OOP1/47.png" />##### OutputStream</p><p><img src="/img/LE-OOP1/48.png" /></p><p><strong>简介</strong>OutputStream是抽象类，所以不能通过“newOutputStream()”的方法构造OutputStream的实例。但它声明了输出流的基本操作，<strong>包括输出数据(write)、关闭输出流(close)、清空缓冲区(flush)等</strong></p><p><strong>分类</strong> +FileOutputStream：用于向<strong>本地文件</strong>中写入数据。 +PipedOutputStream：用于管道输入/输出时把数据向<strong>管道</strong>输出+ DataOutputStream：提供了对java的<strong>基本数据类型</strong>的支持 +PrintStream：提供了<strong>向屏幕输出有格式数据</strong>的很多方法；<strong>System.out</strong><strong>为什么PrintStream适合做打印流？</strong> +它提供了更多的输出成员方法，输出的数据<strong>不必先转换成字符串类型或其它类型</strong>。+ PrintStream的成员方法一般<strong>不会抛出异常</strong>； +PrintStream具有<strong>自动强制输出(flush)功能</strong>，即当输出回车换行时，在缓存中的数据会全部自动写入指定的文件或在标准输出窗口中显示</p><h4 id="字符流">字符流</h4><p><img src="/img/LE-OOP1/49.png" /> <imgsrc="/img/LE-OOP1/50.png" /></p><ul><li>Reader类和Writer类中的大部分方法与InputStream类和OutputStream类中的对应方法名称相同，只是读取或写入的数据是<strong>字符、字符数组和字符串</strong>等。</li><li>如果程序读到的数据是不同国家的语言，其编码不同，那么程序应使用Reader和Writer流。##### InputStreamReader类和OutputStreamWriter类</li><li>InputStreamReader类继承自Reader类，通过其read方法从字节输入流中读取一个或多个<strong>字节数据转换为字符数据</strong>，它不是一个缓冲流，因此其<strong>转换的效率并不高</strong>。</li><li>OutputStreamWriter类继承自Writer类，其作用是<strong>转变字符输出流为字节流输出</strong>。</li><li>InputStreamReader类和OutputStreamWriter类都可以<strong>接一个缓冲流来提高效率</strong>##### FileReader和FileWriterFileReader和FileWriter类分别是Reader和Writer子类，他们分别用来从<strong>字符文件读取字符</strong>和<strong>向字符文件输出字符数据</strong>。</li></ul><h3 id="多线程-13">多线程 13</h3><p><img src="/img/LE-OOP1/51.png" /> <img src="/img/LE-OOP1/52.png" />#### 1 进程的概念</p><ul><li><p><strong>程序</strong>（program）：静态的<strong>代码</strong>。</p></li><li><p><strong>进程</strong>（process）是程序的一次<strong>执行过程</strong>。</p></li><li><p>程序是静态的，进程是动态的。</p></li><li><p>不同进程所<strong>占用的系统资源相对独立</strong>；</p></li><li><p>属于同一进程的所有线程<strong>共享该进程的系统资源</strong>；</p></li><li><p>线程本身既没有入口，也没有出口，其自身也<strong>不能独立运行</strong>，完成其任务后，自动终止，也可以由进程使之强制终止。</p></li></ul><p>当多线程程序执行时<strong>具有并发执行的多个线程</strong>；</p><h5 id="为什么用多线程">为什么用多线程？</h5><ul><li>速度快：线程之间<strong>共享相同的内存单元</strong>(代码和数据)，因此在线程间切换，不需要很大的系统开销，所以线程之间的<strong>切换速度远远比进程之间快</strong>，线程之间的通信也比进程通信快的多。</li><li>CPU利用率高：多个线程轮流抢占CPU资源而运行时，从微观上讲，一个时间里只能有一个作业被执行，在宏观上可使多个作业被同时执行，即等同于要让多台计算机同时工作，使系统资源特别是<strong>CPU的利用率得到提高</strong>，从而可以提高<strong>整个程序的执行效率</strong>。</li></ul><h4 id="线程的运行">2 线程的运行</h4><p>每个线程都有一个独立的程序计数器和方法调用栈（method invocationstack）： + 栈存简单局部变量，堆存类对象 +线程运行中需要的资源：CPU、方法区的代码、堆区的数据、栈区的方法调用栈</p><h4 id="线程的调度">3 线程的调度</h4><h5 id="线程的调度-1">线程的调度</h5><ul><li>在Java中，线程调度通常是<strong>抢占式</strong>(即哪一个线程先抢到CPU资源则先运行)，而不是<strong>分时间片式</strong>。</li><li>一旦一个线程获得执行权，这个线程将<strong>持续运行下去</strong>，直到它运行结束或因为某种原因而阻塞，或者有另一个高优先级线程就绪（这种情况称为<strong>低优先级线程被高优先级线程所抢占</strong>）。</li><li>所有被阻塞的线程按次序排列，组成一个<strong>阻塞队列</strong>。</li><li>所有就绪但没有运行的线程则根据其优先级排入一个<strong>就绪队列</strong>。</li><li>当CPU空闲时，如果就绪队列不空，就绪队列中第一个具有最高优先级的线程将运行。</li><li>当一个线程被抢占而停止运行时，它的运行态被改变并放到就绪队列的队尾；</li><li>一个被阻塞（可能因为睡眠或等待I/O设备）的线程就绪后通常也放到就绪队列的队尾</li></ul><h5 id="优先级">优先级</h5><p>线程的调度是按： 1. 其优先级的高低顺序执行的； 2.同样优先级的线程遵循“先到先执行的原则”</p><p><strong>线程优先级</strong> + 范围 1~10 （10 级）。数值越大，级别越高+ Thread 类定义的 3 个常数： + MIN_PRIORITY 最低(小)优先级（值为1） +MAX_PRIORITY 最高(大)优先级（值为10） + NORM_PRIORITY默认优先级（值为5） + 线程创建时，<strong>继承父线程的优先级</strong>。+ 常用方法： + getPriority( )：获得线程的优先级 + setPriority()：设置线程的优先级</p><h5 id="主线程">主线程</h5><ul><li>main( ) 方法：每当用java命令启动一个Java虚拟机进程（ Application应用程序），Java虚拟机就会创建一个主线程，该线程<strong>从程序入口main()方法开始执行</strong>。</li><li>当在主线程中创建 Thread类或其子类对象时，就创建了一个线程对象。主线程就是<strong>上述创建线程的父线程</strong>。</li><li>Programmer可以控制线程的启动、挂起与终止。</li></ul><h5 id="线程的状态">线程的状态</h5><p>新建、就绪、运行、阻塞、终止 + 新建：当一个 Thread类或其子类对象<strong>被创建时</strong>，新产生的线程处于新建状态，此时它已经有了<strong>相应的内存空间和其他资源</strong>。+ 就绪：调用 <strong>start( )</strong>方法来启动处于新建状态的线程后，将进入线程队列排队等待 CPU服务，此时它已经具备了运行的条件，<strong>一旦轮到它来享用 CPU资源时，就可以脱离创建它的主线程，开始自己的生命周期</strong>。 +运行：当就绪状态的线程被调度并获得处理器资源时，便进入运行状态。 +每一个 Thread 类及其子类的对象都有一个重要的 run( )方法，当线程对象被调用执行时，它将自动调用本对象的 run()方法，从第一句开始顺序执行。 + <strong>run( )</strong>方法定义了这个线程的操作和功能。 +阻塞：一个正在执行的线程暂停自己的执行而进入的状态。引起线程由运行状态进入阻塞状态的可能情况：+ 该线程正在等待 I/O 操作的完成：<strong>等待 I/O操作完成或回到就绪状态</strong> + 网络操作 + 为了获取锁而进入阻塞操作 +调用了该线程的 sleep( )方法：等待其指定的休眠事件结束后，<strong>自动脱离阻塞状态</strong>，回到就绪状态+ 调用了 wait( ) 方法：调用 <strong>notify</strong>( )或<strong>notifyAll</strong>( ) 方法； +让处于运行状态的线程调用另一个线程的join()方法 + 终止： +自然终止：线程完成了自己的全部工作 +强制终止：在线程执行完之前，调用stop( ) 或 destroy( ) 方法终止线程</p><h4 id="创建和启动线程">4 创建和启动线程</h4><p>Java中实现多线程有三种方法： + 一种是继承Thread类； +第二种是实现Runnable接口； + 第三种是实现Callable接口；</p><h5 id="thread构造方法">Thread构造方法</h5><p><img src="/img/LE-OOP1/53.png" /> +一个线程的创建肯定是由另一个线程完成的； +被创建线程的父线程是创建它的线程； +main线程由JVM创建，而main线程又可以成为其他线程的父线程； +如果一个线程创建的时候没有指定ThreadGroup，那么将会和父线程同一个ThreadGroup。main线程所在的ThreadGroup称为main；</p><h5 id="thread常用方法">Thread常用方法</h5><p><img src="/img/LE-OOP1/54.png" /> <img src="/img/LE-OOP1/55.png" /><img src="/img/LE-OOP1/56.png" /></p><h5 id="tips">tips</h5><p>因为Java线程的调度不是分时的，所以你必须确保你的代码中的线程会<strong>不时地给另外一个线程运行的机会</strong>。有三种方法可以做到一点：+ 让处于运行状态的线程调用 <strong>Thread.sleep()</strong> 方法。 +让处于运行状态的线程调用 <strong>Thread.yield()</strong> 方法。 +让处于运行状态的线程调用另一个线程的 <strong>join()</strong> 方法。###### sleep与yield + 这两个方法都是静态的实例方法。 +sleep()会有<strong>中断异常抛出</strong>，而yiled()不抛出任何异常。 +sleep()方法具有更好的<strong>可移植性</strong>，因为yield()的实现还取决于底层的操作系统对线程的调度策略。+对于yield()的主要用途是在<strong>测试阶段</strong>，<strong>人为的提高程序的并发性能，以帮助发现一些隐藏的并发错误</strong>，当程序正常运行时，则不能依靠yield方法提高程序的并发行能。###### wait与sleep +所以，wait,notify和notifyAll都是与同步相关联的方法,只有在synchronized方法中才可以用。在不同步的方法或代码中则使用sleep()方法使线程暂时停止运行###### join作用：使当前正在运行的线程暂停下来，<strong>等待指定的时间后</strong>或<strong>等待调用该方法的线程结束后</strong>，再恢复运行##### 应用线程类Thread创建线程 +将一个类定义为Thread的子类,那么这个类就可以用来创建线程。 +这个类中有一个至关重要的方法——<code>public void run</code>，这个方法称为<strong>线程体</strong>，它是整个线程的<strong>核心</strong>，线程所要完成任务的代码都定义在<strong>线程体</strong>中，实际上<strong>不同功能的线程之间的区别就在于它们线程体的不同</strong><img src="/img/LE-OOP1/57.png" /> ##### 应用Runnable接口创建线程 +Runnable是Java中用以实现线程的接口，从根本上讲，任何实现线程功能的类都必须实现该接口。+ Thread(Runnable target); + Thread(Runnable target, String name); +Runnable接口中只定义了一个方法就是run()方法，也就是线程体 ######适用于采用实现Runnable接口方法的情况 +避免<strong>单继承</strong>的局限：因为Java只允许单继承，如果一个类已经继承了Thread，就不能再继承其他类。+特别是在除了<strong>run()方法</strong>以外,并不打算重写Thread类的其它方法的情况下,以实现Runnable接口的方式生成新线程就显得更加合理了。+ 涉及到数据共享的时候； ##### 终止线程 +当线程执行完run()方法，它将自然终止运行。 +Thread有一个stop()方法，可以强制结束线程，但这种方法是不安全的。因此，在stop()方法已经被废弃。+实际编程中，一般是定义一个标志变量，然后通过程序来改变标志变量的值，从而控制线程从run()方法中自然退出</p><h5 id="总结创建用户多线程的步骤">总结：创建用户多线程的步骤</h5><p>法1 <img src="/img/LE-OOP1/58.png" /></p><p>法2 <img src="/img/LE-OOP1/59.png" /></p><p>法3 <img src="/img/LE-OOP1/60.png" /></p><ul><li>在程序开发中只要是多线程<strong>尽量以实现Runnable接口为主</strong>，因为实现Runnable接口相比继承Thread类有如下好处：<ul><li>避免单继承的局限，一个类可以实现多个接口。</li><li>适合于资源的共享</li></ul></li><li>Runnable的局限性<ul><li><code>run()</code> 方法的返回值是void</li><li>不允许抛出任何已检查的异常（编译时捕获的异常）</li></ul></li></ul><h5 id="callable接口">Callable接口</h5><h6 id="实现callable接口的步骤">实现callable接口的步骤</h6><p><img src="/img/LE-OOP1/61.png" /> <img src="/img/LE-OOP1/62.png" />###### callable接口的特点 <img src="/img/LE-OOP1/63.png" /> +运行Callable任务可以拿到一个Future对象，表示异步计算的结果。它提供了检查计算是否完成的方法，以等待计算的完成，并检索计算的结果。通过Future对象<strong>可以了解任务执行情况</strong>，可取消任务的执行，还可获取执行结果。</p><h6 id="线程池">线程池</h6><p>日常开发中，推荐使用<strong>线程池</strong>的方式来使用。最开始创建一堆线程放在池子里，用的时候拿出来用，不用就放回去，能够减少线程的启动和灭亡</p><h5 id="实际工作中如何选择">实际工作中如何选择</h5><ul><li>取舍的基本原则就是需不需要<strong>返回值</strong>，如果不需要返回值，那直接就选Runnable。如果有返回值的话，使用Callable。</li><li>另外一点就是是否需要<strong>抛出异常</strong>，Runnable是不接受抛出异常的，Callable可以抛出异常。</li><li>Runnable适合那种纯异步的处理逻辑。比如每天定时计算报表，将报表存储到数据库或者其他地方，只是要计算，<strong>不需要马上展示</strong>，展示内容是在其他的方法中单独获取的。（比如那些非核心的功能，当核心流程执行完毕后，非核心功能就自己去执行）</li><li>Callable适用于那些需要返回值或者需要抛出checkedexception的情况，比如对某个任务的计算结果进行处理。在Java中，常常使用callable来实现异步任务的处理，以提高系统的吞吐量和响应速度</li></ul><h3 id="网络编程-14">网络编程 14</h3><h6 id="计算机网络工作模式">计算机网络工作模式</h6><ul><li>客户机/服务器模式(Client/Server C/S) 一共两种<ul><li><strong>数据库服务器端</strong>，客户端<strong>通过数据库连接访问服务器端的数据</strong>；</li><li>（本讲内容）<strong>Socket服务器端</strong>，服务器端的程序通过Socket与客户端的程序通信。另，socket服务器端为“<strong>传输层</strong>”，BS模式为“应用层”</li></ul></li><li>浏览器/服务器模式（Browser/Server）</li></ul><h6 id="网络通信协议与接口">网络通信协议与接口</h6><ul><li>网络通信协议：计算机网络中实现通信必须有一些约定</li><li>网络通信接口：为了使两个结点之间能进行对话，必须在他们之间建立通信工具(即<strong>接口</strong>)，使彼此之间能进行信息交换，接口包括两部分：<ul><li>硬件装置:实现结点之间的信息传递。</li><li>软件装置:规定双方进行通信的约定协议。 <imgsrc="/img/LE-OOP1/64.png" /></li></ul></li></ul><h6 id="uri-包含-url-和-urn">URI 包含 URL 和 URN</h6><p><strong>URI</strong>（Uniform ResourceIdentifier，统一资源<strong>标识</strong>符）用于唯一地<strong>标识</strong>资源，无论是通过名称、位置还是两者兼有。<strong>URL</strong>（Uniform ResourceLocator，统一资源<strong>定位</strong>符）是URI的一个子集，它提供了资源的<strong>定位</strong>信息，即如何访问资源，但不直接提供资源的名称。<strong>URN</strong>（Uniform ResourceName）是URI的另一个子集，它提供了资源的<strong>名称</strong>，但不提供如何定位或访问资源的信息。URN是持久的、与位置无关的标识符。</p><h6 id="tcpip">TCP/IP</h6><p><img src="/img/LE-OOP1/65.png" /></p><h6 id="tcp和udp">TCP和UDP</h6><p><img src="/img/LE-OOP1/66.png" /></p><p><img src="/img/LE-OOP1/67.png" /> <img src="/img/LE-OOP1/68.png" /><img src="/img/LE-OOP1/69.png" /> <img src="/img/LE-OOP1/70.png" /></p><h2 id="设计原则7个-7">设计原则(7个) 7</h2><p>SOLID合成复用 1. S <strong>Single Responsibility Principle(单一职责原则)</strong> ：每个类只干一件事 2. O <strong>Open/ClosedPrinciple (开闭原则)</strong> ：用抽象类和接口而不是if-else 3. L<strong>Liskov Substitution Principle (里氏代换原则)</strong>：子类不能改变父类的方法 4. I <strong>Interface Segregation Principle(接口隔离原则)</strong>：把总接口拆分成多个接口（防止有的类不需要某个功能但被迫实现） 5. D<strong>Dependency Inversion Principle (依赖倒转原则)</strong>：细节(更具体的东西，如email通信)实现抽象(更抽象的东西，如通信)而不是抽象拥有细节6.<strong>迪米特法则</strong>：一个软件实体尽量少的与其他实体发生相互作用（找中介）7. <strong>合成复用原则</strong>：少用继承，用组合/聚合代替继承</p><p><img src="/img/LE-OOP1/71.png" /> <img src="/img/LE-OOP1/72.png" /><img src="/img/LE-OOP1/73.png" /></p><h6 id="开闭">开闭</h6><p>在Java中，开闭原则可以通过抽象类和接口来实现，这样可以在不修改现有代码的情况下扩展功能。以下是一个简单的Java例子，展示了如何遵循开闭原则。<strong>不符合开闭原则的例子：</strong> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Rectangle</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">draw</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Drawing a rectangle&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">draw</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Drawing a circle&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GraphicEditor</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">drawShape</span><span class="hljs-params">(Object shape)</span> &#123;<br>        <span class="hljs-keyword">if</span> (shape <span class="hljs-keyword">instanceof</span> Rectangle) &#123;<br>            ((Rectangle) shape).draw();<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (shape <span class="hljs-keyword">instanceof</span> Circle) &#123;<br>            ((Circle) shape).draw();<br>        &#125;<br>        <span class="hljs-comment">// 如果要添加新的图形，比如三角形，需要修改这个方法</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">GraphicEditor</span> <span class="hljs-variable">editor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GraphicEditor</span>();<br>        editor.drawShape(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Rectangle</span>());<br>        editor.drawShape(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Circle</span>());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>在这个例子中，<code>GraphicEditor</code> 类的 <code>drawShape</code>方法依赖于具体的图形类。如果我们要添加一个新的图形类，比如三角形，我们需要修改<code>GraphicEditor</code> 类，这违反了开闭原则。<strong>符合开闭原则的例子：</strong> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Shape</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">draw</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Rectangle</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Shape</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">draw</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Drawing a rectangle&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Shape</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">draw</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Drawing a circle&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GraphicEditor</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">drawShape</span><span class="hljs-params">(Shape shape)</span> &#123;<br>        shape.draw();<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Triangle</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Shape</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">draw</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Drawing a triangle&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">GraphicEditor</span> <span class="hljs-variable">editor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GraphicEditor</span>();<br>        editor.drawShape(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Rectangle</span>());<br>        editor.drawShape(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Circle</span>());<br>        <span class="hljs-comment">// 添加新的图形时，不需要修改GraphicEditor类</span><br>        editor.drawShape(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Triangle</span>());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>在这个改进的例子中，我们定义了一个 <code>Shape</code>接口，所有的图形类都实现这个接口。<code>GraphicEditor</code> 类的<code>drawShape</code> 方法现在接受一个 <code>Shape</code>接口类型的参数，而不是具体的图形类。这样，当我们需要添加新的图形类（如<code>Triangle</code>）时，我们只需要创建一个新的类实现<code>Shape</code> 接口，而不需要修改 <code>GraphicEditor</code>类。这符合开闭原则，因为我们对扩展是开放的，对修改是关闭的。</p><h6 id="合成复用1">合成复用1</h6><p>当然可以。下面是一个更简单的例子，用于说明合成复用原则：<strong>场景</strong>：我们有一个表示汽车的类，汽车可以有不同的引擎。而不是通过继承来创建不同类型的汽车，我们使用组合来复用引擎的行为。<strong>不使用合成复用原则的例子（使用继承）：</strong> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Engine</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Engine starts&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CarWithPetrolEngine</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Engine</span> &#123;<br>    <span class="hljs-comment">// 使用汽油引擎的汽车</span><br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CarWithDieselEngine</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Engine</span> &#123;<br>    <span class="hljs-comment">// 使用柴油引擎的汽车</span><br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">CarWithPetrolEngine</span> <span class="hljs-variable">petrolCar</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CarWithPetrolEngine</span>();<br>        petrolCar.start(); <span class="hljs-comment">// Engine starts</span><br>        <span class="hljs-type">CarWithDieselEngine</span> <span class="hljs-variable">dieselCar</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CarWithDieselEngine</span>();<br>        dieselCar.start(); <span class="hljs-comment">// Engine starts</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>在这个例子中，我们通过继承来创建不同类型的汽车，但这可能导致不必要的复杂性，尤其是当引擎类型增多时。<strong>使用合成复用原则的例子（使用组合）：</strong> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Engine</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">PetrolEngine</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Engine</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Petrol engine starts&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DieselEngine</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Engine</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Diesel engine starts&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span> &#123;<br>    <span class="hljs-keyword">private</span> Engine engine;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Car</span><span class="hljs-params">(Engine engine)</span> &#123;<br>        <span class="hljs-built_in">this</span>.engine = engine;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">()</span> &#123;<br>        engine.start();<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Car</span> <span class="hljs-variable">petrolCar</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Car</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PetrolEngine</span>());<br>        petrolCar.start(); <span class="hljs-comment">// Petrol engine starts</span><br>        <span class="hljs-type">Car</span> <span class="hljs-variable">dieselCar</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Car</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">DieselEngine</span>());<br>        dieselCar.start(); <span class="hljs-comment">// Diesel engine starts</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>在这个改进的例子中，我们定义了一个 <code>Engine</code> 接口和两个实现类<code>PetrolEngine</code> 和 <code>DieselEngine</code>。<code>Car</code>类有一个 <code>Engine</code>类型的成员变量，并在构造函数中注入具体的引擎。这样，我们可以通过组合不同的引擎来创建不同类型的汽车，而不是通过继承。这种方法的好处是，如果将来我们有新的引擎类型（例如电动引擎），我们只需要添加一个新的实现类，而不需要修改<code>Car</code>类或其子类。这提高了代码的复用性、灵活性和可维护性。</p><h6 id="合成复用2">合成复用2</h6><p>合成复用原则（Composite ReusePrinciple）是面向对象设计的原则之一，它建议在设计中要尽量使用对象组合，而不是继承来达到复用的目的。该原则强调通过组合不同的对象来获得新的功能，而不是通过继承来扩展类的功能。这样可以减少系统的复杂性，提高灵活性和可维护性。以下是一个Java例子，展示了如何应用合成复用原则：<strong>不使用合成复用原则的例子（使用继承）：</strong> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bird</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fly</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Bird is flying&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Sparrow</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Bird</span> &#123;<br>    <span class="hljs-comment">// Sparrow继承了Bird的fly方法</span><br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Penguin</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Bird</span> &#123;<br>    <span class="hljs-comment">// Penguin继承了Bird的fly方法，但企鹅不会飞，这导致了不合理的设计</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fly</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnsupportedOperationException</span>(<span class="hljs-string">&quot;Penguin cannot fly&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Sparrow</span> <span class="hljs-variable">sparrow</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Sparrow</span>();<br>        sparrow.fly(); <span class="hljs-comment">// 合理</span><br>        <span class="hljs-type">Penguin</span> <span class="hljs-variable">penguin</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Penguin</span>();<br>        penguin.fly(); <span class="hljs-comment">// 不合理，抛出异常</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>在这个例子中，<code>Penguin</code> 类继承了 <code>Bird</code>类，但企鹅不会飞，所以继承导致了不合理的设计。我们需要重写<code>fly</code> 方法来抛出异常，这违反了合成复用原则。<strong>使用合成复用原则的例子（使用组合）：</strong> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Flyable</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">fly</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bird</span> &#123;<br>    <span class="hljs-keyword">private</span> Flyable flyable;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Bird</span><span class="hljs-params">(Flyable flyable)</span> &#123;<br>        <span class="hljs-built_in">this</span>.flyable = flyable;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">performFly</span><span class="hljs-params">()</span> &#123;<br>        flyable.fly();<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Sparrow</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Bird</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Sparrow</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">super</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Flyable</span>() &#123;<br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fly</span><span class="hljs-params">()</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;Sparrow is flying&quot;</span>);<br>            &#125;<br>        &#125;);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Penguin</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Bird</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Penguin</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">super</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Flyable</span>() &#123;<br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fly</span><span class="hljs-params">()</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;Penguin cannot fly&quot;</span>);<br>            &#125;<br>        &#125;);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">FlyWithWings</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Flyable</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fly</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Flying with wings&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">NoFly</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Flyable</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fly</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Cannot fly&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Sparrow</span> <span class="hljs-variable">sparrow</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Sparrow</span>();<br>        sparrow.performFly(); <span class="hljs-comment">// 合理</span><br>        <span class="hljs-type">Penguin</span> <span class="hljs-variable">penguin</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Penguin</span>();<br>        penguin.performFly(); <span class="hljs-comment">// 合理，输出&quot;Penguin cannot fly&quot;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>在这个改进的例子中，我们定义了一个 <code>Flyable</code>接口，表示飞行的能力。<code>Bird</code> 类有一个 <code>Flyable</code>类型的成员变量，并在构造函数中注入飞行行为。<code>Sparrow</code> 和<code>Penguin</code>类通过构造函数分别注入了不同的飞行行为。这样，我们通过组合而不是继承来实现了复用，符合合成复用原则。通过这种方式，我们可以更容易地添加新的飞行行为或者修改现有的行为，而无需修改<code>Bird</code>类或其子类的代码，从而提高了系统的灵活性和可维护性。</p><h6 id="依赖倒转">依赖倒转</h6><p><strong>依赖倒转原则</strong>（Dependency InversionPrinciple，DIP）是面向对象设计原则之一，也是SOLID原则中的“D”。它主张：1. 高层模块不应该依赖低层模块，两者都应该依赖抽象。 2.抽象不应该依赖细节，细节应该依赖抽象。<strong>简单例子</strong>：假设我们有一个通知系统，最初只通过邮件发送通知。<strong>违反依赖倒转原则的代码</strong>： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">EmailService</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sendEmail</span><span class="hljs-params">(String message, String recipient)</span> &#123;<br>        <span class="hljs-comment">// 发送邮件的实现</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">NotificationService</span> &#123;<br>    <span class="hljs-keyword">private</span> EmailService emailService;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">NotificationService</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.emailService = <span class="hljs-keyword">new</span> <span class="hljs-title class_">EmailService</span>();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">notify</span><span class="hljs-params">(String message, String recipient)</span> &#123;<br>        emailService.sendEmail(message, recipient);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>在这个例子中，<code>NotificationService</code> 直接依赖于<code>EmailService</code> 的具体实现，这违反了依赖倒转原则。<strong>遵循依赖倒转原则的改进代码</strong>： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">NotificationService</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">notify</span><span class="hljs-params">(String message, String recipient)</span>;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">EmailService</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">NotificationService</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">notify</span><span class="hljs-params">(String message, String recipient)</span> &#123;<br>        <span class="hljs-comment">// 发送邮件的实现</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SMSService</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">NotificationService</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">notify</span><span class="hljs-params">(String message, String recipient)</span> &#123;<br>        <span class="hljs-comment">// 发送短信的实现</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">NotificationController</span> &#123;<br>    <span class="hljs-keyword">private</span> NotificationService notificationService;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">NotificationController</span><span class="hljs-params">(NotificationService notificationService)</span> &#123;<br>        <span class="hljs-built_in">this</span>.notificationService = notificationService;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sendNotification</span><span class="hljs-params">(String message, String recipient)</span> &#123;<br>        notificationService.notify(message, recipient);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>在这个改进的例子中，我们引入了 <code>NotificationService</code>接口，作为抽象。<code>EmailService</code> 和 <code>SMSService</code>都实现了这个接口。<code>NotificationController</code> 类依赖于<code>NotificationService</code> 接口，而不是具体的实现。这样，如果将来我们需要添加新的通知方式（如微信、推送通知等），我们只需要创建新的实现类即可，而不需要修改<code>NotificationController</code>。这提高了代码的灵活性和可维护性。<strong>总结</strong>：依赖倒转原则通过依赖抽象而不是具体实现，降低了模块间的耦合度，使得系统更易于扩展和维护。</p><h6 id="接口隔离原则">接口隔离原则</h6><p>假设我们有一个用于打印文档的接口 <code>Printer</code>，它包含以下方法：- <code>printDocument()</code> - <code>scanDocument()</code> -<code>faxDocument()</code> - <code>printPhoto()</code>现在，我们有几个不同的类实现了这个接口： 1.<strong>SimplePrinter</strong>：一个基本的打印机，只能打印文档。 2.<strong>MultiFunctionPrinter</strong>：一个多功能打印机，可以打印、扫描、传真和打印照片。</p><p>根据接口隔离原则，<code>SimplePrinter</code> 类不应该被迫实现 <code>scanDocument()</code>、<code>faxDocument()</code> 和 <code>printPhoto()</code> 这些它不需要的方法。这样做会导致 <code>SimplePrinter</code> 类包含冗余的、不相关的代码。</p><p>应用接口隔离原则后的改进：我们可以将 <code>Printer</code> 接口拆分成更小的接口： -<code>PrintDocumentInterface</code>：包含 <code>printDocument()</code> 方法。-<code>ScanDocumentInterface</code>：包含 <code>scanDocument()</code> 方法。-<code>FaxDocumentInterface</code>：包含 <code>faxDocument()</code> 方法。-<code>PrintPhotoInterface</code>：包含 <code>printPhoto()</code> 方法。然后，我们的类可以按需实现这些接口： 1.<strong>SimplePrinter</strong>：实现 <code>PrintDocumentInterface</code>。2.<strong>MultiFunctionPrinter</strong>：实现 <code>PrintDocumentInterface</code>、<code>ScanDocumentInterface</code>、<code>FaxDocumentInterface</code> 和 <code>PrintPhotoInterface</code>。</p><h6 id="迪米特法则">迪米特法则</h6><p>在Java中，迪米特法则（Law ofDemeter）同样强调减少类之间的直接交互，以降低耦合度。以下是一个简单的Java例子，用于说明如何应用迪米特法则。<strong>场景：</strong>假设我们有一个订单处理系统，其中包含<code>Order</code>（订单）、<code>Customer</code>（客户）和<code>Payment</code>（支付）等类。<strong>不符合迪米特法则的设计：</strong> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Order</span> &#123;<br>    <span class="hljs-keyword">private</span> Customer customer;<br>    <span class="hljs-keyword">private</span> Payment payment;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">process</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// Order类直接与Customer和Payment类交互</span><br>        customer.verify();<br>        payment.pay();<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Customer</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">verify</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 客户验证逻辑</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Payment</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pay</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 支付逻辑</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>在这个例子中，<code>Order</code> 类直接调用了 <code>Customer</code> 和<code>Payment</code> 类的方法，这意味着 <code>Order</code> 类需要了解<code>Customer</code> 和 <code>Payment</code>类的内部实现。这违反了迪米特法则。<strong>符合迪米特法则的设计：</strong>为了遵守迪米特法则，我们可以引入一个中介者类，例如<code>OrderProcessor</code>，来处理订单处理的逻辑：我们还可以进一步封装 <code>Order</code> 类，使其不直接暴露<code>Customer</code> 和 <code>Payment</code>对象。通过这种方式，我们进一步限制了 <code>Order</code>类与其他类的直接交互，使得类之间的关系更加清晰，符合迪米特法则。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Order</span> &#123;<br>    <span class="hljs-keyword">private</span> Customer customer;<br>    <span class="hljs-keyword">private</span> Payment payment;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">process</span><span class="hljs-params">(OrderProcessor processor)</span> &#123;<br>        processor.process(<span class="hljs-built_in">this</span>);<br>    &#125;<br>    <span class="hljs-comment">// 私有方法，用于OrderProcessor访问</span><br>    <span class="hljs-keyword">private</span> Customer <span class="hljs-title function_">getCustomer</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> customer;<br>    &#125;<br>    <span class="hljs-comment">// 私有方法，用于OrderProcessor访问</span><br>    <span class="hljs-keyword">private</span> Payment <span class="hljs-title function_">getPayment</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> payment;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Customer</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">verify</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 客户验证逻辑</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Payment</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pay</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 支付逻辑</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderProcessor</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">process</span><span class="hljs-params">(Order order)</span> &#123;<br>        <span class="hljs-comment">// OrderProcessor负责处理订单，与Customer和Payment类交互</span><br>        order.getCustomer().verify();<br>        order.getPayment().pay();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure> 在这个改进后的设计中，<code>Order</code> 类不再直接与<code>Customer</code> 和 <code>Payment</code> 类交互，而是通过<code>OrderProcessor</code> 类来进行。这样，<code>Order</code>类不需要了解 <code>Customer</code> 和 <code>Payment</code>类的内部实现，从而减少了类之间的耦合。迪米特法则的应用有助于创建松耦合、高内聚的类设计，从而提高代码的可维护性和可扩展性。然而，也需要注意不要过度应用，以免导致代码过于复杂或难以理解。</p><h6 id="里氏代换原则">里氏代换原则</h6><p>里氏代换原则（Liskov SubstitutionPrinciple，LSP）是面向对象设计中的五大原则之一，由芭芭拉·利斯科夫（BarbaraLiskov）在1987年提出。该原则的核心思想是：子类对象应该能够替换其父类对象，而不会导致程序的业务逻辑出现异常。里氏代换原则强调的是子类和父类之间的兼容性，即子类应该继承父类的所有属性和行为，并且可以在此基础上进行扩展，但不能改变父类原有的行为。这样，在程序中，我们可以放心地使用父类对象的地方替换为子类对象，而不会影响程序的正确性。以下是一个Java例子，用于说明里氏代换原则： <strong>场景：</strong>假设我们有一个表示鸟的基类<code>Bird</code>，以及两个子类<code>Sparrow</code>（麻雀）和<code>Ostrich</code>（鸵鸟）。<strong>不符合里氏代换原则的设计：</strong> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bird</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fly</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;This bird can fly.&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Sparrow</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Bird</span> &#123;<br>    <span class="hljs-comment">// Sparrow继承了Bird的fly方法，可以飞行</span><br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Ostrich</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Bird</span> &#123;<br>    <span class="hljs-comment">// Ostrich也继承了Bird的fly方法，但鸵鸟实际上不会飞</span><br>    <span class="hljs-comment">// 这违反了里氏代换原则，因为Ostrich不能替换Bird而不改变程序的预期行为</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fly</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnsupportedOperationException</span>(<span class="hljs-string">&quot;Ostrich cannot fly.&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Bird</span> <span class="hljs-variable">bird</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Sparrow</span>();<br>        bird.fly(); <span class="hljs-comment">// 正常运行</span><br>        bird = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Ostrich</span>();<br>        bird.fly(); <span class="hljs-comment">// 这里会抛出异常，违反了里氏代换原则</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>在这个例子中，<code>Ostrich</code> 类继承了 <code>Bird</code> 类的<code>fly</code> 方法，但实际上鸵鸟是不会飞的。当我们尝试用<code>Ostrich</code> 对象替换 <code>Bird</code> 对象时，调用<code>fly</code> 方法会抛出异常，这违反了里氏代换原则。<strong>符合里氏代换原则的设计：</strong>为了遵守里氏代换原则，我们不应该让 <code>Ostrich</code> 继承<code>Bird</code> 的 <code>fly</code>方法。我们可以通过提取接口或使用组合的方式来解决这个问题：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Flyable</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">fly</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bird</span> &#123;<br>    <span class="hljs-comment">// Bird类不再包含fly方法</span><br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Sparrow</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Bird</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Flyable</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fly</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Sparrow can fly.&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Ostrich</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Bird</span> &#123;<br>    <span class="hljs-comment">// Ostrich不再继承fly方法，因此不会违反里氏代换原则</span><br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Flyable</span> <span class="hljs-variable">flyableBird</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Sparrow</span>();<br>        flyableBird.fly(); <span class="hljs-comment">// 正常运行</span><br>        <span class="hljs-type">Bird</span> <span class="hljs-variable">bird</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Ostrich</span>();<br>        <span class="hljs-comment">// 鸵鸟没有fly方法，但我们也没有期望它能够飞行</span><br>        <span class="hljs-comment">// 这符合里氏代换原则，因为Ostrich可以替换Bird而不改变程序的预期行为</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure> 在这个改进后的设计中，我们引入了 <code>Flyable</code>接口，只有会飞的鸟（如<code>Sparrow</code>）才实现这个接口。<code>Ostrich</code> 类不再继承<code>fly</code>方法，因此不会违反里氏代换原则。这样，我们可以确保在程序中替换父类对象为子类对象时，不会影响程序的正确性。里氏代换原则是面向对象设计中的重要原则，它有助于我们设计出更加灵活、可扩展和可维护的代码。通过遵守这个原则，我们可以确保子类和父类之间的兼容性，避免在程序运行时出现意外行为。</p><h2 id="设计模式-7">设计模式 7</h2><p><img src="/img/LE-OOP1/74.png" /><strong>工厂方法模式</strong>的核心是把类的<strong>实例化延迟到其子类</strong>被造的东西有个接口、工厂有个接口，被造的东西和工厂分别实现这两个接口，然后工厂类<code>public Vehicle createVehicle() &#123;  return new Car();&#125;</code><strong>适配器模式</strong>的核心是将一个类的接口<strong>转换</strong>成客户希望的另外一个接口两个接口：原来的东西和新加的东西。类来实现新加的东西的接口。Adapter实现原来的东西的接口，同时拥有新加的东西的接口。<strong>装饰模式</strong>的核心是<strong>动态</strong>地给对象添加一些额外的职责。具体组件继承抽象组件；抽象装饰继承抽象组件，同时拥有抽象组件；具体装饰继承抽象装饰，有装饰函数；调用时<code>Bird bird = new Sparrow; bird = new birdDecorator(bird)</code><strong>外观模式</strong>的核心是通过为多个复杂的子系统提供一个<strong>一致的接口</strong>，而使这些子系统<strong>更加容易被访问</strong>的模式。外观角色拥有子系统123；客户角色依赖外观角色。<strong>策略模式</strong>的核心是定义<strong>一系列算法</strong>,把它们一个个<strong>封装</strong>起来,并且使它们可<strong>相互替换</strong>。本模式使得算法可独立于使用它的客户而变化。上下文拥有抽象策略，同时在方法体内调用策略的算法；具体策略实现抽象策略<strong>访问者模式</strong>的核心是在<strong>不改变各个元素的类</strong>的前提下定义作用于这些元素的<strong>新操作</strong>。元素、访问者接口；具体元素实现元素接口；具体访问者实现访问者接口；具体元素和集体访问者相互关联<strong>责任链模式</strong>的关键是将用户的请求<strong>分派给许多对象</strong>。处理者接口规定具体处理者<strong>处理用户的请求的方法</strong>以及具体处理者<strong>设置后继对象</strong>的方法；具体处理者实现处理者接口；使用时先设置后继对象在调用第一个处理者<strong>观察者模式</strong>的核心是当一个对象改变状态时，所有依赖于它的对象都会得到通知并自动更新。被观察者存了一个list表示观察者，观察者存了自己观察的对象。当被观察者发生变化时，通知观察者，观察者更新数据并展示出来### 单例模式 -<strong>饿汉式</strong>：类加载时就创建实例，像是一个饥饿的人急于吃东西。-<strong>懒汉式</strong>：使用时才创建实例，像是一个懒惰的人等到需要时才行动。<img src="/img/LE-OOP1/75.png" /> <img src="/img/LE-OOP1/76.png" />###### 饿汉式 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;  <br>    <span class="hljs-comment">// 静态的。保留自身的引用，类加载时就初始化  </span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">test</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();  <br>    <span class="hljs-comment">// 必须是私有的构造函数  </span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;&#125;  <br>    <span class="hljs-comment">// 公共的静态方法  </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> test;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure> ###### 懒汉式 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;  <br>    <span class="hljs-comment">// 静态的。保留自身的引用  </span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">test</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;  <br>    <span class="hljs-comment">// 必须是私有的构造函数  </span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;&#125;  <br>    <span class="hljs-comment">// 公共的静态方法  </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">if</span>(test == <span class="hljs-literal">null</span>) &#123;  <br>            test = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();  <br>        &#125;  <br>        <span class="hljs-keyword">return</span> test;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure> ######多线程安全的懒汉式 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 修改上述代码避免多线程中的安全问题</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">test</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;&#125;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">if</span>(test == <span class="hljs-literal">null</span>) &#123;  <br>        <span class="hljs-keyword">synchronized</span>(Singleton.class)&#123;<br>        <span class="hljs-keyword">if</span>(test == <span class="hljs-literal">null</span>)&#123;<br>            test = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();  <br>        &#125;<br>        &#125;<br>        &#125;  <br>        <span class="hljs-keyword">return</span> test;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure> ### 工厂模式简单工厂：<strong>一个工厂类</strong>，由一<strong>个工厂类根据传入的参数</strong>决定创建哪一种产品类的实例。工厂方法：<strong>一个工厂接口，一堆工厂类（每种产品都有一个类），一条产品线（产出不同种类的东西）</strong>。工厂方法模式定义了一个创建对象的接口，但<strong>由子类决定要实例化的类是哪一个</strong>。工厂方法模式让类的实例化推迟到子类。抽象工厂：<strong>一个工厂接口，一堆工厂类（每种产品都有一个类），一堆产品线（每条产品线能产出不同种类的东西）</strong>，提供了一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类。这种模式通常用于系统中有多个<strong>产品族</strong>，且每个产品族都有多个产品等级的情况。</p><p>工厂模式（FactoryPattern）是Java中最常用的设计模式之一。这种模式提供了一种创建对象的最佳方式，通过使用工厂模式，我们可以将对象的创建逻辑与使用逻辑分离，使得客户端代码不依赖于具体类的实现，而是依赖于抽象接口或类。这样，当需要更换或增加新的产品类时，不需要修改客户端代码，提高了代码的可扩展性和可维护性。工厂模式主要有三种形式： 1. 简单工厂模式（Simple Factory Pattern） 2.工厂方法模式（Factory Method Pattern） 3. 抽象工厂模式（Abstract FactoryPattern）下面以简单工厂模式和工厂方法模式为例，介绍工厂模式在Java中的实现。 #####简单工厂模式 <img src="/img/LE-OOP1/77.png" /> <strong>示例：</strong>假设我们需要创建不同类型的交通工具，如汽车和自行车。 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 交通工具接口</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Vehicle</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">drive</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-comment">// 汽车类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Vehicle</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">drive</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Driving a car&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 自行车类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bicycle</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Vehicle</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">drive</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Riding a bicycle&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 简单工厂类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">VehicleFactory</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Vehicle <span class="hljs-title function_">createVehicle</span><span class="hljs-params">(String type)</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;car&quot;</span>.equals(type)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Car</span>();<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;bicycle&quot;</span>.equals(type)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bicycle</span>();<br>        &#125;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Unknown vehicle type&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 客户端代码</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SimpleFactoryDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Vehicle</span> <span class="hljs-variable">car</span> <span class="hljs-operator">=</span> VehicleFactory.createVehicle(<span class="hljs-string">&quot;car&quot;</span>);<br>        car.drive();<br>        <span class="hljs-type">Vehicle</span> <span class="hljs-variable">bicycle</span> <span class="hljs-operator">=</span> VehicleFactory.createVehicle(<span class="hljs-string">&quot;bicycle&quot;</span>);<br>        bicycle.drive();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>##### 工厂方法模式 <img src="/img/LE-OOP1/78.png" /><strong>示例：</strong>继续使用交通工具的例子，但这次我们将工厂类抽象化，并为每种交通工具提供一个具体的工厂类。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 交通工具接口</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Vehicle</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">drive</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-comment">// 汽车类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Vehicle</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">drive</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Driving a car&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 自行车类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bicycle</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Vehicle</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">drive</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Riding a bicycle&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 工厂接口</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">VehicleFactory</span> &#123;<br>    Vehicle <span class="hljs-title function_">createVehicle</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-comment">// 汽车工厂类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CarFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">VehicleFactory</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Vehicle <span class="hljs-title function_">createVehicle</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Car</span>();<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 自行车工厂类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BicycleFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">VehicleFactory</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Vehicle <span class="hljs-title function_">createVehicle</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bicycle</span>();<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 客户端代码</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FactoryMethodDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">VehicleFactory</span> <span class="hljs-variable">carFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CarFactory</span>();<br>        <span class="hljs-type">Vehicle</span> <span class="hljs-variable">car</span> <span class="hljs-operator">=</span> carFactory.createVehicle();<br>        car.drive();<br>        <span class="hljs-type">VehicleFactory</span> <span class="hljs-variable">bicycleFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BicycleFactory</span>();<br>        <span class="hljs-type">Vehicle</span> <span class="hljs-variable">bicycle</span> <span class="hljs-operator">=</span> bicycleFactory.createVehicle();<br>        bicycle.drive();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure> 在这个例子中，我们定义了一个 <code>VehicleFactory</code>接口和两个实现该接口的工厂类 <code>CarFactory</code> 和<code>BicycleFactory</code>。每个工厂类负责创建一种类型的交通工具。客户端代码通过具体的工厂类来创建对象，这样当需要添加新的交通工具时，只需要添加新的工厂类和产品类，而不需要修改现有的代码。工厂模式在Java中的应用非常广泛，它可以帮助我们更好地组织代码，实现解耦和灵活的对象创建。通过使用工厂模式，我们可以提高代码的可扩展性、可维护性和可测试性。##### 抽象工厂 <img src="/img/LE-OOP1/79.png" />要将上述代码改写成抽象工厂模式，我们需要定义一个抽象工厂接口，该接口不仅负责创建交通工具，还可能负责创建与交通工具相关的其他产品，比如轮胎（Tire）或引擎（Engine）。这样，每个具体工厂就能创建一个产品家族，而不仅仅是一个产品。以下是一个简单的示例，展示如何将代码改写成抽象工厂模式： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 交通工具接口</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Vehicle</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">drive</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-comment">// 汽车类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Vehicle</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">drive</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Driving a car&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 自行车类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bicycle</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Vehicle</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">drive</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Riding a bicycle&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 轮胎接口</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Tire</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">roll</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-comment">// 汽车轮胎类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CarTire</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Tire</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">roll</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Car tire rolling&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 自行车轮胎类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BicycleTire</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Tire</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">roll</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Bicycle tire rolling&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 抽象工厂接口</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">VehicleFactory</span> &#123;<br>    Vehicle <span class="hljs-title function_">createVehicle</span><span class="hljs-params">()</span>;<br>    Tire <span class="hljs-title function_">createTire</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-comment">// 汽车工厂类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CarFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">VehicleFactory</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Vehicle <span class="hljs-title function_">createVehicle</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Car</span>();<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Tire <span class="hljs-title function_">createTire</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CarTire</span>();<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 自行车工厂类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BicycleFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">VehicleFactory</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Vehicle <span class="hljs-title function_">createVehicle</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bicycle</span>();<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Tire <span class="hljs-title function_">createTire</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BicycleTire</span>();<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 客户端代码</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractFactoryDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">VehicleFactory</span> <span class="hljs-variable">carFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CarFactory</span>();<br>        <span class="hljs-type">Vehicle</span> <span class="hljs-variable">car</span> <span class="hljs-operator">=</span> carFactory.createVehicle();<br>        <span class="hljs-type">Tire</span> <span class="hljs-variable">carTire</span> <span class="hljs-operator">=</span> carFactory.createTire();<br>        car.drive();<br>        carTire.roll();<br>        <span class="hljs-type">VehicleFactory</span> <span class="hljs-variable">bicycleFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BicycleFactory</span>();<br>        <span class="hljs-type">Vehicle</span> <span class="hljs-variable">bicycle</span> <span class="hljs-operator">=</span> bicycleFactory.createVehicle();<br>        <span class="hljs-type">Tire</span> <span class="hljs-variable">bicycleTire</span> <span class="hljs-operator">=</span> bicycleFactory.createTire();<br>        bicycle.drive();<br>        bicycleTire.roll();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>在这个改写后的例子中，<code>VehicleFactory</code>接口现在有两个方法：<code>createVehicle</code> 和<code>createTire</code>。每个具体工厂（<code>CarFactory</code> 和<code>BicycleFactory</code>）都实现了这两个方法，分别用于创建交通工具和对应的轮胎。这样，每个工厂都能创建一个产品家族，而客户端代码可以通过抽象工厂接口来获取这些相关产品的实例。抽象工厂模式的关键在于提供一个接口，用于创建多个相关或依赖对象的家族，而不需要明确指定具体类。这样，客户端代码就可以与具体类的实现细节解耦。</p><h3 id="原型模式">原型模式</h3><p><strong>原型模式（Prototype Pattern）</strong>在Java中通常用于创建对象的一个副本，而不是通过构造函数重新创建。<strong>主要角色：</strong> 1.<strong>Prototype（原型接口）</strong>：声明一个克隆自己的方法。 2.<strong>ConcretePrototype（具体原型类）</strong>：实现原型接口，实现克隆方法。3. <strong>Client（客户端）</strong>：使用原型实例来创建新的对象。</p><h5 id="示例文档编辑器中的文档复制">示例：文档编辑器中的文档复制</h5><p>假设我们有一个文档编辑器，用户可以创建文档，并希望能够复制现有的文档以创建新的文档。这里，文档对象就是一个原型。1. 定义原型接口 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">DocumentPrototype</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Cloneable</span> &#123;<br>    DocumentPrototype <span class="hljs-title function_">clone</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">setContent</span><span class="hljs-params">(String content)</span>;<br>    String <span class="hljs-title function_">getContent</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure> 2. 实现具体原型类 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TextDocument</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">DocumentPrototype</span> &#123;<br>    <span class="hljs-keyword">private</span> String content;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">TextDocument</span><span class="hljs-params">(String content)</span> &#123;<br>        <span class="hljs-built_in">this</span>.content = content;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> DocumentPrototype <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> (TextDocument) <span class="hljs-built_in">super</span>.clone();<br>        &#125; <span class="hljs-keyword">catch</span> (CloneNotSupportedException e) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setContent</span><span class="hljs-params">(String content)</span> &#123;<br>        <span class="hljs-built_in">this</span>.content = content;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getContent</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> content;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure> 3.客户端代码使用原型 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DocumentEditor</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 创建一个初始文档</span><br>        <span class="hljs-type">TextDocument</span> <span class="hljs-variable">originalDocument</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TextDocument</span>(<span class="hljs-string">&quot;Hello, World!&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;Original Document Content: &quot;</span> + originalDocument.getContent());<br>        <span class="hljs-comment">// 复制文档</span><br>        <span class="hljs-type">TextDocument</span> <span class="hljs-variable">copiedDocument</span> <span class="hljs-operator">=</span> (TextDocument) originalDocument.clone();<br>        System.out.println(<span class="hljs-string">&quot;Copied Document Content: &quot;</span> + copiedDocument.getContent());<br>        <span class="hljs-comment">// 修改复制后的文档内容</span><br>        copiedDocument.setContent(<span class="hljs-string">&quot;Hello, Prototype Pattern!&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;Modified Copied Document Content: &quot;</span> + copiedDocument.getContent());<br>        <span class="hljs-comment">// 原始文档内容保持不变</span><br>        System.out.println(<span class="hljs-string">&quot;Original Document Content after copy modification: &quot;</span> + originalDocument.getContent());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure> ##### 输出： <figure class="highlight erlang-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs erlang-repl">Original Document Content: Hello, World!<br>Copied Document Content: Hello, World!<br>Modified Copied Document Content: Hello, Prototype Pattern!<br>Original Document Content after copy modification: Hello, World!<br></code></pre></td></tr></table></figure> #####说明： - <strong>DocumentPrototype</strong>接口定义了克隆方法，所有具体的文档类都需要实现这个接口。 -<strong>TextDocument</strong> 类实现了<strong>DocumentPrototype</strong>接口，并提供了具体的克隆实现。这里使用了Java的 <code>clone()</code>方法，它执行的是深拷贝。 - 在 <strong>DocumentEditor</strong>类中，我们创建了一个文档对象，并使用原型模式复制了这个对象。修改复制后的文档不会影响原始文档。这个例子展示了如何使用原型模式来复制对象，从而避免了通过构造函数重新创建对象的成本。</p><h3 id="适配器模式">适配器模式</h3><p><img src="/img/LE-OOP1/80.png" /> +<strong>目标</strong>（Target）：目标是一个接口，该接口是<strong>客户想使用的接口</strong>。+<strong>被适配者</strong>（Adaptee）：被适配者是一个已经存在的<strong>接口或抽象类</strong>，这个接口或抽象类需要适配。+<strong>适配器</strong>（Adapter）：适配器是一个类，该类实现了目标接口并包含有被适配者的引用，即<strong>适配器的职责是对被适配者接口（抽象类）与目标接口进行适配</strong>。</p><h4 id="例1-1">例1</h4><p>在Java中，适配器模式通常用于将一个类的接口转换成客户期望的另一个接口，使原本接口不兼容的类可以合作无间。下面通过一个具体的例子来介绍适配器模式的应用。##### 场景描述假设我们有一个<code>MediaPlayer</code>接口，它有一个<code>play</code>方法，用于播放音乐文件。目前它只能播放<code>mp3</code>格式的文件。现在我们需要扩展功能，使其能够播放<code>mp4</code>和<code>vlc</code>格式的文件。但是，我们已经有了一些可以播放这些格式的类（<code>Mp4Player</code>和<code>VlcPlayer</code>），它们的接口与<code>MediaPlayer</code>不兼容。这时，我们可以使用适配器模式来解决这个问题。+ 目标： <code>MediaPlayer</code> + 被适配者：<code>AdvancedMediaPlayer</code> + 适配器：<code>MediaAdapter</code></p><h5 id="类图">类图</h5><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">+-------------------+       +-------------------+       +-------------------+<br>|<span class="hljs-string"> MediaPlayer       </span>|<span class="hljs-string">       </span>|<span class="hljs-string"> MediaAdapter      </span>|<span class="hljs-string">       </span>|<span class="hljs-string"> AdvancedMediaPlayer</span>|<br>+-------------------+       +-------------------+       +-------------------+<br>|<span class="hljs-string"> +play(String,     </span>|<span class="hljs-string">&lt;&gt;----&gt;</span>|<span class="hljs-string"> -advancedMusicPlayer </span>|<span class="hljs-string">&lt;&gt;----&gt;</span>|<span class="hljs-string"> +playVlc(String)  </span>|<br>|<span class="hljs-string">  String)          </span>|<span class="hljs-string">       </span>|<span class="hljs-string">                    </span>|<span class="hljs-string">       </span>|<span class="hljs-string"> +playMp4(String)  </span>|<br>+-------------------+       +-------------------+       +-------------------+<br>                             |<span class="hljs-string"> +play(String,     </span>|<br>                             |<span class="hljs-string">  String)          </span>|<br>                             +-------------------+<br></code></pre></td></tr></table></figure><h5 id="代码实现">代码实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// MediaPlayer.java  </span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">MediaPlayer</span> &#123; <span class="hljs-comment">// 目标  </span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">play</span><span class="hljs-params">(String audioType, String fileName)</span>;  <br>&#125;  <br><span class="hljs-comment">// AdvancedMediaPlayer.java  </span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">AdvancedMediaPlayer</span> &#123; <span class="hljs-comment">// 被适配者  </span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">playVlc</span><span class="hljs-params">(String fileName)</span>;  <br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">playMp4</span><span class="hljs-params">(String fileName)</span>;  <br>&#125;  <br><span class="hljs-comment">// Mp4Player.java  </span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Mp4Player</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">AdvancedMediaPlayer</span> &#123; <span class="hljs-comment">// 被适配者的具体类  </span><br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">playVlc</span><span class="hljs-params">(String fileName)</span> &#123;  <br>        <span class="hljs-comment">// Do nothing  </span><br>    &#125;  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">playMp4</span><span class="hljs-params">(String fileName)</span> &#123;  <br>        System.out.println(<span class="hljs-string">&quot;Playing mp4 file. Name: &quot;</span> + fileName);  <br>    &#125;  <br>&#125;  <br><span class="hljs-comment">// VlcPlayer.java  </span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">VlcPlayer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">AdvancedMediaPlayer</span> &#123; <span class="hljs-comment">// 被适配者的具体类  </span><br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">playVlc</span><span class="hljs-params">(String fileName)</span> &#123;  <br>        System.out.println(<span class="hljs-string">&quot;Playing vlc file. Name: &quot;</span> + fileName);  <br>    &#125;  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">playMp4</span><span class="hljs-params">(String fileName)</span> &#123;  <br>        <span class="hljs-comment">// Do nothing  </span><br>    &#125;  <br>&#125;  <br><span class="hljs-comment">// MediaAdapter.java  </span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MediaAdapter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MediaPlayer</span> &#123; <span class="hljs-comment">// 适配器  </span><br>    AdvancedMediaPlayer advancedMusicPlayer;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MediaAdapter</span><span class="hljs-params">()</span> &#123;&#125;  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">play</span><span class="hljs-params">(String audioType, String fileName)</span> &#123;  <br>        <span class="hljs-comment">// Inbuilt support to play mp3 music files  </span><br>        <span class="hljs-keyword">if</span> (audioType.equalsIgnoreCase(<span class="hljs-string">&quot;mp3&quot;</span>)) &#123;  <br>            System.out.println(<span class="hljs-string">&quot;Playing mp3 file. Name: &quot;</span> + fileName);  <br>        &#125;  <br>        <span class="hljs-comment">// MediaAdapter is providing support to play other file formats  </span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (audioType.equalsIgnoreCase(<span class="hljs-string">&quot;vlc&quot;</span>)) &#123;  <br>            advancedMusicPlayer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">VlcPlayer</span>();  <br>            advancedMusicPlayer.playVlc(fileName);  <br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (audioType.equalsIgnoreCase(<span class="hljs-string">&quot;mp4&quot;</span>)) &#123;  <br>            advancedMusicPlayer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Mp4Player</span>();  <br>            advancedMusicPlayer.playMp4(fileName);  <br>        &#125; <span class="hljs-keyword">else</span> &#123;  <br>            System.out.println(<span class="hljs-string">&quot;Invalid media. &quot;</span> + audioType + <span class="hljs-string">&quot; format not supported&quot;</span>);  <br>        &#125;  <br>    &#125;  <br>&#125;  <br>  <br><span class="hljs-comment">// Main.java  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>        <span class="hljs-type">MediaAdapter</span> <span class="hljs-variable">audioPlayer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MediaAdapter</span>();  <br>        audioPlayer.play(<span class="hljs-string">&quot;mp3&quot;</span>, <span class="hljs-string">&quot;beyond the horizon.mp3&quot;</span>);  <br>        audioPlayer.play(<span class="hljs-string">&quot;mp4&quot;</span>, <span class="hljs-string">&quot;alone.mp4&quot;</span>);  <br>        audioPlayer.play(<span class="hljs-string">&quot;vlc&quot;</span>, <span class="hljs-string">&quot;far far away.vlc&quot;</span>);  <br>        audioPlayer.play(<span class="hljs-string">&quot;avi&quot;</span>, <span class="hljs-string">&quot;mind me.avi&quot;</span>);  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><h5 id="输出">输出</h5><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs delphi">Playing mp3 <span class="hljs-keyword">file</span>. <span class="hljs-keyword">Name</span>: beyond the horizon.mp3<br>Playing mp4 <span class="hljs-keyword">file</span>. <span class="hljs-keyword">Name</span>: alone.mp4<br>Playing vlc <span class="hljs-keyword">file</span>. <span class="hljs-keyword">Name</span>: <span class="hljs-keyword">far</span> <span class="hljs-keyword">far</span> away.vlc<br>Invalid media. avi format <span class="hljs-keyword">not</span> supported<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>AudioPlayer</code>类实现了<code>MediaPlayer</code>接口，可以播放<code>mp3</code>文件。对于<code>mp4</code>和<code>vlc</code>文件，它使用了一个<code>MediaAdapter</code>来适配<code>AdvancedMediaPlayer</code>接口，从而实现了播放不同格式文件的功能。这样，我们就通过适配器模式实现了接口的转换，使得原本不兼容的类可以一起工作。</p><h3 id="装饰模式">装饰模式</h3><p><img src="/img/LE-OOP1/81.png" /> +抽象组件（Component）：抽象组件（是抽象类）定义了需要进行装饰的方法。抽象组件就<strong>是“被装饰者”角色</strong>。+ 具体组件（ConcreteComponent）：具体组件是抽象组件的一个子类。 +装饰（Decorator）：该角色是抽象组件的一个子类，<strong>是“装饰者”角色</strong>，其作用是装饰具体组件。Decorator角色需要<strong>包含抽象组件的引用</strong>。+具体装饰（ConcreteDecotator）：具体装饰是Decorator角色的一个非抽象子类</p><p><img src="/img/LE-OOP1/82.png" /></p><p>抽象组件 <img src="/img/LE-OOP1/83.png" /> 具体组件 <imgsrc="/img/LE-OOP1/84.png" /> 装饰 <img src="/img/LE-OOP1/85.png" />具体装饰 <img src="/img/LE-OOP1/86.png" /> 模式的使用 <imgsrc="/img/LE-OOP1/87.png" /> <img src="/img/LE-OOP1/88.png" />最后的<code>bird</code> <img src="/img/LE-OOP1/89.png" /></p><h3 id="外观模式门面模式">外观模式（门面模式）</h3><p><img src="/img/LE-OOP1/90.png" /> +外观（Facade）模式又叫作门面模式，是一种通过为多个复杂的子系统提供一个<strong>一致的接口</strong>，而使这些子系统<strong>更加容易被访问</strong>的模式。+该模式对外有一个统一接口，外部应用程序不用关心内部子系统的具体细节，这样会大大降低应用程序的复杂度，降低其与子系统的耦合，提高了程序的可维护性。+ 是“<strong>迪米特法则</strong>”的典型应用 迪米特法则:一个软件实体应当尽可能少地与其他实体发生相互作用</p><p><img src="/img/LE-OOP1/91.png" /> <imgsrc="/img/LE-OOP1/92.png" /></p><h3 id="策略模式">策略模式</h3><p><img src="/img/LE-OOP1/93.png" /> +<strong>策略</strong>（Strategy）：策略是一个<strong>接口</strong>，该接口定义若干个算法标识，即<strong>定义了若干个抽象方法</strong>。<font color="#ff0000">核心就是将类中经常需要变化的部分分割出来，并将每种可能的变化对应地交给抽象类的一个子类或实现接口的一个类去负责，从而让类的设计者不去关心具体实现，避免所设计的类依赖于具体的实现。</font>+<strong>上下文</strong>（Context）：上下文是依赖于策略接口的<strong>类</strong>（是面向策略设计的类），即上下文<strong>包含有用策略声明的变量</strong>。上下文中提供一个<strong>方法</strong>，该方<strong>法委托策略变量调用具体策略所实现的策略接口中的方法</strong>。+<strong>具体策略</strong>（ConcreteStrategy）：具体策略是<strong>实现策略接口的类</strong>。具体策略实现策略接口所定义的抽象方法，即<strong>给出算法标识的具体算法</strong>。</p><p>问题：在多个裁判负责打分的比赛中，每位裁判给选手一个得分，选手的最后得分是根据全体裁判的得分计算出来的。请给出几种计算选手得分的评分方案（策略），对于某次比赛，可以从你的方案中选择一种方案作为本次比赛的评分方案。+在这里我们把策略接口命名为：<code>Strategy</code>。在具体应用中，这个角色的名字可以根据具体问题来命名。+ 在本问题中将上下文命名为 <code>AverageScore</code>，即让<code>AverageScore</code> 类依赖于 <code>Strategy</code> 接口。 +每个具体策略负责一系列算法中的一个。</p><ul><li>策略（ <code>Strategy</code> ） <imgsrc="/img/LE-OOP1/94.png" /></li><li>上下文（ <code>Context</code> ） <imgsrc="/img/LE-OOP1/95.png" /></li><li>具体策略StrategyA.java <img src="/img/LE-OOP1/96.png" /></li><li>具体策略StrategyB.java <img src="/img/LE-OOP1/97.png" /></li><li>模式的使用 <img src="/img/LE-OOP1/98.png" /> <imgsrc="/img/LE-OOP1/99.png" /> <img src="/img/LE-OOP1/100.png" /></li></ul><h3 id="访问者模式">访问者模式</h3><ul><li><strong>模式优点</strong>：在不改变一个集合中的元素的类的情况下，可以增加新的施加于该元素上的新操作。保持一定的扩展性。</li><li><strong>使用场景</strong>：需要对集合中的对象进行很多不同的并且不相关的操作，而我们又不想修改对象的类，就可以使用访问者模式。访问者模式可以在Visitor类中集中定义一些关于集合中对象的操作。</li></ul><p><img src="/img/LE-OOP1/101.png" /> +抽象元素（Element）：一个抽象类，该类定义了接收访问者的accept操作。 +具体元素（Concrete Element）：Element的子类。 +抽象访问者（Visitor）：一个接口，该接口定义操作具体元素的方法。 +具体访问者（Concrete Visitor）：实现Visitor接口的类。</p><ul><li><p><strong>门诊部</strong>是一个类似于<strong>访问者的对象</strong>，它可以<strong>访问不同类型的病人对象</strong>，例如普通病人、急诊病人、儿科病人等。</p></li><li><p><strong>不同类型的病人对象可以有不同的处理方法</strong>，例如看病、输液、检查等。</p></li><li><p>门诊部可以对不同类型的病人对象进行不同的操作，而不需要改变病人对象的类层次结构。</p></li><li><p>抽象访问者 <img src="/img/LE-OOP1/102.png" /></p></li><li><p>具体访问者 <img src="/img/LE-OOP1/103.png" /></p></li><li><p>抽象元素 <img src="/img/LE-OOP1/104.png" /></p></li><li><p>具体元素 <img src="/img/LE-OOP1/105.png" /></p></li><li><p>结构对象 <img src="/img/LE-OOP1/106.png" /></p></li><li><p>测试案例 <img src="/img/LE-OOP1/107.png" /></p></li></ul><h3 id="责任链模式">责任链模式</h3><p>责任链模式是使用多个对象处理用户请求的成熟模式，责任链模式的关键是将用户的请求分派给许多对象。</p><p><img src="/img/LE-OOP1/108.png" /> +处理者（Handler）：处理者是一个接口，负责规定具体处理者<strong>处理用户的请求的方法</strong>以及具体处理者<strong>设置后继对象</strong>的方法。+具体处理者（ConcreteHandler）：具体处理者是实现处理者接口的类的实例。具体处理者通过调用处理者接口规定的方法处理用户的请求，即在接到用户的请求后，处理者将调用接口规定的方法，在执行该方法的过程中，<strong>如果发现能处理用户的请求，就处理有关数据，否则就反馈无法处理的信息给用户，然后将用户的请求传递给自己的后继对象</strong>。</p><p><img src="/img/LE-OOP1/109.png" /> <imgsrc="/img/LE-OOP1/110.png" /></p><p>抽象处理者：领导类 <img src="/img/LE-OOP1/111.png" />具体处理者1：班主任类 <img src="/img/LE-OOP1/112.png" />具体处理者2：系主任类 <img src="/img/LE-OOP1/113.png" />具体处理者：院长类 <img src="/img/LE-OOP1/114.png" /> 测试类 <imgsrc="/img/LE-OOP1/115.png" /> dlc：具体处理者4：教务处长类 <imgsrc="/img/LE-OOP1/116.png" /></p><h3 id="观察者模式">观察者模式</h3><p>被观察者存了一个list表示观察者，观察者存了自己观察的对象当被观察者发生变化时，通知观察者，观察者更新数据并展示出来</p><p>观察者模式（ObserverPattern）是一种行为设计模式，它定义了对象之间的一对多依赖关系，当一个对象改变状态时，所有依赖于它的对象都会得到通知并自动更新。这种模式在Java中经常用于实现事件处理系统、消息订阅和发布等场景。</p><h5 id="场景描述">场景描述</h5><p>假设我们有一个天气数据类（<code>WeatherData</code>），它包含了温度、湿度等天气信息。我们希望当天气数据更新时，能够通知多个显示天气信息的界面（如当前天气状况显示、天气统计信息显示等）进行更新。这里可以使用观察者模式来实现。</p><h5 id="类图-1">类图</h5><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">+-------------------+       +-------------------+       +-------------------+<br>|<span class="hljs-string"> Observer          </span>|<span class="hljs-string">       </span>|<span class="hljs-string"> Subject           </span>|<span class="hljs-string">       </span>|<span class="hljs-string"> ConcreteObserver  </span>|<br>+-------------------+       +-------------------+       +-------------------+<br>|<span class="hljs-string"> +update()         </span>|<span class="hljs-string">&lt;&gt;----&gt;</span>|<span class="hljs-string"> +registerObserver()</span>|<span class="hljs-string">       </span>|<span class="hljs-string"> +update()         </span>|<br>+-------------------+       |<span class="hljs-string"> +removeObserver()  </span>|<span class="hljs-string">       +-------------------+</span><br><span class="hljs-string">                             </span>|<span class="hljs-string"> +notifyObservers() </span>|<br>                             +-------------------+<br>                                          ^<br>                                          |<span class="hljs-string"></span><br><span class="hljs-string">+-------------------+       +-------------------+</span><br><span class="hljs-string"></span>|<span class="hljs-string"> ConcreteObserver  </span>|<span class="hljs-string">       </span>|<span class="hljs-string"> WeatherData       </span>|<br>+-------------------+       +-------------------+<br>|<span class="hljs-string"> +update()         </span>|<span class="hljs-string">       </span>|<span class="hljs-string"> -observers        </span>|<br>+-------------------+       |<span class="hljs-string"> -temperature      </span>|<br>                             |<span class="hljs-string"> -humidity         </span>|<br>                             |<span class="hljs-string"> -pressure         </span>|<br>                             |<span class="hljs-string"> + measurementsChanged()</span>|<br>                             |<span class="hljs-string"> + registerObserver()  </span>|<br>                             |<span class="hljs-string"> + removeObserver()    </span>|<br>                             |<span class="hljs-string"> + notifyObservers()   </span>|<br>                             +-------------------+<br></code></pre></td></tr></table></figure><h5 id="代码实现-1">代码实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Observer.java 观察者</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Observer</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(<span class="hljs-type">float</span> temperature, <span class="hljs-type">float</span> humidity, <span class="hljs-type">float</span> pressure)</span>;<br>&#125;<br><span class="hljs-comment">// Subject.java 被观察者</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Subject</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerObserver</span><span class="hljs-params">(Observer o)</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeObserver</span><span class="hljs-params">(Observer o)</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">notifyObservers</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-comment">// DisplayElement.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">DisplayElement</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">display</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-comment">// WeatherData.java 被观察者——天气</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WeatherData</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Subject</span> &#123;<br>    <span class="hljs-keyword">private</span> List&lt;Observer&gt; observers;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">float</span> temperature;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">float</span> humidity;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">float</span> pressure;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">WeatherData</span><span class="hljs-params">()</span> &#123;<br>        observers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerObserver</span><span class="hljs-params">(Observer o)</span> &#123;<br>        observers.add(o);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeObserver</span><span class="hljs-params">(Observer o)</span> &#123;<br>        observers.remove(o);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">notifyObservers</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> (Observer observer : observers) &#123;<br>            observer.update(temperature, humidity, pressure);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">measurementsChanged</span><span class="hljs-params">()</span> &#123;<br>        notifyObservers();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setMeasurements</span><span class="hljs-params">(<span class="hljs-type">float</span> temperature, <span class="hljs-type">float</span> humidity, <span class="hljs-type">float</span> pressure)</span> &#123;<br>        <span class="hljs-built_in">this</span>.temperature = temperature;<br>        <span class="hljs-built_in">this</span>.humidity = humidity;<br>        <span class="hljs-built_in">this</span>.pressure = pressure;<br>        measurementsChanged();<br>    &#125;<br>    <span class="hljs-comment">// Other WeatherData methods here.</span><br>&#125;<br><span class="hljs-comment">// CurrentConditionsDisplay.java 观察者，实现展示功能</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CurrentConditionsDisplay</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Observer</span>, DisplayElement &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">float</span> temperature;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">float</span> humidity;<br>    <span class="hljs-keyword">private</span> Subject weatherData;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">CurrentConditionsDisplay</span><span class="hljs-params">(Subject weatherData)</span> &#123;<br>        <span class="hljs-built_in">this</span>.weatherData = weatherData;<br>        weatherData.registerObserver(<span class="hljs-built_in">this</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(<span class="hljs-type">float</span> temperature, <span class="hljs-type">float</span> humidity, <span class="hljs-type">float</span> pressure)</span> &#123;<br>        <span class="hljs-built_in">this</span>.temperature = temperature;<br>        <span class="hljs-built_in">this</span>.humidity = humidity;<br>        display();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">display</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Current conditions: &quot;</span> + temperature + <span class="hljs-string">&quot;F degrees and &quot;</span> + humidity + <span class="hljs-string">&quot;% humidity&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">// Main.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">WeatherData</span> <span class="hljs-variable">weatherData</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeatherData</span>();<br>        <span class="hljs-type">CurrentConditionsDisplay</span> <span class="hljs-variable">currentDisplay</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CurrentConditionsDisplay</span>(weatherData);<br>        weatherData.setMeasurements(<span class="hljs-number">80</span>, <span class="hljs-number">65</span>, <span class="hljs-number">30.4f</span>);<br>        weatherData.setMeasurements(<span class="hljs-number">82</span>, <span class="hljs-number">70</span>, <span class="hljs-number">29.2f</span>);<br>        weatherData.setMeasurements(<span class="hljs-number">78</span>, <span class="hljs-number">90</span>, <span class="hljs-number">29.2f</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="输出-1">输出</h5><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Current</span> conditions: <span class="hljs-number">80</span>.<span class="hljs-number">0</span>F degrees and <span class="hljs-number">65</span>.<span class="hljs-number">0</span>% humidity<br><span class="hljs-attribute">Current</span> conditions: <span class="hljs-number">82</span>.<span class="hljs-number">0</span>F degrees and <span class="hljs-number">70</span>.<span class="hljs-number">0</span>% humidity<br><span class="hljs-attribute">Current</span> conditions: <span class="hljs-number">78</span>.<span class="hljs-number">0</span>F degrees and <span class="hljs-number">90</span>.<span class="hljs-number">0</span>% humidity<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>WeatherData</code>类实现了<code>Subject</code>接口，它有一个观察者列表，用于注册、移除和通知观察者。<code>CurrentConditionsDisplay</code>类实现了<code>Observer</code>和<code>DisplayElement</code>接口，它注册为<code>WeatherData</code>的观察者，并在数据更新时接收通知并显示当前天气状况。当<code>WeatherData</code>的<code>setMeasurements</code>方法被调用时，它会更新天气数据并调用<code>measurementsChanged</code>方法，后者会通知所有注册的观察者。观察者接收到通知后，会调用它们的<code>update</code>方法来获取新的数据并更新显示。这样，我们就通过观察者模式实现了当天气数据变化时，自动通知</p><h2 id="uml图-7">UML图 7</h2><p><img src="/img/LE-OOP1/117.png" /> <imgsrc="/img/LE-OOP1/118.png" /></p><h2 id="java集合框架-8">Java集合框架 8</h2><p><img src="/img/LE-OOP1/119.png" /> <imgsrc="/img/LE-OOP1/120.png" /></p><p><strong>普通数组的定义</strong>：<code>int[] a = new int[10];</code></p><p><strong>ArrayList</strong>：无序，可重复，长度可变，<strong>遍历元素和随机访问元素效率较高</strong><img src="/img/LE-OOP1/121.png" /> 数组大小：<code>site.size()</code></p><p><strong>LinkedList</strong>：无序，可重复，FIFO，<strong>插入删除元素效率较高</strong><img src="/img/LE-OOP1/122.png" /> <img src="/img/LE-OOP1/123.png" /><img src="/img/LE-OOP1/124.png" /></p><p><strong>HashSet</strong>：无序，不可重复 <imgsrc="/img/LE-OOP1/125.png" /></p><p><strong>HashMap</strong>：无序，键（Key）不能重复，值（Value）可以重复<img src="/img/LE-OOP1/126.png" /></p><p><strong>重写排序</strong> 如果 <code>a</code> 是 list：<code>Collection.sort(a)</code> 如果 <code>a</code> 是普通数组：<code>Arrays.sort(a)</code> <img src="/img/LE-OOP1/127.png" /> <imgsrc="/img/LE-OOP1/128.png" /></p>]]></content>
    
    
    <categories>
      
      <category>学习经验</category>
      
      <category>大二上</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习经验</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【学习经验】算法板子</title>
    <link href="/2025/01/10/LE-suanfabanzi/"/>
    <url>/2025/01/10/LE-suanfabanzi/</url>
    
    <content type="html"><![CDATA[<h5 id="说在前面">说在前面</h5><p>算法应该是大二上我学的最轻松的一门课了，我有一个完美的开始和一个完美的结束——尽管中间一度每周打算签完到就不做了，非常感谢狗头学长的板子(<ahref="https://onlyar.site/2022/01/24/Cpp-template/">C++算法板子积累 -Only(AR)的编程日记</a>)，也特别感谢各位助教对我的帮助。下面的板子转pdf打印出来大概有90多页，虽然大部分都用不上，但是！有总比没有好嘛——</p><h5 id="tips">Tips</h5><p><strong>图论</strong> + 重边：最短路记得判断，只存最短的边 +负环？负边权？ +有重边的情况下判断负环：有负数就存负数，负数越小越好；否则存正数，正数越大越好+ 最短路径 + 单源最短路径：一个点到其他任意点的最短路径 +Bellman-Ford算法：时间<spanclass="math inline">\(O(VE)\)</span>；可<strong>负权重</strong>；可<strong>回路</strong>；可以<strong>检测负环</strong>，但不能在存在负环的图中计算单源最短路径。+ 有向无环图中的单源最短路径问题：时间<spanclass="math inline">\(O(V+E)\)</span>；可<strong>负权重</strong>；不可回路+ Dijkstra算法：时间<spanclass="math inline">\(O((V+E)*logV)\)</span>；不可负权重；可<strong>回路</strong>+ 所有结点对的最短路径问题：所有点到所有点的最短路径 +floyd算法：时间<span class="math inline">\(O(n^3)\)</span>空间<spanclass="math inline">\(O(n^2)\)</span>；可<strong>负权重</strong>；可<strong>回路</strong>；不能检测负环，不能有负环+ 特别地，可以用<strong>BFS</strong>求无权图最短路径 +最大流：在一个流网络中，找到从源点到汇点的最大流量。流网络是一个有向图，每条边有一个容量限制，表示通过该边的最大流量。+ Edmonds-Karp算法：时间 <spanclass="math inline">\(O(VE^{2})\)</span>；适合<strong>稀疏</strong>图 +Dinic算法：时间 <spanclass="math inline">\(O(V^{2}E)\)</span>；适合<strong>稠密</strong>图 +最大二分匹配：在二分图中找到最大的匹配数。二分图是一种特殊的图，其节点可以分为两个互不相交的集合，使得每条边都连接这两个不同集合中的节点。+ Dinic最小割/最大流算法：时间 <spanclass="math inline">\(O(V^2E)\)</span> + 匈牙利算法：时间 <spanclass="math inline">\(O(VE)\)</span> +最小生成树：在连通加权图中，找到一棵包含所有节点的树，使得树中所有边的权重之和最小。目的是找到连接所有顶点的最小总权重的边集。不关心顶点之间的具体路径长度，只关心整体结构的权重最小。+ Prim：时间 朴素版 <spanclass="math inline">\(O(V^2)\)</span>，堆优化版 <spanclass="math inline">\(O(ElogV)\)</span> + Kruskal：时间 <spanclass="math inline">\(O(ElogE)\)</span> + 有向无环图 <spanclass="math inline">\(G(V,E)\)</span>，<spanclass="math inline">\(G\)</span>是半连通的当且仅当有一条路径，这条路径上有图 <spanclass="math inline">\(G\)</span>中所有点：所以判断一个图是不是半连通的只需要判断拓扑序列的相邻节点是否有边</p><p><strong>做题思想/技巧</strong> <imgsrc="/img/LE-suanfabanzi/001.png" /></p><p><strong>注意事项</strong> + 在对接近 0 的负数四舍五入时应输出<code>0.00</code> 而非<code>-0.00</code>：<code>fabs(a) &lt; 0.005</code> 时输出<code>0.00</code> + <strong>快速读写</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//快读</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> ll <span class="hljs-title">read</span><span class="hljs-params">()</span></span>&#123;<br>   ll s=<span class="hljs-number">0</span>,w=<span class="hljs-number">1</span>;<br>   <span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<br>   <span class="hljs-keyword">while</span>(ch&lt;<span class="hljs-string">&#x27;0&#x27;</span>||ch&gt;<span class="hljs-string">&#x27;9&#x27;</span>)&#123;<span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;-&#x27;</span>)w=<span class="hljs-number">-1</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<br>   <span class="hljs-keyword">while</span>(ch&gt;=<span class="hljs-string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="hljs-string">&#x27;9&#x27;</span>) s=s*<span class="hljs-number">10</span>+ch-<span class="hljs-string">&#x27;0&#x27;</span>,ch=<span class="hljs-built_in">getchar</span>();<br>   <span class="hljs-keyword">return</span> s*w;<br>&#125;<br><span class="hljs-comment">//快写</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">out</span><span class="hljs-params">(ll a)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(a&gt;=<span class="hljs-number">10</span>)<span class="hljs-built_in">out</span>(a/<span class="hljs-number">10</span>);<br>    <span class="hljs-built_in">putchar</span>(a%<span class="hljs-number">10</span>+<span class="hljs-string">&#x27;0&#x27;</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    ll n;<br>    n=<span class="hljs-built_in">read</span>();<br>    <span class="hljs-built_in">out</span>(n);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure> + 数组大小如无向图双倍空间，FFT四倍空间 空间计算 <code>sizeof</code>，如下方法计算 数组所占空间（KB）：<code>cout &lt;&lt; sizeof a/1024</code> + corner case <spanclass="math inline">\(n  = 0,1\)</span> <span class="math inline">\(a_i= 0, 1e9, -1e9\)</span> 几何中斜率为0 + 初始化 +多测清空，<strong>不要滥用 <code>memset</code></strong><code>memset(a, 0, sizeof(int)*(n+1));</code> 正确<code>memset(a, 0, sizeof a);</code> 超时 以及 <code>memset</code>初始化最大值 应为 <code>memset(a, 0x3f, sizeof(int) * (n+1));</code> +<strong>long long</strong> + cin和cout关闭同步流（但关闭后不能用scanfprintf等c语言的输入输出） <code>ios::sync_with_stdio(false)</code> +cin, cout时用 '' 代替 endl + <strong>数组</strong>是否够大 +<strong>浮点数误差</strong>：如<strong>几何</strong>求面积能否直接用整数计算+ <strong>不要用gets!!!!!!!!!!!!!!!!!!</strong> + <strong>int max:2147483647, which is 2^31 - 1</strong> <strong>int min: -2147483648,which is -2^31</strong> <strong>long long max: 9223372036854775807,which is 2^63 - 1</strong> <strong>long long min: -9223372036854775808,which is -2^63</strong> + 一些最大值最小值 用 <code>climits</code>头文件 <code>INT_MAX</code> <code>INT_MIN</code> <code>LLONG_MAX</code><code>LLONG_MIN</code> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;climits&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 打印整型的最大值和最小值</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;int 的最大值是：&quot;</span> &lt;&lt; INT_MAX &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;int 的最小值是：&quot;</span> &lt;&lt; INT_MIN &lt;&lt; std::endl;<br>    <span class="hljs-comment">// 打印长整型的最大值和最小值</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;long long 的最大值是：&quot;</span> &lt;&lt; LLONG_MAX &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;long long 的最小值是：&quot;</span> &lt;&lt; LLONG_MIN &lt;&lt; std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><h5 id="cppstart">cppStart</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stack&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;set&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;climits&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></td></tr></table></figure><h5 id="标准库">标准库</h5><ul><li><p>能<strong>按索引访问</strong>元素的容器：<code>vector</code></p></li><li><p>能<strong>遍历</strong>的容器：<code>vector</code>,<code>set</code>, <code>multiset</code></p></li><li><p><code>vector</code>（向量）:动态数组；当需要<strong>随机访问</strong>元素且频繁在末尾添加或删除元素时。</p></li><li><p><code>queue</code>（队列）:FIFO的数据结构；当需要按照添加顺序处理元素时，如广度优先搜索（BFS）。</p></li><li><p><code>priority_queue</code>（优先队列）:<strong>自动排序</strong>；当需要处理具有优先级的任务时，如最小生成树算法（Prim’s）或处理事件驱动的系统。</p></li><li><p><code>stack</code>（栈）:LIFO；当需要后进先出的处理顺序时，如深度优先搜索（DFS）、递归算法的辅助数据结构。</p></li><li><p><code>set</code>（集合）:<strong>自动排序</strong>，<strong>不包含重复元素</strong>；当需要存储唯一元素并经常进行查找操作时，如去重、集合运算。</p></li><li><p><code>multiset</code>（多重集合）: 与 <code>set</code>类似，但允许存储<strong>重复的元素</strong>；当需要存储元素并保持<strong>有序</strong>，但元素可以重复时。</p></li></ul><h6 id="algorithm">algorithm</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp">__gcd(a, b) <span class="hljs-comment">// 求两个数的最大公因数  </span><br>__builtin_popcount(a) <span class="hljs-comment">// 求 int 的二进制里多少个 1  </span><br>  <br><span class="hljs-built_in">is_sorted</span>(a, a + n) <span class="hljs-comment">// 是否升序  </span><br><span class="hljs-built_in">is_sorted_until</span>(a, a + n) <span class="hljs-comment">// 到哪里是升序  </span><br><span class="hljs-built_in">sort</span>(a, a + n) <span class="hljs-comment">// 不稳定排序(默认升序)  </span><br><span class="hljs-built_in">sort</span>(a, a + n, <span class="hljs-built_in">greater</span>&lt;<span class="hljs-type">int</span>&gt;()) <span class="hljs-comment">// 降序排序  </span><br><span class="hljs-built_in">stable_sort</span>(a, a + n) <span class="hljs-comment">// 稳定排序  </span><br><span class="hljs-built_in">nth_element</span>(a, a + k, a + n) <span class="hljs-comment">// 将第 k 大元素放到 a[k]  </span><br><span class="hljs-built_in">unique</span>(begin, end) <span class="hljs-comment">// 对有序数组去重，返回末尾地址(去除的是相邻的重复元素,所以使用前需先排序)</span><br>  <br><span class="hljs-built_in">max</span>(a, b) <span class="hljs-comment">// 返回较大值  </span><br><span class="hljs-built_in">min</span>(a, b) <span class="hljs-comment">// 返回较小值  </span><br><span class="hljs-built_in">max_element</span>(a, a + n) <span class="hljs-comment">// 返回最大值位置  </span><br><span class="hljs-built_in">min_element</span>(a, a + n) <span class="hljs-comment">// 返回最小值位置  </span><br>  <br><span class="hljs-type">int</span> pos1 = <span class="hljs-built_in">lower_bound</span>(a, a + n, key)-a; <span class="hljs-comment">// 返回第一个大于等于 key 的元素的下标 </span><br><span class="hljs-type">int</span> pos2 = <span class="hljs-built_in">upper_bound</span>(a, a + n, key)-a; <span class="hljs-comment">// 返回第一个大于 key 的元素的下标</span><br><span class="hljs-built_in">binary_search</span>(a, a + n, key) <span class="hljs-comment">// 二分查找是否存在  </span><br>  <br><span class="hljs-built_in">is_heap</span>(a, a + n) <span class="hljs-comment">// 判断是否为大顶堆 vector&lt;int&gt;a; is_heap(a.begin(), a.end())</span><br><span class="hljs-built_in">is_heap_until</span>(a, a + n) <span class="hljs-comment">// 到哪里是大顶堆  </span><br><span class="hljs-built_in">make_heap</span>(a, a + n) <span class="hljs-comment">// 区间建堆 vector&lt;int&gt;a; make_heap(a.begin(), a.end())</span><br><span class="hljs-built_in">push_heap</span>(a, a + n) <span class="hljs-comment">// 末尾元素入堆并调整，与push_back配合（push_back将元素添加到数组的末尾，然后用push_heap来调整堆）</span><br><span class="hljs-built_in">pop_heap</span>(a, a + n) <span class="hljs-comment">// 堆顶移到末尾并调整，与pop_back配合（pop_heap将堆顶元素移动到数组的末尾，然后用pop_back从数组中移除该元素）</span><br><span class="hljs-built_in">sort_heap</span>(a, a + n) <span class="hljs-comment">// 升序堆排序  </span><br>  <br><span class="hljs-built_in">is_permutation</span>() <span class="hljs-comment">// 两个序列是否互为另一个的排序，即检查它们是否包含相同数量的相同元素，尽管元素的顺序可能不同</span><br><span class="hljs-built_in">next_permutation</span>() <span class="hljs-comment">// 重排为字典序的下一个更大的排列。如果这样的排列存在，返回true；否则，重排为第一个排列（即升序排列），返回false</span><br><span class="hljs-built_in">prev_permutation</span>() <span class="hljs-comment">// 重排为字典序的上一个更小的排列。如果这样的排列存在，返回true；否则，重排为最后一个排列（即降序排列），返回false</span><br>  <br><span class="hljs-built_in">fill</span>(a, a + n, val) <span class="hljs-comment">// 批量赋值  </span><br><span class="hljs-built_in">reverse</span>(a, a + n) <span class="hljs-comment">// 数组翻转</span><br><br><span class="hljs-keyword">auto</span> it = <span class="hljs-built_in">find</span>(shuzu, shuzu+n, <span class="hljs-number">1</span>)<br><span class="hljs-keyword">auto</span> it = <span class="hljs-built_in">find</span>(v1.<span class="hljs-built_in">begin</span>(), v1.<span class="hljs-built_in">end</span>(), <span class="hljs-number">1</span>) <span class="hljs-comment">// 查找v1中有没有1，find函数返回一个迭代器，如果v1中有1则迭代器it指向找到的第一个目标元素，否则指向v1.end()</span><br><span class="hljs-comment">// vector set multiset 普通数组都能用find，queue priority_queue stack不能用</span><br></code></pre></td></tr></table></figure><p>如 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> a[<span class="hljs-number">10</span>] = &#123;<span class="hljs-number">5</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;  <br><span class="hljs-type">int</span> b[<span class="hljs-number">10</span>] = &#123;<span class="hljs-number">5</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">1</span>&#125;;  <br>cout &lt;&lt; <span class="hljs-built_in">is_permutation</span>(a, &amp;a[<span class="hljs-number">5</span>], b);<br><span class="hljs-built_in">is_permutation</span> (c1.<span class="hljs-built_in">begin</span>()+<span class="hljs-number">1</span>, c1.<span class="hljs-built_in">end</span>(), c2.<span class="hljs-built_in">begin</span>());<br></code></pre></td></tr></table></figure></p><h6 id="vector">vector</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector &lt;<span class="hljs-type">int</span>&gt; v1 <span class="hljs-comment">// 空</span><br>vector &lt;<span class="hljs-type">int</span>&gt; <span class="hljs-built_in">v2</span>(<span class="hljs-number">5</span>,<span class="hljs-number">0</span>); <span class="hljs-comment">// 5个0</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">v3</span><span class="hljs-params">(v2.begin(), v2.end())</span></span>;  <span class="hljs-comment">// 和v2相同</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">v4</span><span class="hljs-params">(v2)</span></span>;   <span class="hljs-comment">// 和v2相同</span><br>v.<span class="hljs-built_in">at</span>(k)   <span class="hljs-comment">// 访问 v[k]  </span><br>v.<span class="hljs-built_in">front</span>() <span class="hljs-comment">// 首元素  </span><br>v.<span class="hljs-built_in">back</span>()  <span class="hljs-comment">// 末元素  </span><br>v.<span class="hljs-built_in">begin</span>() <span class="hljs-comment">// 首地址(迭代器)  用于和v.end()一起放到find()里面去找v中是否存在某个值</span><br>v.<span class="hljs-built_in">end</span>()   <span class="hljs-comment">// 末地址(迭代器)  如auto it = find(v1.begin(),v1.end(),1)</span><br>v.<span class="hljs-built_in">empty</span>()      <span class="hljs-comment">// 是否空  返回true/false</span><br>v.<span class="hljs-built_in">size</span>()       <span class="hljs-comment">// 大小  </span><br>v.<span class="hljs-built_in">max_size</span>()   <span class="hljs-comment">// 最大空间  </span><br>v.<span class="hljs-built_in">clear</span>()      <span class="hljs-comment">// 清除  </span><br>v.<span class="hljs-built_in">insert</span>(pos, item)   <span class="hljs-comment">// 在 pos(迭代器) 位置插入 item  </span><br>v.<span class="hljs-built_in">eraze</span>(pos)   <span class="hljs-comment">// 擦除 pos(迭代器) 位置的元素  </span><br>v.<span class="hljs-built_in">push_back</span>(item)     <span class="hljs-comment">// 末尾插入  </span><br>v.<span class="hljs-built_in">pop_back</span>()   <span class="hljs-comment">// 末尾删除</span><br><br>v.<span class="hljs-built_in">reserve</span>(n);  <span class="hljs-comment">// 请求向量容量至少足以包含 _n_ 个元素。</span><br><br><span class="hljs-comment">// v.size()的返回值是unsigned，所以...</span><br>vector&lt;<span class="hljs-type">int</span>&gt; v;<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">3</span>);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=v.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i++) &#123;<span class="hljs-comment">//错误</span><br>cout&lt;&lt;v[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=(<span class="hljs-type">int</span>)v.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i++) &#123;<span class="hljs-comment">//(正确)</span><br>cout&lt;&lt;v[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="queue">queue</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*----- queue -----*/</span>  <br>queue&lt;<span class="hljs-type">int</span>&gt; q;<br>q.<span class="hljs-built_in">push</span>(item) <span class="hljs-comment">// item 入队  </span><br>q.<span class="hljs-built_in">front</span>() <span class="hljs-comment">// 访问队头  </span><br>q.<span class="hljs-built_in">pop</span>() <span class="hljs-comment">// 出队  </span><br>q.<span class="hljs-built_in">back</span>() <span class="hljs-comment">// 访问队尾  </span><br>q.<span class="hljs-built_in">empty</span>() <span class="hljs-comment">// 是否空  </span><br>q.<span class="hljs-built_in">size</span>() <span class="hljs-comment">// 大小  </span><br>q.<span class="hljs-built_in">emplace</span>(item) <span class="hljs-comment">// item 替换队尾  </span><br><span class="hljs-comment">/*----- priority_queue -----*/</span>  <br>priority_queue&lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;, greater&lt;<span class="hljs-type">int</span>&gt;&gt; pq  <br>pq.<span class="hljs-built_in">top</span>() <span class="hljs-comment">// 访问队首  </span><br>pq.<span class="hljs-built_in">empty</span>() <span class="hljs-comment">// 优先队列是否空  </span><br>pq.<span class="hljs-built_in">size</span>() <span class="hljs-comment">// 大小  </span><br>pq.<span class="hljs-built_in">push</span>(item) <span class="hljs-comment">// 插入 item  </span><br>pq.<span class="hljs-built_in">pop</span>() <span class="hljs-comment">// 出队</span><br></code></pre></td></tr></table></figure><h6 id="优先队列的声明">优先队列的声明</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">priority_queue &lt;<span class="hljs-type">int</span>&gt; i;  <span class="hljs-comment">//【排序】14 12 10 8 6</span><br>priority_queue &lt;<span class="hljs-type">double</span>&gt; d;  <br>priority_queue &lt;<span class="hljs-type">int</span>,vector&lt;<span class="hljs-type">int</span>&gt;,less&lt;<span class="hljs-type">int</span>&gt; &gt;q;<span class="hljs-comment">//【排序】14 12 10 8 6</span><br>priority_queue &lt;<span class="hljs-type">int</span>,vector&lt;<span class="hljs-type">int</span>&gt;,greater&lt;<span class="hljs-type">int</span>&gt; &gt; q;<span class="hljs-comment">//【排序】6 8 10 12 14</span><br><span class="hljs-comment">// 不需要#include&lt;vector&gt;头文件，注意后面两个“&gt;”不要写在一起，“&gt;&gt;”是右移运算符  </span><br></code></pre></td></tr></table></figure><h6 id="结构体的优先队列">结构体的优先队列</h6><p>重写cmp <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;<br>    <span class="hljs-type">int</span> fir,sec;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>,&amp;fir,&amp;sec);&#125;<br>&#125;input;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">cmp1</span>&#123;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span> <span class="hljs-params">()</span> <span class="hljs-params">(<span class="hljs-type">const</span> node &amp;x,<span class="hljs-type">const</span> node &amp;y)</span> <span class="hljs-type">const</span></span>&#123;<br>        <span class="hljs-keyword">return</span> x.fir&lt;y.fir;<br>    &#125;<br>&#125;;<span class="hljs-comment">//当一个node x的fir值小于另一个node y的fir值时，x在y后面</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">cmp3</span>&#123;  <br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span> <span class="hljs-params">()</span> <span class="hljs-params">(<span class="hljs-type">const</span> node &amp;x,<span class="hljs-type">const</span> node &amp;y)</span> <span class="hljs-type">const</span></span>&#123;  <br>        <span class="hljs-keyword">return</span> x.fir+x.sec&lt;y.fir+y.sec;  <br>    &#125;  <br>&#125;;<span class="hljs-comment">//当一个node x的fri值和sec值的和小于另一个node y的fir值和sec值的和时，x在y后面</span><br>priority_queue&lt;node,vector&lt;node&gt;,cmp1&gt; q1;  <br>priority_queue&lt;node,vector&lt;node&gt;,cmp3&gt; q3;  <br><span class="hljs-keyword">while</span>(!q1.<span class="hljs-built_in">empty</span>()) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;(%d,%d) &quot;</span>,q1.<span class="hljs-built_in">top</span>().fir,q1.<span class="hljs-built_in">top</span>().sec),q1.<span class="hljs-built_in">pop</span>(); <br><span class="hljs-keyword">while</span>(!q3.<span class="hljs-built_in">empty</span>()) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;(%d,%d) &quot;</span>,q3.<span class="hljs-built_in">top</span>().fir,q3.<span class="hljs-built_in">top</span>().sec),q3.<span class="hljs-built_in">pop</span>();<br><br>【输入】<br><span class="hljs-number">1</span> <span class="hljs-number">2</span>  <br><span class="hljs-number">2</span> <span class="hljs-number">1</span>  <br><span class="hljs-number">6</span> <span class="hljs-number">9</span>  <br><span class="hljs-number">9</span> <span class="hljs-number">6</span>  <br><span class="hljs-number">-100</span> <span class="hljs-number">100</span>  <br><span class="hljs-number">-500</span> <span class="hljs-number">20</span>  <br><span class="hljs-number">4000</span> <span class="hljs-number">-3000</span><br>【输出】<br>cmp1: (<span class="hljs-number">4000</span>,<span class="hljs-number">-3000</span>) (<span class="hljs-number">9</span>,<span class="hljs-number">6</span>) (<span class="hljs-number">6</span>,<span class="hljs-number">9</span>) (<span class="hljs-number">2</span>,<span class="hljs-number">1</span>) (<span class="hljs-number">1</span>,<span class="hljs-number">2</span>) (<span class="hljs-number">-100</span>,<span class="hljs-number">100</span>) (<span class="hljs-number">-500</span>,<span class="hljs-number">20</span>)  <br>cmp3: (<span class="hljs-number">4000</span>,<span class="hljs-number">-3000</span>) (<span class="hljs-number">6</span>,<span class="hljs-number">9</span>) (<span class="hljs-number">9</span>,<span class="hljs-number">6</span>) (<span class="hljs-number">1</span>,<span class="hljs-number">2</span>) (<span class="hljs-number">2</span>,<span class="hljs-number">1</span>) (<span class="hljs-number">-100</span>,<span class="hljs-number">100</span>) (<span class="hljs-number">-500</span>,<span class="hljs-number">20</span>)<br></code></pre></td></tr></table></figure></p><h6 id="stack">stack</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp">stack&lt;<span class="hljs-type">int</span>&gt; s;<br>s.<span class="hljs-built_in">push</span>(item) <span class="hljs-comment">// item 入栈  </span><br>s.<span class="hljs-built_in">top</span>() <span class="hljs-comment">// 访问栈顶  </span><br>s.<span class="hljs-built_in">pop</span>() <span class="hljs-comment">// 出栈</span><br>s.<span class="hljs-built_in">empty</span>() <span class="hljs-comment">// 栈是否空  </span><br>s.<span class="hljs-built_in">size</span>() <span class="hljs-comment">// 大小  </span><br>s.<span class="hljs-built_in">emplace</span>(item) <span class="hljs-comment">// item 替换栈顶  </span><br></code></pre></td></tr></table></figure><h6 id="set">set</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*----- set 不允许容器中有重复元素 -----*/</span>  <br>s.<span class="hljs-built_in">size</span>() <span class="hljs-comment">// 大小  </span><br>s.<span class="hljs-built_in">empty</span>() <span class="hljs-comment">// 是否空  </span><br>s.<span class="hljs-built_in">clear</span>() <span class="hljs-comment">// 清除  </span><br>s.<span class="hljs-built_in">insert</span>(key) <span class="hljs-comment">// 插入  </span><br>s.<span class="hljs-built_in">erase</span>(pos/key) <span class="hljs-comment">// 删除  </span><br>s.<span class="hljs-built_in">erase</span>(<span class="hljs-number">3</span>); <span class="hljs-comment">// 删除键值为3的元素 &#123;1,2,3,4,5&#125;-&gt;&#123;1,2,4,5&#125;</span><br><span class="hljs-keyword">auto</span> it = s.<span class="hljs-built_in">find</span>(<span class="hljs-number">4</span>);<br><span class="hljs-keyword">if</span> (it != s.<span class="hljs-built_in">end</span>())&#123; <br>s.<span class="hljs-built_in">erase</span>(it); <span class="hljs-comment">// 删除迭代器it指向的元素 &#123;1,2,3,4,5&#125;-&gt;&#123;1,2,3,5&#125;</span><br>&#125;<br>s.<span class="hljs-built_in">count</span>(key) <span class="hljs-comment">// 是否存在  </span><br>s.<span class="hljs-built_in">find</span>(key) <span class="hljs-comment">// 查找，成功返回位置，失败返回 s.end()  </span><br><span class="hljs-comment">/*----- multiset 允许容器中有重复元素 -----*/</span>  <br>ms.<span class="hljs-built_in">size</span>() <span class="hljs-comment">// 大小  </span><br>ms.<span class="hljs-built_in">empty</span>() <span class="hljs-comment">// 是否空  </span><br>ms.<span class="hljs-built_in">clear</span>() <span class="hljs-comment">// 清除  </span><br>ms.<span class="hljs-built_in">insert</span>(key) <span class="hljs-comment">// 插入  </span><br>ms.<span class="hljs-built_in">erase</span>(pos/key) <span class="hljs-comment">// 删除  </span><br>ms.<span class="hljs-built_in">count</span>(key) <span class="hljs-comment">// 计数  </span><br>ms.<span class="hljs-built_in">find</span>(key) <span class="hljs-comment">// 查找，成功返回位置，失败返回 s.end()</span><br><br><span class="hljs-comment">//插⼊</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>s.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">gint</span>());<br><br><span class="hljs-comment">// set容器排序：利用仿函数改变排序规则</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCompare</span>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> v1, <span class="hljs-type">int</span> v2)</span> </span>&#123;<br><span class="hljs-keyword">return</span> v1 &gt; v2;<br>&#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">//默认从小到大 10 20 30 40 50</span><br>set&lt;<span class="hljs-type">int</span>&gt; s1 = &#123;<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>, <span class="hljs-number">50</span>&#125;;<br><span class="hljs-comment">//指定排序规则 50 40 30 20 10</span><br>set&lt;<span class="hljs-type">int</span>, MyCompare&gt; s2 = &#123;<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>, <span class="hljs-number">50</span>&#125;;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// set的遍历</span><br><span class="hljs-comment">// 法1</span><br><span class="hljs-keyword">for</span> (set&lt;<span class="hljs-type">int</span>&gt;::iterator it = s1.<span class="hljs-built_in">begin</span>(); it != s1.<span class="hljs-built_in">end</span>(); ++it) &#123;  <br>    cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;  <br>&#125;<br><span class="hljs-comment">// 法2</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = mySet.<span class="hljs-built_in">begin</span>(); it != mySet.<span class="hljs-built_in">end</span>(); ++it) &#123;  <br>    cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;  <br>&#125;<br><span class="hljs-comment">// 法3</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> it : mySet) &#123;  <br>    cout &lt;&lt; it &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;  <br>&#125;<br></code></pre></td></tr></table></figure><h6 id="pair">pair</h6><p>可以用来代替一些便捷的自定义struct。且pair自带小于号，可直接用于排序，第一关键字为第一维升序，第二关键字为第二维升序<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; p1;<br>pair&lt;<span class="hljs-type">int</span>,string&gt; p2;<br>pair&lt;<span class="hljs-type">double</span>,<span class="hljs-type">int</span>&gt; p3;<br></code></pre></td></tr></table></figure></p><h6 id="map">map</h6><p>构建⼀个映射关系复杂度为 <span class="math inline">\(O(logn)\)</span><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">map&lt;T1,T2&gt; mp;<br>map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; mp1;<br>map&lt;string,<span class="hljs-type">int</span>&gt; mp2;<br>map&lt;<span class="hljs-type">int</span>,set&lt;<span class="hljs-type">int</span>&gt; mp3;<br>map&lt;<span class="hljs-type">int</span>,vector&lt;<span class="hljs-type">int</span>&gt;&gt; mp4;<br></code></pre></td></tr></table></figure></p><h5 id="存图">存图</h5><h6 id="邻接矩阵">邻接矩阵</h6><ul><li>存储<strong>稠密图</strong></li><li>实现时需要注意<strong>重边与自环</strong>。对于最短路问题，可以在重复的边中选择边权最小的一条保留。</li><li>Floyd 算法适合邻接矩阵 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> d[N][N]; <span class="hljs-comment">// N 个结点的邻接矩阵</span><br></code></pre></td></tr></table></figure> ###### 邻接表</li><li>存储<strong>稠密图</strong></li><li>对于每个结点，使用一个 vector 保存与之相连的边。<strong>vector实现无权邻接表</strong></li><li>假设图中总共至多有 N 个结点，每条边不含边权。可以这样实现邻接表：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;<span class="hljs-type">int</span>&gt; g[N]; <span class="hljs-comment">// N 个结点的邻接表</span><br>g[u].<span class="hljs-built_in">emplace_back</span>(v); <span class="hljs-comment">// 添加一条边 u → v</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; g[u].<span class="hljs-built_in">size</span>(); i++) &#123;<br><span class="hljs-type">int</span> v = g[u][i]; <span class="hljs-comment">// 遍历 u 的出边 u → v</span><br><span class="hljs-comment">// · · ·</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li>实际上，可以使用语法糖简化遍历出边的实现，但是并不建议滥用 auto。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> v : g[u]) &#123;<br><span class="hljs-comment">// 遍历 u 的出边 u → v</span><br><span class="hljs-comment">// · · ·</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p><strong>vector实现有权邻接表</strong> +对于具有<strong>边权</strong>或是<strong>其他信息</strong>的边，可以定义结构体以保存边的信息。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span> &#123;<br><span class="hljs-type">int</span> to; <span class="hljs-comment">// 边指向的点</span><br><span class="hljs-type">int</span> weight; <span class="hljs-comment">// 边权</span><br>&#125;<br>vector&lt;Edge&gt; g[N];  <span class="hljs-comment">// N 个结点的邻接表</span><br>g[u].<span class="hljs-built_in">emplace_back</span>(&#123;v, w&#125;);  <span class="hljs-comment">// 添加边权为 w 的一条边 u → v</span><br></code></pre></td></tr></table></figure></p><p><strong>pair实现有权邻接表</strong> + 两个元素的有序对<code>⟨x, y⟩</code> 可以使用 STL 的 pair 保存。 +<code>pair ⟨x, y⟩</code> 之间的大小关系定义为：<spanclass="math inline">\(⟨x1, y1⟩ &lt; ⟨x2, y2⟩ ⇐⇒ x1 &lt; x2 ∨ (x1 = x2 ∧y1 &lt; y2)\)</span> + 第一个元素类型 T1，第二个元素类型 T2 的pair：<code>pair&lt;T1, T2&gt; p;</code> + 创建一个pair：<code>p = make_pair(x, y);</code> + 取 pair的第一个元素：<code>p.first</code> + 取 pair的第二个元素：<code>p.second</code> + 可以用 pair实现邻接表。第一个元素保存<strong>边指向的点</strong>，第二个元素保存<strong>边权</strong>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; g[N];<br>g[u].<span class="hljs-built_in">emplace_back</span>(<span class="hljs-built_in">make_pair</span>(v, w));<br><span class="hljs-comment">// 添加边权为 w 的一条边 u → v</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> e : g[u]) &#123;<br><span class="hljs-type">int</span> v = e.first, w = e.second;<br><span class="hljs-comment">// 遍历 u 的出边 u → v，边权为 w</span><br>&#125;<br></code></pre></td></tr></table></figure></p><h5 id="char和string">char*和string</h5><h6 id="char-to-string">char* to string</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">char</span>* name;<br>string softwareName = name;<br></code></pre></td></tr></table></figure><h6 id="string-to-char">string to char*</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">char</span>* <span class="hljs-title">strToChar</span><span class="hljs-params">(string strSend)</span></span>&#123;<br>    <span class="hljs-type">char</span>* ConvertData;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> len2 = strSend.<span class="hljs-built_in">length</span>();<br>    ConvertData = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[len2 + <span class="hljs-number">1</span>];<br>    <span class="hljs-built_in">strcpy</span>(ConvertData, strSend.<span class="hljs-built_in">c_str</span>());<br>    <span class="hljs-keyword">return</span> ConvertData;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="插入排序">插入排序</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">insertSort</span><span class="hljs-params">(keytype k[ ],<span class="hljs-type">int</span> n)</span>&#123;  <br>keytype temp;  <br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;n; i++)&#123;  <br>temp = k[i];  <br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i<span class="hljs-number">-1</span>; j&gt;=<span class="hljs-number">0</span> &amp;&amp; temp&lt;k[j]; j--)   <br>k[j+<span class="hljs-number">1</span>] = k[j];  <br>k[j+<span class="hljs-number">1</span>] = temp;  <br>&#125;  <br>&#125;<br></code></pre></td></tr></table></figure><h5 id="归并排序-on-log-n">归并排序 <span class="math inline">\(O(n logn)\)</span></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ctype.h&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;math.h&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX 1000  </span><br>  <br><span class="hljs-type">int</span> temp[MAX], ans[MAX] = &#123;<span class="hljs-number">50</span>, <span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">70</span>, <span class="hljs-number">40</span>, <span class="hljs-number">80</span>, <span class="hljs-number">60</span>&#125;;  <br>  <br><span class="hljs-type">void</span> <span class="hljs-title function_">Mergesort</span><span class="hljs-params">(<span class="hljs-type">int</span> startId, <span class="hljs-type">int</span> endId)</span>;  <br><span class="hljs-type">void</span> <span class="hljs-title function_">Merge</span><span class="hljs-params">(<span class="hljs-type">int</span> startId, <span class="hljs-type">int</span> midId, <span class="hljs-type">int</span> endId)</span>;  <br>  <br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;  <br>Mergesort(<span class="hljs-number">0</span>, <span class="hljs-number">7</span>);  <br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">8</span>; i++)  <br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, ans[i]);  <br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;  <br><br><span class="hljs-type">void</span> <span class="hljs-title function_">Mergesort</span><span class="hljs-params">(<span class="hljs-type">int</span> startId, <span class="hljs-type">int</span> endId)</span>&#123;  <br><span class="hljs-type">int</span> midId = startId + (endId - startId)/<span class="hljs-number">2</span>;  <br><span class="hljs-keyword">if</span>(startId &lt; endId)&#123;  <br>Mergesort(startId, midId);  <br>Mergesort(midId+<span class="hljs-number">1</span>, endId);  <br>Merge(startId, midId, endId);  <br>&#125;  <br>&#125;  <br>  <br><span class="hljs-type">void</span> <span class="hljs-title function_">Merge</span><span class="hljs-params">(<span class="hljs-type">int</span> startId, <span class="hljs-type">int</span> midId, <span class="hljs-type">int</span> endId)</span>&#123;  <br><span class="hljs-type">int</span> i=startId, j=midId+<span class="hljs-number">1</span>, k=startId;  <br><span class="hljs-keyword">while</span>(i &lt;= midId &amp;&amp; j&lt;=endId)&#123;  <br><span class="hljs-keyword">if</span>(ans[i] &lt; ans[j])&#123;  <br>temp[k] = ans[i];  <br>k++; i++;  <br>&#125;<span class="hljs-keyword">else</span>&#123;  <br>temp[k] = ans[j];  <br>k++; j++;  <br>&#125;  <br>&#125;  <br><span class="hljs-keyword">while</span>(i &lt;= midId)&#123;  <br>temp[k] = ans[i];  <br>k++; i++;  <br>&#125;  <br><span class="hljs-keyword">while</span>(j &lt;= endId)&#123;  <br>temp[k] = ans[j];  <br>k++; j++;  <br>&#125;  <br><span class="hljs-keyword">for</span>(i=startId; i&lt;=endId; i++)&#123;  <br>ans[i] = temp[i];  <br>&#125;  <br>&#125;<br></code></pre></td></tr></table></figure><h5 id="逆序对计数">逆序对计数</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span>  </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;  <br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;  <br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX (200000+5)  </span><br><span class="hljs-type">int</span> temp[MAX], a[MAX];  <br><span class="hljs-function">ll <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-type">int</span> a[], <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span></span>;  <br>  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;  <br>    <span class="hljs-type">int</span> n;  <br>    cin &gt;&gt; n;  <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)  <br>        cin &gt;&gt; a[i];  <br>    cout &lt;&lt; <span class="hljs-built_in">solve</span>(a, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>);  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;  <br><span class="hljs-function">ll <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-type">int</span> a[], <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> </span>&#123;  <br>    <span class="hljs-keyword">if</span> (left == right)  <br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>    <span class="hljs-keyword">else</span> &#123;  <span class="hljs-comment">// 分治  </span><br>        <span class="hljs-type">int</span> mid = (right - left) / <span class="hljs-number">2</span> + left; <span class="hljs-comment">// 分  </span><br>        ll s1 = <span class="hljs-built_in">solve</span>(a, left, mid);         <span class="hljs-comment">// 治：左边排序  </span><br>        ll s2 = <span class="hljs-built_in">solve</span>(a, mid + <span class="hljs-number">1</span>, right);    <span class="hljs-comment">// 治：右边排序  </span><br>        ll s3 = <span class="hljs-number">0</span>;  <br>        <span class="hljs-type">int</span> i = left, j = mid + <span class="hljs-number">1</span>, k = <span class="hljs-number">0</span>;  <br>        <span class="hljs-keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= right) &#123;     <span class="hljs-comment">// 合：整体排序  </span><br>            <span class="hljs-keyword">if</span> (a[i] &lt;= a[j]) &#123;     <span class="hljs-comment">// 如果 a[i] &lt;= a[j] 就放a[i]进去  </span><br>                temp[left + k] = a[i];  <br>                k++;  <br>                i++;  <br>            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-comment">// 如果 a[i] &gt; a[j] 就放a[j]进去  </span><br>                temp[left + k] = a[j];  <br>                s3 += (mid - i + <span class="hljs-number">1</span>);    <span class="hljs-comment">// 如果a[j]&lt;a[i]，说明a[j]&lt;a[i]~a[mid]，共有mid-i+1个逆序对  </span><br>                k++;  <br>                j++;  <br>            &#125;  <br>        &#125;  <br>        <span class="hljs-keyword">if</span> (i &lt;= mid)  <br>            <span class="hljs-keyword">while</span> (i &lt;= mid) &#123;  <br>                temp[k + left] = a[i];  <br>                k++;  <br>                i++;  <br>            &#125;  <br>        <span class="hljs-keyword">else</span>  <br>            <span class="hljs-keyword">while</span> (j &lt;= right) &#123;  <br>                temp[k + left] = a[j];  <br>                k++;  <br>                j++;  <br>            &#125;  <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> l = left; l &lt;= right; l++)  <br>            a[l] = temp[l];  <br>        <span class="hljs-keyword">return</span> s1 + s2 + s3;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><h5 id="多数问题">多数问题</h5><p>n个数组成一个数组，寻找是否有一个数的数量≥n/2 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span>  </span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">2000000</span>;    <span class="hljs-comment">//定义数组的最大长度  </span><br><span class="hljs-type">int</span> a[N];  <br><span class="hljs-type">int</span> <span class="hljs-title function_">majorityDC</span><span class="hljs-params">(<span class="hljs-type">int</span> a[], <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end, <span class="hljs-type">int</span> *result)</span> &#123;<br><span class="hljs-comment">// 分治法求解多数问题，*result是数量过半的数的值，数组下标区间为[start, end]  </span><br>    <span class="hljs-keyword">if</span> (start == end) &#123;  <br>        *result = a[end];  <br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;  <br>    &#125;<span class="hljs-keyword">else</span>&#123;  <br>        <span class="hljs-type">int</span> m1, m2;  <br>        majorityDC(a, start, (start + end) / <span class="hljs-number">2</span>, &amp;m1);    <br>        <span class="hljs-comment">//m1为前半区间[start, (start + end) / 2]的多数  </span><br>        majorityDC(a, (start + end) / <span class="hljs-number">2</span> + <span class="hljs-number">1</span>, end, &amp;m2);   <br>        <span class="hljs-comment">//m2为后半区间[(start + end) / 2 + 1, end]的多数  </span><br>        <span class="hljs-type">int</span> count1 = <span class="hljs-number">0</span>, count2 = <span class="hljs-number">0</span>;  <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = start; i &lt;= end; i++) &#123;  <br>            <span class="hljs-keyword">if</span> (a[i] == m1) &#123;   <span class="hljs-comment">//count1记录m1在数组a[]中出现的次数  </span><br>                count1++;  <br>            &#125;  <br>            <span class="hljs-keyword">if</span> (a[i] == m2) &#123;   <span class="hljs-comment">//count2记录m2在数组a[]中出现的次数  </span><br>                count2++;  <br>            &#125;  <br>        &#125;  <br>        <span class="hljs-keyword">if</span>(count1 &gt; ((end - start + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>)) &#123;  <br>            <span class="hljs-comment">//m1在数组a[]中出现的次数大于数组长度的一半，则m1为多数  </span><br>            *result = m1;  <br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;  <br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(count2 &gt; ((end - start + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>)) &#123;  <br>            <span class="hljs-comment">//m2在数组a[]中出现的次数大于数组长度的一半，则m2为多数  </span><br>            *result = m2;  <br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;  <br>        &#125;<span class="hljs-keyword">else</span>&#123;  <br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <span class="hljs-comment">//m1, m2均不是多数，则数组a[]的多数不存在  </span><br>        &#125;  <br>    &#125;  <br>&#125;  <br>  <br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-type">int</span> n, resultDC;  <br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);  <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;n; i++)&#123;  <br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, &amp;a[i]);  <br>    &#125;  <br>    <span class="hljs-keyword">if</span>(majorityDC(a, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>, &amp;resultDC))&#123;  <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, resultDC);  <br>    &#125;<span class="hljs-keyword">else</span>&#123;  <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Can not find the majority!&quot;</span>);  <br>    &#125;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></td></tr></table></figure></p><h5 id="维护堆的性质">维护堆的性质</h5><ol type="1"><li>堆的定义：<ol type="1"><li>是一棵完全二叉树</li><li>每个节点的值都大于或等于其子节点的值，为最大堆；反之为最小堆。</li></ol></li><li>堆的存储：一般用数组来表示堆，下标为i的结点的父结点下标为<spanclass="math inline">\(\frac{i-1}2\)</span>；其左右子结点分别为 <spanclass="math inline">\(2i + 1\)</span>、<span class="math inline">\(2i +2\)</span>（若数组编号从0开始）。下标为i的结点的父结点下标为<spanclass="math inline">\(\frac{i-1}2\)</span>；其左右子结点分别为<spanclass="math inline">\(2i\)</span>、<span class="math inline">\(2i +1\)</span>（若数组编号从1开始） 时间复杂度<spanclass="math inline">\(O(lgn)\)</span>或对于树高h的节点来说，时间复杂度<spanclass="math inline">\(O(h)\)</span> ###### c递归维护 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 维护最大堆的性质  </span><br><span class="hljs-comment">// arr:一个最大堆的数组  </span><br><span class="hljs-comment">// i:需要调整的堆中的元素  </span><br><span class="hljs-type">void</span> <span class="hljs-title function_">max_heapify</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> n)</span>&#123;  <br>    <span class="hljs-comment">// 从a[i] a[l] a[r]选择最大的  </span><br>    <span class="hljs-type">int</span> l = <span class="hljs-number">2</span>*i+<span class="hljs-number">1</span>, r = <span class="hljs-number">2</span>*i+<span class="hljs-number">2</span>;  <br>    <span class="hljs-type">int</span> largest = i;  <br>    <span class="hljs-keyword">if</span>(l &lt;= n &amp;&amp; arr[l]&gt;arr[largest])&#123;  <br>        largest = l;  <br>    &#125;  <br>    <span class="hljs-keyword">if</span>(r &lt;= n &amp;&amp; arr[r]&gt;arr[largest])&#123;  <br>        largest = r;  <br>    &#125;  <br>    <span class="hljs-comment">// 如果a[i]最大，程序结束  </span><br>    <span class="hljs-keyword">if</span>(largest != i)&#123;  <br>        swap(&amp;arr[i], &amp;arr[largest]);  <br>        max_heapify(arr, largest);  <br>    &#125;  <br>&#125;  <br>  <br><span class="hljs-type">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>* a, <span class="hljs-type">int</span>* b)</span> &#123;  <br>    <span class="hljs-type">int</span> temp = *b;  <br>    *b = *a;  <br>    *a = temp;  <br>&#125;<br></code></pre></td></tr></table></figure>###### c非递归维护 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 维护最大堆的性质  </span><br><span class="hljs-comment">// arr:一个最大堆的数组  </span><br><span class="hljs-comment">// i:需要调整的堆中的元素  </span><br><span class="hljs-type">void</span> <span class="hljs-title function_">max_heapify</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> &#123;  <br><span class="hljs-comment">//建立父节点指标和子节点指标  </span><br><span class="hljs-type">int</span> dad = start;  <br><span class="hljs-type">int</span> son = dad * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;  <br><span class="hljs-keyword">while</span> (son &lt;= end) &#123; <span class="hljs-comment">//若子节点指标在范围内才做比较  </span><br><span class="hljs-keyword">if</span> (son + <span class="hljs-number">1</span> &lt;= end &amp;&amp; arr[son] &lt; arr[son + <span class="hljs-number">1</span>]) <span class="hljs-comment">//先比较两个子节点大小，选择最大的  </span><br>son++;  <br><span class="hljs-keyword">if</span> (arr[dad] &gt; arr[son]) <span class="hljs-comment">//如果父节点大于子节点代表调整完毕，直接跳出函数  </span><br><span class="hljs-keyword">return</span>;  <br><span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">//否则交换父子内容再继续子节点和孙节点比较  </span><br>swap(&amp;arr[dad], &amp;arr[son]);  <br>dad = son;  <br>son = dad * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;  <br>&#125;  <br>&#125;  <br>&#125;  <br>  <br><span class="hljs-type">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>* a, <span class="hljs-type">int</span>* b)</span> &#123;  <br><span class="hljs-type">int</span> temp = *b;  <br>*b = *a;  <br>*a = temp;  <br>&#125;<br></code></pre></td></tr></table></figure> ##### 建堆 时间复杂度<spanclass="math inline">\(O(n)\)</span> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">build_max_heap</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[ ],<span class="hljs-type">int</span> n)</span>&#123;  <br><span class="hljs-type">int</span> i;  <br><span class="hljs-keyword">for</span>(i=n/<span class="hljs-number">2</span><span class="hljs-number">-1</span>; i&gt;=<span class="hljs-number">0</span>; i--) <span class="hljs-comment">// 建初始堆积  </span><br>max_heapify(arr, i, n);  <br>&#125;<br></code></pre></td></tr></table></figure> ##### 堆排序算法时间复杂度<span class="math inline">\(O(nlgn)\)</span> ######c非递归维护最大堆 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 堆排序  </span><br><span class="hljs-type">void</span> <span class="hljs-title function_">heapsort</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> n)</span>&#123;  <br>    build_max_heap(arr, n);     <span class="hljs-comment">// 先建堆  </span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i--) &#123;  <br>        swap(&amp;arr[<span class="hljs-number">0</span>], &amp;arr[i]);     <span class="hljs-comment">// 将第一个元素(剩下的max)和已排好元素前一位做交换  </span><br>        max_heapify(arr, <span class="hljs-number">0</span>, i - <span class="hljs-number">1</span>); <span class="hljs-comment">// 重新调整  </span><br>    &#125;  <br>&#125;  <br>  <br><span class="hljs-comment">// 建堆  </span><br><span class="hljs-type">void</span> <span class="hljs-title function_">build_max_heap</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[ ],<span class="hljs-type">int</span> n)</span>&#123;  <br>    <span class="hljs-type">int</span> i;  <br>    <span class="hljs-keyword">for</span>(i=n/<span class="hljs-number">2</span><span class="hljs-number">-1</span>; i&gt;=<span class="hljs-number">0</span>; i--) <span class="hljs-comment">// 建初始堆积  </span><br>        max_heapify(arr, i, n);  <br>&#125;  <br>  <br><span class="hljs-comment">// 维护最大堆的性质  </span><br><span class="hljs-comment">// arr:一个最大堆的数组  </span><br><span class="hljs-comment">// i:需要调整的堆中的元素  </span><br><span class="hljs-type">void</span> <span class="hljs-title function_">max_heapify</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> n)</span>&#123;  <br>    <span class="hljs-comment">// 从a[i] a[l] a[r]选择最大的  </span><br>    <span class="hljs-type">int</span> l = <span class="hljs-number">2</span>*i+<span class="hljs-number">1</span>, r = <span class="hljs-number">2</span>*i+<span class="hljs-number">2</span>;  <br>    <span class="hljs-type">int</span> largest = i;  <br>    <span class="hljs-keyword">if</span>(l &lt;= n &amp;&amp; arr[l]&gt;arr[i])&#123;  <br>        largest = l;  <br>    &#125;  <br>    <span class="hljs-keyword">if</span>(r &lt;= n &amp;&amp; arr[r]&gt;arr[largest])&#123;  <br>        largest = r;  <br>    &#125;  <br>    <span class="hljs-comment">// 如果a[i]最大，程序结束  </span><br>    <span class="hljs-keyword">if</span>(largest != i)&#123;  <br>        swap(&amp;arr[i], &amp;arr[largest]);  <br>        max_heapify(arr, largest, n);  <br>    &#125;  <br>&#125;  <br>  <br><span class="hljs-type">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>* a, <span class="hljs-type">int</span>* b)</span> &#123;  <br>    <span class="hljs-type">int</span> temp = *b;  <br>    *b = *a;  <br>    *a = temp;  <br>&#125;<br></code></pre></td></tr></table></figure> ###### c+cpp递归维护最大堆<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span>  </span><br><span class="hljs-type">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>* a, <span class="hljs-type">int</span>* b)</span> &#123;  <br><span class="hljs-type">int</span> temp = *b;  <br>*b = *a;  <br>*a = temp;  <br>&#125;  <br>  <br><span class="hljs-comment">// 维护最大堆的性质  </span><br><span class="hljs-comment">// arr:一个最大堆的数组  </span><br><span class="hljs-comment">// i:需要调整的堆中的元素  </span><br><span class="hljs-type">void</span> <span class="hljs-title function_">max_heapify</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> &#123;  <br><span class="hljs-comment">//建立父节点指标和子节点指标  </span><br><span class="hljs-type">int</span> dad = start;  <br><span class="hljs-type">int</span> son = dad * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;  <br><span class="hljs-keyword">while</span> (son &lt;= end) &#123; <span class="hljs-comment">//若子节点指标在范围内才做比较  </span><br><span class="hljs-keyword">if</span> (son + <span class="hljs-number">1</span> &lt;= end &amp;&amp; arr[son] &lt; arr[son + <span class="hljs-number">1</span>]) <span class="hljs-comment">//先比较两个子节点大小，选择最大的  </span><br>son++;  <br><span class="hljs-keyword">if</span> (arr[dad] &gt; arr[son]) <span class="hljs-comment">//如果父节点大于子节点代表调整完毕，直接跳出函数  </span><br><span class="hljs-keyword">return</span>;  <br><span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">//否则交换父子内容再继续子节点和孙节点比较  </span><br>swap(&amp;arr[dad], &amp;arr[son]);  <br>dad = son;  <br>son = dad * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;  <br>&#125;  <br>&#125;  <br>&#125;  <br><span class="hljs-comment">// 堆排序算法  </span><br><span class="hljs-type">void</span> <span class="hljs-title function_">heap_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> len)</span> &#123;  <br><span class="hljs-type">int</span> i;  <br><span class="hljs-comment">//建堆，初始化，i从最后一个父节点开始调整  </span><br><span class="hljs-keyword">for</span> (i = len / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)  <br>max_heapify(arr, i, len - <span class="hljs-number">1</span>);  <br><span class="hljs-comment">//先将第一个元素和已排好元素前一位做交换，再从新调整，直到排序完毕  </span><br><span class="hljs-keyword">for</span> (i = len - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i--) &#123;  <br>swap(&amp;arr[<span class="hljs-number">0</span>], &amp;arr[i]);  <br>max_heapify(arr, <span class="hljs-number">0</span>, i - <span class="hljs-number">1</span>);  <br>&#125;  <br>&#125;  <br></code></pre></td></tr></table></figure> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span>  </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 维护最大堆的性质  </span><br><span class="hljs-comment">// arr:一个最大堆的数组  </span><br><span class="hljs-comment">// i:需要调整的堆中的元素  </span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">max_heapify</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> </span>&#123;  <br><span class="hljs-comment">//建立父节点指标和子节点指标  </span><br><span class="hljs-type">int</span> dad = start;  <br><span class="hljs-type">int</span> son = dad * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;  <br><span class="hljs-keyword">while</span> (son &lt;= end) &#123; <span class="hljs-comment">//若子节点指标在范围内才做比较  </span><br><span class="hljs-keyword">if</span> (son + <span class="hljs-number">1</span> &lt;= end &amp;&amp; arr[son] &lt; arr[son + <span class="hljs-number">1</span>]) <span class="hljs-comment">//先比较两个子节点大小，选择最大的  </span><br>son++;  <br><span class="hljs-keyword">if</span> (arr[dad] &gt; arr[son]) <span class="hljs-comment">//如果父节点大于子节点代表调整完毕，直接跳出函数  </span><br><span class="hljs-keyword">return</span>;  <br><span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">//否则交换父子内容再继续子节点和孙节点比较  </span><br><span class="hljs-built_in">swap</span>(arr[dad], arr[son]);  <br>dad = son;  <br>son = dad * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;  <br>&#125;  <br>&#125;  <br>&#125;  <br><br><span class="hljs-comment">// 堆排序算法  </span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">heap_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> len)</span> </span>&#123;  <br><span class="hljs-comment">//初始化，i从最后一个父节点开始调整  </span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = len / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)  <br><span class="hljs-built_in">max_heapify</span>(arr, i, len - <span class="hljs-number">1</span>);  <br><span class="hljs-comment">//先将第一个元素和已经排好的元素前一位做交换，再从新调整(刚调整的元素之前的元素)，直到排序完毕  </span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = len - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i--) &#123;  <br><span class="hljs-built_in">swap</span>(arr[<span class="hljs-number">0</span>], arr[i]);  <br><span class="hljs-built_in">max_heapify</span>(arr, <span class="hljs-number">0</span>, i - <span class="hljs-number">1</span>);  <br>&#125;  <br>&#125;  <br></code></pre></td></tr></table></figure> ###### 用cpp的algorithm建堆和堆排序<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span>  </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;  <br>    vector&lt;<span class="hljs-type">int</span>&gt; a = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>&#125;;  <br>    <span class="hljs-built_in">make_heap</span>(a.<span class="hljs-built_in">begin</span>(), a.<span class="hljs-built_in">end</span>());   <span class="hljs-comment">// 造堆</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i : a)&#123;  <br>        cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;  <br>    &#125;  <br>    cout &lt;&lt; endl;  <br>    <span class="hljs-built_in">sort_heap</span>(a.<span class="hljs-built_in">begin</span>(), a.<span class="hljs-built_in">end</span>());   <span class="hljs-comment">// 堆排序</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i : a)&#123;  <br>        cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;  <br>    &#125;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h5 id="c优先队列">c优先队列</h5><h6 id="读最大元素-o1">读最大元素 O(1)</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">heap_maximum</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[])</span>&#123;  <br><span class="hljs-keyword">return</span> arr[<span class="hljs-number">0</span>];<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="移走最大元素-olgn">移走最大元素 O(lgn)</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">heap_extract_max</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> n)</span>&#123;  <br><span class="hljs-keyword">if</span>(n &lt; <span class="hljs-number">1</span>)&#123;  <br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;HEAP UNDERFLOW&quot;</span>);  <br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;  <br><span class="hljs-type">int</span> max = arr[<span class="hljs-number">0</span>];  <br>arr[<span class="hljs-number">0</span>] = arr[n<span class="hljs-number">-1</span>];  <br>n--;  <br>max_heapify(arr, <span class="hljs-number">0</span>, n);  <br><span class="hljs-keyword">return</span> max;  <br>&#125;<br></code></pre></td></tr></table></figure><h6 id="增加某结点的值-olgn">增加某结点的值 O(lgn)</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">heap_increase_key</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> key)</span>&#123;  <span class="hljs-comment">// 修改结点arr[i]的值为key</span><br><span class="hljs-keyword">if</span>(key &lt; arr[i])&#123;  <br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;NEW KEY IS SMALLER THAN CURRENT KEY&quot;</span>);  <br>&#125;  <br>arr[i] = key;  <br><span class="hljs-keyword">while</span>(i&gt;<span class="hljs-number">0</span> &amp;&amp; arr[(i<span class="hljs-number">-1</span>)/<span class="hljs-number">2</span>]&lt;arr[i])&#123;  <br>swap(&amp;a[i], &amp;arr[(i<span class="hljs-number">-1</span>)/<span class="hljs-number">2</span>]);  <br>i = (i<span class="hljs-number">-1</span>)/<span class="hljs-number">2</span>;  <br>&#125;  <br>&#125;<br></code></pre></td></tr></table></figure><h6 id="插入一个新节点-olgn">插入一个新节点 O(lgn)</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">max_heap_insert</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> key, <span class="hljs-type">int</span> n)</span>&#123;  <br>n++;  <br>a[n<span class="hljs-number">-1</span>] = key<span class="hljs-number">-1</span>;  <br>heap_increase_key(arr, n<span class="hljs-number">-1</span>, key);  <br>&#125;<br></code></pre></td></tr></table></figure><h5 id="快速排序">快速排序</h5><p>最好情况/平均情况：<span class="math inline">\(O(nlgn)\)</span>###### 法1 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// way1  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> keytype int  </span><br>  <br>using namespace <span class="hljs-built_in">std</span>;  <br><span class="hljs-type">void</span> <span class="hljs-title function_">quickSort</span><span class="hljs-params">(keytype k[],<span class="hljs-type">int</span> n)</span>;  <br><span class="hljs-type">void</span> <span class="hljs-title function_">quick</span><span class="hljs-params">(keytype k[ ],<span class="hljs-type">int</span> left,<span class="hljs-type">int</span> right)</span>;  <br><span class="hljs-type">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span> *x, <span class="hljs-type">int</span> *y)</span>;  <br>  <br><span class="hljs-type">void</span> <span class="hljs-title function_">quickSort</span><span class="hljs-params">(keytype k[],<span class="hljs-type">int</span> n)</span>&#123;  <br>    quick(k, <span class="hljs-number">0</span>, n<span class="hljs-number">-1</span>);  <br>&#125;  <br><span class="hljs-type">void</span> <span class="hljs-title function_">quick</span><span class="hljs-params">(keytype k[ ],<span class="hljs-type">int</span> left,<span class="hljs-type">int</span> right)</span>&#123;  <br>    <span class="hljs-type">int</span> i, j;  <br>    keytype pivot;  <br>    <span class="hljs-keyword">if</span>(left &lt; right)&#123;  <br>        i = left;  <br>        j = right+<span class="hljs-number">1</span>;  <br>        pivot = k[left];  <br>        <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;  <br>            <span class="hljs-keyword">while</span>(k[++i]&lt;pivot &amp;&amp; i!=right) &#123; &#125;  <br>            <span class="hljs-keyword">while</span>(k[--j]&gt;pivot &amp;&amp; j!=left) &#123; &#125;  <br>            <span class="hljs-keyword">if</span>(i &lt; j)  <br>                swap(&amp;k[i], &amp;k[j]);  <span class="hljs-comment">/*交换K[i]与K[j]的内容*/</span>  <br>            <span class="hljs-keyword">else</span>  <br>                <span class="hljs-keyword">break</span>;  <br>        &#125;  <br>        swap(&amp;k[left], &amp;k[j]);      <span class="hljs-comment">/*交换K[s]与K[j]的内容*/</span>  <br>        quick(k, left, j<span class="hljs-number">-1</span>);       <span class="hljs-comment">/* 对前一部分排序 */</span><br>        quick(k, j+<span class="hljs-number">1</span>, right);       <span class="hljs-comment">/* 对后一部分排序 */</span><br>    &#125;  <br>&#125;  <br><span class="hljs-type">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(keytype *x, keytype *y)</span>&#123;  <br>    keytype temp;  <br>    temp = *x;<span class="hljs-comment">//取内容交换    </span><br>*x = *y;  <br>    *y = temp;  <br>&#125;  <br>  <br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-type">int</span> a[<span class="hljs-number">100</span>] = &#123;<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">123</span>,<span class="hljs-number">1524</span>,<span class="hljs-number">4235</span>,<span class="hljs-number">345</span>,<span class="hljs-number">34</span>,<span class="hljs-number">67</span>,<span class="hljs-number">324</span>&#125;;  <br>    quickSort(a, <span class="hljs-number">12</span>);  <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">12</span>; i++)&#123;  <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, a[i]);  <br>    &#125;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></td></tr></table></figure> ###### 法2 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// way2 BY K&amp;R  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> keytype int  </span><br>  <br>using namespace <span class="hljs-built_in">std</span>;  <br><span class="hljs-type">void</span> <span class="hljs-title function_">quickSort</span><span class="hljs-params">(keytype k[],<span class="hljs-type">int</span> n)</span>;  <br><span class="hljs-type">void</span> <span class="hljs-title function_">qsort</span><span class="hljs-params">(keytype v[ ],<span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span>;  <br><span class="hljs-type">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(keytype v[ ],<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span>;  <br>  <br><span class="hljs-type">void</span> <span class="hljs-title function_">quickSort</span><span class="hljs-params">(keytype k[],<span class="hljs-type">int</span> n)</span>&#123;  <br>    qsort(k, <span class="hljs-number">0</span>, n<span class="hljs-number">-1</span>);  <br>&#125;  <br><span class="hljs-type">void</span> <span class="hljs-title function_">qsort</span><span class="hljs-params">(keytype v[ ],<span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span>&#123;  <br>    <span class="hljs-type">int</span> i, last;  <br>    <span class="hljs-keyword">if</span>(left &gt;= right)  <br>        <span class="hljs-keyword">return</span>;  <br>    swap(v, left, (left+right)/<span class="hljs-number">2</span>);<span class="hljs-comment">// 将中间与left交换，将中间作为基准  </span><br>    last = left;    <span class="hljs-comment">// last: 最后一个比left小的元素  </span><br>    <span class="hljs-keyword">for</span>(i=left+<span class="hljs-number">1</span>; i&lt;=right; i++)  <br>        <span class="hljs-keyword">if</span>(v[i] &lt; v[left])  <span class="hljs-comment">// 如果当前元素小于基准元素  </span><br>            swap(v, ++last, i); <span class="hljs-comment">// last右移，获得新的last  </span><br>    swap(v, left, last);    <span class="hljs-comment">// 把基准元素left放到正确位置  </span><br>    qsort(v, left, last);  <br>    qsort(v, last+<span class="hljs-number">1</span>, right);  <br>&#125;  <br><span class="hljs-type">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(keytype v[ ],<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span>&#123;  <br>    keytype tmp;  <br>    tmp = v[i];  <br>    v[i] = v[j];  <br>    v[j] = tmp;  <br>&#125;  <br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-type">int</span> a[<span class="hljs-number">100</span>] = &#123;<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">123</span>,<span class="hljs-number">1524</span>,<span class="hljs-number">4235</span>,<span class="hljs-number">345</span>,<span class="hljs-number">34</span>,<span class="hljs-number">67</span>,<span class="hljs-number">324</span>&#125;;  <br>    quickSort(a, <span class="hljs-number">12</span>);  <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">12</span>; i++)&#123;  <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, a[i]);  <br>    &#125;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></td></tr></table></figure></p><h5 id="快速排序的随机化版本">快速排序的随机化版本</h5><p>最坏情况：<span class="math inline">\(O(n^2)\)</span>期望运行时间：<span class="math inline">\(O(nlgn)\)</span><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;random&gt;</span>  </span><br>  <br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">randomized_partition</span><span class="hljs-params">(<span class="hljs-type">int</span> a[], <span class="hljs-type">int</span> p, <span class="hljs-type">int</span> r)</span></span>;  <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">randomized_quiksort</span><span class="hljs-params">(<span class="hljs-type">int</span> a[], <span class="hljs-type">int</span> p, <span class="hljs-type">int</span> r)</span></span>;  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(<span class="hljs-type">int</span> a[], <span class="hljs-type">int</span> p, <span class="hljs-type">int</span> r)</span></span>;  <br>  <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">randomized_quiksort</span><span class="hljs-params">(<span class="hljs-type">int</span> a[], <span class="hljs-type">int</span> p, <span class="hljs-type">int</span> r)</span></span>&#123;  <br>    <span class="hljs-keyword">if</span>(p &lt; r)&#123;  <br>        <span class="hljs-type">int</span> q = <span class="hljs-built_in">randomized_partition</span>(a, p, r); <span class="hljs-comment">// 随机选择一个元素作为基准，并进行划分  </span><br>        <span class="hljs-built_in">randomized_quiksort</span>(a, p, q<span class="hljs-number">-1</span>);  <br>        <span class="hljs-built_in">randomized_quiksort</span>(a, q+<span class="hljs-number">1</span>, r);  <br>    &#125;  <br>&#125;  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">randomized_partition</span><span class="hljs-params">(<span class="hljs-type">int</span> a[], <span class="hljs-type">int</span> p, <span class="hljs-type">int</span> r)</span></span>&#123;  <br>    <span class="hljs-type">int</span> i = <span class="hljs-built_in">rand</span>()%(r-p)+p; <span class="hljs-comment">// 在[p, r]范围内随机选择一个索引作为基准  </span><br>    <span class="hljs-built_in">swap</span>(a[r], a[i]);  <br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">partition</span>(a, p, r); <span class="hljs-comment">// 调用partition函数进行划分  </span><br>&#125;  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(<span class="hljs-type">int</span> a[], <span class="hljs-type">int</span> p, <span class="hljs-type">int</span> r)</span></span>&#123;  <br>    <span class="hljs-type">int</span> x = a[r];  <br>    <span class="hljs-type">int</span> i = p<span class="hljs-number">-1</span>; <span class="hljs-comment">// i指向小于基准的最后一个元素  </span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=p; j&lt;=r<span class="hljs-number">-1</span>; j++)&#123;  <br>        <span class="hljs-keyword">if</span>(a[j] &lt;= x)&#123;  <br>            i++; <span class="hljs-comment">// i右移  </span><br>            <span class="hljs-built_in">swap</span>(a[i], a[j]); <span class="hljs-comment">// 交换元素，将小于基准的元素移到左边  </span><br>        &#125;  <br>    &#125;  <br>    <span class="hljs-built_in">swap</span>(a[i+<span class="hljs-number">1</span>], a[r]); <span class="hljs-comment">// 将基准元素交换到正确的位置  </span><br>    <span class="hljs-keyword">return</span> i+<span class="hljs-number">1</span>; <span class="hljs-comment">// 返回基准元素的最终位置  </span><br>&#125;  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;  <br>    <span class="hljs-type">int</span> a[<span class="hljs-number">100</span>] = &#123;<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">123</span>,<span class="hljs-number">1524</span>,<span class="hljs-number">4235</span>,<span class="hljs-number">345</span>,<span class="hljs-number">34</span>,<span class="hljs-number">67</span>,<span class="hljs-number">324</span>&#125;;  <br>    <span class="hljs-built_in">randomized_quiksort</span>(a, <span class="hljs-number">0</span>, <span class="hljs-number">12</span>);  <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">12</span>; i++)&#123;  <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, a[i]);  <br>    &#125;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></td></tr></table></figure> ##### 最大子列和 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX 1000005  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long  </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;  <br><span class="hljs-type">int</span> a[MAX];  <br><span class="hljs-comment">// 输入：数组array 数组长度n     返回：array的子列中最大的和</span><br><span class="hljs-function">ll <span class="hljs-title">maxSubArray</span><span class="hljs-params">(<span class="hljs-type">int</span> *array, <span class="hljs-type">int</span> n)</span> </span>&#123;  <br>    ll Max = <span class="hljs-number">-0x3f3f3f3f3f3f3f3f</span>;  <br>    ll sum = <span class="hljs-number">0</span>;  <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;  <br>        <span class="hljs-keyword">if</span> (sum &lt; <span class="hljs-number">0</span>)  <span class="hljs-comment">// 如果sum已经&lt;0了，留下sum只会让之后的和更小，所以去掉sum</span><br>            sum = array[i];  <br>        <span class="hljs-keyword">else</span>  <br>            sum += array[i];  <br>        Max = <span class="hljs-built_in">max</span>(sum, Max);  <br>    &#125;  <br>    <span class="hljs-keyword">return</span> Max;  <br>&#125;  <br>  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;  <br>    <span class="hljs-type">int</span> n;  <br>    cin &gt;&gt; n;  <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)  <br>        cin &gt;&gt; a[i];  <br>    cout &lt;&lt; <span class="hljs-built_in">maxSubArray</span>(a, n);  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></td></tr></table></figure> ##### 钢条切割给定一段长度为 <span class="math inline">\(n\)</span>英寸的钢条和一个价格表 <spanclass="math inline">\(p_i(i=1,2,...,n)\)</span>，求切割钢条方案，使得销售收益 <span class="math inline">\(r_n\)</span>最大。 ###### 带备忘的自顶向下法(top-down with memoization) +复杂度：<span class="math inline">\(O(n^2)\)</span>将钢条分为两部分，左边长度为 <span class="math inline">\(i\)</span>，右边长度为 <span class="math inline">\(n-i\)</span>，只对右边继续进行切割（递归求解），对左边不再进行切割。这样，不做任何切割的方案就可以描述为：第一段的长度为 <spanclass="math inline">\(n\)</span> ，收益为 <spanclass="math inline">\(p_n\)</span> ，剩余部分长度为 <spanclass="math inline">\(0\)</span> ，对应的收益为 <spanclass="math inline">\(r_n=0\)</span> 。于是我们可以得到公式：<spanclass="math inline">\(r_n = max_{1\ge i \ge n}(p_i + r_{n-i})\)</span>。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span>  </span><br>using namespace <span class="hljs-built_in">std</span>;  <br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX 100  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MIN_VALUE -1  </span><br><span class="hljs-type">int</span> <span class="hljs-title function_">max</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span>&#123;  <br>    <span class="hljs-keyword">if</span>(a &gt; b)&#123;  <br>        <span class="hljs-keyword">return</span> a;  <br>    &#125;<span class="hljs-keyword">else</span>&#123;  <br>        <span class="hljs-keyword">return</span> b;  <br>    &#125;  <br>&#125;  <br>  <br><span class="hljs-comment">// p为价格表，n为正在切割的钢管长度，r为最大收益  </span><br><span class="hljs-type">int</span> <span class="hljs-title function_">MEMOIZED_CUT_ROD_AUX</span><span class="hljs-params">(<span class="hljs-type">int</span>* p, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span>* r)</span>&#123;  <br>    <span class="hljs-type">int</span> q;  <br>    <span class="hljs-keyword">if</span>(r[n] &gt;= <span class="hljs-number">0</span>)&#123;  <span class="hljs-comment">// 切过这个长度，已经记住了  </span><br>        <span class="hljs-keyword">return</span> r[n];  <br>    &#125;  <br>    <span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span>)&#123;     <span class="hljs-comment">// 切一段长度为0的  </span><br>        q = <span class="hljs-number">0</span>;  <br>    &#125;<span class="hljs-keyword">else</span>&#123;  <br>        q = MIN_VALUE;  <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)&#123;    <span class="hljs-comment">// 左边长度i，右边长度n-i  </span><br>            q = max(q, p[i]+MEMOIZED_CUT_ROD_AUX(p, n-i, r));  <br>        &#125;  <br>    &#125;  <br>    r[n] = q;  <br>    <span class="hljs-keyword">return</span> q;  <br>&#125;  <br><br><span class="hljs-comment">// 函数入口 p为价格表 n为正在切割的钢管长度     返回能得到的最大value</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">MEMOIZED_CUT_ROD</span><span class="hljs-params">(<span class="hljs-type">int</span>* p, <span class="hljs-type">int</span> n)</span>&#123;  <br>    <span class="hljs-type">int</span> r[MAX];  <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;=n; i++)&#123;  <br>        r[i] = MIN_VALUE;<span class="hljs-comment">// 初始化  </span><br>    &#125;  <br>    <span class="hljs-keyword">return</span> MEMOIZED_CUT_ROD_AUX(p, n, r);  <br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-type">int</span> p[<span class="hljs-number">15</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">17</span>,<span class="hljs-number">17</span>, <span class="hljs-number">20</span>, <span class="hljs-number">24</span>, <span class="hljs-number">30</span>&#125;;  <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, MEMOIZED_CUT_ROD(p, <span class="hljs-number">14</span>));  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></td></tr></table></figure> ###### 给出最大收益及最优切割方案 下面的EXTENDED_BOTTOM_UP_CUT_ROD 对长度为 <spanclass="math inline">\(i\)</span> 的钢条不仅计算最大收益值 <spanclass="math inline">\(r_j\)</span>，还保存最优解对应的第一段钢条的切割长度 <spanclass="math inline">\(S\)</span> 。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span>  </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;  <br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX 100  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MIN_VALUE (-1)  </span><br><span class="hljs-type">int</span> s[MAX], r[MAX];  <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">EXTENDED_BOTTOM_UP_CUT_ROD</span><span class="hljs-params">(<span class="hljs-type">int</span> *p, <span class="hljs-type">int</span> n)</span></span>&#123;  <br>    r[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;  <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>; j&lt;=n; j++)&#123;  <br>        <span class="hljs-type">int</span> q = MIN_VALUE;  <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=j; i++)&#123;  <br>            <span class="hljs-keyword">if</span>(q &lt; p[i]+r[j-i])&#123;    <span class="hljs-comment">// 更好的切割  </span><br>                q = p[i]+r[j-i];    <span class="hljs-comment">// 更新价格  </span><br>                s[j] = i;           <span class="hljs-comment">// 更新切割方式  </span><br>            &#125;  <br>        &#125;  <br>        r[j] = q;  <br>    &#125;  <br>&#125;  <br><span class="hljs-comment">// p:价格表 n:要切的钢条长度  </span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PRINT_CUT_ROD_SOLUTION</span><span class="hljs-params">(<span class="hljs-type">int</span> *p,<span class="hljs-type">int</span> n)</span></span>&#123;  <br>    <span class="hljs-built_in">EXTENDED_BOTTOM_UP_CUT_ROD</span>(p, n);  <br>    <span class="hljs-comment">// 计算切割下来的每段钢条的长度s[1..n]和最大value r[1..n]  </span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, r[n]);  <br>    <span class="hljs-keyword">while</span>(n &gt; <span class="hljs-number">0</span>)&#123;  <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, s[n]);  <br>        n -= s[n];  <br>    &#125;  <br>&#125;  <br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;  <br>    <span class="hljs-type">int</span> p[<span class="hljs-number">15</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">17</span>,<span class="hljs-number">17</span>, <span class="hljs-number">20</span>, <span class="hljs-number">24</span>, <span class="hljs-number">30</span>&#125;;  <br>    <span class="hljs-built_in">PRINT_CUT_ROD_SOLUTION</span>(p, <span class="hljs-number">14</span>);  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></td></tr></table></figure> ##### 矩阵链乘法 +<strong>矩阵链乘法问题</strong>：给定n个矩阵的链<spanclass="math inline">\(&lt;A_1,A_2,...,A_n&gt;\)</span>，矩阵<spanclass="math inline">\(A_i\)</span>是规模为 <spanclass="math inline">\(p_{i-1}\times p_{i}(1\le i\len)\)</span>，求完全括号化方案，使得计算乘积 <spanclass="math inline">\(A_1A_2...A_n\)</span> 所需标量乘法次数最少。 +<strong>完全括号化</strong>：它是单一矩阵，或者是两个完全括号化的矩阵乘积链的积，且已外加括号。例如，如果矩阵链为<spanclass="math inline">\(&lt;A_1,A_2,A_3,A_4&gt;\)</span>，则共有5种完全括号化的矩阵乘积链：<spanclass="math inline">\((A_1\ (A_{2}\ (A_{3}\ A_{4}))),\ (A_{1}\ ((A_{2}\A_3)A_{4})),\ ((A_{1}\ A_2)(A_{3}\ A_{4})),\)</span><spanclass="math inline">\(\ ((A_{1}(A_{2}\ A_{3}))A_{4}),\ (((A_{1}\A_2)A_{3}\ )A_{4}\ )\)</span> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span>  </span><br>using namespace <span class="hljs-built_in">std</span>;  <br><span class="hljs-comment">/*  </span><br><span class="hljs-comment"> * p: 表示矩阵的规模，矩阵 A_i 的规模用 p_i-1 * p_i 表示</span><br><span class="hljs-comment"> * s: s[i,j]表示A_i A_i+1 ... A_j最优括号化方案的分割点位置k  </span><br><span class="hljs-comment"> * m: m[i,j]表示A_i A_i+1 ... A_j所需标量乘法次数的最小值  </span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX 100  </span><br><span class="hljs-type">long</span> <span class="hljs-type">long</span> p[MAX],m[MAX][MAX],s[MAX][MAX];  <br><span class="hljs-type">void</span> <span class="hljs-title function_">MATRIX_CHAIN_ORDER</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span>&#123;  <br>    <span class="hljs-comment">// 初始化  </span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)&#123;  <br>        m[i][i] = <span class="hljs-number">0</span>;  <br>    &#125;  <br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> l=<span class="hljs-number">2</span>; l&lt;=n; l++)&#123;    <span class="hljs-comment">// l is the chain length  </span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n-l+<span class="hljs-number">1</span>; i++)&#123;    <span class="hljs-comment">// 矩阵链的起始位置  </span><br>            <span class="hljs-type">int</span> j = i+l<span class="hljs-number">-1</span>;              <span class="hljs-comment">// 矩阵链的结束位置  </span><br>            m[i][j] = <span class="hljs-number">9223372036854775807</span>;  <span class="hljs-comment">// long long 最大值  </span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=i; k&lt;=j<span class="hljs-number">-1</span>; k++)&#123;  <span class="hljs-comment">// A_i...A_j 的最优括号化方案的分割点为k</span><br>                <span class="hljs-type">long</span> <span class="hljs-type">long</span> q = m[i][k]+m[k+<span class="hljs-number">1</span>][j] + p[i<span class="hljs-number">-1</span>]*p[k]*p[j];  <br>                <span class="hljs-keyword">if</span>(q &lt; m[i][j])&#123;  <br>                    m[i][j] = q;  <br>                    s[i][j] = k;  <br>                &#125;  <br>            &#125;  <br>        &#125;  <br>    &#125;  <br>&#125;  <br><span class="hljs-type">void</span> <span class="hljs-title function_">PRINT_OPTIMAL_PARENS</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> i, <span class="hljs-type">long</span> <span class="hljs-type">long</span> j)</span>&#123;  <br>    <span class="hljs-keyword">if</span>(i == j)&#123;  <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;A&quot;</span>);  <br>    &#125;<span class="hljs-keyword">else</span>&#123;  <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;(&quot;</span>);  <br>        PRINT_OPTIMAL_PARENS(i, s[i][j]);  <br>        PRINT_OPTIMAL_PARENS(s[i][j]+<span class="hljs-number">1</span>, j);  <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;)&quot;</span>);  <br>    &#125;  <br>&#125;  <br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-type">int</span> n;  <br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);  <span class="hljs-comment">// n个矩阵</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;=n; i++)&#123;  <br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>, &amp;p[i]);  <br>    &#125;  <br>    MATRIX_CHAIN_ORDER(n);  <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, m[<span class="hljs-number">1</span>][n]);   <span class="hljs-comment">// A_1..A_n所需标量乘法次数的最小值  </span><br>    PRINT_OPTIMAL_PARENS(<span class="hljs-number">1</span>,n);   <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></td></tr></table></figure></p><h5 id="最长公共子序列">最长公共子序列</h5><ul><li><strong>子序列</strong>：给定一个序列 <span class="math inline">\(X= &lt;x_1, x_2, ..., x_m&gt;\)</span>，另一个序列 <spanclass="math inline">\(Z = &lt;z_1,z_2,...,z_k&gt;\)</span>满足如下条件时成为 <span class="math inline">\(X\)</span>的子序列（subsequence），即存在一个严格递增的 <spanclass="math inline">\(X\)</span> 的下表序列 <spanclass="math inline">\(&lt;i_1,i_2,...,i_k&gt;\)</span>，对所有 <spanclass="math inline">\(j=1,2,...,k\)</span>，满足 <spanclass="math inline">\(x_{i_1} = z_j\)</span> 。 例如，<spanclass="math inline">\(Z=&lt;B,C,D,B&gt;\)</span> 是 <spanclass="math inline">\(X=&lt;A,B,C,B,D,A,B&gt;\)</span>的子序列，对应的下标序列为 <spanclass="math inline">\(&lt;2,3,5,7&gt;\)</span> 。</li><li><strong>公共子序列</strong>：给定两个序列 <spanclass="math inline">\(X\)</span> 和 <spanclass="math inline">\(Y\)</span> ，如果 Z 既是 X 的子序列，也是 Y的子序列，我们称它是 X 和 Y 的公共子序列（common subsequence）。</li><li><strong>最长公共子序列问题</strong>（longest-common-subsequenceproblem）：给定两个序列 <span class="math inline">\(X =&lt;x_1,x_2,...,x_m&gt;\)</span> 和 <spanclass="math inline">\(Y=&lt;y_1,y_2,..,y_n&gt;\)</span>，求 <spanclass="math inline">\(X\)</span> 和 <spanclass="math inline">\(Y\)</span> 长度最长的公共子序列。 复杂度：<spanclass="math inline">\(O(n^2)\)</span> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX 100  </span><br>  <br><span class="hljs-type">int</span> c[MAX][MAX];  <br>  <br><span class="hljs-comment">// 接受字符串x和y，寻找x和y的最长公共子序列  </span><br><span class="hljs-type">void</span> <span class="hljs-title function_">LCS_LENGTH</span><span class="hljs-params">(<span class="hljs-type">char</span> *x, <span class="hljs-type">char</span> *y)</span>&#123;  <br>    <span class="hljs-comment">// 初始化  </span><br>    <span class="hljs-type">int</span> xLen = <span class="hljs-built_in">strlen</span>(x), yLen = <span class="hljs-built_in">strlen</span>(y);  <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;xLen; i++)&#123;  <br>        <span class="hljs-keyword">if</span>(y[<span class="hljs-number">0</span>] == x[i] || c[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>] == <span class="hljs-number">1</span>)&#123;  <br>            c[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;  <br>        &#125;  <br>    &#125;  <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;yLen; i++)&#123;  <br>        <span class="hljs-keyword">if</span>(x[<span class="hljs-number">0</span>] == y[i] || c[<span class="hljs-number">0</span>][i<span class="hljs-number">-1</span>] == <span class="hljs-number">1</span>)&#123;  <br>            c[<span class="hljs-number">0</span>][i] = <span class="hljs-number">1</span>;  <br>        &#125;  <br>    &#125;  <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;xLen; i++)&#123;  <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>; j&lt;yLen; j++)&#123;  <br>            <span class="hljs-keyword">if</span>(x[i] == y[j])&#123;  <br>                c[i][j] = c[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] + <span class="hljs-number">1</span>;  <br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(c[i<span class="hljs-number">-1</span>][j] &gt;= c[i][j<span class="hljs-number">-1</span>])&#123;   <span class="hljs-comment">// xi!=yj时f(x)=max(c[i-1,j],c[i,j-1])</span><br>                c[i][j] = c[i<span class="hljs-number">-1</span>][j];  <br>            &#125;<span class="hljs-keyword">else</span>&#123;  <br>                c[i][j] = c[i][j<span class="hljs-number">-1</span>];  <br>            &#125;  <br>        &#125;  <br>    &#125;  <br>&#125;  <br><span class="hljs-comment">// 最长公共子序列 输入字符串x,y 字符串长度-1是i,j</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">PRINT_LCS</span><span class="hljs-params">(<span class="hljs-type">char</span> *x, <span class="hljs-type">char</span> *y, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span>&#123;  <br>    <span class="hljs-keyword">if</span>(i == <span class="hljs-number">-1</span> || j == <span class="hljs-number">-1</span>)&#123;  <br>        <span class="hljs-keyword">return</span>;  <br>    &#125;  <br>    <span class="hljs-keyword">if</span>(x[i] == y[j])&#123;  <br>        PRINT_LCS(x, y, i<span class="hljs-number">-1</span>, j<span class="hljs-number">-1</span>);  <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c &quot;</span>, x[i]);  <br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(c[i<span class="hljs-number">-1</span>][j] &gt;= c[i][j<span class="hljs-number">-1</span>])&#123;  <br>        PRINT_LCS(x, y, i<span class="hljs-number">-1</span>, j);  <br>    &#125;<span class="hljs-keyword">else</span>&#123;  <br>        PRINT_LCS(x, y, i, j<span class="hljs-number">-1</span>);  <br>    &#125;  <br>&#125;  <br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-type">char</span> x[MAX] = <span class="hljs-string">&quot;ABCBDAB&quot;</span>, y[MAX] = <span class="hljs-string">&quot;BDCABA&quot;</span>;  <br>    LCS_LENGTH(x,y);  <br>    PRINT_LCS(x, y, <span class="hljs-built_in">strlen</span>(x)<span class="hljs-number">-1</span>, <span class="hljs-built_in">strlen</span>(y)<span class="hljs-number">-1</span>);  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h5 id="最长公共子串">最长公共子串</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 最长公共子串 输入字符串s1和s2 返回最长公共子串的长度max  </span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">PRINT_LCS2</span><span class="hljs-params">(<span class="hljs-type">char</span> *s1, <span class="hljs-type">char</span> *s2)</span></span>&#123;  <br>    <span class="hljs-type">int</span> max = <span class="hljs-number">0</span>, start = <span class="hljs-number">0</span>, len1 = <span class="hljs-built_in">strlen</span>(s1), len2 = <span class="hljs-built_in">strlen</span>(s2);  <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=len1; i++)&#123;  <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>; j&lt;=len2; j++)&#123;  <br>            <span class="hljs-keyword">if</span>(s1[i<span class="hljs-number">-1</span>] == s2[j<span class="hljs-number">-1</span>])  <br>                dp[i][j] = dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] + <span class="hljs-number">1</span>;  <br>            <span class="hljs-keyword">if</span>(dp[i][j] &gt; max)&#123;  <br>                max = dp[i][j]; <span class="hljs-comment">// 最长公共子串的长度  </span><br>                start = i - max; <span class="hljs-comment">// 该子串的起始点位  </span><br>            &#125;  <br>        &#125;  <br>    &#125;  <br>    <span class="hljs-keyword">return</span> max;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="最优二叉搜索树">最优二叉搜索树</h5><ul><li><strong>最优二叉搜索树问题</strong>：给定一个 <spanclass="math inline">\(n\)</span> 个不同关键字的已排序的序列 <spanclass="math inline">\(K=&lt;k_1,k_2,…,k_n&gt;(k_1&lt;k_2&lt;…&lt;k_n)\)</span>，我们希望用这些关键字构造一棵二叉搜索树。对每个关键字 <spanclass="math inline">\(k\)</span>，都有一个概率<spanclass="math inline">\(p_i\)</span>，表示其搜索频率。有些要搜索的值可能不在<span class="math inline">\(K\)</span> 中，因此我们还有 <spanclass="math inline">\(n+1个\)</span> <strong>伪关键字</strong> <spanclass="math inline">\(d_0,d_1,d_2,...,d+n\)</span> 表示不在 <spanclass="math inline">\(K\)</span> 中的值。<spanclass="math inline">\(d_0\)</span> 表示所有小于 <spanclass="math inline">\(k_1\)</span> 的值，<spanclass="math inline">\(d_n\)</span> 表示所有大于 <spanclass="math inline">\(k_n\)</span> 的值，对 <spanclass="math inline">\(i=1，2，…，n-1\)</span>，伪关键字 <spanclass="math inline">\(d_i\)</span> 表示所有在 <spanclass="math inline">\(k_i\)</span> 和 <spanclass="math inline">\(k_{i+1}\)</span> 之间的值。对每个伪关键字 <spanclass="math inline">\(d_i\)</span>，也都有一个概率 <spanclass="math inline">\(q_i\)</span> 表示对应的搜索频率。每个关键字 <spanclass="math inline">\(k_i\)</span> 是一个内部结点，而每个伪关键字 <spanclass="math inline">\(d_i\)</span>是一个叶结点。每次搜索要么成功（找到某个关键字 <spanclass="math inline">\(k_i\)</span>）要么失败（找到某个为关键字 <spanclass="math inline">\(d_i\)</span> ），因此有如下公式：<spanclass="math inline">\(\sum\limits^{n}_{i=1}p_{i}+\sum\limits^{n}_{i=0}q_{i}= 1\)</span></li><li><strong>最优二叉搜索树</strong>：对于一个给定的概率集合，我们希望构造一棵期望搜索代价最小的二叉搜索树，我们称之为<strong>最优二叉搜索树</strong>复杂度：<span class="math inline">\(\Theta(n^{3})\)</span></li><li>穷举法获得最优二叉搜索树的时间复杂度为 <spanclass="math inline">\(\Omega (\frac{4^{n}}{n^{\frac{3}{2}}})\)</span><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span>  </span><br>  <br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX (1000+10)  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXE 1000000000  </span><br><span class="hljs-type">double</span> p[MAX], q[MAX], w[MAX][MAX], e[MAX][MAX];  <br><span class="hljs-comment">// p,q为概率，表示其搜索频率</span><br><span class="hljs-comment">// e[i,j]为在包含关键字k_i,..,k_j的最优二叉搜索树中进行一次搜索的期望代价</span><br><span class="hljs-comment">// w[i,j]为在关键字k_i,..,k_j的期望之和</span><br><span class="hljs-type">int</span> root[MAX][MAX], n = <span class="hljs-number">5</span>;  <br>  <br><span class="hljs-type">void</span> <span class="hljs-title function_">optimalBST</span><span class="hljs-params">(<span class="hljs-type">double</span> *p,<span class="hljs-type">double</span> *q,<span class="hljs-type">int</span> n)</span>;  <br><span class="hljs-type">void</span> <span class="hljs-title function_">printRoot</span><span class="hljs-params">()</span>;  <br><span class="hljs-type">void</span> <span class="hljs-title function_">printOptimalBST</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j,<span class="hljs-type">int</span> r)</span>;  <br>  <br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);  <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)&#123;  <br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lf&quot;</span>, &amp;p[i]);  <br>    &#125;  <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;=n; i++)&#123;  <br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lf&quot;</span>, &amp;q[i]);  <br>    &#125;  <br>    optimalBST(p,q,n);  <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lf\n&quot;</span>, e[<span class="hljs-number">1</span>][n]);   <span class="hljs-comment">// 最小的cost  </span><br>    printRoot();    <span class="hljs-comment">// 输出所有的根  </span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;最优二叉树结构：best structure\n&quot;</span>);  <br>    printOptimalBST(<span class="hljs-number">1</span>,n,<span class="hljs-number">-1</span>);    <span class="hljs-comment">// 深度优先遍历输出最优二叉树的结构  </span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;  <br><span class="hljs-comment">//接受概率列表p和q及规模n作为输入，返回cost表e和根表root。  </span><br><span class="hljs-type">void</span> <span class="hljs-title function_">optimalBST</span><span class="hljs-params">(<span class="hljs-type">double</span> *p,<span class="hljs-type">double</span> *q,<span class="hljs-type">int</span> n)</span>&#123;  <br>    <span class="hljs-comment">// 初始化只包括虚拟键的子树  </span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n + <span class="hljs-number">1</span>;++i)&#123;  <br>        w[i][i - <span class="hljs-number">1</span>] = q[i - <span class="hljs-number">1</span>];  <br>        e[i][i - <span class="hljs-number">1</span>] = q[i - <span class="hljs-number">1</span>];  <br>    &#125;  <br>  <br>    <span class="hljs-comment">// 由上到下，由左到右逐步计算  </span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> len = <span class="hljs-number">1</span>;len &lt;= n;++len)&#123;  <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n - len + <span class="hljs-number">1</span>;++i)&#123;  <br>            <span class="hljs-type">int</span> j = i + len - <span class="hljs-number">1</span>;  <br>            e[i][j] = MAXE;  <br>            w[i][j] = w[i][j - <span class="hljs-number">1</span>] + p[j] + q[j];  <span class="hljs-comment">// i到j的期望之和</span><br>            <span class="hljs-comment">// 求取最小代价的子树的根  </span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = i;k &lt;= j;++k)&#123;  <span class="hljs-comment">// 遍历所有可能的根</span><br>            <span class="hljs-comment">// e[i,j] = p_k+(e[i,k-1]+w[i,k-1]) + (e[k+1,j]+w[k+1,j])</span><br>                <span class="hljs-comment">//        = e[i,k-1]+e[k+1,j] + w[i,j]</span><br>                <span class="hljs-type">double</span> temp = e[i][k - <span class="hljs-number">1</span>] + e[k + <span class="hljs-number">1</span>][j] + w[i][j];<br>                <span class="hljs-keyword">if</span> (temp &lt; e[i][j])&#123;  <br>                    e[i][j] = temp;  <br>                    root[i][j] = k;  <br>                &#125;  <br>            &#125;  <br>        &#125;  <br>    &#125;  <br>&#125;  <br>  <br><span class="hljs-comment">// 输出最优二叉查找树所有子树的根  </span><br><span class="hljs-type">void</span> <span class="hljs-title function_">printRoot</span><span class="hljs-params">()</span>&#123;  <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;各子树的根 roots\n&quot;</span>);  <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;++i)&#123;  <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j &lt;= n;++j)&#123;  <br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, root[i][j]);  <br>        &#125;  <br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);  <br>    &#125;  <br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);  <br>&#125;  <br>  <br><span class="hljs-comment">// 打印最优二叉查找树的结构  </span><br><span class="hljs-comment">// 打印出[i,j]的子树，它是根r的左子树和右子树  </span><br><span class="hljs-type">void</span> <span class="hljs-title function_">printOptimalBST</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j,<span class="hljs-type">int</span> r)</span>&#123;  <br>    <span class="hljs-type">int</span> rootChild = root[i][j];  <br>    <span class="hljs-keyword">if</span> (rootChild == root[<span class="hljs-number">1</span>][n])&#123;  <br>        <span class="hljs-comment">// 输出整棵树的根  </span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;k%d is root\n&quot;</span>, rootChild);  <br>        printOptimalBST(i,rootChild - <span class="hljs-number">1</span>,rootChild);  <br>        printOptimalBST(rootChild + <span class="hljs-number">1</span>,j,rootChild);  <br>        <span class="hljs-keyword">return</span>;  <br>    &#125;  <br>    <span class="hljs-keyword">if</span> (j &lt; i - <span class="hljs-number">1</span>)&#123;  <br>        <span class="hljs-keyword">return</span>;  <br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (j == i - <span class="hljs-number">1</span>)&#123;      <span class="hljs-comment">// 遇到虚拟键  </span><br>        <span class="hljs-keyword">if</span> (j &lt; r)&#123;  <br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;d%d is k%d&#x27;s left son\n&quot;</span>, j, r);  <br>        &#125;<span class="hljs-keyword">else</span> &#123;  <br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;d%d is k%d&#x27;s right son\n&quot;</span>, j, r);  <br>        &#125;  <br>        <span class="hljs-keyword">return</span>;  <br>    &#125;<span class="hljs-keyword">else</span>&#123;      <span class="hljs-comment">// 遇到内部结点  </span><br>        <span class="hljs-keyword">if</span> (rootChild &lt; r)&#123;  <br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;k%d is k%d&#x27;s left son\n&quot;</span>, rootChild, r);  <br>        &#125;<span class="hljs-keyword">else</span>&#123;  <br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;k%d is k%d&#x27;s right son\n&quot;</span>, rootChild, r);  <br>        &#125;  <br>    &#125;  <br>    printOptimalBST(i,rootChild - <span class="hljs-number">1</span>,rootChild);  <br>    printOptimalBST(rootChild + <span class="hljs-number">1</span>,j,rootChild);  <br>&#125;<br></code></pre></td></tr></table></figure> ##### 最小编辑距离 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX 2005  </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;  <br><span class="hljs-type">int</span> ans;  <br><span class="hljs-type">int</span> dp[<span class="hljs-number">2</span>][MAX];  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">min3</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c)</span> </span>&#123;  <br>    <span class="hljs-type">int</span> m = a;  <br>    <span class="hljs-keyword">if</span> (b &lt; m)  <br>        m = b;  <br>    <span class="hljs-keyword">if</span> (c &lt; m)  <br>        <span class="hljs-keyword">return</span> c;  <br>    <span class="hljs-keyword">return</span> m;  <br>&#125;  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minDistance</span><span class="hljs-params">(string word1, string word2)</span> </span>&#123;  <br>    <span class="hljs-type">int</span> l1 = word1.<span class="hljs-built_in">length</span>();  <br>    <span class="hljs-type">int</span> l2 = word2.<span class="hljs-built_in">length</span>();  <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= l2; j++)  <br>        dp[<span class="hljs-number">0</span>][j] = j;   <span class="hljs-comment">// 初始化dp[0]为从空字符串到word2的编辑距离  </span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= l1; i++) &#123;  <br>        <span class="hljs-comment">// dp[0][j]: word1前i-1个字符转化成word2的前j个字符的编辑距离  </span><br>        <span class="hljs-comment">// dp[1][j]: word1前i个字符转化成word2的前j个字符的编辑距离  </span><br>        dp[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = i;  <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= l2; j++)  <br>            <span class="hljs-keyword">if</span> (word1[i - <span class="hljs-number">1</span>] == word2[j - <span class="hljs-number">1</span>])  <br>                dp[<span class="hljs-number">1</span>][j] = dp[<span class="hljs-number">0</span>][j - <span class="hljs-number">1</span>];  <span class="hljs-comment">// 如果相同，和i-1到j-1的编辑距离一样  </span><br>            <span class="hljs-keyword">else</span> &#123;  <br>                dp[<span class="hljs-number">1</span>][j] = <span class="hljs-built_in">min3</span>(dp[<span class="hljs-number">0</span>][j - <span class="hljs-number">1</span>], dp[<span class="hljs-number">0</span>][j], dp[<span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]) + <span class="hljs-number">1</span>;  <br>                <span class="hljs-comment">// dp[0][j-1] 和i-1转成j-1一样，相当于word1换个字  </span><br>                <span class="hljs-comment">// dp[0][j] 和i-1转成j一样，相当于word1加个字  </span><br>                <span class="hljs-comment">// dp[1][j-1] 和i转成j-1一样，相当于word1删个字  </span><br>            &#125;  <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= l2; j++)  <br>            dp[<span class="hljs-number">0</span>][j] = dp[<span class="hljs-number">1</span>][j];  <br>    &#125;  <br>    <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][l2];  <br>&#125;  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;  <br>    string a;  <br>    string b;  <br>    cin &gt;&gt; a &gt;&gt; b;  <br>    cout &lt;&lt; <span class="hljs-built_in">minDistance</span>(a, b);  <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n%d\n&quot;</span>,ans);  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></td></tr></table></figure> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 进行了什么编辑操作</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX 2005  </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;  <br>  <br><span class="hljs-type">int</span> replace_count = <span class="hljs-number">0</span>;  <br><span class="hljs-type">int</span> delete_count = <span class="hljs-number">0</span>;  <br><span class="hljs-type">int</span> insert_count = <span class="hljs-number">0</span>;  <br><span class="hljs-type">int</span> dp[MAX][MAX] = &#123;&#125;;  <br>  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">min3</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c)</span> </span>&#123;  <br>    <span class="hljs-type">int</span> m = a;  <br>    <span class="hljs-keyword">if</span> (b &lt; m)  <br>        m = b;  <br>    <span class="hljs-keyword">if</span> (c &lt; m)  <br>        <span class="hljs-keyword">return</span> c;  <br>    <span class="hljs-keyword">return</span> m;  <br>&#125;  <br>  <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printOperations</span><span class="hljs-params">(string word1, string word2, <span class="hljs-type">int</span> dp[MAX][MAX])</span> </span>&#123;  <br>    <span class="hljs-type">int</span> i = word1.<span class="hljs-built_in">length</span>();  <br>    <span class="hljs-type">int</span> j = word2.<span class="hljs-built_in">length</span>();  <br>    <span class="hljs-keyword">while</span> (i &gt; <span class="hljs-number">0</span> || j &gt; <span class="hljs-number">0</span>) &#123;  <br>        <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; j &gt; <span class="hljs-number">0</span> &amp;&amp; word1[i - <span class="hljs-number">1</span>] == word2[j - <span class="hljs-number">1</span>]) &#123;  <br>            i--;  <br>            j--;  <br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (j &gt; <span class="hljs-number">0</span> &amp;&amp; (i == <span class="hljs-number">0</span> || dp[i][j] == dp[i][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>)) &#123;  <br>            insert_count++;  <br>            j--;  <br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; (j == <span class="hljs-number">0</span> || dp[i][j] == dp[i - <span class="hljs-number">1</span>][j] + <span class="hljs-number">1</span>)) &#123;  <br>            delete_count++;  <br>            i--;  <br>        &#125; <span class="hljs-keyword">else</span> &#123;  <br>            replace_count++;  <br>            i--;  <br>            j--;  <br>        &#125;  <br>    &#125;  <br>&#125;  <br>  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minDistance</span><span class="hljs-params">(string word1, string word2)</span> </span>&#123;  <br>    <span class="hljs-type">int</span> l1 = word1.<span class="hljs-built_in">length</span>();  <br>    <span class="hljs-type">int</span> l2 = word2.<span class="hljs-built_in">length</span>();  <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= l2; j++)  <br>        dp[<span class="hljs-number">0</span>][j] = j;  <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= l1; i++) &#123;  <br>        dp[i][<span class="hljs-number">0</span>] = i;  <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= l2; j++) &#123;  <br>            <span class="hljs-keyword">if</span> (word1[i - <span class="hljs-number">1</span>] == word2[j - <span class="hljs-number">1</span>])  <br>                dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];  <br>            <span class="hljs-keyword">else</span>  <br>                dp[i][j] = <span class="hljs-built_in">min3</span>(dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>], dp[i - <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>]) + <span class="hljs-number">1</span>;  <br>        &#125;  <br>    &#125;  <br>    <span class="hljs-built_in">printOperations</span>(word1, word2, dp);  <br>    <span class="hljs-keyword">return</span> dp[l1][l2];  <br>&#125;  <br>  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;  <br>    string a;  <br>    string b;  <br>    cin &gt;&gt; a &gt;&gt; b;  <br>    <span class="hljs-type">int</span> distance = <span class="hljs-built_in">minDistance</span>(a, b);  <br>    cout &lt;&lt; distance &lt;&lt; endl;  <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Replace: %d\n&quot;</span>, replace_count);  <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Delete: %d\n&quot;</span>, delete_count);  <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Insert: %d\n&quot;</span>, insert_count);  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h5id="最长单调子序列lislongest-increasing-subsequence">最长单调子序列/LIS（LongestIncreasing Subsequence）</h5><p><span class="math inline">\(O(n^2)\)</span> 做法 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">LIS</span><span class="hljs-params">()</span></span>&#123; <span class="hljs-comment">// a为目标数组 ans为最终得到的最长单调子序列的长度  </span><br>    <span class="hljs-type">int</span> ans=<span class="hljs-number">1</span>;  <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)&#123;<span class="hljs-comment">//枚举子序列的终点  </span><br>        dp[i]=<span class="hljs-number">1</span>;<span class="hljs-comment">// 初始化为1，长度最短为自身  </span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>; j&lt;i; j++)&#123;<span class="hljs-comment">//从头向终点检查每一个元素  </span><br>            <span class="hljs-keyword">if</span>(a[i]&gt;a[j])&#123;  <br>                dp[i]=<span class="hljs-built_in">max</span>(dp[i],dp[j]+<span class="hljs-number">1</span>);  <span class="hljs-comment">// 状态转移  </span><br>            &#125;  <br>        &#125;<br>        ans=<span class="hljs-built_in">max</span>(ans,dp[i]);  <span class="hljs-comment">// 比较每一个dp[i],最大值为答案  </span><br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;  <br>    <span class="hljs-keyword">while</span>(cin&gt;&gt;n)&#123;  <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)&#123; <span class="hljs-comment">// 下标从1开始  </span><br>            cin&gt;&gt;a[i];  <br>        &#125;  <br>        <span class="hljs-type">int</span> ans=<span class="hljs-built_in">LIS</span>();  <br>        cout&lt;&lt;ans&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;  <br>    &#125;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></td></tr></table></figure></p><p><span class="math inline">\(O(nlgn)\)</span> 做法 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 严格单调递增子列的长度  </span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lsrsa</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt; &amp;a)</span> </span>&#123;  <br>    vector&lt;<span class="hljs-type">int</span>&gt; sa;  <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x: a) &#123;  <br>        <span class="hljs-keyword">if</span> (sa.<span class="hljs-built_in">empty</span>() || x &gt; sa.<span class="hljs-built_in">back</span>())  <span class="hljs-comment">// 如果sa为空或x&gt;sa的最后一个元素  </span><br>            sa.<span class="hljs-built_in">push_back</span>(x);  <br>        <span class="hljs-keyword">else</span>  <br>            <span class="hljs-comment">// 如果x&lt;=sa的最后一个元素，二分查找找到sa中第一个&gt;=x的数，并用x替换它。  </span><br>            <span class="hljs-comment">// 实际上是在尝试找到更小的元素替代sa中的元素，这样后续可能可以添加更多的元素到sa中，从而形成一个更长的子序列。  </span><br>            *<span class="hljs-built_in">lower_bound</span>(sa.<span class="hljs-built_in">begin</span>(), sa.<span class="hljs-built_in">end</span>(), x) = x;  <br>    &#125;  <br>    <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>) sa.<span class="hljs-built_in">size</span>();  <br>&#125;  <br><span class="hljs-comment">// 单调不减子列的长度  </span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lrsa</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt; &amp;a)</span> </span>&#123;  <br>    vector&lt;<span class="hljs-type">int</span>&gt; sa;  <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x: a) &#123;  <br>        <span class="hljs-keyword">if</span> (sa.<span class="hljs-built_in">empty</span>() || x &gt;= sa.<span class="hljs-built_in">back</span>())  <span class="hljs-comment">// 如果sa为空或x&gt;=sa的最后一个元素  </span><br>            sa.<span class="hljs-built_in">push_back</span>(x);  <br>        <span class="hljs-keyword">else</span> <span class="hljs-comment">// 如果x&lt;sa的最后一个元素，二分查找找到sa中第一个&gt;x的数，并用x替换它。  </span><br>            *<span class="hljs-built_in">upper_bound</span>(sa.<span class="hljs-built_in">begin</span>(), sa.<span class="hljs-built_in">end</span>(), x) = x;  <br>    &#125;  <br>    <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>) sa.<span class="hljs-built_in">size</span>();  <br>&#125;<br></code></pre></td></tr></table></figure></p><h5 id="活动选择问题">活动选择问题</h5><p>假定有一个 <span class="math inline">\(n\)</span> 个活动的集合 <spanclass="math inline">\(S=\{a_{1}, a_{2},...,a_{n}\}\)</span>，这些活动使用同一个资源，而这个资源在某个时刻只能供一个活动使用，每个活动<span class="math inline">\(a_{i}\)</span> 都有一个开始时间 <spanclass="math inline">\(s_{i}\)</span> 和一个结束时间 <spanclass="math inline">\(f_{i}\)</span> ，其中 <spanclass="math inline">\(0\le s_{i}&lt;f_{i}&lt;∞\)</span>，如果被选中，任务 <span class="math inline">\(a_i\)</span>发生在半开时间区间 <span class="math inline">\([s_i,f_i)\)</span>期间。如果两个活动时间不重叠，则称他们是<strong>兼容的</strong>。在<strong>活动选择问题</strong>中，我们希望选出一个<strong>最大兼容活动集</strong>。假定活动已按结束时间的单调递增顺序排序。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX 100  </span><br>using namespace <span class="hljs-built_in">std</span>;  <br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">thing</span>&#123;</span>  <br>    <span class="hljs-type">int</span> startTime, endTime;  <br>&#125;;  <br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">thing</span> <span class="hljs-title">things</span>[<span class="hljs-title">MAX</span>], <span class="hljs-title">ans</span>[<span class="hljs-title">MAX</span>];</span> <span class="hljs-comment">// ans 参加的活动们  </span><br><span class="hljs-type">int</span> n;  <br><span class="hljs-type">void</span> <span class="hljs-title function_">Greedy_Activity_Selector</span><span class="hljs-params">()</span>&#123;  <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;0 &quot;</span>);  <br>    ans[<span class="hljs-number">0</span>] = things[<span class="hljs-number">0</span>];  <br>    <span class="hljs-type">int</span> lastId=<span class="hljs-number">0</span>, ansNum = <span class="hljs-number">1</span>;   <span class="hljs-comment">// 当前的最后一个活动的截止时间 当前已经参加的活动数量  </span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>; i&lt;=n; i++)&#123;  <br>        <span class="hljs-keyword">if</span>(things[i].startTime &gt;= things[lastId].endTime)&#123;  <br>            ans[ansNum] = things[i];  <br>            ansNum++;  <br>            lastId = i;  <br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, i);  <br>        &#125;  <br>    &#125;  <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n%d&quot;</span>, ansNum);  <br>&#125;  <br><span class="hljs-type">int</span> <span class="hljs-title function_">cmp</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *a, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *b)</span>&#123;  <br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">thing</span> *<span class="hljs-title">pa</span> =</span> (<span class="hljs-keyword">struct</span> thing *)a;  <br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">thing</span> *<span class="hljs-title">pb</span> =</span> (<span class="hljs-keyword">struct</span> thing *)b;  <br>    <span class="hljs-keyword">if</span>(pa-&gt;endTime &lt; pb-&gt;endTime)&#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;  <br>    &#125;<span class="hljs-keyword">else</span>&#123;  <br>        <span class="hljs-keyword">if</span>(pa-&gt;startTime &lt; pb-&gt;startTime)&#123;  <br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;  <br>        &#125;<span class="hljs-keyword">else</span>&#123;  <br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;  <br>        &#125;  <br>    &#125;  <br>&#125;  <br>  <br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);  <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;n; i++)&#123;  <br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;things[i].startTime);  <br>    &#125;  <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;n; i++)&#123;  <br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;things[i].endTime);  <br>    &#125;  <br>    qsort(things, n, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> thing), cmp);  <span class="hljs-comment">// 按活动结束时间升序排序  </span><br>    Greedy_Activity_Selector();  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></td></tr></table></figure></p><h5 id="背包">0-1背包</h5><p>一个正在抢劫商店的小偷发现了 <span class="math inline">\(n\)</span>个商品，第 <span class="math inline">\(i\)</span> 个商品价值 <spanclass="math inline">\(v_i\)</span> 美元，重 <spanclass="math inline">\(w_i\)</span> 磅，<spanclass="math inline">\(v_{i}\)</span> 和 <spanclass="math inline">\(w_i\)</span>都是整数。这个小偷希望拿走价值尽量高的商品，但他的背包最多能容纳 <spanclass="math inline">\(W\)</span> 磅重的商品，<spanclass="math inline">\(W\)</span> 是一个整数。他应该拿哪些商品呢? ######二维dp <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span>  </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;  <br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>;  <br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MaxW = <span class="hljs-number">10000</span>;  <br><span class="hljs-type">int</span> n, W, v[N], w[N], f[N][MaxW];  <br>  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;  <br>    cin &gt;&gt; n &gt;&gt; W;  <span class="hljs-comment">// n物品数量 W最大重量  </span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i)  <br>        cin &gt;&gt; v[i] &gt;&gt; w[i];    <span class="hljs-comment">// v价值 w重量  </span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)&#123;   <span class="hljs-comment">// 遍历所有物品  </span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= W; ++j)&#123;   <span class="hljs-comment">// 重量从0到最大重量  </span><br>            f[i][j] = f[i - <span class="hljs-number">1</span>][j]; <span class="hljs-comment">// 不选择当前物品时的价值，直接继承上一个状态的价值  </span><br>            <span class="hljs-comment">// 如果当前背包容量可以放下当前物品，则尝试放入，更新最大价值  </span><br>            <span class="hljs-keyword">if</span> (j &gt;= w[i]) f[i][j] = <span class="hljs-built_in">max</span>(f[i][j], f[i - <span class="hljs-number">1</span>][j - w[i]] + v[i]);  <br>        &#125;  <br>    &#125;  <br>    cout &lt;&lt; f[n][W] &lt;&lt; endl;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></td></tr></table></figure> ###### 一维dp <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span>  </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;  <br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>;  <br><span class="hljs-type">int</span> n, W, v[N], w[N], f[N];  <br>  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;  <br>    cin &gt;&gt; n &gt;&gt; W;  <span class="hljs-comment">// n物品数量 W最大重量    </span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i)  <br>        cin &gt;&gt; v[i] &gt;&gt; w[i];  <span class="hljs-comment">// v价值 w重量    </span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i)&#123; <span class="hljs-comment">// 遍历所有物品  </span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = W; j &gt;= w[i]; j--)&#123; <span class="hljs-comment">// 逆序遍历背包容量  </span><br>            <span class="hljs-comment">// 更新f[j]，即考虑放入当前物品i时的最大价值  </span><br>            f[j] = <span class="hljs-built_in">max</span>(f[j], f[j - w[i]] + v[i]);  <br>        &#125;  <br>    &#125;  <br>    cout &lt;&lt; f[W] &lt;&lt; endl;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></td></tr></table></figure> ######01背包变种，一维dp 同样的 <span class="math inline">\(w, v,W\)</span>，但背包容量 <span class="math inline">\(W\)</span>极大，无法开数组 <spanclass="math inline">\(f[0..W]\)</span>，求背包能装下的最大价值<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span>  </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;  <br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 510  </span><br><span class="hljs-type">long</span> <span class="hljs-type">long</span> n, W, v[N], w[N], f[N*N], sumV;  <br>  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;  <br>    <span class="hljs-built_in">memset</span>(f, <span class="hljs-number">0x3f</span>, <span class="hljs-built_in">sizeof</span>(f));  <br>    f[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;  <br>    cin &gt;&gt; n &gt;&gt; W;  <span class="hljs-comment">// n个物品 W最大重量  </span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;  <br>        cin &gt;&gt; w[i] &gt;&gt; v[i];    <span class="hljs-comment">// w重量 v价值    </span><br>sumV += v[i];   <span class="hljs-comment">// 最大价值    </span><br>&#125;  <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i)&#123; <span class="hljs-comment">// 遍历所有物品    </span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=sumV; j&gt;=v[i]; j--)&#123;  <span class="hljs-comment">// 从最大价值开始，只有在j&gt;=v[i]的情况下才有可能装当前的物品，否则f保持不变    </span><br>f[j] = <span class="hljs-built_in">min</span>(f[j], f[j-v[i]]+w[i]);   <span class="hljs-comment">// f[j]表示包内物品价值为j时的最小重量    </span><br>&#125;  <br>    &#125;  <br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> ans = <span class="hljs-number">0</span>;  <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;=sumV; j++)&#123; <span class="hljs-comment">// 从价值为0到最大价值    </span><br><span class="hljs-keyword">if</span>(f[j] &lt;= W)&#123;  <span class="hljs-comment">// 如果包内重量小于W    </span><br>ans = j;    <span class="hljs-comment">// 更新ans    </span><br>&#125;  <br>    &#125;  <br>    cout &lt;&lt; ans &lt;&lt; endl;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></td></tr></table></figure></p><h5 id="完全背包">完全背包</h5><p>一个正在抢劫商店的小偷发现了 <span class="math inline">\(n\)</span>种商品，第 <span class="math inline">\(i\)</span> 种商品价值 <spanclass="math inline">\(v_i\)</span> 美元，重 <spanclass="math inline">\(w_i\)</span> 磅，<spanclass="math inline">\(v_{i}\)</span> 和 <spanclass="math inline">\(w_i\)</span>都是整数，<strong>每种商品都有无限个</strong>。这个小偷希望拿走价值尽量高的商品，但他的背包最多能容纳<span class="math inline">\(W\)</span> 磅重的商品，<spanclass="math inline">\(W\)</span> 是一个整数。他应该拿哪些商品呢?<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span>  </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;  <br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>;  <br><span class="hljs-type">int</span> n, W, v[N], w[N], f[N];  <br>  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;  <br>    cin &gt;&gt; n &gt;&gt; W;      <span class="hljs-comment">// 物品种类n 最大容量W  </span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i)  <br>        cin &gt;&gt; v[i] &gt;&gt; w[i];    <span class="hljs-comment">// 价值v 体积w  </span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i)&#123; <span class="hljs-comment">// 遍历所有物品  </span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = v[i]; j &lt;= W; j--)&#123; <span class="hljs-comment">// 顺序遍历背包容量  </span><br>            <span class="hljs-comment">// 更新f[j]，即考虑放入当前物品i时的最大价值  </span><br>            f[j] = <span class="hljs-built_in">max</span>(f[j], f[j - v[i]] + w[i]);  <br>        &#125;  <br>    &#125;  <br>    cout &lt;&lt; f[W] &lt;&lt; endl;  <br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></td></tr></table></figure> ##### 分组背包物品被分成若干组，<strong>每组中的物品只能选择一个</strong>。也就是说，从每组物品中，你只能选择一个或者不选，但不能选择多个<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span>  </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;  <br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;  <br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX = <span class="hljs-number">1005</span>;  <br><span class="hljs-keyword">struct</span> &#123;  <br>    <span class="hljs-type">int</span> cnt;  <br>    ll ID[MAX];  <br>&#125; group[MAX]; <span class="hljs-comment">//用一个结构体来存储每一组的物品编号  </span><br>ll dp[MAX];     <span class="hljs-comment">// 最大价值  </span><br>ll val[MAX];    <span class="hljs-comment">// 每个物品的价值  </span><br>ll weight[MAX]; <span class="hljs-comment">// 每个物品的重量  </span><br>  <br><span class="hljs-function">ll <span class="hljs-title">group_bag</span><span class="hljs-params">(<span class="hljs-type">int</span> cap, <span class="hljs-type">int</span> max_group)</span></span>;  <br>  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;  <br>    <span class="hljs-type">int</span> n, W;  <br>    cin &gt;&gt; W &gt;&gt; n;  <span class="hljs-comment">//  n表示物品数量，W表示背包容量  </span><br>    <span class="hljs-type">int</span> a, b, k, max_group = <span class="hljs-number">0</span>;  <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;  <br>        cin &gt;&gt; a &gt;&gt; b &gt;&gt; k; <span class="hljs-comment">// a重量  b价值  k物品所在的组号  </span><br>        weight[i] = a;  <br>        val[i] = b;  <br>        group[k].ID[group[k].cnt++] = i;  <br>        max_group = <span class="hljs-built_in">max</span>(max_group, k);  <br>    &#125;  <br>    cout &lt;&lt; <span class="hljs-built_in">group_bag</span>(W, max_group);  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;  <br>  <br><span class="hljs-function">ll <span class="hljs-title">group_bag</span><span class="hljs-params">(<span class="hljs-type">int</span> W, <span class="hljs-type">int</span> max_group)</span> </span>&#123;  <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= max_group; i++) <span class="hljs-comment">// 第一层循环，遍历所有组  </span><br>        <span class="hljs-keyword">for</span> (ll j = W; j &gt;= <span class="hljs-number">0</span>; j--) <span class="hljs-comment">// 第二层循环，从背包容量W到0倒序遍历  </span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; group[i].cnt; k++) <span class="hljs-comment">// 第三层循环，遍历当前组内的所有物品  </span><br>                <span class="hljs-keyword">if</span> (j &gt;= weight[group[i].ID[k]]) <span class="hljs-comment">// 如果当前物品可以放入背包  </span><br>                    <span class="hljs-comment">// 更新dp数组，选择放入或不放入当前物品，取最大值  </span><br>                    dp[j] = <span class="hljs-built_in">max</span>(dp[j],dp[j - weight[group[i].ID[k]]] + val[group[i].ID[k]]);  <br>    <span class="hljs-keyword">return</span> dp[W];  <br>&#125;<br></code></pre></td></tr></table></figure> ##### 多重背包 一个正在抢劫商店的小偷发现了 <spanclass="math inline">\(n\)</span> 种商品，第 <spanclass="math inline">\(i\)</span> 种商品价值 <spanclass="math inline">\(v_i\)</span> 美元，重 <spanclass="math inline">\(w_i\)</span> 磅，<spanclass="math inline">\(v_{i}\)</span> 和 <spanclass="math inline">\(w_i\)</span> 都是整数，<strong>每种商品有 <spanclass="math inline">\(M_{i}\)</span>个</strong>。这个小偷希望拿走价值尽量高的商品，但他的背包最多能容纳<span class="math inline">\(W\)</span> 磅重的商品，<spanclass="math inline">\(W\)</span> 是一个整数。他应该拿哪些商品呢?<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//二进制优化  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span>  </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;  <br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAXN=<span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;  <br><span class="hljs-type">int</span> n,W;  <br><span class="hljs-type">int</span> v[MAXN],w[MAXN];  <br><span class="hljs-type">int</span> f[MAXN];  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;  <br>    cin &gt;&gt; n &gt;&gt; W;  <span class="hljs-comment">// 物品个数n和最大重量W    </span><br><span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;    <span class="hljs-comment">// 记录二进制合成后的物体数</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>,a,b,s; i&lt;=n; i++)   &#123;  <br>        cin&gt;&gt; a &gt;&gt; b &gt;&gt; s;   <span class="hljs-comment">// 单个价值a 单个重量b 数量s</span><br><span class="hljs-type">int</span> k = <span class="hljs-number">1</span>;  <br>        <span class="hljs-keyword">while</span>(k &lt;= s)&#123; <span class="hljs-comment">// 将每个物品都按照二进制合成    </span><br>v[++cnt] = k*a;  <br>            w[cnt] = k*b;  <br>            s -= k;  <br>            k *= <span class="hljs-number">2</span>;  <br>        &#125;  <br>        <span class="hljs-keyword">if</span>(s)&#123;  <br>            v[++cnt] = s*a;  <br>            w[cnt] = s*b;  <br>        &#125;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=cnt; i++) <span class="hljs-comment">// 01背包     </span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=W; j&gt;=v[i]; j--)  <br>            f[j] = <span class="hljs-built_in">max</span>(f[j], f[j-v[i]]+w[i]);  <br>    cout &lt;&lt; f[W];  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></td></tr></table></figure></p><h5 id="分数背包部分背包">分数背包（部分背包）</h5><p>一个正在抢劫商店的小偷发现了 <span class="math inline">\(n\)</span>个商品，第 <span class="math inline">\(i\)</span> 个商品价值 <spanclass="math inline">\(v_i\)</span> 美元，重 <spanclass="math inline">\(w_i\)</span> 磅，<spanclass="math inline">\(v_{i}\)</span> 和 <spanclass="math inline">\(w_i\)</span>都是整数，对每个商品，小偷<strong>可以拿走其一部分</strong>，而不是只能做出二元(0-1)选择。。这个小偷希望拿走价值尽量高的商品，但他的背包最多能容纳<span class="math inline">\(W\)</span> 磅重的商品，<spanclass="math inline">\(W\)</span> 是一个整数。他应该拿哪些商品呢?<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span>  </span><br>  <br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">coin</span>&#123;</span>  <br>    <span class="hljs-type">double</span> w;<span class="hljs-comment">// 重量  </span><br>    <span class="hljs-type">double</span> v;<span class="hljs-comment">// value  </span><br>    <span class="hljs-type">double</span> rou;  <br>&#125;;  <br>  <br><span class="hljs-type">int</span> <span class="hljs-title function_">cmp</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *a, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *b)</span>&#123;  <br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">coin</span> *<span class="hljs-title">pa</span> =</span> (<span class="hljs-keyword">struct</span> coin *)a;  <br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">coin</span> *<span class="hljs-title">pb</span> =</span> (<span class="hljs-keyword">struct</span> coin *)b;  <br>    <span class="hljs-keyword">if</span>(pa-&gt;rou &gt; pb-&gt;rou)&#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;  <br>    &#125;<span class="hljs-keyword">else</span>&#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;  <br>    &#125;  <br>&#125;  <br>  <br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-type">int</span> n;      <span class="hljs-comment">// 物品个数n  </span><br>    <span class="hljs-type">double</span> W;   <span class="hljs-comment">// 最大容量W  </span><br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%lf&quot;</span>, &amp;n, &amp;W);  <br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">coin</span> <span class="hljs-title">gold</span>[110]=</span>&#123;&#125;;  <br>  <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;n; i++)&#123;  <br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lf%lf&quot;</span>, &amp;gold[i].w, &amp;gold[i].v);  <br>        gold[i].rou = gold[i].v / gold[i].w;  <br>    &#125;  <br>    qsort(gold, n, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> coin), cmp);  <br>  <br>    <span class="hljs-type">double</span> ans=<span class="hljs-number">0</span>;  <br>    <span class="hljs-type">int</span> now=<span class="hljs-number">0</span>;  <br>    <span class="hljs-keyword">while</span>(W &gt;= <span class="hljs-number">0</span>)&#123;  <br>        <span class="hljs-keyword">if</span>(now == n)&#123;   <span class="hljs-comment">// 遍历完所有物品  </span><br>            <span class="hljs-keyword">break</span>;  <br>        &#125;  <br>        <span class="hljs-keyword">if</span>(gold[now].w &lt; W)&#123;    <span class="hljs-comment">// 放得下整个物品now  </span><br>            W -= gold[now].w;  <br>            ans += gold[now].v;  <br>        &#125;<span class="hljs-keyword">else</span>&#123;      <span class="hljs-comment">// 只能放部分  </span><br>            ans += gold[now].v * (W/gold[now].w);  <br>            W = <span class="hljs-number">0</span>;  <br>            <span class="hljs-keyword">break</span>;  <br>        &#125;  <br>        now++;  <br>    &#125;  <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.2lf&quot;</span>, ans);  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></td></tr></table></figure></p><h5 id="赫夫曼编码">赫夫曼编码</h5><p>考虑一种<strong>二进制字符编码</strong>，其中每个字符用一个唯一的二进制串表示，称为<strong>码字</strong>。如果使用<strong>定长编码</strong>，需要用3位来表示6个字符:a=000，b=001，…，f=101。这种方法需要300000个二进制位来编码文件。是否有更好的编码方案呢?时间复杂度 <span class="math inline">\(O(nlgn)\)</span><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX 100  </span><br><span class="hljs-comment">// 结构体</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> &#123;</span>  <br>    <span class="hljs-type">char</span> data;  <br>    <span class="hljs-type">int</span> frequency;  <br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>* <span class="hljs-title">left</span>;</span>  <br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>* <span class="hljs-title">right</span>;</span>  <br>&#125; Node;  <br>  <br><span class="hljs-comment">// 创建新节点的函数 return结构体指针类型 data结构体的字符 frequency字符的出现频率</span><br>Node* <span class="hljs-title function_">createNode</span><span class="hljs-params">(<span class="hljs-type">char</span> data, <span class="hljs-type">int</span> frequency)</span> &#123;  <br>    Node* node = (Node*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Node));  <br>    node-&gt;data = data;  <br>    node-&gt;frequency = frequency;  <br>    node-&gt;left = <span class="hljs-literal">NULL</span>;  <br>    node-&gt;right = <span class="hljs-literal">NULL</span>;  <br>    <span class="hljs-keyword">return</span> node;  <br>&#125;  <br>  <br><span class="hljs-comment">// Huffman构建函数</span><br>Node* <span class="hljs-title function_">buildHuffmanTree</span><span class="hljs-params">(<span class="hljs-type">char</span>* inputText)</span> &#123;  <br>    <span class="hljs-type">int</span> charCount[<span class="hljs-number">256</span>] = &#123;&#125;;  <br>    <span class="hljs-type">int</span> length = <span class="hljs-built_in">strlen</span>(inputText);  <br>    <span class="hljs-type">int</span> i;  <br>  <br>    <span class="hljs-comment">// 统计ascii码为inputText[i]的字符的出现次数    </span><br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; length; i++) &#123;  <br>        charCount[(<span class="hljs-type">int</span>)inputText[i]]++;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">// 创建叶子结点    </span><br>Node* nodes[<span class="hljs-number">256</span>];  <br>    <span class="hljs-type">int</span> nodeCount = <span class="hljs-number">0</span>;  <br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">256</span>; i++) &#123;  <br>        <span class="hljs-keyword">if</span> (charCount[i] &gt; <span class="hljs-number">0</span>) &#123;  <br>            nodes[nodeCount] = createNode((<span class="hljs-type">char</span>)i, charCount[i]);  <br>            nodeCount++;  <br>        &#125;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">// 依次合并叶子结点    </span><br><span class="hljs-keyword">while</span> (nodeCount &gt; <span class="hljs-number">1</span>) &#123;  <br>        <span class="hljs-type">int</span> minFrequency1 = length + <span class="hljs-number">1</span>;     <span class="hljs-comment">// 当前频率最小的    </span><br><span class="hljs-type">int</span> minFrequency2 = length + <span class="hljs-number">1</span>;     <span class="hljs-comment">// 当前频率次小的    </span><br><span class="hljs-type">int</span> index1 = <span class="hljs-number">-1</span>;  <br>        <span class="hljs-type">int</span> index2 = <span class="hljs-number">-1</span>;  <br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; nodeCount; i++) &#123;   <span class="hljs-comment">// 获得minFrequency1和minFrequency2以及index1 index2    </span><br><span class="hljs-keyword">if</span> (nodes[i]-&gt;frequency &lt; minFrequency1) &#123;  <br>                minFrequency2 = minFrequency1;  <br>                index2 = index1;  <br>                minFrequency1 = nodes[i]-&gt;frequency;  <br>                index1 = i;  <br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nodes[i]-&gt;frequency &lt; minFrequency2) &#123;  <br>                minFrequency2 = nodes[i]-&gt;frequency;  <br>                index2 = i;  <br>            &#125;  <br>        &#125;  <br>  <br>        <span class="hljs-comment">// 把最小的和次小的构建为一个树    </span><br>Node* parent = createNode(<span class="hljs-string">&#x27;\0&#x27;</span>, nodes[index1]-&gt;frequency + nodes[index2]-&gt;frequency);  <br>        parent-&gt;left = nodes[index1];  <br>        parent-&gt;right = nodes[index2];  <br>  <br>        <span class="hljs-comment">// parent放进去，原孩子删掉，最后一个往前移，node数量--    </span><br>nodes[index2] = parent;  <br>        nodes[index1] = nodes[nodeCount - <span class="hljs-number">1</span>];  <br>        nodeCount--;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">return</span> nodes[<span class="hljs-number">0</span>];  <br>&#125;  <br>  <br><span class="hljs-comment">// 编写huffman编码表及打印  </span><br><span class="hljs-type">void</span> <span class="hljs-title function_">printHuffmanCodes</span><span class="hljs-params">(Node* root, <span class="hljs-type">int</span> code[], <span class="hljs-type">int</span> top, <span class="hljs-type">int</span> codeTable[][<span class="hljs-number">256</span>], <span class="hljs-type">int</span> codeLengths[])</span> &#123;  <br>    <span class="hljs-comment">// root根结点 code当前字符的huffman函数 top当前字符的树的深度/huffman编码长度   </span><br><span class="hljs-comment">// codeTable所有字符的huffman编码 codeLengths 所有字符的huffman编码长度  </span><br>    <span class="hljs-keyword">if</span> (root-&gt;left) &#123;   <span class="hljs-comment">// 有左子结点    </span><br>code[top] = <span class="hljs-number">0</span>;  <br>        printHuffmanCodes(root-&gt;left, code, top + <span class="hljs-number">1</span>, codeTable, codeLengths);  <br>    &#125;  <br>    <span class="hljs-keyword">if</span> (root-&gt;right) &#123;  <span class="hljs-comment">// 有右子节点    </span><br>code[top] = <span class="hljs-number">1</span>;  <br>        printHuffmanCodes(root-&gt;right, code, top + <span class="hljs-number">1</span>, codeTable, codeLengths);  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">if</span> (root-&gt;left == <span class="hljs-literal">NULL</span> &amp;&amp; root-&gt;right == <span class="hljs-literal">NULL</span>) &#123;    <span class="hljs-comment">// 是叶子节点    </span><br>codeLengths[(<span class="hljs-type">int</span>)root-&gt;data] = top;     <span class="hljs-comment">// 字符root-&gt;data的编码长度为top    </span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c:&quot;</span>,root-&gt;data);       <span class="hljs-comment">// 输出字符root-&gt;data    </span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; top; i++) &#123;         <span class="hljs-comment">// 输出字符root-&gt;data的编码    </span><br>codeTable[(<span class="hljs-type">int</span>)root-&gt;data][i] = code[i];  <br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,code[i]);  <br>        &#125;  <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);  <br>    &#125;  <br>&#125;  <br>  <br><span class="hljs-comment">// 编码函数  </span><br><span class="hljs-type">void</span> <span class="hljs-title function_">encodeText</span><span class="hljs-params">(Node* root, <span class="hljs-type">char</span>* inputText, <span class="hljs-type">char</span> encodedText[], <span class="hljs-type">int</span> codeTable[][<span class="hljs-number">256</span>], <span class="hljs-type">int</span> codeLengths[])</span>&#123;  <br>    <span class="hljs-comment">// 翻译inputText为huffman编码encodedText  </span><br>    <span class="hljs-type">int</span> length = <span class="hljs-built_in">strlen</span>(inputText);  <br>    <span class="hljs-type">int</span> i, j;  <br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; length; i++) &#123;  <br>        <span class="hljs-type">char</span> character = inputText[i];      <span class="hljs-comment">// 当前处理的字符    </span><br><span class="hljs-type">int</span> length = codeLengths[(<span class="hljs-type">int</span>)character];   <span class="hljs-comment">// 字符转化成huffman编码后的长度    </span><br><span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; length; j++) &#123;  <br>            encodedText[<span class="hljs-built_in">strlen</span>(encodedText)] = codeTable[(<span class="hljs-type">int</span>)character][j] + <span class="hljs-string">&#x27;0&#x27;</span>;  <br>        &#125;  <br>    &#125;  <br>&#125;  <br>  <br><span class="hljs-comment">// 解码函数  </span><br><span class="hljs-type">void</span> <span class="hljs-title function_">decodeText</span><span class="hljs-params">(Node* root, <span class="hljs-type">char</span>* encodedText, <span class="hljs-type">char</span>* decodedText)</span> &#123;  <br>    <span class="hljs-comment">// 翻译huffman编码encodedText为decodedText  </span><br>    <span class="hljs-type">int</span> length = <span class="hljs-built_in">strlen</span>(encodedText);  <br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;  <br>  <br>    <span class="hljs-keyword">while</span> (i &lt; length) &#123;  <br>        Node* current = root;  <br>        <span class="hljs-keyword">while</span> (current-&gt;left != <span class="hljs-literal">NULL</span> || current-&gt;right != <span class="hljs-literal">NULL</span>) &#123;  <br>            <span class="hljs-keyword">if</span> (encodedText[i] == <span class="hljs-string">&#x27;0&#x27;</span>) &#123;  <br>                current = current-&gt;left;  <br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (encodedText[i] == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;  <br>                current = current-&gt;right;  <br>            &#125;  <br>            i++;  <br>        &#125;  <br>        decodedText[<span class="hljs-built_in">strlen</span>(decodedText)] = current-&gt;data;  <br>    &#125;  <br>    decodedText[<span class="hljs-built_in">strlen</span>(decodedText)] = <span class="hljs-string">&#x27;\0&#x27;</span>;  <br>&#125;  <br>  <br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-type">char</span> inputText[MAX] = <span class="hljs-string">&quot;&quot;</span>;  <br>    gets(inputText);  <br>    Node* root = buildHuffmanTree(inputText);   <span class="hljs-comment">// 建树  </span><br>    <span class="hljs-type">int</span> code[<span class="hljs-number">256</span>];  <span class="hljs-comment">// 当前字符的huffman编码  </span><br>    <span class="hljs-type">int</span> top = <span class="hljs-number">0</span>;  <br>  <br>    <span class="hljs-type">int</span> codeTable[<span class="hljs-number">256</span>][<span class="hljs-number">256</span>] = &#123;<span class="hljs-number">0</span>&#125;;  <span class="hljs-comment">// 所有字符的huffman编码  </span><br>    <span class="hljs-type">int</span> codeLengths[<span class="hljs-number">256</span>] = &#123;<span class="hljs-number">0</span>&#125;;     <span class="hljs-comment">// 所有字符的编码长度  </span><br>  <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Huffman Codes:\n&quot;</span>);  <br>    printHuffmanCodes(root, code, top, codeTable, codeLengths);  <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);  <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;InputText:\n%s\n\n&quot;</span>,inputText);  <br>  <br>    <span class="hljs-comment">// 字符转huffman    </span><br><span class="hljs-type">char</span> encodedText[<span class="hljs-number">1000</span>] = <span class="hljs-string">&quot;&quot;</span>;  <br>    encodeText(root, inputText, encodedText, codeTable, codeLengths);  <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Encoded Text: \n%s\n\n&quot;</span>, encodedText);  <br>  <br>    <span class="hljs-comment">// huffman转字符    </span><br><span class="hljs-type">char</span> decodedText[<span class="hljs-number">1000</span>] = <span class="hljs-string">&quot;&quot;</span>;  <br>    decodeText(root, encodedText, decodedText);  <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Decoded Text: \n%s\n\n&quot;</span>, decodedText);  <br>  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></td></tr></table></figure></p><h5 id="链式前向星">链式前向星</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span>&#123;  <br>    <span class="hljs-type">int</span> to, w, next; <span class="hljs-comment">//终点，权值，前驱  </span><br>&#125; e[E_MAX];  <br><span class="hljs-type">int</span> cnt_E = <span class="hljs-number">0</span>;  <br><span class="hljs-type">int</span> head[V_MAX]; <span class="hljs-comment">//需要先初始化为-1    </span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">intList</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>&#123;  <br><span class="hljs-built_in">memset</span>(head, <span class="hljs-number">-1</span>, <span class="hljs-built_in">sizeof</span>(head));  <br>&#125;  <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addEdge</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> w)</span></span>&#123;  <br>e[cnt_E].to = y; <span class="hljs-comment">//保存终点    </span><br>e[cnt_E].next = head[x]; <span class="hljs-comment">//添加链接    </span><br>head[x] = cnt_E++; <span class="hljs-comment">//更新表头</span><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="bfs广度优先搜索">BFS广度优先搜索</h5><h6 id="邻接矩阵-1">邻接矩阵</h6><p>时间复杂度 <span class="math inline">\(O(n^2)\)</span><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MaxV (10000+10)  </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;  <br><span class="hljs-type">int</span> G[MaxV][MaxV];  <span class="hljs-comment">// 邻接矩阵  </span><br><span class="hljs-type">bool</span> visited[MaxV];    <br><span class="hljs-type">int</span> last[MaxV], d[MaxV];  <span class="hljs-comment">// last[i]点i的前驱结点 d[i]点i的深度  </span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">BFS</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> n)</span></span>;    <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printPath</span><span class="hljs-params">(<span class="hljs-type">int</span> s, <span class="hljs-type">int</span> v)</span></span>;    <br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <br><span class="hljs-type">int</span> n, m;    <br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);  <span class="hljs-comment">// n顶点数 m边数  </span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;m; i++)&#123;    <br><span class="hljs-type">int</span> u, v;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;u, &amp;v);    <br>        G[u][v] = <span class="hljs-number">1</span>;    <br>    &#125;<br><span class="hljs-built_in">BFS</span>(<span class="hljs-number">1</span>, n);    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>; i&lt;=n; i++)&#123; <span class="hljs-comment">// 如果是非连通图，该循环保证每个极大连通子图中的顶点都能被遍历到</span><br><span class="hljs-keyword">if</span>(!visited[i])<br><span class="hljs-built_in">BFS</span>(i,n);<br>    &#125;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);    <br>    <span class="hljs-built_in">printPath</span>(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>);  <span class="hljs-comment">// 打印从点1到点4的路径  </span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, d[<span class="hljs-number">4</span>]);  <span class="hljs-comment">// 打印点4的高度  </span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <br>&#125;    <br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">BFS</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> n)</span></span>&#123;  <span class="hljs-comment">// i起始顶点 n顶点总数  </span><br>    queue&lt;<span class="hljs-type">int</span>&gt; Q;   <span class="hljs-comment">// 待访问的顶点  </span><br>    Q.<span class="hljs-built_in">push</span>(i);  <span class="hljs-comment">// 当前节点    </span><br>visited[i] = <span class="hljs-literal">true</span>;  <span class="hljs-comment">// 当前节点被visited过了</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;v%d-&gt;&quot;</span>, i);<br>    <br>    <span class="hljs-keyword">while</span>(!Q.<span class="hljs-built_in">empty</span>())&#123;   <br><span class="hljs-type">int</span> k = Q.<span class="hljs-built_in">front</span>();<br>        Q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>; j&lt;=n; j++)&#123;<br><span class="hljs-keyword">if</span>(G[k][j] == <span class="hljs-number">1</span> &amp;&amp; !visited[j])&#123;<br>Q.<span class="hljs-built_in">push</span>(j);  <span class="hljs-comment">// 当前节点</span><br>visited[j] = <span class="hljs-literal">true</span>;  <span class="hljs-comment">// 当前节点被visited过了</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;v%d-&gt;&quot;</span>, j);<br>                d[j] = d[k]+<span class="hljs-number">1</span>;<br>                last[j] = k;<br>            &#125;<br>&#125;<br>&#125;  <br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printPath</span><span class="hljs-params">(<span class="hljs-type">int</span> s, <span class="hljs-type">int</span> v)</span></span>&#123;  <span class="hljs-comment">// s起始顶点 v终点  </span><br>    <span class="hljs-keyword">if</span>(v == s)&#123;    <br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, s);<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(last[v] == <span class="hljs-number">0</span>)&#123;    <br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;No path from %d to %d exists&quot;</span>, s, v);<br>    &#125;<span class="hljs-keyword">else</span>&#123;    <br><span class="hljs-built_in">printPath</span>(s, last[v]);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, v);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><h6 id="邻接表">邻接表</h6><p>时间复杂度 <span class="math inline">\(O(n+e)\)</span><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MaxV (10000+10)  </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;  <br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span>&#123;       <span class="hljs-comment">// 定义边结点类型  </span><br>    <span class="hljs-type">int</span> adjvex;  <span class="hljs-comment">//指向的点  </span><br>    <span class="hljs-type">int</span> weight;  <span class="hljs-comment">//边的权重  </span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span> *next;  <span class="hljs-comment">//相邻的边  </span><br>&#125;ELink;  <br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">ver</span>&#123;       <span class="hljs-comment">// 定义顶点结点类型  </span><br>    <span class="hljs-type">int</span> vertex;  <span class="hljs-comment">//顶点id  </span><br>    ELink* link;  <span class="hljs-comment">//从此顶点出发的边  </span><br>&#125;VLink;  <br>  <br>VLink G[MaxV];  <br><span class="hljs-type">bool</span> visited[MaxV];  <br><span class="hljs-type">int</span> last[MaxV], d[MaxV];  <span class="hljs-comment">// last[i]点i的前驱结点 d[i]点i的深度  </span><br>  <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">BFS</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> n)</span></span>;  <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printPath</span><span class="hljs-params">(<span class="hljs-type">int</span> s, <span class="hljs-type">int</span> v)</span></span>;  <br>  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;  <br>    <span class="hljs-type">int</span> n, m;  <br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);  <span class="hljs-comment">// n顶点数 m边数  </span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;m; i++)&#123;  <br>        <span class="hljs-type">int</span> u, v;  <br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;u, &amp;v);  <span class="hljs-comment">// u到v有边，有向的  </span><br>        ELink* e = (ELink*) <span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span> (ELink));  <br>        e-&gt;adjvex = v, e-&gt;weight = <span class="hljs-number">0</span>, e-&gt;next = <span class="hljs-literal">nullptr</span>;  <br>        <span class="hljs-keyword">if</span>(G[u].link == <span class="hljs-literal">nullptr</span>)&#123;  <br>            G[u].link = e;  <br>        &#125;<span class="hljs-keyword">else</span>&#123;  <br>            e-&gt;next = G[u].link;  <br>            G[u].link = e;  <br>        &#125;  <br>    &#125;  <br>    <span class="hljs-built_in">BFS</span>(<span class="hljs-number">1</span>, n);  <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++)&#123;   <span class="hljs-comment">// 如果是非连通图，该循环保证每个极大连通子图中的顶点都能被遍历到</span><br><span class="hljs-keyword">if</span>(!visited[i])  <br>            <span class="hljs-built_in">BFS</span>(i,n);  <br>    &#125;  <br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);  <br>    <span class="hljs-built_in">printPath</span>(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>);  <span class="hljs-comment">// 打印从点1到点4的路径  </span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);  <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, d[<span class="hljs-number">4</span>]);  <span class="hljs-comment">// 打印点4的高度  </span><br>  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;  <br>  <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">BFS</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> n)</span></span>&#123;  <br>    queue&lt;<span class="hljs-type">int</span>&gt; Q;   <span class="hljs-comment">// 待访问的顶点  </span><br>    ELink* p;  <br>  <br>    Q.<span class="hljs-built_in">push</span>(i);  <span class="hljs-comment">// 当前节点  </span><br>    visited[i] = <span class="hljs-literal">true</span>;  <span class="hljs-comment">// 当前节点被visited过了  </span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;v%d-&gt;&quot;</span>, i);  <br>  <br>    <span class="hljs-keyword">while</span>(!Q.<span class="hljs-built_in">empty</span>())&#123;  <br>        <span class="hljs-type">int</span> k = Q.<span class="hljs-built_in">front</span>();  <br>        Q.<span class="hljs-built_in">pop</span>();  <br>        p = G[k].link;  <br>  <br>        <span class="hljs-keyword">while</span>(p != <span class="hljs-literal">nullptr</span>)&#123;    <span class="hljs-comment">// 如果队列头结点非空  </span><br>            <span class="hljs-type">int</span> j = p-&gt;adjvex;  <span class="hljs-comment">// 头结点序号  </span><br>            <span class="hljs-keyword">if</span>(!visited[j])&#123;    <span class="hljs-comment">// 没visited过当前节点  </span><br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;v%d-&gt;&quot;</span>, j);  <br>                visited[j] = <span class="hljs-literal">true</span>;  <br>                Q.<span class="hljs-built_in">push</span>(j);  <br>                d[j] = d[k]+<span class="hljs-number">1</span>;  <br>                last[j] = k;  <br>            &#125;  <br>            p = p-&gt;next;    <span class="hljs-comment">// 下个节点  </span><br>        &#125;  <br>    &#125;  <br>&#125;  <br>  <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printPath</span><span class="hljs-params">(<span class="hljs-type">int</span> s, <span class="hljs-type">int</span> v)</span></span>&#123;  <br>    <span class="hljs-keyword">if</span>(v == s)&#123;  <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, s);  <br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(last[v] == <span class="hljs-number">0</span>)&#123;  <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;No path from %d to %d exists&quot;</span>, s, v);  <br>    &#125;<span class="hljs-keyword">else</span>&#123;  <br>        <span class="hljs-built_in">printPath</span>(s, last[v]);  <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, v);  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure></p><h5 id="dfs深度优先搜索">DFS深度优先搜索</h5><h6 id="邻接矩阵-2">邻接矩阵</h6><p>时间复杂度 <span class="math inline">\(O(n^2)\)</span> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MaxV (10000+10)  </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;  <br><span class="hljs-type">int</span> G[MaxV][MaxV];        <span class="hljs-comment">// 邻接矩阵  </span><br><span class="hljs-type">bool</span> visited[MaxV];  <br><span class="hljs-type">int</span> last[MaxV], d[MaxV];  <span class="hljs-comment">// last[i]点i的前驱结点 d[i]点i的深度  </span><br>  <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DFS</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> n)</span></span>;  <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printPath</span><span class="hljs-params">(<span class="hljs-type">int</span> s, <span class="hljs-type">int</span> v)</span></span>;  <br>  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;  <br>    <span class="hljs-type">int</span> n, m;  <span class="hljs-comment">// n顶点数 m边数  </span><br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);  <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;m; i++)&#123;  <br>        <span class="hljs-type">int</span> u, v;  <br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;u, &amp;v);  <br>        G[u][v] = <span class="hljs-number">1</span>;  <br>    &#125;  <br>    <span class="hljs-built_in">DFS</span>(<span class="hljs-number">1</span>, n);  <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++)&#123;   <span class="hljs-comment">// 如果是非连通图，该循环保证每个极大连通子图中的顶点都能被遍历到</span><br>    <span class="hljs-keyword">if</span>(!visited[i])  <br>            <span class="hljs-built_in">DFS</span>(i,n);  <br>    &#125;  <br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);  <br>    <span class="hljs-built_in">printPath</span>(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>);  <span class="hljs-comment">// 打印从点1到点4的路径</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);  <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, d[<span class="hljs-number">4</span>]);  <span class="hljs-comment">// 打印点4的高度</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;  <br>  <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DFS</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> n)</span></span>&#123; <span class="hljs-comment">// i当前结点 n总结点数量  </span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;v%d-&gt;&quot;</span>, i);  <br>    visited[i] = <span class="hljs-literal">true</span>;  <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>; j&lt;=n; j++)&#123;  <br>        <span class="hljs-keyword">if</span>(G[i][j] == <span class="hljs-number">1</span> &amp;&amp; !visited[j])&#123;  <br>            last[j] = i;    <span class="hljs-comment">// 前驱  </span><br>            d[j] = d[i]+<span class="hljs-number">1</span>;  <span class="hljs-comment">// 深度  </span><br>            <span class="hljs-built_in">DFS</span>(j, n);  <br>        &#125;  <br>    &#125;  <br>&#125;  <br>  <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printPath</span><span class="hljs-params">(<span class="hljs-type">int</span> s, <span class="hljs-type">int</span> v)</span></span>&#123;   <span class="hljs-comment">// s起点 v终点  </span><br>    <span class="hljs-keyword">if</span>(v == s)&#123;  <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, s);  <br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(last[v] == <span class="hljs-number">0</span>)&#123;  <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;No path from %d to %d exists&quot;</span>, s, v);  <br>    &#125;<span class="hljs-keyword">else</span>&#123;  <br>        <span class="hljs-built_in">printPath</span>(s, last[v]);  <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, v);  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure>###### 邻接表 时间复杂度 <span class="math inline">\(O(n+e)\)</span><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MaxV (10000+10)  </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;  <br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span>&#123;       <span class="hljs-comment">// 定义边结点类型  </span><br>    <span class="hljs-type">int</span> adjvex;  <span class="hljs-comment">//指向的点  </span><br>    <span class="hljs-type">int</span> weight;  <span class="hljs-comment">//边的权重  </span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span> *next;  <span class="hljs-comment">//相邻的边  </span><br>&#125;ELink;  <br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">ver</span>&#123;       <span class="hljs-comment">// 定义顶点结点类型  </span><br>    <span class="hljs-type">int</span> vertex;  <span class="hljs-comment">//顶点id  </span><br>    ELink* link;  <span class="hljs-comment">//从此顶点出发的边  </span><br>&#125;VLink;  <br>  <br>VLink G[MaxV];  <br><span class="hljs-type">bool</span> visited[MaxV];  <br><span class="hljs-type">int</span> last[MaxV], d[MaxV];  <br>  <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DFS</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> n)</span></span>;  <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printPath</span><span class="hljs-params">(<span class="hljs-type">int</span> s, <span class="hljs-type">int</span> v)</span></span>;  <br>  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;  <br>    <span class="hljs-type">int</span> n, m;  <br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);  <span class="hljs-comment">// n顶点数 m边数  </span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;m; i++)&#123;  <br>        <span class="hljs-type">int</span> u, v;  <span class="hljs-comment">// u到v有边，有向的  </span><br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;u, &amp;v);  <br>        ELink* e = (ELink*) <span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span> (ELink));  <br>        e-&gt;adjvex = v, e-&gt;weight = <span class="hljs-number">0</span>, e-&gt;next = <span class="hljs-literal">nullptr</span>;  <br>        <span class="hljs-keyword">if</span>(G[u].link == <span class="hljs-literal">nullptr</span>)&#123;  <br>            G[u].link = e;  <br>        &#125;<span class="hljs-keyword">else</span>&#123;  <br>            e-&gt;next = G[u].link;  <br>            G[u].link = e;  <br>        &#125;  <br>    &#125;  <br>    <span class="hljs-built_in">DFS</span>(<span class="hljs-number">1</span>, n);  <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++)&#123;   <span class="hljs-comment">// 如果是非连通图，该循环保证每个极大连通子图中的顶点都能被遍历到</span><br><span class="hljs-keyword">if</span>(!visited[i])  <br>            <span class="hljs-built_in">DFS</span>(i,n);  <br>    &#125;  <br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);  <br>    <span class="hljs-built_in">printPath</span>(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>);  <span class="hljs-comment">// 打印从点1到点4的路径</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);  <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, d[<span class="hljs-number">4</span>]);  <span class="hljs-comment">// 打印点4的高度</span><br>  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;  <br>  <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DFS</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> n)</span></span>&#123; <span class="hljs-comment">// i当前结点 n总结点数量  </span><br>    ELink* p;  <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;v%d-&gt;&quot;</span>, i);  <br>    visited[i] = <span class="hljs-literal">true</span>;  <br>    p = G[i].link;  <br>    <span class="hljs-keyword">while</span>(p != <span class="hljs-literal">NULL</span>)&#123;  <br>        <span class="hljs-type">int</span> j = p-&gt;adjvex;  <br>        <span class="hljs-keyword">if</span>(!visited[j])&#123;  <br>            last[j] = i;    <span class="hljs-comment">// 前驱  </span><br>            d[j] = d[i]+<span class="hljs-number">1</span>;  <span class="hljs-comment">// 深度  </span><br>            <span class="hljs-built_in">DFS</span>(j, n);  <br>        &#125;  <br>        p = p-&gt;next;  <br>    &#125;  <br>&#125;  <br>  <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printPath</span><span class="hljs-params">(<span class="hljs-type">int</span> s, <span class="hljs-type">int</span> v)</span></span>&#123;   <span class="hljs-comment">// s起点 v终点  </span><br>    <span class="hljs-keyword">if</span>(v == s)&#123;  <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, s);  <br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(last[v] == <span class="hljs-number">0</span>)&#123;  <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;No path from %d to %d exists&quot;</span>, s, v);  <br>    &#125;<span class="hljs-keyword">else</span>&#123;  <br>        <span class="hljs-built_in">printPath</span>(s, last[v]);  <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, v);  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure></p><h5 id="拓扑排序">拓扑排序</h5><p>拓扑排序：对于<strong>有向无环图</strong> <spanclass="math inline">\(G\)</span> 来说，如果图G包含边 <spanclass="math inline">\((u,v)\)</span>，则结点 <spanclass="math inline">\(u\)</span> 在拓扑排序中处于结点 <spanclass="math inline">\(v\)</span> 的前面。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span>  </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;  <br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_VERTICES 10010 <span class="hljs-comment">// 定义图的最大顶点数  </span></span><br>unordered_map&lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;&gt;graph; <span class="hljs-comment">// 定义图的结构  </span><br>  <br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span> &#123;         <span class="hljs-comment">//链式前向星，存边的起点、终点、和前驱  </span><br>    <span class="hljs-type">int</span> from, to, next;  <br>&#125; e[MAX_VERTICES];  <br><span class="hljs-type">int</span> cnt;          <span class="hljs-comment">//存储的边数  </span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;  <br>    <span class="hljs-type">int</span> t;  <br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;t);  <br>    <span class="hljs-keyword">while</span>(t--)&#123;  <br>        <span class="hljs-type">int</span> head[MAX_VERTICES] = &#123;&#125;;  <span class="hljs-comment">//下标是起点的表头，存第一个边的编号，初始化为 -1</span><br><span class="hljs-type">int</span> id[MAX_VERTICES]=&#123;&#125;;  <span class="hljs-comment">//每个点的入度  </span><br>        <span class="hljs-built_in">memset</span>(head, <span class="hljs-number">-1</span>, <span class="hljs-built_in">sizeof</span>(head));  <br>        graph.<span class="hljs-built_in">clear</span>();  <br>  <br>        <span class="hljs-type">int</span> n, m;  <br>        cnt = <span class="hljs-number">1</span>;  <br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);  <br>  <br>        <span class="hljs-comment">// 读入  </span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;  <br>            <span class="hljs-type">int</span> from, to;  <br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;from, &amp;to);  <br>            e[cnt].from = from;  <span class="hljs-comment">//起点  </span><br>            e[cnt].to = to;      <span class="hljs-comment">//终点  </span><br>            e[cnt].next = head[from];  <span class="hljs-comment">//添加  </span><br>            id[to]++;  <br>            head[from] = cnt++;  <span class="hljs-comment">//更新表头  </span><br>            graph[from].<span class="hljs-built_in">push_back</span>(to);  <br>        &#125;  <br>        <br>        <span class="hljs-comment">// 拓扑排序  </span><br>        priority_queue&lt;<span class="hljs-type">int</span>&gt; q; <span class="hljs-comment">// 对于拓扑排序不唯一的情况,先输出序号大的点,再输出序号小的点,即输出字典序最大的拓扑排序</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++) &#123;  <br>            <span class="hljs-keyword">if</span> (id[i] == <span class="hljs-number">0</span>)  <br>                q.<span class="hljs-built_in">push</span>(i);  <span class="hljs-comment">//把入度为0的点入队  </span><br>        &#125;  <br>        vector&lt;<span class="hljs-type">int</span>&gt; ans;  <span class="hljs-comment">//数组保存结果  </span><br>        <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;  <br>            <span class="hljs-type">int</span> x = q.<span class="hljs-built_in">top</span>();  <span class="hljs-comment">//出队  </span><br>            q.<span class="hljs-built_in">pop</span>();  <br>            ans.<span class="hljs-built_in">push_back</span>(x);  <br>            <span class="hljs-type">int</span> edge = head[x];  <br>            <span class="hljs-keyword">while</span> (edge != <span class="hljs-number">-1</span>) &#123;  <br>                id[e[edge].to]--;  <span class="hljs-comment">//删除边  </span><br>                <span class="hljs-keyword">if</span> (id[e[edge].to] == <span class="hljs-number">0</span>) <span class="hljs-comment">//把入度为0的点入队  </span><br>                    q.<span class="hljs-built_in">push</span>(e[edge].to);  <br>                edge = e[edge].next;  <br>            &#125;  <br>        &#125;  <br>  <br>        <span class="hljs-comment">// 输出形成的拓扑序列  </span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> an : ans)&#123;  <br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, an);  <br>        &#125;  <br>  <br>    &#125;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></td></tr></table></figure></p><h5 id="单源最短路径">单源最短路径</h5><h6 id="bellman-ford算法">1 Bellman-Ford算法</h6><ul><li><strong>权重可以为负</strong>，可以<strong>有回路</strong>。时间复杂度<spanclass="math inline">\(O(VE)\)</span> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span>  </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;  <br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX 0x3f3f3f3f  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 1010  </span><br>  <br><span class="hljs-type">int</span> nodenum, edgenum, original; <span class="hljs-comment">//点，边，起点  </span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span>&#123; <span class="hljs-comment">//边  </span><br>    <span class="hljs-type">int</span> u, v;   <span class="hljs-comment">// 起点 终点  </span><br>    <span class="hljs-type">int</span> cost;   <span class="hljs-comment">// 权重  </span><br>&#125;Edge;  <br>  <br>Edge edge[N];  <br><span class="hljs-type">int</span> dis[N], pre[N]; <span class="hljs-comment">// dis源点到每个顶点的最短距离，pre最短路径的前驱节点  </span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Bellman_Ford</span><span class="hljs-params">()</span></span>;  <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print_path</span><span class="hljs-params">(<span class="hljs-type">int</span> root)</span></span>;  <br>  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;  <br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;nodenum, &amp;edgenum, &amp;original);  <br>    pre[original] = original; <span class="hljs-comment">// 初始化源点的前驱为自己  </span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= edgenum; ++i)&#123;  <br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;edge[i].u, &amp;edge[i].v, &amp;edge[i].cost);  <br>    &#125;  <br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">Bellman_Ford</span>())  <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= nodenum; ++i)&#123; <span class="hljs-comment">//每个点最短路  </span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, dis[i]); <span class="hljs-comment">// 输出源点到该顶点的最短距离  </span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Path:&quot;</span>);  <br>            <span class="hljs-built_in">print_path</span>(i); <span class="hljs-comment">// 打印路径  </span><br>        &#125;  <br>    <span class="hljs-keyword">else</span> <span class="hljs-comment">// 如果存在负权回路，输出提示信息  </span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;have negative circle\n&quot;</span>);  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;  <br>  <br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Bellman_Ford</span><span class="hljs-params">()</span></span>&#123;  <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= nodenum; ++i) <span class="hljs-comment">//初始化  </span><br>        dis[i] = (i == original ? <span class="hljs-number">0</span> : MAX);  <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= nodenum - <span class="hljs-number">1</span>; ++i) <span class="hljs-comment">// n-1遍</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= edgenum; ++j)  <br>            <span class="hljs-keyword">if</span>(dis[edge[j].v] &gt; dis[edge[j].u] + edge[j].cost)&#123; <span class="hljs-comment">//松弛  </span><br>                dis[edge[j].v] = dis[edge[j].u] + edge[j].cost;  <br>                pre[edge[j].v] = edge[j].u; <span class="hljs-comment">// 更新前驱节点  </span><br>            &#125;  <br>    <span class="hljs-type">bool</span> flag = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 标记是否存在负权回路 false为有  </span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= edgenum; ++i)  <br>        <span class="hljs-keyword">if</span>(dis[edge[i].v] &gt; dis[edge[i].u] + edge[i].cost)&#123;  <br>            <span class="hljs-comment">// 如果还能松弛，则存在负权回路  </span><br>            flag = <span class="hljs-literal">false</span>;  <br>            <span class="hljs-keyword">break</span>;  <br>        &#125;  <br>    <span class="hljs-keyword">return</span> flag;  <br>&#125;  <br>  <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print_path</span><span class="hljs-params">(<span class="hljs-type">int</span> root)</span></span>&#123; <span class="hljs-comment">// 打印最短路的路径（反向）  </span><br>    <span class="hljs-keyword">while</span>(root != pre[root])&#123; <span class="hljs-comment">// 前驱  </span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d--&gt;&quot;</span>, root);  <br>        root = pre[root];  <br>    &#125;  <br>    <span class="hljs-keyword">if</span>(root == pre[root])  <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, root);  <br>&#125;<br></code></pre></td></tr></table></figure> ###### 2有向无环图中的单源最短路径问题<strong>权重可以为负</strong>，<strong>不能有回路</strong>。时间复杂度<spanclass="math inline">\(O(V+E)\)</span> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span>  </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;  <br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_VERTICES 10010  <span class="hljs-comment">// 定义图的最大结点数  </span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_EDGE 10010       <span class="hljs-comment">// 定义图的最大边数  </span></span><br>  <br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span>&#123;       <span class="hljs-comment">// 定义边结点类型  </span><br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> adjvex;  <span class="hljs-comment">//指向的点  </span><br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> weight;  <span class="hljs-comment">//边的权重  </span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span> *next; <span class="hljs-comment">//相邻的边  </span><br>&#125;ELink;  <br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">ver</span>&#123;       <span class="hljs-comment">// 定义顶点结点类型  </span><br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> vertex, id, d, last;  <br>    <span class="hljs-comment">// 编号 入度 到源点的距离 最短路径中的前驱结点  </span><br>    ELink* link; <span class="hljs-comment">// 与顶点相连的第一个边结点的指针  </span><br>&#125;VLink;  <br>  <br><span class="hljs-comment">// 定义图的结构  </span><br>VLink G[MAX_VERTICES];  <br>  <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InitializeSingleSource</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> n, <span class="hljs-type">long</span> <span class="hljs-type">long</span> s)</span></span>;  <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Relax</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span>  u, <span class="hljs-type">long</span> <span class="hljs-type">long</span> v, ELink* edge)</span></span>;  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;  <br>    <span class="hljs-type">int</span> t;  <br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;t);  <br>    <span class="hljs-keyword">while</span>(t--)&#123;  <br>        <span class="hljs-type">int</span> n, m, s;  <br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;s); <span class="hljs-comment">// 顶点数 边数 源点  </span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;m; i++)&#123;  <br>            <span class="hljs-type">long</span> <span class="hljs-type">long</span> u, v, w;  <br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld%lld&quot;</span>, &amp;u, &amp;v, &amp;w);  <br>            ELink* e = (ELink*) <span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span> (ELink));  <br>            e-&gt;adjvex = v, e-&gt;weight = w, e-&gt;next = <span class="hljs-literal">nullptr</span>;  <br>            <span class="hljs-keyword">if</span>(G[u].link == <span class="hljs-literal">nullptr</span>)&#123;  <br>                G[u].link = e;  <br>            &#125;<span class="hljs-keyword">else</span>&#123;  <br>                e-&gt;next = G[u].link;  <br>                G[u].link = e;  <br>            &#125;  <br>            G[v].id++;  <br>        &#125;  <br>  <br>        <span class="hljs-comment">// 拓扑排序  </span><br>        queue&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span> &gt; q;  <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;  <br>            <span class="hljs-keyword">if</span> (G[i].id == <span class="hljs-number">0</span>)  <br>                q.<span class="hljs-built_in">push</span>(i);  <span class="hljs-comment">//把入度为0的点入队  </span><br>        &#125;  <br>        vector&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span> &gt; ans; <span class="hljs-comment">// 拓扑排序结果  </span><br>        <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;  <br>            <span class="hljs-type">long</span> <span class="hljs-type">long</span> x = q.<span class="hljs-built_in">front</span>();  <br>            q.<span class="hljs-built_in">pop</span>();  <br>            ans.<span class="hljs-built_in">push_back</span>(x);  <br>            ELink* edge = G[x].link;  <br>            <span class="hljs-keyword">while</span> (edge != <span class="hljs-literal">nullptr</span>) &#123;  <br>                G[edge-&gt;adjvex].id--;  <br>                <span class="hljs-keyword">if</span> (G[edge-&gt;adjvex].id == <span class="hljs-number">0</span>) <span class="hljs-comment">//把入度为0的点入队  </span><br>                    q.<span class="hljs-built_in">push</span>(edge-&gt;adjvex);  <br>                edge = edge-&gt;next;  <br>            &#125;  <br>        &#125;  <br>  <br>        <span class="hljs-built_in">InitializeSingleSource</span>(n, s); <span class="hljs-comment">// 初始化  </span><br>        <span class="hljs-comment">// 松弛结点  </span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">long</span> <span class="hljs-type">long</span> an: ans)&#123;  <br>            VLink now = G[an];  <br>            ELink* temp = now.link;  <br>            <span class="hljs-keyword">while</span> (temp != <span class="hljs-literal">nullptr</span>) &#123;  <br>                <span class="hljs-built_in">Relax</span>(an, temp-&gt;adjvex, temp);  <br>                temp = temp-&gt;next;  <br>            &#125;  <br>        &#125;  <br>        <span class="hljs-comment">// 输出结果  </span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">long</span> <span class="hljs-type">long</span> an: ans)&#123;  <br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld:%lld &quot;</span>, an, G[an].d);  <br>            <span class="hljs-comment">// 输出每个顶点到源点的最短距离  </span><br>        &#125;  <br>    &#125;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;  <br>  <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InitializeSingleSource</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> n, <span class="hljs-type">long</span> <span class="hljs-type">long</span>  s)</span></span>&#123;  <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)&#123;  <br>        G[i].d = LONG_LONG_MAX;  <br>    &#125;  <br>    G[s].d = <span class="hljs-number">0</span>;  <br>&#125;  <br>  <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Relax</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span>  u, <span class="hljs-type">long</span> <span class="hljs-type">long</span> v, ELink* edge)</span></span>&#123;  <br>    <span class="hljs-keyword">if</span>(G[v].d &gt; G[u].d+edge-&gt;weight)&#123;  <br>        G[v].d = G[u].d+edge-&gt;weight;   <span class="hljs-comment">// 更新距离  </span><br>        G[v].last = u;  <span class="hljs-comment">// 更新前驱  </span><br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure> ###### 3Dijkstra算法</li><li><strong>非负</strong>权重的图，可以有<strong>回路</strong>。时间复杂度<spanclass="math inline">\(O((V+E)*logV)\)</span> <strong>标准版</strong><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;queue&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MaxV 2005  </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;  <br>  <br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span> &#123;  <br>    <span class="hljs-type">int</span> to;  <br>    <span class="hljs-type">int</span> weight;  <br>    <span class="hljs-comment">// 构造函数，初始化目标顶点和权重  </span><br>    <span class="hljs-built_in">Edge</span>(<span class="hljs-type">int</span> t, <span class="hljs-type">int</span> w) :<span class="hljs-built_in">to</span>(t), <span class="hljs-built_in">weight</span>(w) &#123;&#125;  <br>&#125;;  <br>  <br><span class="hljs-comment">//graph用邻接表表示的图 src源节点  </span><br>vector&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">dijkstra</span>(<span class="hljs-type">const</span> vector&lt;vector&lt;Edge&gt;&gt;&amp; graph, <span class="hljs-type">int</span> src) &#123;  <br>    <span class="hljs-comment">//储存各个顶点到src顶点的距离  </span><br>    vector&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">dis</span>(MaxV, INT_MAX);  <br>    <span class="hljs-comment">//记录访问过的顶点  </span><br>    vector&lt;<span class="hljs-type">bool</span>&gt;<span class="hljs-built_in">vis</span>(MaxV, <span class="hljs-literal">false</span>);  <br>    <span class="hljs-comment">//用优先级队列来处理距离最短的顶点，pair&lt;int,int&gt;的第一个int存储距离，第二个int存储顶点;  </span><br>    <span class="hljs-comment">//底层用vector来存储这个队列；greater表示从小到大排  </span><br>priority_queue&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;,vector&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; &gt;,greater&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; &gt; &gt;pq;  <br>  <br>    <span class="hljs-comment">//src顶点到自己的距离为0  </span><br>    dis[src] = <span class="hljs-number">0</span>;  <br>    pq.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">0</span>,src&#125;);  <br>  <br>    <span class="hljs-keyword">while</span> (!pq.<span class="hljs-built_in">empty</span>()) &#123;  <br>        <span class="hljs-comment">//v表示当前距离最短的顶点  </span><br>        <span class="hljs-type">int</span> v = pq.<span class="hljs-built_in">top</span>().second; pq.<span class="hljs-built_in">pop</span>();  <br>        <span class="hljs-comment">//若是访问过当前顶点则跳过  </span><br>        <span class="hljs-keyword">if</span> (vis[v]) <span class="hljs-keyword">continue</span>;  <br>        vis[v] = <span class="hljs-literal">true</span>;  <br>        <span class="hljs-comment">//访问邻接顶点  </span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp;edge: graph[v]) &#123;  <br>            <span class="hljs-type">int</span> t = edge.to;  <br>            <span class="hljs-type">int</span> w = edge.weight;  <br>            <span class="hljs-keyword">if</span> (!vis[t] &amp;&amp; w+dis[v]&lt;dis[t]) &#123;  <br>                dis[t] = w + dis[v];  <br>                pq.<span class="hljs-built_in">push</span>(&#123; dis[t],t &#125;);  <br>            &#125;  <br>        &#125;  <br>    &#125;  <br>    <span class="hljs-keyword">return</span> dis;  <br>&#125;  <br>  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;  <br>    <span class="hljs-type">int</span> n, m, source;  <span class="hljs-comment">// 顶点数 边数 源点 </span><br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;source);<br>    vector&lt;vector&lt;Edge&gt;&gt;<span class="hljs-built_in">graph</span>(MaxV);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;m; i++)&#123;<br>        <span class="hljs-type">int</span> u, v, w;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;u, &amp;v, &amp;w);<br>        graph[u].<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">Edge</span>(v,w)); <span class="hljs-comment">// 有向图 u到v权重为w</span><br>    &#125;  <br>    vector&lt;<span class="hljs-type">int</span>&gt;shortest_path = <span class="hljs-built_in">dijkstra</span>(graph, source); <span class="hljs-comment">// 起点source</span><br>    cout &lt;&lt; shortest_path[<span class="hljs-number">3</span>]; <span class="hljs-comment">// 顶点source到顶点3的最短路径长度  </span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h5 id="所有结点对的最短路径问题">所有结点对的最短路径问题</h5><h6 id="floyd算法">floyd算法</h6><p>空间复杂度 <span class="math inline">\(O(V^2)\)</span><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;limits.h&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> V 310  <span class="hljs-comment">// 图中节点的数量  </span></span><br><span class="hljs-type">long</span> <span class="hljs-type">long</span> dist[V][V], graph[V][V], Path[V][V];  <br><span class="hljs-comment">// dist两点间的最短距离 graph图的邻接矩阵 Path最短路径的中转点  </span><br>  <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">floydWarshall</span><span class="hljs-params">()</span></span>;  <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PrintPath</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> u, <span class="hljs-type">long</span> <span class="hljs-type">long</span> v)</span></span>;  <br>  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;  <br>    <span class="hljs-type">int</span> n, m;   <span class="hljs-comment">// 顶点数 边数  </span><br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);  <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;m; i++)&#123;  <br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> u, v, w;  <span class="hljs-comment">// 起点、终点和权重  </span><br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld%lld&quot;</span>, &amp;u, &amp;v, &amp;w);  <br>        <span class="hljs-keyword">if</span>((graph[u][v]!=<span class="hljs-number">0</span> &amp;&amp; w&lt;graph[u][v]) || graph[u][v] == <span class="hljs-number">0</span>)&#123;  <br>            <span class="hljs-comment">// 考虑到可能有重复边  </span><br>            graph[u][v] = w;  <br>        &#125;  <br>    &#125;  <br>    <span class="hljs-built_in">floydWarshall</span>();  <br>  <br>    <span class="hljs-type">int</span> q;  <span class="hljs-comment">// q次询问  </span><br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;q);  <br>    <span class="hljs-keyword">while</span>(q--)&#123;  <br>        <span class="hljs-type">int</span> u, v;  <br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;u, &amp;v);  <span class="hljs-comment">// 询问的起点和终点  </span><br>        <span class="hljs-keyword">if</span>(u == v)&#123;     <span class="hljs-comment">// u和v是同一个点，距离为0  </span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d-&gt;%d: 0\n&quot;</span>, u, v);  <br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(dist[u][v] == LONG_LONG_MAX)&#123;  <span class="hljs-comment">// u不可达v，输出-1  </span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d-&gt;%d: -1\n&quot;</span>, u, v);  <br>        &#125;<span class="hljs-keyword">else</span>&#123;  <span class="hljs-comment">// u可达v  </span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d-&gt;%d: %lld\n&quot;</span>, u, v, dist[u][v]);  <span class="hljs-comment">// 最短距离  </span><br>            <span class="hljs-built_in">PrintPath</span>(u, v);  <span class="hljs-comment">// 打印最短路径  </span><br>        &#125;  <br>    &#125;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;  <br>  <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">floydWarshall</span><span class="hljs-params">()</span> </span>&#123;  <br>    <span class="hljs-comment">// 初始化最短路径矩阵  </span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; V; i++)  <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; V; j++)&#123;  <br>            <span class="hljs-keyword">if</span>(graph[i][j] != <span class="hljs-number">0</span>)&#123;  <br>                dist[i][j] = graph[i][j];  <br>            &#125;<span class="hljs-keyword">else</span>&#123;  <br>                dist[i][j] = LONG_LONG_MAX;  <br>            &#125;  <br>            <span class="hljs-keyword">if</span>(dist[i][j] &lt; LONG_LONG_MAX &amp;&amp; i != j)&#123;  <br>                Path[i][j] = j; <span class="hljs-comment">// 初始化路径为直接连接  </span><br>            &#125;<span class="hljs-keyword">else</span>&#123;  <br>                Path[i][j] = <span class="hljs-number">-1</span>;  <br>            &#125;  <br>        &#125;  <br>  <br>    <span class="hljs-comment">// 更新最短路径矩阵  </span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; V; k++) &#123;  <span class="hljs-comment">// 遍历所有节点作为中转点  </span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; V; i++) &#123;  <span class="hljs-comment">// 遍历所有起点  </span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; V; j++) &#123;  <span class="hljs-comment">// 遍历所有终点  </span><br>                <span class="hljs-keyword">if</span> (dist[i][k] != LONG_LONG_MAX &amp;&amp; dist[k][j] != LONG_LONG_MAX &amp;&amp; dist[i][k] + dist[k][j] &lt; dist[i][j]) &#123;  <br>                    <span class="hljs-comment">// 如果通过k点可以使i到j的距离更短，松弛  </span><br>                    dist[i][j] = dist[i][k] + dist[k][j];  <br>                    Path[i][j] = k;  <span class="hljs-comment">// 更新路径的中转点为k  </span><br>                &#125;  <br>            &#125;  <br>        &#125;  <br>    &#125;  <br>&#125;  <br><br><span class="hljs-comment">// 打印最短路径  </span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PrintPath</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> u, <span class="hljs-type">long</span> <span class="hljs-type">long</span> v)</span></span>&#123;  <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld &quot;</span>, u);  <span class="hljs-comment">// 打印起点  </span><br>    <span class="hljs-keyword">while</span>(Path[u][v] != v)&#123;  <span class="hljs-comment">// 当中转点不是终点时  </span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld &quot;</span>, Path[u][v]);  <span class="hljs-comment">// 打印中转点  </span><br>        u = Path[u][v];  <span class="hljs-comment">// 更新起点为中转点  </span><br>    &#125;  <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, v);  <span class="hljs-comment">// 打印终点  </span><br>&#125;<br></code></pre></td></tr></table></figure></p><h6 id="有向图的传递闭包">有向图的传递闭包</h6><ul><li><strong>传递闭包</strong>：<spanclass="math inline">\(G*=(V,E*)\)</span> ，其中 <spanclass="math inline">\(E*=\{(i,j)|如果图G中包含一条从结点i到结点j的路径\}\)</span></li><li>用于解决问题：给定有向图，判断对于所有结点对i和j，图G是否包含一条从结点i到结点j的路径时间复杂度：<span class="math inline">\(O(n^3)\)</span><strong>法1：floyd算法每条边权重赋1</strong> <strong>法2</strong><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> V 310  <span class="hljs-comment">// 图中节点的数量  </span></span><br><span class="hljs-type">long</span> <span class="hljs-type">long</span> dist[V][V];  <span class="hljs-comment">// dist[i][j] i到j的可达性  </span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">floydWarshall</span><span class="hljs-params">()</span></span>;  <br>  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;  <br>    <span class="hljs-type">int</span> n, m;  <br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);  <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;m; i++)&#123;  <br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> u, v, w;  <br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld%lld&quot;</span>, &amp;u, &amp;v, &amp;w);  <br>        dist[u][v] = <span class="hljs-number">1</span>;  <br>    &#125;  <br>    <span class="hljs-built_in">floydWarshall</span>();  <br>  <br>    <span class="hljs-type">int</span> q;  <span class="hljs-comment">// q次询问  </span><br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;q);  <br>    <span class="hljs-keyword">while</span>(q--)&#123;  <br>        <span class="hljs-type">int</span> u, v;  <br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;u, &amp;v);  <br>        <span class="hljs-keyword">if</span>(dist[u][v])&#123;     <span class="hljs-comment">// u可达v，输出1  </span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d-&gt;%d: 1\n&quot;</span>, u, v);  <br>        &#125;<span class="hljs-keyword">else</span>&#123;  <span class="hljs-comment">// u不可达v，输出0  </span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d-&gt;%d: 0\n&quot;</span>, u, v);  <br>        &#125;  <br>    &#125;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;  <br>  <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">floydWarshall</span><span class="hljs-params">()</span> </span>&#123;  <br>    <span class="hljs-comment">// 初始化最短路径矩阵  </span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; V; i++)  <br>        dist[i][i] = <span class="hljs-number">1</span>;  <br>  <br>    <span class="hljs-comment">// 更新最短路径矩阵  </span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; V; k++) &#123;  <span class="hljs-comment">// 遍历所有节点作为中转点  </span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; V; i++) &#123;  <span class="hljs-comment">// 遍历所有起点  </span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; V; j++) &#123;  <span class="hljs-comment">// 遍历所有终点  </span><br>                dist[i][j] = dist[i][j] | (dist[i][k] &amp; dist[k][j]);  <br>            &#125;  <br>        &#125;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h6 id="经过固定点的最短路径">经过固定点的最短路径</h6><p><img src="/img/LE-suanfabanzi/002.png" /> ##### 最大流 ######Edmonds-Karp算法 时间复杂度 <spanclass="math inline">\(O(VE^{2})\)</span>，其中 <spanclass="math inline">\(V\)</span> 为点的总数，<spanclass="math inline">\(E\)</span> 为边的总数 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span>  </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;  <br>  <br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">210</span>;<span class="hljs-comment">// 最大节点数量  </span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> INF=<span class="hljs-number">0x7FFFFFFF</span>;  <br><span class="hljs-type">int</span> n,m; <span class="hljs-comment">// n为节点数，m为汇点编号  </span><br><span class="hljs-type">int</span> map0[N][N]; <span class="hljs-comment">// 残留图，表示每条有向边的容量  </span><br><span class="hljs-type">int</span> pi[N];  <span class="hljs-comment">//BFS的前驱图  </span><br><span class="hljs-type">int</span> flow_in[N]; <span class="hljs-comment">//流入i的最大流量是flow_in[i]  </span><br><span class="hljs-type">int</span> start,end0; <span class="hljs-comment">// 源点和汇点  </span><br>queue&lt;<span class="hljs-type">int</span>&gt; q;  <br>  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span></span>;  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Edmonds_Karp</span><span class="hljs-params">()</span></span>;  <br>  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;  <br>    <span class="hljs-type">int</span> i,u,v,cost;  <br>    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m)!=EOF)&#123; <span class="hljs-comment">// 读取节点数和汇点编号  </span><br>        <span class="hljs-built_in">memset</span>(map0,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(map0));  <br>        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;  <br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;u,&amp;v,&amp;cost);  <br>            map0[u][v]+=cost; <span class="hljs-comment">// 更新残留图的容量  </span><br>        &#125;  <br>        start=<span class="hljs-number">1</span>,end0=m;  <span class="hljs-comment">// 1是源点，m是汇点  </span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,<span class="hljs-built_in">Edmonds_Karp</span>());  <br>    &#125;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;  <br>  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span></span>&#123;  <br>    <span class="hljs-type">int</span> i,t;  <br>    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>()) q.<span class="hljs-built_in">pop</span>();  <br>    <span class="hljs-built_in">memset</span>(pi,<span class="hljs-number">-1</span>,<span class="hljs-built_in">sizeof</span>(pi));  <br>    pi[start]=<span class="hljs-number">0</span>; <span class="hljs-comment">// 源点的前驱为自己  </span><br>    flow_in[start]=INF;  <br>  <br>    q.<span class="hljs-built_in">push</span>(start);  <br>    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;  <br>        t=q.<span class="hljs-built_in">front</span>();  <br>        q.<span class="hljs-built_in">pop</span>();  <br>  <br>        <span class="hljs-keyword">if</span>(t==end0) <span class="hljs-keyword">break</span>;  <span class="hljs-comment">// 已经走到汇点，循环结束  </span><br>        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;  <br>            <span class="hljs-keyword">if</span>(pi[i]==<span class="hljs-number">-1</span> &amp;&amp; map0[t][i])&#123; <span class="hljs-comment">// 节点i未被访问且t到i有边  </span><br>                flow_in[i] = <span class="hljs-built_in">min</span>(flow_in[t], map0[t][i]); <span class="hljs-comment">// 更新流入i的最大流量  </span><br>                q.<span class="hljs-built_in">push</span>(i);  <br>                pi[i]=t;    <span class="hljs-comment">// i的前驱结点为t  </span><br>            &#125;  <br>        &#125;  <br>    &#125;  <br>    <span class="hljs-keyword">if</span>(pi[end0]==<span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// 如果汇点未被访问，说明没有增广路径  </span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> flow_in[m]; <span class="hljs-comment">// 返回增广路径的流量  </span><br>&#125;  <br>  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Edmonds_Karp</span><span class="hljs-params">()</span></span>&#123;  <br>    <span class="hljs-type">int</span> max_flow_in=<span class="hljs-number">0</span>; <span class="hljs-comment">// 流f的流值|f|  </span><br>    <span class="hljs-type">int</span> cf_p;     <span class="hljs-comment">// 增广路径的残留容量Cf(p)  </span><br>  <br>    <span class="hljs-keyword">while</span>((cf_p=<span class="hljs-built_in">bfs</span>())!=<span class="hljs-number">-1</span>)&#123;    <span class="hljs-comment">// 当还有增广路径时  </span><br>        <span class="hljs-comment">//1. 流值|f|增加本次增广路径的残留容量cf_p  </span><br>        max_flow_in+=cf_p;  <br>  <br>        <span class="hljs-comment">//2. 更新残留图  </span><br>        <span class="hljs-type">int</span> now=end0;  <br>        <span class="hljs-keyword">while</span>(now!=start)&#123;  <br>            <span class="hljs-type">int</span> pre=pi[now]; <span class="hljs-comment">// 获取前驱节点  </span><br>            map0[pre][now]-=cf_p;  <span class="hljs-comment">//更新正向边的实际容量  </span><br>            map0[now][pre]+=cf_p;  <span class="hljs-comment">//添加反向边  </span><br>            now=pre; <span class="hljs-comment">// 移动到前驱节点  </span><br>        &#125;  <br>    &#125;  <br>    <span class="hljs-keyword">return</span> max_flow_in; <span class="hljs-comment">// 返回最大流  </span><br>&#125;<br></code></pre></td></tr></table></figure> ######Dinic算法 时间复杂度 <spanclass="math inline">\(O(V^{2}E)\)</span>，其中 <spanclass="math inline">\(V\)</span> 为点的总数，<spanclass="math inline">\(E\)</span> 为边的总数 + 第一行一个正整数T（1≤T≤10），表示数据组数。 + 对于每组数据，第一行四个正整数n,m,s,t（1≤n≤100，1≤m≤5×10^3，1≤s,t≤n），n个点，m条边，计算从s到t的最大流。+ 接下来 m 行，每行三个正整数ui,vi,wi（1≤ui,vi≤n，0≤wi&lt;2^31），表示第 i 条有向边 ui→vi的最大容量为 wi。 + 图中有可能存在<strong>重边和自环</strong>。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span>  </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;  <br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;  <br><span class="hljs-type">const</span> <span class="hljs-type">int</span> V_MAX = <span class="hljs-number">205</span>; <span class="hljs-comment">// 最大顶点数  </span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> E_MAX = <span class="hljs-number">5005</span>; <span class="hljs-comment">// 最大边数  </span><br><span class="hljs-type">const</span> ll LL_INF = <span class="hljs-number">0x3f3f3f3f3f3f3f3f</span>;  <br>ll max_stream = <span class="hljs-number">0</span>; <span class="hljs-comment">// 最大流  </span><br><span class="hljs-type">int</span> cnt_E = <span class="hljs-number">0</span>;  <br><span class="hljs-type">int</span> n, m, s, t;  <br>  <br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span> &#123;  <br>    <span class="hljs-type">int</span> to; <span class="hljs-comment">// 边的目标顶点  </span><br>    <span class="hljs-type">int</span> nxt; <span class="hljs-comment">// 下一条边的索引  </span><br>    ll val; <span class="hljs-comment">// 边的容量  </span><br>&#125; e[E_MAX * <span class="hljs-number">2</span>]; <span class="hljs-comment">// 边数组，每条边对应一条正向边和一条反向边  </span><br><span class="hljs-type">int</span> head[V_MAX]; <span class="hljs-comment">// 邻接表的头指针数组  </span><br><span class="hljs-type">int</span> depth[V_MAX]; <span class="hljs-comment">// 每个顶点的层次  </span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addEdge</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> w)</span></span>;  <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span>;  <br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span></span>;  <br><span class="hljs-function">ll <span class="hljs-title">Dinic</span><span class="hljs-params">()</span></span>;  <br>  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;  <br>    <span class="hljs-type">int</span> T;  <br>    cin &gt;&gt; T;  <br>    <span class="hljs-keyword">while</span>(T--)&#123;  <br>        cin &gt;&gt; n &gt;&gt; m &gt;&gt; s &gt;&gt; t; <span class="hljs-comment">// 顶点数 边数 源点 汇点  </span><br>        cnt_E = <span class="hljs-number">0</span>, max_stream = <span class="hljs-number">0</span>; <span class="hljs-comment">// 初始化边计数器和最大流  </span><br>        <span class="hljs-built_in">fill</span>(head + <span class="hljs-number">1</span>, head + <span class="hljs-number">1</span> + n, <span class="hljs-number">-1</span>);  <br>        <span class="hljs-built_in">read</span>();  <br>        cout &lt;&lt; <span class="hljs-built_in">Dinic</span>() &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;  <br>    &#125;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;  <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addEdge</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> w)</span> </span>&#123;  <br>    e[cnt_E].to = y;  <br>    e[cnt_E].val = w;  <br>    e[cnt_E].nxt = head[x];  <br>    head[x] = cnt_E++;  <br>&#125;  <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;  <br>    <span class="hljs-type">int</span> u, v, w;  <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;  <br>        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;  <br>        <span class="hljs-built_in">addEdge</span>(u, v, w); <span class="hljs-comment">// 添加正向边  </span><br>        <span class="hljs-built_in">addEdge</span>(v, u, <span class="hljs-number">0</span>); <span class="hljs-comment">// 添加反向边，容量为0  </span><br>    &#125;  <br>&#125;  <br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span> </span>&#123;   <span class="hljs-comment">// bfs用于获得层次（分层图）  </span><br>    <span class="hljs-built_in">memset</span>(depth, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(depth));  <br>    depth[s] = <span class="hljs-number">1</span>; <span class="hljs-comment">// 源点的层次为1  </span><br>    queue&lt;<span class="hljs-type">int</span>&gt; q;  <br>    q.<span class="hljs-built_in">push</span>(s); <span class="hljs-comment">// 将源点加入队列  </span><br>    <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;  <br>        <span class="hljs-type">int</span> u = q.<span class="hljs-built_in">front</span>();  <br>        q.<span class="hljs-built_in">pop</span>();  <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = head[u]; i &gt; <span class="hljs-number">-1</span>; i = e[i].nxt) &#123;  <br>            <span class="hljs-type">int</span> v = e[i].to;  <br>            <span class="hljs-keyword">if</span> (e[i].val &amp;&amp; !depth[v]) &#123; <span class="hljs-comment">// 边有剩余容量且目标顶点未访问  </span><br>                depth[v] = depth[u] + <span class="hljs-number">1</span>; <span class="hljs-comment">// 更新目标顶点的层次  </span><br>                q.<span class="hljs-built_in">push</span>(v); <span class="hljs-comment">// 将目标顶点加入队列  </span><br>            &#125;  <br>        &#125;  <br>    &#125;  <br>    <span class="hljs-keyword">if</span> (depth[t] != <span class="hljs-number">0</span>) <span class="hljs-comment">// 如果汇点可达  </span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 返回true表示存在增广路径  </span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <br>&#125;  <br>  <br><span class="hljs-function">ll <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> pos, ll in)</span> </span>&#123; <span class="hljs-comment">// DFS用于寻找增广路径并计算流量  </span><br>    <span class="hljs-keyword">if</span> (pos == t) <span class="hljs-comment">// 如果当前顶点是汇点，则返回当前流量  </span><br>        <span class="hljs-keyword">return</span> in;  <br>    ll out = <span class="hljs-number">0</span>; <span class="hljs-comment">// 初始化当前顶点的流出量为0  </span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> u = head[pos]; u &gt; <span class="hljs-number">-1</span> &amp;&amp; in; u = e[u].nxt) &#123;  <br>        <span class="hljs-type">int</span> v = e[u].to;  <br>        <span class="hljs-comment">// 如果边有剩余容量且目标顶点的层次恰好是当前顶点层次加1  </span><br>        <span class="hljs-keyword">if</span> (e[u].val &amp;&amp; depth[v] == depth[pos] + <span class="hljs-number">1</span>) &#123;  <br>            <span class="hljs-comment">// 递归调用dfs寻找增广路径，并计算可以流过当前边的流量  </span><br>            ll res = <span class="hljs-built_in">dfs</span>(v, <span class="hljs-built_in">min</span>(e[u].val, in));  <br>            e[u].val -= res; <span class="hljs-comment">// 更新正向边的容量  </span><br>            e[u ^ <span class="hljs-number">1</span>].val += res; <span class="hljs-comment">// 更新反向边的容量  </span><br>            in -= res; <span class="hljs-comment">// 减少当前流量  </span><br>            out += res; <span class="hljs-comment">// 增加流出量  </span><br>        &#125;  <br>    &#125;  <br>    <span class="hljs-keyword">if</span> (out == <span class="hljs-number">0</span>)  <br>        <span class="hljs-comment">// 如果当前顶点没有流出量，则将其层次设为0，表示在后续的BFS中不会再访问  </span><br>        depth[pos] = <span class="hljs-number">0</span>;  <br>    <span class="hljs-keyword">return</span> out;  <br>&#125;  <br><span class="hljs-function">ll <span class="hljs-title">Dinic</span><span class="hljs-params">()</span> </span>&#123;  <br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">bfs</span>())   <span class="hljs-comment">// 存在增广路径  </span><br>        max_stream += <span class="hljs-built_in">dfs</span>(s, LL_INF);  <br>    <span class="hljs-keyword">return</span> max_stream;  <br>&#125;<br></code></pre></td></tr></table></figure></p><h5 id="最大二分匹配">最大二分匹配</h5><h6 id="dinic最小割最大流算法">Dinic最小割/最大流算法</h6><p>时间复杂度 <span class="math inline">\(O(VE)\)</span> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 最大流等于最小割  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;queue&gt;</span>  </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;  <br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e3</span>+<span class="hljs-number">10</span>, M = <span class="hljs-number">5e5</span>+<span class="hljs-number">1e4</span>+<span class="hljs-number">10</span>, INT = <span class="hljs-number">0x3f3f3f3f</span>;  <br><span class="hljs-comment">// 最大节点数(至少n+m+2) 最大边数(至少最大边数+n+m，因为有源点汇点的边) 无穷大常量  </span><br><span class="hljs-type">int</span> e[M], ne[M], f[M], h[N], idx;  <br><span class="hljs-comment">// e边的终点 ne下一条边的索引 f边的容量 h每个节点边的起始索引 idx边的索引  </span><br><span class="hljs-type">int</span> cur[N], d[N]; <span class="hljs-comment">// cur当前弧优化 d节点层次  </span><br><span class="hljs-comment">// 弧优化通过记录每次DFS搜索的断点，使得下一次DFS可以直接从上次搜索的断点继续，从而跳过那些已经饱和的边</span><br><span class="hljs-type">int</span> n, m, eNum, S, T; <span class="hljs-comment">// n: 节点数, m: 边数, S: 源点, T: 汇点  </span><br>  <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c)</span></span>;  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dinic</span><span class="hljs-params">()</span></span>;  <br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span></span>;  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> lim)</span></span>;  <br>  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;  <br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;eNum);  <br>    S = <span class="hljs-number">0</span>, T = n + m + <span class="hljs-number">1</span>; <span class="hljs-comment">// 设置源点和汇点  </span><br>    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> h);  <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) <span class="hljs-built_in">add</span>(S, i, <span class="hljs-number">1</span>); <span class="hljs-comment">// 添加源点到左侧点的边  </span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n + <span class="hljs-number">1</span>; i &lt;= n+m; i++) <span class="hljs-built_in">add</span>(i, T, <span class="hljs-number">1</span>); <span class="hljs-comment">// 添加右侧点到汇点的边  </span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= eNum; i++)&#123;  <br>        <span class="hljs-type">int</span> a, b;  <br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);  <br>        <span class="hljs-built_in">add</span>(a, b+n, <span class="hljs-number">1</span>); <span class="hljs-comment">// 起点 终点 容量为1  </span><br>    &#125;  <br>    cout &lt;&lt; <span class="hljs-built_in">dinic</span>() &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; <span class="hljs-comment">// 输出二分图最大匹配的边数  </span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;idx;i+=<span class="hljs-number">2</span>)  <span class="hljs-comment">// 输出二分图匹配的点对  </span><br>    &#123;  <br>        <span class="hljs-keyword">if</span>(e[i]&gt;n &amp;&amp; e[i]&lt;=n+m &amp;&amp; !f[i]) <span class="hljs-comment">// 是右侧的边且剩余容量为0(这条边在最大流中已经被完全使用)  </span><br>        &#123;  <br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d\n&quot;</span>,e[i^<span class="hljs-number">1</span>],e[i]-n); <span class="hljs-comment">// 左侧的点 右侧的点  </span><br>        &#125;  <br>    &#125;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;  <br>  <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c)</span></span>&#123; <span class="hljs-comment">// a: 起点, b: 终点, c: 容量  </span><br>    e[idx] = b, f[idx] = c, ne[idx] = h[a], h[a] = idx++; <span class="hljs-comment">// 添加正向边  </span><br>    e[idx] = a, f[idx] = <span class="hljs-number">0</span>, ne[idx] = h[b], h[b] = idx++; <span class="hljs-comment">// 添加反向边，容量为0  </span><br>&#125;  <br>  <br><span class="hljs-comment">// Dinic算法主函数  </span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dinic</span><span class="hljs-params">()</span></span>&#123;  <br>    <span class="hljs-type">int</span> r = <span class="hljs-number">0</span>, flow; <span class="hljs-comment">// 初始化最大流为0  </span><br>    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">bfs</span>()) <span class="hljs-comment">// 当BFS可以构建分层图时  </span><br>        <span class="hljs-keyword">while</span>(flow = <span class="hljs-built_in">dfs</span>(S, INT))  <br>            r += flow; <span class="hljs-comment">// 通过DFS寻找增广路径并累加流量  </span><br>    <span class="hljs-keyword">return</span> r; <span class="hljs-comment">// 返回最大流  </span><br>&#125;  <br>  <br><span class="hljs-comment">// BFS用于分层图构建  </span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span></span>&#123;  <br>    queue&lt;<span class="hljs-type">int</span>&gt; q;  <br>    q.<span class="hljs-built_in">push</span>(S); <span class="hljs-comment">// 将源点加入队列  </span><br>    <span class="hljs-built_in">memset</span>(d, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> d);  <br>    d[S] = <span class="hljs-number">0</span>, cur[S] = h[S]; <span class="hljs-comment">// 源点的层次为0，初始化当前弧  </span><br>    <span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>())&#123;  <br>        <span class="hljs-type">int</span> t = q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">pop</span>();  <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = h[t]; ~i; i = ne[i])&#123; <span class="hljs-comment">// 遍历所有邻接边  </span><br>            <span class="hljs-type">int</span> ver = e[i]; <span class="hljs-comment">// 邻接边的终点  </span><br>            <span class="hljs-keyword">if</span>(d[ver] == <span class="hljs-number">-1</span> &amp;&amp; f[i])&#123; <span class="hljs-comment">// 如果终点未访问且正向边有容量  </span><br>                d[ver] = d[t] + <span class="hljs-number">1</span>; <span class="hljs-comment">// 更新终点层次  </span><br>                cur[ver] = h[ver]; <span class="hljs-comment">// 初始化当前弧  </span><br>                <span class="hljs-keyword">if</span>(ver == T) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 如果到达汇点，返回true  </span><br>                q.<span class="hljs-built_in">push</span>(ver); <span class="hljs-comment">// 将终点加入队列  </span><br>            &#125;  <br>        &#125;  <br>    &#125;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 如果无法到达汇点，返回false  </span><br>&#125;  <br>  <br><span class="hljs-comment">// DFS用于寻找增广路径  </span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> lim)</span></span>&#123;  <br>    <span class="hljs-keyword">if</span>(u == T) <span class="hljs-keyword">return</span> lim; <span class="hljs-comment">// 如果到达汇点，返回剩余流量  </span><br>    <span class="hljs-type">int</span> flow = <span class="hljs-number">0</span>; <span class="hljs-comment">// 初始化当前节点的流量为0  </span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = cur[u]; ~i &amp;&amp; flow &lt; lim; i = ne[i])&#123; <span class="hljs-comment">// 遍历当前节点所有邻接边  </span><br>        <span class="hljs-type">int</span> ver = e[i]; <span class="hljs-comment">// 邻接边的终点  </span><br>        cur[u] = i; <span class="hljs-comment">// 更新当前弧  </span><br>        <span class="hljs-keyword">if</span>(d[ver] == d[u] + <span class="hljs-number">1</span> &amp;&amp; f[i])&#123; <span class="hljs-comment">// 如果终点层次正确且正向边有容量  </span><br>            <span class="hljs-type">int</span> t = <span class="hljs-built_in">dfs</span>(ver, <span class="hljs-built_in">min</span>(f[i], lim - flow)); <span class="hljs-comment">// 递归寻找增广路径  </span><br>            <span class="hljs-keyword">if</span>(!t)  <br>                d[ver] = <span class="hljs-number">-1</span>; <span class="hljs-comment">// 如果无法增广，更新终点层次为-1  </span><br>            f[i] -= t, f[i^<span class="hljs-number">1</span>] += t, flow += t; <span class="hljs-comment">// 更新正向边和反向边的容量，累加流量  </span><br>        &#125;  <br>    &#125;  <br>    <span class="hljs-keyword">return</span> flow; <span class="hljs-comment">// 返回当前节点的流量  </span><br>&#125;<br></code></pre></td></tr></table></figure>###### 匈牙利算法 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span>  </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;  <br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">555</span>;   <span class="hljs-comment">// 定义最大可能的节点数  </span><br>vector&lt;<span class="hljs-type">int</span>&gt; G[N];  <span class="hljs-comment">// 邻接表，用于存储每个男生的认识的女生的列表  </span><br><span class="hljs-type">int</span> match[N],vis[N];  <br><span class="hljs-comment">// match用于存储谁（i）和谁（match[i]）匹配  </span><br><span class="hljs-comment">// vis用于存储当前这一边搜索是否已经让某个男生找过增广路了  </span><br><span class="hljs-type">bool</span> used[N][N];   <span class="hljs-comment">// 用于标记某个男生和女生之间是否有边  </span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">hungary</span><span class="hljs-params">(<span class="hljs-type">int</span> p,<span class="hljs-type">int</span> op)</span></span>;  <br>  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;  <br>    <span class="hljs-type">int</span> n,m,e,a,b; <span class="hljs-comment">// n男生数 m女生数 e边数 a男生编号 b女生编号  </span><br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;e);  <br>    <span class="hljs-keyword">while</span>(e--)&#123;  <br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;a,&amp;b); <span class="hljs-comment">//a范围1~n b范围1~m  </span><br>        <span class="hljs-keyword">if</span>(used[a][b]) <span class="hljs-comment">//判重边  </span><br>            <span class="hljs-keyword">continue</span>;  <br>        used[a][b]=<span class="hljs-literal">true</span>;  <br>        G[a].<span class="hljs-built_in">push_back</span>(b);  <br>    &#125;  <br>    <span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;  <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)  <br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">hungary</span>(i,i))    <span class="hljs-comment">// 第i个男生，同时也是第i次搜寻  </span><br>            ans++;  <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,ans);  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;  <br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">hungary</span><span class="hljs-params">(<span class="hljs-type">int</span> p,<span class="hljs-type">int</span> op)</span></span>&#123;  <span class="hljs-comment">// p表示第几个男生，op表示第几趟匹配  </span><br>    <span class="hljs-keyword">if</span>(vis[p]==op) <span class="hljs-comment">// 如果当前男生在当前轮次已经找过增广路径，返回false  </span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <br>    vis[p]=op;  <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i:G[p])&#123;    <span class="hljs-comment">// 对于每个男生p，遍历一遍他认识的女生  </span><br>        <span class="hljs-keyword">if</span>(!match[i]||<span class="hljs-built_in">hungary</span>(match[i],op))&#123;  <br>            <span class="hljs-comment">// 如果当前的女生没被匹配到，自然可以直接让她与当前的男生p进行匹配  </span><br>            <span class="hljs-comment">// 如果已经被匹配过，则尝试让匹配她的那个男生去再找找看其他女生（开始套娃），  </span><br>            <span class="hljs-comment">// 如果返回true也可以正常匹配  </span><br>            match[i]=p;  <br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <br>        &#125;  <br>    &#125;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <br>&#125;<br></code></pre></td></tr></table></figure></p><h5 id="最小生成树">最小生成树</h5><h6 id="prim-朴素版">prim-朴素版</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span>  </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;  <br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">2005</span>,M = <span class="hljs-number">5005</span>,INF = <span class="hljs-number">0x3f3f3f3f</span>;  <br><span class="hljs-comment">// N最大节点数 M最大边数 INF无穷大  </span><br><span class="hljs-type">int</span> n,m;  <br><span class="hljs-type">int</span> g[N][N]; <span class="hljs-comment">// g为图的邻接矩阵，存储所有节点之间的边权重  </span><br><span class="hljs-type">int</span> dist[N]; <span class="hljs-comment">// dist存储从已选节点集合到未选节点集合的最小距离  </span><br><span class="hljs-type">bool</span> used[N];<span class="hljs-comment">// used标记节点是否已被添加到最小生成树中  </span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">prim</span><span class="hljs-params">()</span></span>;  <br>  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;  <br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m); <span class="hljs-comment">// 读取节点数和边数  </span><br>    <span class="hljs-comment">//重要  </span><br>    <span class="hljs-built_in">memset</span>(g,<span class="hljs-number">0x3f</span>,<span class="hljs-built_in">sizeof</span>(g));  <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; m; i++)&#123;  <br>        <span class="hljs-type">int</span> u,v,w; <span class="hljs-comment">// 读取边(u, v)的权重w  </span><br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;u,&amp;v,&amp;w);  <br>        g[u][v] = g[v][u] = <span class="hljs-built_in">min</span>(g[u][v],w); <span class="hljs-comment">// 更新邻接矩阵，保证是无向图且权重最小  </span><br>    &#125;  <br>  <br>    <span class="hljs-type">int</span> r = <span class="hljs-built_in">prim</span>(); <span class="hljs-comment">// 调用prim函数计算最小生成树的权重和  </span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,r);  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;  <br>  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">prim</span><span class="hljs-params">()</span></span>&#123; <span class="hljs-comment">// 返回最小生成树的权重和  </span><br>    <span class="hljs-built_in">memset</span>(dist,<span class="hljs-number">0x3f</span>,<span class="hljs-keyword">sizeof</span> dist);  <br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>; <span class="hljs-comment">// res用于存储最小生成树的权重和  </span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++)&#123;  <br>        <span class="hljs-type">int</span> t = <span class="hljs-number">-1</span>; <span class="hljs-comment">// t用于存储当前未选节点中距离已选节点集合最近的节点  </span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j &lt;= n; j++)&#123;  <br>            <span class="hljs-keyword">if</span>((!used[j]) &amp;&amp; (t == <span class="hljs-number">-1</span> || dist[t] &gt; dist[j]))  <br>                t = j;  <br>        &#125;  <br>        used[t] = <span class="hljs-literal">true</span>;  <br>        <span class="hljs-comment">// 如果不是第一个节点且距离为无穷大，说明图不连通，返回无穷大  </span><br>        <span class="hljs-keyword">if</span>(i &amp;&amp; dist[t] == INF) <span class="hljs-keyword">return</span> INF;  <br>        <span class="hljs-keyword">if</span>(i)res += dist[t]; <span class="hljs-comment">// 如果不是第一个节点，累加到res中  </span><br>  <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j &lt;= n;j++)&#123; <span class="hljs-comment">// 更新未选节点的距离  </span><br>            <span class="hljs-keyword">if</span>(!used[j])  <br>                dist[j] = <span class="hljs-built_in">min</span>(dist[j],g[t][j]);  <br>        &#125;  <br>    &#125;  <br>    <span class="hljs-keyword">return</span> res;  <br>&#125;<br></code></pre></td></tr></table></figure><h6 id="prim-堆优化">prim-堆优化</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span>  </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;  <br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INF 2147483647  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N (100000+10)  </span><br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;pii;  <br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">cmp</span>&#123;  <br>    <span class="hljs-comment">//自定义排序方法 因为我定义的优先队列里，边权和是第二个元素，如果直接greater，它会默认按第一个元素排序  </span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(pii &amp;a,pii &amp;b)</span></span>&#123;  <br>        <span class="hljs-keyword">return</span> a.second&gt;b.second;  <br>    &#125;  <br>&#125;;  <br>vector&lt;pii&gt;e[N]; <span class="hljs-comment">// 邻接表，e[i] 存储与节点 i 相连的边和对应的权重  </span><br><span class="hljs-type">int</span> d[N],vis[N],cnt,sum,n,m;  <br><span class="hljs-comment">// d存储最小距离，vis标记节点是否已访问，cnt计数，sum总权重，n节点数，m边数  </span><br>priority_queue &lt;pii,vector&lt;pii&gt;,cmp &gt; q; <span class="hljs-comment">// 优先队列，用于存储和获取最小边  </span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add_edge</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> z)</span></span>;  <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>;  <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">prim</span><span class="hljs-params">()</span></span>;  <br>  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;  <br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m); <span class="hljs-comment">// 节点数n 边数m  </span><br>    <span class="hljs-built_in">init</span>(n);  <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=m; i++)&#123;  <br>        <span class="hljs-type">int</span> x,y,z; <span class="hljs-comment">// 边(x, y)的权重z  </span><br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;x,&amp;y,&amp;z);  <br>        <span class="hljs-built_in">add_edge</span>(x,y,z);  <br>    &#125;  <br>    <span class="hljs-built_in">prim</span>(); <span class="hljs-comment">// 调用prim函数计算最小生成树的权重和  </span><br>    <span class="hljs-keyword">if</span> (cnt==n) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,sum); <span class="hljs-comment">// 有最小生成树  </span><br>    <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;orz&quot;</span>); <span class="hljs-comment">// 否则输出&quot;orz&quot;，表示图不连通  </span><br>&#125;  <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add_edge</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> z)</span></span>&#123;  <span class="hljs-comment">//邻接表存图  </span><br>    e[x].<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">make_pair</span>(y, z));  <br>    e[y].<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">make_pair</span>(x, z)); <span class="hljs-comment">// 无向图，添加边(y, x)权重z  </span><br>&#125;  <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>&#123; <span class="hljs-comment">//初始化  </span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) e[i].<span class="hljs-built_in">clear</span>();  <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) d[i] = INF;  <br>&#125;  <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">prim</span><span class="hljs-params">()</span></span>&#123;  <br>    d[<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>; <span class="hljs-comment">// 从节点1开始，将其距离设为0  </span><br>    q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_pair</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>)); <span class="hljs-comment">// 将节点1和距离0加入优先队列  </span><br>    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>() &amp;&amp; cnt&lt;n)&#123; <span class="hljs-comment">// 当队列不为空且处理过的节点数小于n时  </span><br>        <span class="hljs-type">int</span> now=q.<span class="hljs-built_in">top</span>().first; <span class="hljs-comment">// 当前处理的节点  </span><br>        <span class="hljs-type">int</span> dis=q.<span class="hljs-built_in">top</span>().second; <span class="hljs-comment">// 当前节点的最小距离  </span><br>        q.<span class="hljs-built_in">pop</span>(); <span class="hljs-comment">// 弹出当前节点  </span><br>        <span class="hljs-keyword">if</span>(vis[now]) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// 如果当前节点已访问，跳过  </span><br>        cnt++; <span class="hljs-comment">// 计数增加  </span><br>        sum += dis; <span class="hljs-comment">// 累加到总权重  </span><br>        vis[now] = <span class="hljs-number">1</span>; <span class="hljs-comment">// 标记当前节点为已访问  </span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;e[now].<span class="hljs-built_in">size</span>(); i++)&#123; <span class="hljs-comment">// 遍历当前节点的所有邻接边  </span><br>            <span class="hljs-type">int</span> v=e[now][i].first; <span class="hljs-comment">// 邻接节点  </span><br>            <span class="hljs-keyword">if</span>(d[v]&gt;e[now][i].second)&#123; <span class="hljs-comment">// 如果找到更小的距离  </span><br>                d[v]=e[now][i].second; <span class="hljs-comment">// 更新最小距离  </span><br>                q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_pair</span>(v,d[v])); <span class="hljs-comment">// 将新距离和节点加入优先队列  </span><br>            &#125;  <br>        &#125;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><h6 id="kruskal">kruskal</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> V_MAX 300005 <span class="hljs-comment">// 定义最大顶点数  </span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> E_MAX 500005 <span class="hljs-comment">// 定义最大边数  </span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;  <br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;  <br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span> &#123;  <br>    <span class="hljs-type">int</span> x, y, w;    <span class="hljs-comment">// 起点 终点 权重  </span><br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> Edge &amp;b) <span class="hljs-type">const</span> &#123; <span class="hljs-keyword">return</span> w &lt; b.w; &#125;  <br>&#125; e[E_MAX];  <br><span class="hljs-type">int</span> v[V_MAX]; <span class="hljs-comment">// 并查集数组，用于存储每个顶点的父节点  </span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>; <span class="hljs-comment">// 查找元素x所在集合的代表元素  </span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isUnion</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span>; <span class="hljs-comment">// 判断两个元素是否在同一个集合中  </span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Union</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span>; <span class="hljs-comment">// 合并两个集合  </span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">makeSet</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>; <span class="hljs-comment">// 初始化并查集  </span><br>  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;  <br>    <span class="hljs-type">int</span> n, m;  <br>    cin &gt;&gt; n &gt;&gt; m; <span class="hljs-comment">// n为顶点数，m为边数  </span><br>    <span class="hljs-built_in">makeSet</span>(n);  <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)  <br>        cin &gt;&gt; e[i].x &gt;&gt; e[i].y &gt;&gt; e[i].w;  <br>    <span class="hljs-built_in">sort</span>(e, e + m); <span class="hljs-comment">// 按权重从小到大对边进行排序  </span><br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>; <span class="hljs-comment">// 已加入最小生成树的边数  </span><br>    ll sum = <span class="hljs-number">0</span>; <span class="hljs-comment">// 最小生成树的总权重  </span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; cnt &lt; n - <span class="hljs-number">1</span>; i++)&#123; <span class="hljs-comment">// 循环直到找到n-1条边  </span><br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isUnion</span>(e[i].x, e[i].y)) <span class="hljs-comment">// 如果两个顶点已经在同一个集合中，跳过这条边  </span><br>            <span class="hljs-keyword">continue</span>;  <br>        cnt++;  <br>        sum += e[i].w;  <br>        <span class="hljs-built_in">Union</span>(e[i].x, e[i].y); <br>    &#125;  <br>    cout &lt;&lt; sum; <span class="hljs-comment">// 输出最小生成树的总权重  </span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;  <br>  <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">makeSet</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123; <span class="hljs-comment">// 初始化并查集，每个顶点自成一个集合  </span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)  <br>        v[i] = i; <span class="hljs-comment">// 初始化顶点i的父节点为自身  </span><br>&#125;  <br>  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123; <span class="hljs-comment">// 查找x所在集合的代表元素，并进行路径压缩  </span><br>    <span class="hljs-keyword">if</span> (v[x] == x)  <span class="hljs-comment">// 如果x是代表元素，直接返回  </span><br>        <span class="hljs-keyword">return</span> x;  <br>    <span class="hljs-keyword">return</span> v[x] = <span class="hljs-built_in">Find</span>(v[x]); <span class="hljs-comment">// 否则递归查找并路径压缩  </span><br>&#125;  <br>  <br><span class="hljs-comment">// 判断两个元素是否在同一个集合中  </span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isUnion</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">Find</span>(x) == <span class="hljs-built_in">Find</span>(y); &#125;  <br><span class="hljs-comment">// 合并两个集合，将y所在集合的代表元素指向x所在集合的代表元素  </span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Union</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123; v[<span class="hljs-built_in">Find</span>(y)] = <span class="hljs-built_in">Find</span>(x); &#125;<br></code></pre></td></tr></table></figure><h5 id="傅里叶变换">傅里叶变换</h5><p>最高次数为n，次数界可以为n, n+1, n+2, 2n 对于次数界为n的多项式 <spanclass="math inline">\(A(x) = \sum\limits_{j=0}^{n-1}a_{j}x^{j}\)</span>，dft求的是 <span class="math inline">\(y_{k} =A(\omega_{n}^{k})=\sum\limits_{j=0}^{n-1}a_{j}\omega_{n}^{kj}\)</span>即 <span class="math inline">\(y = DFT_{n}(a)\)</span> 其中 <spanclass="math inline">\(ω=cos\frac{2π}{2^{n}}+i\sin\frac{2π}{2^{n}}\)</span> ###### 多项式乘法-普通版 时间复杂度 <spanclass="math inline">\(\Theta(nlgn)\)</span> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span>  </span><br>  <br><span class="hljs-type">const</span> <span class="hljs-type">double</span> Pi = <span class="hljs-built_in">acos</span>(<span class="hljs-number">-1</span>);  <br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX = <span class="hljs-number">4000005</span>;  <span class="hljs-comment">// 字符串最大长度</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;  <br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;  <br>  <br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Complex</span> &#123;  <br><span class="hljs-type">double</span> x, y; <span class="hljs-comment">// 实部和虚部</span><br>Complex <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> Complex &amp;b) <span class="hljs-type">const</span> &#123;  <br><span class="hljs-keyword">return</span> &#123;x + b.x, y + b.y&#125;;  <br>&#125;  <br>  <br>Complex <span class="hljs-keyword">operator</span>-(<span class="hljs-type">const</span> Complex &amp;b) <span class="hljs-type">const</span> &#123;  <br><span class="hljs-keyword">return</span> &#123;x - b.x, y - b.y&#125;;  <br>&#125;  <br>  <br>Complex <span class="hljs-keyword">operator</span>*(<span class="hljs-type">const</span> Complex &amp;b) <span class="hljs-type">const</span> &#123;  <br><span class="hljs-keyword">return</span> &#123;x * b.x - y * b.y, x * b.y + y * b.x&#125;;  <br>&#125;  <br>&#125; f[MAX], p[MAX], sav[MAX];  <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dft</span><span class="hljs-params">(Complex *f, <span class="hljs-type">int</span> len)</span></span>;  <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">idft</span><span class="hljs-params">(Complex *f, <span class="hljs-type">int</span> len)</span></span>;  <br>  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;  <br><span class="hljs-type">int</span> n, m;  <br>cin &gt;&gt; n &gt;&gt; m;  <span class="hljs-comment">// 第一个多项式最多n次，第二个最多m次</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++)  <br>cin &gt;&gt; f[i].x;  <span class="hljs-comment">// 读入第一个多项式的系数</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= m; i++)  <br>cin &gt;&gt; p[i].x;  <span class="hljs-comment">// 读入第二个多项式的系数</span><br><span class="hljs-keyword">for</span> (m += n, n = <span class="hljs-number">1</span>; n &lt;= m; n &lt;&lt;= <span class="hljs-number">1</span>);  <span class="hljs-comment">// 相乘最多n+m位</span><br><span class="hljs-built_in">dft</span>(f, n); <span class="hljs-comment">// 对第一个多项式进行DFT</span><br><span class="hljs-built_in">dft</span>(p, n); <span class="hljs-comment">// 对第二个多项式进行DFT</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)  <br>f[i] = f[i] * p[i]; <span class="hljs-comment">// 点乘得到乘积的DFT</span><br><span class="hljs-built_in">idft</span>(f, n); <span class="hljs-comment">// 对结果进行逆DFT</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= m; i++)  <br>cout &lt;&lt; (<span class="hljs-type">int</span>) (f[i].x / n + <span class="hljs-number">0.49</span>) &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;  <span class="hljs-comment">// 四舍五入</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;  <br>  <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dft</span><span class="hljs-params">(Complex *f, <span class="hljs-type">int</span> len)</span> </span>&#123;  <br><span class="hljs-keyword">if</span> (len == <span class="hljs-number">1</span>)  <br><span class="hljs-keyword">return</span>;  <br>Complex *fl = f, *fr = f + len / <span class="hljs-number">2</span>; <span class="hljs-comment">// 分治法，将数组分为两部分</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; len; k++)  <br>sav[k] = f[k]; <span class="hljs-comment">// 备份原数组</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; len / <span class="hljs-number">2</span>; k++) &#123;  <br>fl[k] = sav[k &lt;&lt; <span class="hljs-number">1</span>]; <span class="hljs-comment">// 分配偶数次的系数到左子数组</span><br>fr[k] = sav[k &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>]; <span class="hljs-comment">// 分配奇数次的系数到右子数组</span><br>&#125;  <br><span class="hljs-built_in">dft</span>(fl, len / <span class="hljs-number">2</span>);  <br><span class="hljs-built_in">dft</span>(fr, len / <span class="hljs-number">2</span>);  <br>Complex tG = &#123;<span class="hljs-built_in">cos</span>(<span class="hljs-number">2</span> * Pi / len), <span class="hljs-built_in">sin</span>(<span class="hljs-number">2</span> * Pi / len)&#125;;  <span class="hljs-comment">// omega_n单位根</span><br>Complex buf = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;;  <span class="hljs-comment">// omega初始化旋转因子</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; len / <span class="hljs-number">2</span>; k++) &#123;  <br>sav[k] = fl[k] + buf * fr[k]; <span class="hljs-comment">// 合并结果</span><br>sav[k + len / <span class="hljs-number">2</span>] = fl[k] - buf * fr[k];  <br>buf = buf * tG;  <span class="hljs-comment">// omega = omega*omega_n更新旋转因子</span><br>&#125;  <br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; len; k++)  <br>f[k] = sav[k];  <br>&#125;  <br>  <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">idft</span><span class="hljs-params">(Complex *f, <span class="hljs-type">int</span> len)</span> </span>&#123;  <br><span class="hljs-keyword">if</span> (len == <span class="hljs-number">1</span>)  <br><span class="hljs-keyword">return</span>;  <br>Complex *fl = f, *fr = f + len / <span class="hljs-number">2</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; len; k++)  <br>sav[k] = f[k];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; len / <span class="hljs-number">2</span>; k++) &#123;  <br>fl[k] = sav[k &lt;&lt; <span class="hljs-number">1</span>];  <br>fr[k] = sav[k &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>];  <br>&#125;  <br><span class="hljs-built_in">idft</span>(fl, len / <span class="hljs-number">2</span>);  <br><span class="hljs-built_in">idft</span>(fr, len / <span class="hljs-number">2</span>);  <br>Complex tG = &#123;<span class="hljs-built_in">cos</span>(<span class="hljs-number">2</span> * Pi / len), -<span class="hljs-built_in">sin</span>(<span class="hljs-number">2</span> * Pi / len)&#125;; <span class="hljs-comment">// 与dft唯一的区别</span><br>Complex buf = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;;  <br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; len / <span class="hljs-number">2</span>; k++) &#123;  <br>sav[k] = fl[k] + buf * fr[k];  <br>sav[k + len / <span class="hljs-number">2</span>] = fl[k] - buf * fr[k];  <br>buf = buf * tG;  <br>&#125;  <br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; len; k++)  <br>f[k] = sav[k];  <br>&#125;<br></code></pre></td></tr></table></figure></p><h6 id="多项式乘法-高效版位逆序版">多项式乘法-高效版/位逆序版</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span>  </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;  <br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">1000000</span> + <span class="hljs-number">7</span>;  <br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PI acos(-1)  </span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Complex</span> &#123;  <br>    <span class="hljs-type">double</span> x, y; <span class="hljs-comment">// 实部和虚部  </span><br>    Complex <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> Complex &amp;b) <span class="hljs-type">const</span> &#123;  <br>        <span class="hljs-keyword">return</span> &#123;x + b.x, y + b.y&#125;;  <br>    &#125;  <br>  <br>    Complex <span class="hljs-keyword">operator</span>-(<span class="hljs-type">const</span> Complex &amp;b) <span class="hljs-type">const</span> &#123;  <br>        <span class="hljs-keyword">return</span> &#123;x - b.x, y - b.y&#125;;  <br>    &#125;  <br>  <br>    Complex <span class="hljs-keyword">operator</span>*(<span class="hljs-type">const</span> Complex &amp;b) <span class="hljs-type">const</span> &#123;  <br>        <span class="hljs-keyword">return</span> &#123;x * b.x - y * b.y, x * b.y + y * b.x&#125;;  <br>    &#125;  <br>&#125;;  <br>  <br><span class="hljs-type">int</span> n,m; <span class="hljs-comment">// 两个多项式的次数  </span><br>Complex a[maxn*<span class="hljs-number">3</span>], b[maxn*<span class="hljs-number">3</span>]; <span class="hljs-comment">// 存储多项式的系数  </span><br><span class="hljs-type">int</span> pos[maxn*<span class="hljs-number">3</span>]; <span class="hljs-comment">// 定义位置数组，用于FFT中的位置交换  </span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">FFT</span><span class="hljs-params">(Complex*A, <span class="hljs-type">int</span> len, <span class="hljs-type">int</span> type)</span></span>;  <br>  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;  <br>    <span class="hljs-type">int</span> x;pos[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;  <br>    <span class="hljs-type">int</span> maxLen = <span class="hljs-number">1</span>, l = <span class="hljs-number">0</span>; <span class="hljs-comment">// maxLen为FFT的长度，l为log2(maxLen)  </span><br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);  <br>    <span class="hljs-keyword">while</span>(maxLen &lt; n+m+<span class="hljs-number">1</span>)&#123;  <br>        maxLen&lt;&lt;=<span class="hljs-number">1</span>;  <br>        l++;  <br>    &#125;  <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;=n;i++)&#123; <span class="hljs-comment">// 第一个多项式的系数  </span><br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lf&quot;</span>,&amp;a[i].x);  <br>    &#125;  <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;=m;i++)&#123; <span class="hljs-comment">// 读取第二个多项式的系数  </span><br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lf&quot;</span>,&amp;b[i].x);  <br>    &#125;  <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;maxLen;i++)&#123; <span class="hljs-comment">// 求最后交换的位置（奇数特殊处理）  </span><br>        pos[i] = (pos[i&gt;&gt;<span class="hljs-number">1</span>]&gt;&gt;<span class="hljs-number">1</span>)|((i&amp;<span class="hljs-number">1</span>)&lt;&lt;(l<span class="hljs-number">-1</span>));  <br>        <span class="hljs-comment">// 计算每个索引i的位逆序位置(将一个数的二进制位顺序颠倒011-&gt;110)  </span><br>        <span class="hljs-comment">// i&gt;&gt;1 将i的二进制位右移一位，即去掉最低位  </span><br>        <span class="hljs-comment">// pos[i&gt;&gt;1]&gt;&gt;1 取i的前面所有位（去掉最低位）的位逆序，然后再右移一位  </span><br>        <span class="hljs-comment">// (i&amp;1)&lt;&lt;(l-1) 取i的最低位，并将其左移到最高位的位置  </span><br>        <span class="hljs-comment">// 通过|操作将两部分合并，得到i的位逆序  </span><br>    &#125;  <br>  <br>    <span class="hljs-built_in">FFT</span>(a,maxLen,<span class="hljs-number">1</span>);  <br>    <span class="hljs-built_in">FFT</span>(b,maxLen,<span class="hljs-number">1</span>);  <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;maxLen;i++)  <br>        a[i] = a[i]*b[i];  <br>  <br>    <span class="hljs-built_in">FFT</span>(a,maxLen,<span class="hljs-number">-1</span>); <span class="hljs-comment">// 对结果进行IDFT  </span><br>  <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;n+m+<span class="hljs-number">1</span>; i++)&#123;  <br>        <span class="hljs-keyword">if</span>(i!=<span class="hljs-number">0</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; &quot;</span>);  <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,(<span class="hljs-type">int</span>)(a[i].x+<span class="hljs-number">0.49</span>));  <br>    &#125;  <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;  <br><span class="hljs-comment">// A为输入数组，len为长度，type为1表示DFT，-1表示IDFT  </span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">FFT</span><span class="hljs-params">(Complex*A, <span class="hljs-type">int</span> len, <span class="hljs-type">int</span> type)</span></span>&#123;  <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;len; i++)&#123;<span class="hljs-comment">//将数组A中的元素按照位逆序的位置进行交换  </span><br>        <span class="hljs-keyword">if</span>(i&lt;pos[i])<span class="hljs-comment">// 如果i已经小于其逆序位置pos[i]，则说明这一对已经交换过  </span><br>            <span class="hljs-built_in">swap</span>(A[i], A[pos[i]]);<span class="hljs-comment">//保证每对只交换一次  </span><br>    &#125;  <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> L=<span class="hljs-number">2</span>; L&lt;=len; L&lt;&lt;=<span class="hljs-number">1</span>)&#123;<span class="hljs-comment">//循环合并的区间长度  </span><br>        <span class="hljs-type">int</span> HLen = L/<span class="hljs-number">2</span>;<span class="hljs-comment">//区间的一半  </span><br>        Complex Wn = &#123;<span class="hljs-built_in">cos</span>(<span class="hljs-number">2.0</span>*PI/L), type*<span class="hljs-built_in">sin</span>(<span class="hljs-number">2.0</span>*PI/L)&#125;; <span class="hljs-comment">// 计算单位根  </span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> R=<span class="hljs-number">0</span>; R&lt;len; R+=L)&#123;<span class="hljs-comment">//每个小区间的起点  </span><br>            Complex w = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;; <span class="hljs-comment">// 初始化旋转因子  </span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>; k&lt;HLen; k++, w=w*Wn)&#123;<span class="hljs-comment">//求该区间下的值  </span><br>                Complex Buf = A[R+k];<span class="hljs-comment">//蝴蝶操作，去掉odd和even数组，使变化原地进行  </span><br>                A[R+k] =  A[R+k] + w*A[R+k+HLen];  <br>                A[R+k+HLen] = Buf - w*A[R+k+HLen];  <br>            &#125;  <br>        &#125;  <br>    &#125;  <br>    <span class="hljs-keyword">if</span> (type == <span class="hljs-number">-1</span>) &#123;  <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;  <br>            A[i].x /= len;  <br>            A[i].y /= len;  <br>        &#125;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 位逆序代码</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span>  </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;  <br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">1000000</span> + <span class="hljs-number">7</span>;  <br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PI acos(-1)  </span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Complex</span> &#123;  <br>    <span class="hljs-type">int</span> x, y; <span class="hljs-comment">// 实部和虚部  </span><br>    Complex <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> Complex &amp;b) <span class="hljs-type">const</span> &#123;  <br>        <span class="hljs-keyword">return</span> &#123;x + b.x, y + b.y&#125;;  <br>    &#125;  <br>    Complex <span class="hljs-keyword">operator</span>-(<span class="hljs-type">const</span> Complex &amp;b) <span class="hljs-type">const</span> &#123;  <br>        <span class="hljs-keyword">return</span> &#123;x - b.x, y - b.y&#125;;  <br>    &#125;  <br>    Complex <span class="hljs-keyword">operator</span>*(<span class="hljs-type">const</span> Complex &amp;b) <span class="hljs-type">const</span> &#123;  <br>        <span class="hljs-keyword">return</span> &#123;x * b.x - y * b.y, x * b.y + y * b.x&#125;;  <br>    &#125;  <br>&#125;;  <br>  <br><span class="hljs-type">int</span> n,m; <span class="hljs-comment">// 两个多项式的次数  </span><br>Complex a[maxn*<span class="hljs-number">3</span>], b[maxn*<span class="hljs-number">3</span>]; <span class="hljs-comment">// 存储多项式的系数  </span><br><span class="hljs-type">int</span> pos[maxn*<span class="hljs-number">3</span>]; <span class="hljs-comment">// 定义位置数组，用于FFT中的位置交换  </span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">FFT</span><span class="hljs-params">(Complex*A, <span class="hljs-type">int</span> len, <span class="hljs-type">int</span> type)</span></span>;  <br>  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;  <br>    <span class="hljs-type">int</span> x;pos[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;  <br>    <span class="hljs-type">int</span> maxLen = <span class="hljs-number">1</span>, l = <span class="hljs-number">0</span>; <span class="hljs-comment">// maxLen为FFT的长度，l为log2(maxLen)  </span><br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);  <br>    <span class="hljs-keyword">while</span>(maxLen &lt; n)&#123;  <br>        maxLen&lt;&lt;=<span class="hljs-number">1</span>;  <br>        l++;  <br>    &#125;  <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;n;i++)&#123; <span class="hljs-comment">// 第一个多项式的系数  </span><br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i].x);  <br>    &#125;  <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;n;i++)&#123; <span class="hljs-comment">// 求最后交换的位置（奇数特殊处理）  </span><br>        pos[i] = (pos[i&gt;&gt;<span class="hljs-number">1</span>]&gt;&gt;<span class="hljs-number">1</span>)|((i&amp;<span class="hljs-number">1</span>)&lt;&lt;(l<span class="hljs-number">-1</span>));  <br>        <span class="hljs-comment">// 计算每个索引i的位逆序位置(将一个数的二进制位顺序颠倒011-&gt;110)  </span><br>        <span class="hljs-comment">// i&gt;&gt;1 将i的二进制位右移一位，即去掉最低位  </span><br>        <span class="hljs-comment">// pos[i&gt;&gt;1]&gt;&gt;1 取i的前面所有位（去掉最低位）的位逆序，然后再右移一位  </span><br>        <span class="hljs-comment">// (i&amp;1)&lt;&lt;(l-1) 取i的最低位，并将其左移到最高位的位置  </span><br>        <span class="hljs-comment">// 通过|操作将两部分合并，得到i的位逆序  </span><br>    &#125;  <br>    <span class="hljs-built_in">FFT</span>(a,maxLen,<span class="hljs-number">1</span>);  <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;n; i++)&#123;  <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, a[i].x);  <br>    &#125;  <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;  <br><span class="hljs-comment">// A为输入数组，len为长度，type为1表示DFT，-1表示IDFT  </span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">FFT</span><span class="hljs-params">(Complex*A, <span class="hljs-type">int</span> len, <span class="hljs-type">int</span> type)</span></span>&#123;  <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;len; i++)&#123;<span class="hljs-comment">//将数组A中的元素按照位逆序的位置进行交换  </span><br>        <span class="hljs-keyword">if</span>(i&lt;pos[i])<span class="hljs-comment">// 如果i已经小于其逆序位置pos[i]，则说明这一对已经交换过  </span><br>            <span class="hljs-built_in">swap</span>(A[i], A[pos[i]]);<span class="hljs-comment">//保证每对只交换一次  </span><br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><h6 id="高精度乘法">高精度乘法</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span>  </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;  <br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">1000000</span> + <span class="hljs-number">7</span>;  <br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PI acos(-1)  </span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Complex</span> &#123;  <br>    <span class="hljs-type">double</span> x, y; <span class="hljs-comment">// 实部和虚部  </span><br>    Complex <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> Complex &amp;b) <span class="hljs-type">const</span> &#123;  <br>        <span class="hljs-keyword">return</span> &#123;x + b.x, y + b.y&#125;;  <br>    &#125;  <br>  <br>    Complex <span class="hljs-keyword">operator</span>-(<span class="hljs-type">const</span> Complex &amp;b) <span class="hljs-type">const</span> &#123;  <br>        <span class="hljs-keyword">return</span> &#123;x - b.x, y - b.y&#125;;  <br>    &#125;  <br>  <br>    Complex <span class="hljs-keyword">operator</span>*(<span class="hljs-type">const</span> Complex &amp;b) <span class="hljs-type">const</span> &#123;  <br>        <span class="hljs-keyword">return</span> &#123;x * b.x - y * b.y, x * b.y + y * b.x&#125;;  <br>    &#125;  <br>&#125;;  <br>  <br><span class="hljs-type">int</span> n,m; <span class="hljs-comment">// 两个多项式的次数  </span><br>Complex a[maxn*<span class="hljs-number">3</span>], b[maxn*<span class="hljs-number">3</span>]; <span class="hljs-comment">// 存储多项式的系数  </span><br><span class="hljs-type">long</span> <span class="hljs-type">long</span> ans[maxn*<span class="hljs-number">3</span>];  <br><span class="hljs-type">int</span> pos[maxn*<span class="hljs-number">3</span>]; <span class="hljs-comment">// 定义位置数组，用于FFT中的位置交换  </span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">FFT</span><span class="hljs-params">(Complex*A, <span class="hljs-type">int</span> len, <span class="hljs-type">int</span> type)</span></span>;  <br>  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;  <br>    <span class="hljs-type">int</span> t;  <br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;t);  <br>    <span class="hljs-keyword">while</span>(t--)&#123;  <br>        <span class="hljs-type">int</span> x;pos[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;  <br>        <span class="hljs-type">int</span> maxLen = <span class="hljs-number">1</span>, l = <span class="hljs-number">0</span>; <span class="hljs-comment">// maxLen为FFT的长度，l为log2(maxLen)  </span><br>        <span class="hljs-type">char</span> str1[maxn], str2[maxn];  <br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot; %s %s&quot;</span>, str1, str2); <span class="hljs-comment">// 读取两个大数  </span><br>        n = <span class="hljs-built_in">strlen</span>(str1);  <br>        m = <span class="hljs-built_in">strlen</span>(str2);  <br>        <span class="hljs-keyword">while</span>(maxLen &lt; n+m+<span class="hljs-number">1</span>)&#123;  <br>            maxLen&lt;&lt;=<span class="hljs-number">1</span>;  <br>            l++;  <br>        &#125;  <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;=maxLen; i++)&#123;  <br>            a[i].y = a[i].x = b[i].y = b[i].x = ans[i] = <span class="hljs-number">0</span>;  <br>        &#125;  <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123; <span class="hljs-comment">// 将第一个大数的字符转换为数字，并倒序存储  </span><br>            a[i].x = str1[n - i - <span class="hljs-number">1</span>] - <span class="hljs-string">&#x27;0&#x27;</span>;  <br>        &#125;  <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;  <br>            b[i].x = str2[m - i - <span class="hljs-number">1</span>] - <span class="hljs-string">&#x27;0&#x27;</span>;  <br>        &#125;  <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;maxLen;i++)&#123; <span class="hljs-comment">// 求最后交换的位置（奇数特殊处理）  </span><br>            pos[i] = (pos[i&gt;&gt;<span class="hljs-number">1</span>]&gt;&gt;<span class="hljs-number">1</span>)|((i&amp;<span class="hljs-number">1</span>)&lt;&lt;(l<span class="hljs-number">-1</span>));  <br>            <span class="hljs-comment">// 计算每个索引i的位逆序位置(将一个数的二进制位顺序颠倒011-&gt;110)  </span><br>            <span class="hljs-comment">// i&gt;&gt;1 将i的二进制位右移一位，即去掉最低位  </span><br>            <span class="hljs-comment">// pos[i&gt;&gt;1]&gt;&gt;1 取i的前面所有位（去掉最低位）的位逆序，然后再右移一位  </span><br>            <span class="hljs-comment">// (i&amp;1)&lt;&lt;(l-1) 取i的最低位，并将其左移到最高位的位置  </span><br>            <span class="hljs-comment">// 通过|操作将两部分合并，得到i的位逆序  </span><br>        &#125;  <br>  <br>        <span class="hljs-built_in">FFT</span>(a,maxLen,<span class="hljs-number">1</span>);  <br>        <span class="hljs-built_in">FFT</span>(b,maxLen,<span class="hljs-number">1</span>);  <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;maxLen;i++)  <br>            a[i] = a[i]*b[i];  <br>        <span class="hljs-built_in">FFT</span>(a,maxLen,<span class="hljs-number">-1</span>); <span class="hljs-comment">// 对结果进行IDFT  </span><br>  <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; maxLen; i++)&#123;  <br>            ans[i] += <span class="hljs-built_in">round</span>(a[i].x);  <br>            ans[i + <span class="hljs-number">1</span>] += ans[i] / <span class="hljs-number">10</span>; <span class="hljs-comment">// 如果是8进制就换成8  </span><br>            ans[i] %= <span class="hljs-number">10</span>; <span class="hljs-comment">// 如果是8进制就换成8  </span><br>        &#125;  <br>        <span class="hljs-type">int</span> t1 = maxLen;  <br>        <span class="hljs-keyword">while</span> (ans[t1] == <span class="hljs-number">0</span> &amp;&amp; t1 &gt; <span class="hljs-number">0</span>)  <br>            t1--; <span class="hljs-comment">// 去除结果数组末尾的零  </span><br>        <span class="hljs-keyword">while</span> (t1 &gt;= <span class="hljs-number">0</span>)  <br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld&quot;</span>, ans[t1--]);  <br>        cout &lt;&lt; endl;  <br>    &#125;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;  <br><span class="hljs-comment">// A为输入数组，len为长度，type为1表示DFT，-1表示IDFT  </span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">FFT</span><span class="hljs-params">(Complex*A, <span class="hljs-type">int</span> len, <span class="hljs-type">int</span> type)</span></span>&#123;  <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;len; i++)&#123;<span class="hljs-comment">//将数组A中的元素按照位逆序的位置进行交换  </span><br>        <span class="hljs-keyword">if</span>(i&lt;pos[i])<span class="hljs-comment">// 如果i已经小于其逆序位置pos[i]，则说明这一对已经交换过  </span><br>            <span class="hljs-built_in">swap</span>(A[i], A[pos[i]]);<span class="hljs-comment">//保证每对只交换一次  </span><br>    &#125;  <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> L=<span class="hljs-number">2</span>; L&lt;=len; L&lt;&lt;=<span class="hljs-number">1</span>)&#123;<span class="hljs-comment">//循环合并的区间长度  </span><br>        <span class="hljs-type">int</span> HLen = L/<span class="hljs-number">2</span>;<span class="hljs-comment">//区间的一半  </span><br>        Complex Wn = &#123;<span class="hljs-built_in">cos</span>(<span class="hljs-number">2.0</span>*PI/L), type*<span class="hljs-built_in">sin</span>(<span class="hljs-number">2.0</span>*PI/L)&#125;; <span class="hljs-comment">// 计算单位根  </span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> R=<span class="hljs-number">0</span>; R&lt;len; R+=L)&#123;<span class="hljs-comment">//每个小区间的起点  </span><br>            Complex w = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;; <span class="hljs-comment">// 初始化旋转因子  </span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>; k&lt;HLen; k++, w=w*Wn)&#123;<span class="hljs-comment">//求该区间下的值  </span><br>                Complex Buf = A[R+k];<span class="hljs-comment">//蝴蝶操作，去掉odd和even数组，使变化原地进行  </span><br>                A[R+k] =  A[R+k] + w*A[R+k+HLen];  <br>                A[R+k+HLen] = Buf - w*A[R+k+HLen];  <br>            &#125;  <br>        &#125;  <br>    &#125;  <br>    <span class="hljs-keyword">if</span> (type == <span class="hljs-number">-1</span>) &#123; <span class="hljs-comment">// 归一化  </span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;  <br>            A[i].x /= len;  <br>            A[i].y /= len;  <br>        &#125;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><h5 id="最大公约数欧几里得算法">最大公约数：欧几里得算法</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">euclid</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span>&#123;<br><span class="hljs-keyword">if</span>(b == <span class="hljs-number">0</span>)&#123;<br><span class="hljs-keyword">return</span> a;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">euclid</span>(b, a%b);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="欧几里得算法的扩展形式">欧几里得算法的扩展形式</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 法1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span>  </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> d, x, y;  <br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">extendedEuclid</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span>&#123;  <br>    <span class="hljs-keyword">if</span>(b == <span class="hljs-number">0</span>)&#123;  <br>        d = a, x = <span class="hljs-number">1</span>, y = <span class="hljs-number">0</span>;  <br>    &#125;<span class="hljs-keyword">else</span>&#123;  <br>        <span class="hljs-built_in">extendedEuclid</span>(b, a%b);  <br>        <span class="hljs-type">int</span> tempX = x;  <br>        x = y, y = tempX-(<span class="hljs-type">int</span>)<span class="hljs-built_in">floor</span>(a/b)*y;  <br>    &#125;  <br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;  <br>    <span class="hljs-type">int</span> a, b;  <br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);  <br>    <span class="hljs-built_in">extendedEuclid</span>(a, b);  <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d = gcd(%d, %d) = %d*%d+%d*%d&quot;</span>, d, a, b, a, x, b, y);  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></td></tr></table></figure><h5 id="同余方程-ax-b-mod-m">同余方程 <span class="math inline">\(ax ≡ b(mod\ m)\)</span></h5><p><span class="math inline">\(ax ≡ b (mod\ m)\)</span> 即 <spanclass="math inline">\(ax - b = km\)</span> 1.<strong>通解形式</strong>：线性同余方程 <code>ax ≡ b (mod m)</code>的通解可以表示为 <code>x = x0 + km/d</code>，其中 <code>x0</code>是一个特解，<code>k</code> 是任意整数，<code>d = gcd(a, m)</code>。 2.<strong>遍历所有解</strong>：解的周期性为<code>d</code>，我们可以通过遍历 <code>k</code> 从 <code>0</code> 到<code>d-1</code> 来找到所有可能的解。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 计算同余方程的所有解  </span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> a,<span class="hljs-type">long</span> <span class="hljs-type">long</span> b,<span class="hljs-type">long</span> <span class="hljs-type">long</span> m)</span></span>&#123;  <br>    <span class="hljs-built_in">extendedEuclid</span>(a,m);  <br>    <span class="hljs-keyword">if</span>(b%d) <span class="hljs-comment">// 同余方程有解的前提是b是d（a和m的最大公约数的倍数）  </span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<span class="hljs-comment">//无解  </span><br>    x=x*(b/d)%m; <span class="hljs-comment">// 一个特解  </span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=d; i++)&#123; <span class="hljs-comment">// 遍历所有解的可能  </span><br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> tempAns = (x+(i<span class="hljs-number">-1</span>)*m/d)%m;  <br>        <span class="hljs-keyword">while</span>(tempAns&lt;<span class="hljs-number">0</span>)&#123; <span class="hljs-comment">// 确保解为正数  </span><br>            tempAns += m;  <br>        &#125;  <br>        <span class="hljs-keyword">if</span>(tempAns &lt; ans)&#123; <span class="hljs-comment">// 更新解为最小的解  </span><br>            ans = tempAns;  <br>        &#125;  <br>    &#125;  <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld&quot;</span>, ans);  <br>&#125;<br></code></pre></td></tr></table></figure></p><h5 id="字符串匹配">字符串匹配</h5><h6 id="rabin-karp算法-双哈希">Rabin-Karp算法 双哈希</h6><p>预处理时间 <spanclass="math inline">\(\Theta(m)\)</span>，最坏运行时间 <spanclass="math inline">\(\Theta((n-m+1)m)\)</span>，期望运行时间 <spanclass="math inline">\(O(n)+O(m(v+\frac{n}{q}))\)</span><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span>  </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;  <br>  <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Rabin_Karp_search</span><span class="hljs-params">(<span class="hljs-type">const</span> string &amp;T, <span class="hljs-type">const</span> string &amp;P, <span class="hljs-type">int</span> d, <span class="hljs-type">int</span> q1, <span class="hljs-type">int</span> q2)</span></span>;  <br>  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;  <br>    string T = <span class="hljs-string">&quot;Rabin–Karp string search algorithm: Rabin-Karp&quot;</span>;  <span class="hljs-comment">// 文本字符串  </span><br>    string P = <span class="hljs-string">&quot;Rabin&quot;</span>;  <span class="hljs-comment">// 模式字符串  </span><br>    <span class="hljs-type">int</span> q1 = <span class="hljs-number">101</span>; <span class="hljs-comment">// 第一个质数，用于取模运算  </span><br>    <span class="hljs-type">int</span> q2 = <span class="hljs-number">103</span>; <span class="hljs-comment">// 第二个质数，用于取模运算  </span><br>    <span class="hljs-type">int</span> d = <span class="hljs-number">52</span>; <span class="hljs-comment">// a到z 大小写  </span><br>    <span class="hljs-built_in">Rabin_Karp_search</span>(T, P, d, q1, q2);  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;  <br>  <br><span class="hljs-comment">// T文本字符串 P模式字符串 字符集的大小 两个用于取模运算的质数  </span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Rabin_Karp_search</span><span class="hljs-params">(<span class="hljs-type">const</span> string &amp;T, <span class="hljs-type">const</span> string &amp;P, <span class="hljs-type">int</span> d, <span class="hljs-type">int</span> q1, <span class="hljs-type">int</span> q2)</span></span>&#123;  <br>    <span class="hljs-type">int</span> m = P.<span class="hljs-built_in">length</span>(); <span class="hljs-comment">// 模式字符串的长度  </span><br>    <span class="hljs-type">int</span> n = T.<span class="hljs-built_in">length</span>(); <span class="hljs-comment">// 文本字符串的长度  </span><br>    <span class="hljs-type">int</span> i, j;  <br>    <span class="hljs-type">int</span> p1 = <span class="hljs-number">0</span>, p2 = <span class="hljs-number">0</span>; <span class="hljs-comment">// 模式字符串的双哈希值  </span><br>    <span class="hljs-type">int</span> t1 = <span class="hljs-number">0</span>, t2 = <span class="hljs-number">0</span>; <span class="hljs-comment">// 文本字符串的双哈希值  </span><br>    <span class="hljs-type">int</span> h1 = <span class="hljs-number">1</span>, h2 = <span class="hljs-number">1</span>; <span class="hljs-comment">// 用于计算哈希值的基数  </span><br>  <br>    <span class="hljs-comment">// h的值将是&quot;d的(m-1)次方对q取模&quot;  </span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; m<span class="hljs-number">-1</span>; i++)&#123;  <br>        h1 = (h1*d)%q1;  <br>        h2 = (h2*d)%q2;  <br>    &#125;  <br>    <span class="hljs-comment">// 计算模式字符串和文本字符串第一个窗口的总哈希值  </span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;  <br>        p1 = (d*p1 + P[i])%q1;  <br>        p2 = (d*p2 + P[i])%q2;  <br>        t1 = (d*t1 + T[i])%q1;  <br>        t2 = (d*t2 + T[i])%q2;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">// 逐个将模式字符串在文本字符串上滑动  </span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt;= n - m; i++) &#123;  <br>        <span class="hljs-comment">// 检查当前窗口的文本字符串和模式字符串的双哈希值  </span><br>        <span class="hljs-comment">// 如果双哈希值匹配，则逐个字符检查  </span><br>        <span class="hljs-keyword">if</span> ( p1 == t1 &amp;&amp; p2 == t2 ) &#123;  <br>            <span class="hljs-comment">/* 逐个字符检查 */</span>            <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; m; j++)  <br>                <span class="hljs-keyword">if</span> (T[i+j] != P[j])  <br>                    <span class="hljs-keyword">break</span>;  <br>            <span class="hljs-keyword">if</span> (j == m) <span class="hljs-comment">// 如果哈希值匹配且字符也完全匹配  </span><br>                cout&lt;&lt;<span class="hljs-string">&quot;Pattern found at index :&quot;</span>&lt;&lt;i&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;  <br>        &#125;  <br>  <br>        <span class="hljs-comment">// 为下一个窗口的文本字符串计算哈希值：移除首位数字，添加末位数字  </span><br>        <span class="hljs-keyword">if</span> ( i &lt; n-m )&#123;  <br>            t1 = (d*(t1 - T[i]*h1) + T[i+m])%q1;  <br>            t2 = (d*(t2 - T[i]*h2) + T[i+m])%q2;  <br>            <span class="hljs-comment">// 如果t为负值，则将其转换为正值  </span><br>            <span class="hljs-keyword">if</span>(t1 &lt; <span class="hljs-number">0</span>)  <br>                t1 = (t1 + q1);  <br>            <span class="hljs-keyword">if</span>(t2 &lt; <span class="hljs-number">0</span>)  <br>                t2 = (t2 + q2);  <br>        &#125;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure></p><h6 id="字符匹配有限自动机">字符匹配有限自动机</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span>  </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;  <br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> total_chars 256 <span class="hljs-comment">// 字符集的总数，通常是256（ASCII字符集大小）  </span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> trans_func(i, j) (trans_func[(i) * (m+1) + (j)])</span><br><span class="hljs-comment">// 定义转换函数的宏，用于访问转换表  </span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">transition</span><span class="hljs-params">(<span class="hljs-type">int</span>* trans_func, string &amp;pattern)</span></span>;  <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">FSA</span><span class="hljs-params">(string &amp;pattern, string &amp;text)</span></span>;  <br>  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;  <br>    string pattern = <span class="hljs-string">&quot;abc&quot;</span>; <span class="hljs-comment">// 模式字符串  </span><br>    string text = <span class="hljs-string">&quot;abcabcdefghabc&quot;</span>; <span class="hljs-comment">// 文本字符串  </span><br>    <span class="hljs-built_in">FSA</span>(pattern, text);  <br>&#125;  <br>  <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">FSA</span><span class="hljs-params">(string &amp;pattern, string &amp;text)</span> </span>&#123;  <br>    <span class="hljs-type">int</span> m = pattern.<span class="hljs-built_in">length</span>();  <br>    <span class="hljs-type">int</span> n = text.<span class="hljs-built_in">length</span>();  <br>    <span class="hljs-type">int</span>* trans_func = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[total_chars * m]; <span class="hljs-comment">// 分配转换表的空间  </span><br>    <span class="hljs-built_in">transition</span>(trans_func, pattern); <span class="hljs-comment">// 构建转换表  </span><br>    <span class="hljs-type">int</span> q = <span class="hljs-number">0</span>; <span class="hljs-comment">// 状态机的当前状态  </span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;  <br>        q = <span class="hljs-built_in">trans_func</span>(text[i], q); <span class="hljs-comment">// 根据当前字符和状态更新状态  </span><br>        <span class="hljs-keyword">if</span> (q == m) &#123; <span class="hljs-comment">// 如果达到最终状态（模式匹配成功）  </span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Pattern found at index :%d &quot;</span>, i-m+<span class="hljs-number">1</span>);  <br>            q = <span class="hljs-number">0</span>; <span class="hljs-comment">// 重置状态  </span><br>        &#125;  <br>    &#125;  <br>    <span class="hljs-comment">// 输出一个表格，i,j表示如果第j个字符是i，会匹配跳转到哪里  </span><br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> ans = <span class="hljs-number">0</span>;  <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;total_chars; j++)&#123;  <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = (m+<span class="hljs-number">1</span>)*j+<span class="hljs-number">0</span>; i &lt; (m+<span class="hljs-number">1</span>)*j+m+<span class="hljs-number">1</span>; i++) &#123;  <br><span class="hljs-comment">//            printf(&quot;%d &quot;, trans_func[i]);  </span><br>            ans += trans_func[i];  <br>        &#125;  <br><span class="hljs-comment">//        puts(&quot;&quot;);  </span><br>    &#125;  <br><span class="hljs-comment">//    printf(&quot;%lld&quot;, ans);  </span><br>&#125;  <br>  <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">transition</span><span class="hljs-params">(<span class="hljs-type">int</span>* trans_func, string &amp;pattern)</span> </span>&#123;  <br>    <span class="hljs-type">int</span> m = pattern.<span class="hljs-built_in">length</span>();  <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; total_chars; i++) &#123; <span class="hljs-comment">// 初始化转换表的第一列  </span><br>        <span class="hljs-keyword">if</span> (i == pattern[<span class="hljs-number">0</span>]) &#123; <span class="hljs-comment">// 如果字符匹配模式的第一个字符  </span><br>            <span class="hljs-built_in">trans_func</span>(i, <span class="hljs-number">0</span>) = <span class="hljs-number">1</span>;  <br>        &#125; <span class="hljs-keyword">else</span> &#123;  <br>            <span class="hljs-built_in">trans_func</span>(i, <span class="hljs-number">0</span>) = <span class="hljs-number">0</span>;  <br>        &#125;  <br>    &#125;  <br>    <span class="hljs-type">int</span> X = <span class="hljs-number">0</span>; <span class="hljs-comment">// 失败函数，记录了pattern的前j个字符中最长相同前后缀  </span><br>    <span class="hljs-comment">// 例如，对于模式字符串&quot;ABABAC&quot;，其部分匹配表为[0, 0, 1, 2, 3, 0]。  </span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; m; j++) &#123; <span class="hljs-comment">// 构建转换表的其余部分  </span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; total_chars; i++) &#123;  <br>            <span class="hljs-keyword">if</span> (pattern[j] == i) &#123; <span class="hljs-comment">// 如果字符匹配模式的当前字符  </span><br>                <span class="hljs-built_in">trans_func</span>(i, j) = j + <span class="hljs-number">1</span>; <span class="hljs-comment">// 状态转移到下一个  </span><br>            &#125; <span class="hljs-keyword">else</span> &#123;  <br>                <span class="hljs-built_in">trans_func</span>(i, j) = <span class="hljs-built_in">trans_func</span>(i, X);  <br>            &#125;  <br>        &#125;  <br>        X = <span class="hljs-built_in">trans_func</span>(pattern[j], X);  <br>    &#125;  <br>    <span class="hljs-comment">// 转换表的最后一列  </span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; total_chars; i++) &#123;  <br>        <span class="hljs-keyword">if</span> (pattern[X] == i) &#123;  <br>            <span class="hljs-built_in">trans_func</span>(i, m) = X + <span class="hljs-number">1</span>;  <br>        &#125; <span class="hljs-keyword">else</span> &#123;  <br>            <span class="hljs-built_in">trans_func</span>(i, m) = <span class="hljs-built_in">trans_func</span>(i, X);  <br>        &#125;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><h6 id="kmp算法">KMP算法</h6><p>时间复杂度 <span class="math inline">\(O(m+n)\)</span><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span>  </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;  <br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">prefix</span><span class="hljs-params">(string str)</span></span>;  <br>  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;  <br>    string text;  <br>    string key;  <br>    cin &gt;&gt; text; <span class="hljs-comment">// 文本字符串  </span><br>    cin &gt;&gt; key;  <span class="hljs-comment">// 模式字符串  </span><br>    <span class="hljs-type">int</span> kl = key.<span class="hljs-built_in">length</span>();  <br>    vector&lt;<span class="hljs-type">int</span>&gt; kmp = <span class="hljs-built_in">prefix</span>(key); <span class="hljs-comment">// 计算模式字符串的KMP前缀表即π</span><br>    <span class="hljs-type">int</span> k = <span class="hljs-number">0</span>;  <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; text.<span class="hljs-built_in">length</span>(); i++)&#123;  <br>        <span class="hljs-comment">// 当匹配长度大于0且当前字符不匹配时，回退到前缀表的相应位置  </span><br>        <span class="hljs-keyword">while</span> (k &amp;&amp; key[k] != text[i])  <br>            k = kmp[k - <span class="hljs-number">1</span>];  <br>        <span class="hljs-comment">// 如果当前字符匹配，增加匹配长度  </span><br>        <span class="hljs-keyword">if</span>(text[i] == key[k])  <br>            k++;  <br>        <span class="hljs-comment">// 如果匹配长度等于模式字符串的长度，输出匹配的位置  </span><br>        <span class="hljs-keyword">if</span>(k == kl)  <br>            cout &lt;&lt; i - k + <span class="hljs-number">2</span> &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;  <br>    &#125;  <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> x: kmp) <span class="hljs-comment">// 输出KMP前缀表即π的每个值  </span><br>        cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;  <br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">prefix</span><span class="hljs-params">(string str)</span></span>&#123;  <br>    <span class="hljs-type">int</span> l = (<span class="hljs-type">int</span>) str.<span class="hljs-built_in">length</span>();  <br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">pre</span><span class="hljs-params">(l)</span></span>; <span class="hljs-comment">// 创建一个长度为l的向量来存储前缀表  </span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; l; i++)&#123;  <br>        <span class="hljs-type">int</span> j = pre[i - <span class="hljs-number">1</span>];     <span class="hljs-comment">// i-1的最大的前缀==后缀  </span><br>        <span class="hljs-comment">// 如果 j&gt;0(防止死循环) 且当前字符与前缀的最后一个字符不匹配时，回退j的值  </span><br>        <span class="hljs-keyword">while</span> (j &amp;&amp; str[j] != str[i])  <br>            j = pre[j - <span class="hljs-number">1</span>];     <span class="hljs-comment">// ababaababab  </span><br>        <span class="hljs-keyword">if</span>(str[j] == str[i]) <span class="hljs-comment">// 如果当前字符与前缀的最后一个字符匹配，增加j的值  </span><br>            j++;  <br>        pre[i] = j; <span class="hljs-comment">// 设置当前字符的前缀表值  </span><br>    &#125;  <br>    <span class="hljs-keyword">return</span> pre;  <br>&#125;<br></code></pre></td></tr></table></figure></p><h5id="确定连续线段是向左转还是向右转">确定连续线段是向左转还是向右转</h5><p>已知 <span class="math inline">\(\overrightarrow{p_{0}p_{1}},\overrightarrow{p_{1}p_{2}}\)</span> 。计算 <spanclass="math inline">\((p_{2}-p_{0})\times(p_{1}-p_{0}) =(x_{2}-x_{0})(y_{1}-y_{0})-(y_{2}-y_{0})(x_{1}-x_{0})\)</span> + 结果<span class="math inline">\(&lt;0\)</span> ，则在 <spanclass="math inline">\(p_{1}\)</span> 左转 + 结果 <spanclass="math inline">\(&gt;0\)</span> ，则在 <spanclass="math inline">\(p_{1}\)</span> 右转 + 结果 <spanclass="math inline">\(=0\)</span> ，则在 <spanclass="math inline">\(p_{0}, p_{1}, p_{2}\)</span> 三者共线<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">dot</span>&#123;  <br>    <span class="hljs-type">int</span> x, y;  <br>&#125;;  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">direction</span><span class="hljs-params">(dot pi, dot pj, dot pk)</span></span>&#123;  <br>    <span class="hljs-comment">// 计算向量pi-pj和向量pk-pj的叉积，用于判断方向  </span><br>    <span class="hljs-comment">// 如果&lt;0，则pipj pjpk在pj左转  </span><br>    <span class="hljs-comment">// 如果&gt;0，则pipj pjpk在pj右转  </span><br>    <span class="hljs-comment">// 否则三者共线  </span><br>    <span class="hljs-keyword">return</span> ((pk.x-pi.x)*(pj.y-pi.y)-(pk.y-pi.y)*(pj.x-pi.x));  <br>&#125;<br></code></pre></td></tr></table></figure> ##### 判定两条线是否相交 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">dot</span>&#123;  <br>    <span class="hljs-type">int</span> x, y;  <br>&#125;;  <br><span class="hljs-comment">// 计算向量pi-pj和向量pk-pj的叉积，用于判断方向  </span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">direction</span><span class="hljs-params">(dot pi, dot pj, dot pk)</span></span>&#123;  <br>    <span class="hljs-keyword">return</span> ((pk.x-pi.x)*(pj.y-pi.y)-(pk.y-pi.y)*(pj.x-pi.x));  <br>&#125;  <br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">onSegment</span><span class="hljs-params">(dot pi, dot pj, dot pk)</span></span>&#123; <span class="hljs-comment">// 判断点pk是否在线段pi-pj上  </span><br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">min</span>(pi.x, pj.x) &lt;= pk.x &amp;&amp; <span class="hljs-built_in">max</span>(pi.x, pj.x) &gt;= pk.x &amp;&amp;  <br>            <span class="hljs-comment">// 判断pk的x坐标是否在pi和pj的x坐标之间  </span><br>            <span class="hljs-built_in">min</span>(pi.y, pj.y) &lt;= pk.y &amp;&amp; <span class="hljs-built_in">max</span>(pi.y, pj.y) &gt;= pk.y)&#123;  <br>            <span class="hljs-comment">// 判断pk的y坐标是否在pi和pj的y坐标之间  </span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <br>    &#125;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <br>&#125;  <br><span class="hljs-comment">//线段p1p2与p3p4是否相交  </span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">segmentsIntersect</span><span class="hljs-params">(dot p1, dot p2, dot p3, dot p4)</span></span>&#123;  <br>    <span class="hljs-type">int</span> d1 = <span class="hljs-built_in">direction</span>(p3, p4, p1);  <br>    <span class="hljs-type">int</span> d2 = <span class="hljs-built_in">direction</span>(p3, p4, p2);  <br>    <span class="hljs-type">int</span> d3 = <span class="hljs-built_in">direction</span>(p1, p2, p3);  <br>    <span class="hljs-type">int</span> d4 = <span class="hljs-built_in">direction</span>(p1, p2, p4);  <br>    <span class="hljs-keyword">if</span>(((d1&gt;<span class="hljs-number">0</span> &amp;&amp; d2&lt;<span class="hljs-number">0</span>)||(d1&lt;<span class="hljs-number">0</span> &amp;&amp; d2&gt;<span class="hljs-number">0</span>)) &amp;&amp; ((d3&gt;<span class="hljs-number">0</span> &amp;&amp; d4&lt;<span class="hljs-number">0</span>)||(d3&lt;<span class="hljs-number">0</span> &amp;&amp; d4&gt;<span class="hljs-number">0</span>)))&#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 如果两线段在彼此的两侧，则相交  </span><br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(d1 == <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-built_in">onSegment</span>(p3, p4, p1))&#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 如果p1在p3p4上  </span><br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(d2 == <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-built_in">onSegment</span>(p3, p4, p2))&#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 如果p2在p3p4上  </span><br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(d3 == <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-built_in">onSegment</span>(p1, p2, p3))&#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 如果p3在p1p2上  </span><br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(d4 == <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-built_in">onSegment</span>(p1, p2, p4))&#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 如果p4在p1p2上  </span><br>    &#125;<span class="hljs-keyword">else</span>&#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure></p><h5 id="确定任意一对线段是否相交">确定任意一对线段是否相交</h5><p><span class="math inline">\(O(n^2)\)</span> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span>  </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;  <br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Point</span> &#123;  <br>    <span class="hljs-type">int</span> x, y;  <br>    Point <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> Point &amp;b) <span class="hljs-type">const</span> &#123;  <br>        <span class="hljs-keyword">return</span> &#123;x + b.x, y + b.y&#125;;  <br>    &#125;  <br>    Point <span class="hljs-keyword">operator</span>-(<span class="hljs-type">const</span> Point &amp;b) <span class="hljs-type">const</span> &#123;  <br>        <span class="hljs-keyword">return</span> &#123;x - b.x, y - b.y&#125;;  <br>    &#125;  <br>    <span class="hljs-comment">// 重载乘法运算符，用于点与整数相乘  </span><br>    Point <span class="hljs-keyword">operator</span>*(<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;b) <span class="hljs-type">const</span> &#123;  <br>        <span class="hljs-keyword">return</span> &#123;x * b, y * b&#125;;  <br>    &#125;  <br>    <span class="hljs-comment">// 重载异或运算符，用于计算两个向量的叉积  </span><br>    <span class="hljs-type">int</span> <span class="hljs-keyword">operator</span>^(<span class="hljs-type">const</span> Point &amp;b) <span class="hljs-type">const</span> &#123;  <br>        <span class="hljs-keyword">return</span> x * b.y - y * b.x;  <br>    &#125;  <br>&#125;;  <br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Line</span> &#123; <span class="hljs-comment">// 定义线段结构体  </span><br>    Point p; <span class="hljs-comment">// 线段的起点  </span><br>    Point q; <span class="hljs-comment">// 线段的终点  </span><br>&#125;;  <br>vector&lt;Line&gt; lines;  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sgn</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>;  <br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">intersect</span><span class="hljs-params">(Line l1, Line l2)</span></span>;  <br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">onSegment</span><span class="hljs-params">(Point point, Line line)</span></span>;  <br>  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;  <br>    <span class="hljs-type">int</span> n, cnt = <span class="hljs-number">0</span>;  <br>    cin &gt;&gt; n; <span class="hljs-comment">// 线段数量  </span><br>    <span class="hljs-type">int</span> x1, y1, x2, y2;  <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;  <br>        cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2;  <br>        lines.<span class="hljs-built_in">push_back</span>(&#123;&#123;x1, y1&#125;, &#123;x2, y2&#125;&#125;); <span class="hljs-comment">// 将线段添加到数组中  </span><br>    &#125;  <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) <span class="hljs-comment">// 双重循环遍历所有线段对，判断是否相交  </span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++)  <br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">intersect</span>(lines[i], lines[j]))  <br>                cnt++; <span class="hljs-comment">// 如果相交，则计数器加一  </span><br>    cout &lt;&lt; cnt; <span class="hljs-comment">// 输出相交线段对数  </span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;  <br>  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sgn</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;  <br>    <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;  <br>    <span class="hljs-keyword">if</span> (x &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;  <br>  <br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">intersect</span><span class="hljs-params">(Line l1, Line l2)</span> </span>&#123;  <br>    <span class="hljs-type">int</span> d1 = <span class="hljs-built_in">sgn</span>((l1.q - l1.p) ^ (l2.p - l1.p));  <br>    <span class="hljs-type">int</span> d2 = <span class="hljs-built_in">sgn</span>((l1.q - l1.p) ^ (l2.q - l1.p));  <br>    <span class="hljs-type">int</span> d3 = <span class="hljs-built_in">sgn</span>((l2.q - l2.p) ^ (l1.p - l2.p));  <br>    <span class="hljs-type">int</span> d4 = <span class="hljs-built_in">sgn</span>((l2.q - l2.p) ^ (l1.q - l2.p));  <br>    <span class="hljs-comment">// 如果两线段在彼此的两侧，则相交  </span><br>    <span class="hljs-keyword">if</span> (d1 * d2 &lt; <span class="hljs-number">0</span> &amp;&amp; d3 * d4 &lt; <span class="hljs-number">0</span>)  <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <br>    <span class="hljs-comment">// 其中一个端点在另一条线段上，也视为相交  </span><br>    <span class="hljs-keyword">if</span> (d1 == <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-built_in">onSegment</span>(l2.p, l1))  <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <br>    <span class="hljs-keyword">if</span> (d2 == <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-built_in">onSegment</span>(l2.q, l1))  <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <br>    <span class="hljs-keyword">if</span> (d3 == <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-built_in">onSegment</span>(l1.p, l2))  <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <br>    <span class="hljs-keyword">if</span> (d4 == <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-built_in">onSegment</span>(l1.q, l2))  <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <br>&#125;  <br>  <br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">onSegment</span><span class="hljs-params">(Point point, Line line)</span> </span>&#123; <span class="hljs-comment">// 判断点是否在线段上  </span><br>    <span class="hljs-keyword">if</span> (point.x &gt;= <span class="hljs-built_in">min</span>(line.p.x, line.q.x) &amp;&amp;  <br>        point.x &lt;= <span class="hljs-built_in">max</span>(line.p.x, line.q.x) &amp;&amp;  <br>        point.y &gt;= <span class="hljs-built_in">min</span>(line.p.y, line.q.y) &amp;&amp;  <br>        point.y &lt;= <span class="hljs-built_in">max</span>(line.p.y, line.q.y))  <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <br>&#125;<br></code></pre></td></tr></table></figure></p><h5 id="寻找凸包graham扫描法">寻找凸包(Graham扫描法)</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span>  </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;  <br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX = <span class="hljs-number">200005</span>;  <br><span class="hljs-type">const</span> <span class="hljs-type">double</span> eps = <span class="hljs-number">1e-7</span>;  <br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Point</span> &#123;  <br>    <span class="hljs-type">double</span> x, y;  <br>    Point <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> Point &amp;b) <span class="hljs-type">const</span> &#123;  <br>        <span class="hljs-keyword">return</span> &#123;x + b.x, y + b.y&#125;;  <br>    &#125;  <br>    Point <span class="hljs-keyword">operator</span>-(<span class="hljs-type">const</span> Point &amp;b) <span class="hljs-type">const</span> &#123;  <br>        <span class="hljs-keyword">return</span> &#123;x - b.x, y - b.y&#125;;  <br>    &#125;  <br>    <span class="hljs-comment">// 重载异或运算符，用于计算两个向量的叉积  </span><br>    <span class="hljs-type">double</span> <span class="hljs-keyword">operator</span>^(<span class="hljs-type">const</span> Point &amp;b) <span class="hljs-type">const</span> &#123;  <br>        <span class="hljs-keyword">return</span> x * b.y - y * b.x;  <br>    &#125;  <br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> Point &amp;b) <span class="hljs-type">const</span> &#123;  <br>        <span class="hljs-keyword">if</span> (x != b.x)  <br>            <span class="hljs-keyword">return</span> x &lt; b.x;  <br>        <span class="hljs-keyword">return</span> y &lt; b.y;  <br>    &#125;  <br>&#125;;  <br>Point p[MAX]; <span class="hljs-comment">// 存储所有点的数组  </span><br>Point s[MAX]; <span class="hljs-comment">// 用于构建凸包的栈  </span><br><span class="hljs-type">int</span> top; <span class="hljs-comment">// 栈顶指针  </span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">selMin</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>;  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">cmp</span><span class="hljs-params">(Point a, Point b)</span></span>;  <br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">equal</span><span class="hljs-params">(<span class="hljs-type">double</span> a, <span class="hljs-type">double</span> b)</span></span>;  <br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">dis</span><span class="hljs-params">(Point a, Point b)</span></span>;  <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">graham</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>;  <br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">s_sqr</span><span class="hljs-params">(Point a, Point b, Point c)</span></span>;  <br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">diameter</span><span class="hljs-params">()</span></span>;  <br>  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;  <br>    <span class="hljs-type">int</span> n;  <br>    cin &gt;&gt; n; <span class="hljs-comment">// 点的数量  </span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)  <br>        cin &gt;&gt; p[i].x &gt;&gt; p[i].y; <span class="hljs-comment">// 每个点的坐标  </span><br>    <span class="hljs-built_in">selMin</span>(n); <span class="hljs-comment">// 选择最小的点作为起点  </span><br>    <span class="hljs-built_in">sort</span>(p + <span class="hljs-number">1</span>, p + n, cmp); <span class="hljs-comment">// 根据极角排序  </span><br>    <span class="hljs-built_in">graham</span>(n); <span class="hljs-comment">// 执行Graham扫描算法构建凸包，凸包中的点在数组s中  </span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.6f&quot;</span>, <span class="hljs-built_in">sqrt</span>(<span class="hljs-built_in">diameter</span>())) ; <span class="hljs-comment">// 输出凸包的直径（开方后）  </span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;  <br>  <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">selMin</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;  <br>    Point Min = p[<span class="hljs-number">0</span>]; <span class="hljs-comment">// 初始化最小点  </span><br>    <span class="hljs-type">int</span> IDMin = <span class="hljs-number">0</span>; <span class="hljs-comment">// 最小点的索引  </span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)  <br>        <span class="hljs-keyword">if</span> (p[i] &lt; Min) &#123; <span class="hljs-comment">// 如果找到更小的点  </span><br>            Min = p[i];  <br>            IDMin = i;  <br>        &#125;  <br>    <span class="hljs-built_in">swap</span>(p[<span class="hljs-number">0</span>], p[IDMin]); <span class="hljs-comment">// 将最小点交换到数组第一个位置  </span><br>&#125;  <br>  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">cmp</span><span class="hljs-params">(Point a, Point b)</span> </span>&#123;  <br>    <span class="hljs-type">double</span> x = (a - p[<span class="hljs-number">0</span>]) ^ (b - p[<span class="hljs-number">0</span>]); <span class="hljs-comment">// 计算相对于起点的叉积  </span><br>    <span class="hljs-keyword">if</span> (x &gt; <span class="hljs-number">0</span>) <span class="hljs-comment">// 点a的极角大于点b的极角  </span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;  <br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">equal</span>(x, <span class="hljs-number">0</span>) &amp;&amp; (<span class="hljs-built_in">dis</span>(a, p[<span class="hljs-number">0</span>]) &lt; <span class="hljs-built_in">dis</span>(b, p[<span class="hljs-number">0</span>])))  <br>        <span class="hljs-comment">// 如点a和点b具有相同的极角且a离起点更近  </span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;  <br>  <br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">dis</span><span class="hljs-params">(Point a, Point b)</span> </span>&#123; <span class="hljs-comment">// 计算点a到点b距离  </span><br>    <span class="hljs-type">double</span> x = a.x - b.x;  <br>    <span class="hljs-type">double</span> y = a.y - b.y;  <br>    <span class="hljs-keyword">return</span> x * x + y * y;  <br>&#125;  <br>  <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">graham</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;    <span class="hljs-comment">// n点的个数  </span><br>    top = <span class="hljs-number">1</span>; <span class="hljs-comment">// 初始化栈顶指针  </span><br>    s[<span class="hljs-number">0</span>] = p[<span class="hljs-number">0</span>]; <span class="hljs-comment">// 起点入栈  </span><br>    s[<span class="hljs-number">1</span>] = p[<span class="hljs-number">1</span>]; <span class="hljs-comment">// 第二个点入栈  </span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt; n; i++) &#123;  <br>        <span class="hljs-comment">// 如果当前点与栈顶两个点构成的向量方向不是逆时针，则栈顶点出栈  </span><br>        <span class="hljs-keyword">while</span> (top &gt; <span class="hljs-number">1</span> &amp;&amp; ((p[i] - s[top]) ^ (s[top - <span class="hljs-number">1</span>] - s[top])) &lt;= <span class="hljs-number">0</span>)  <br>            top--;  <br>        s[++top] = p[i]; <span class="hljs-comment">// 当前点入栈  </span><br>    &#125;  <br>&#125;  <br>  <br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">s_sqr</span><span class="hljs-params">(Point a, Point b, Point c)</span> </span>&#123;<span class="hljs-comment">// 计算三角形abc的面积平方  </span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">fabs</span>((a - b) ^ (c - b));  <br>&#125;  <br>  <br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">diameter</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">// 计算凸包的直径（即最远点对距离）  </span><br>    <span class="hljs-type">double</span> diam = <span class="hljs-number">0</span>;  <br>    <span class="hljs-type">int</span> j = <span class="hljs-number">2</span>; <span class="hljs-comment">// 初始化另一个点的索引  </span><br>    s[++top] = s[<span class="hljs-number">0</span>]; <span class="hljs-comment">// 将凸包的起点再次加入栈中，以便于计算  </span><br>    <span class="hljs-keyword">if</span> (top &lt; <span class="hljs-number">3</span>) <span class="hljs-comment">// 如果凸包中的点少于3个，直接返回这两点间的距离  </span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dis</span>(s[<span class="hljs-number">0</span>], s[<span class="hljs-number">1</span>]);  <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; top - <span class="hljs-number">1</span>; i++) &#123;  <br>        <span class="hljs-comment">// 旋转卡壳算法，寻找以s[i]和s[i+1]为基线的最远点s[j]  </span><br>        <span class="hljs-keyword">while</span> (<span class="hljs-built_in">s_sqr</span>(s[i], s[i + <span class="hljs-number">1</span>], s[j]) &lt; <span class="hljs-built_in">s_sqr</span>(s[i], s[i + <span class="hljs-number">1</span>], s[(j + <span class="hljs-number">1</span>) % top]))  <br>            j = (j + <span class="hljs-number">1</span>) % top; <span class="hljs-comment">// 更新j的值，取模是为了循环遍历凸包上的点  </span><br>        <span class="hljs-comment">// 更新直径，取当前基线与最远点的最大距离  </span><br>        diam = <span class="hljs-built_in">max</span>(diam, <span class="hljs-built_in">max</span>(<span class="hljs-built_in">dis</span>(s[i], s[j]), <span class="hljs-built_in">dis</span>(s[i + <span class="hljs-number">1</span>], s[j])));  <br>    &#125;  <br>    <span class="hljs-keyword">return</span> diam;  <br>&#125;  <br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">equal</span><span class="hljs-params">(<span class="hljs-type">double</span> a, <span class="hljs-type">double</span> b)</span></span>&#123;<span class="hljs-comment">// 判断两个浮点数是否相等  </span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">fabs</span>(a - b) &lt; eps;  <br>&#125;<br></code></pre></td></tr></table></figure><h5 id="点向量相关">点、向量相关</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//向量、点结构定义和操作</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">point</span>&#123;<br><span class="hljs-type">double</span> x,y;<br><span class="hljs-comment">//求点所在的象限</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">quad</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">if</span>(x&gt;<span class="hljs-number">0</span>&amp;&amp;y&gt;=<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<span class="hljs-keyword">if</span>(x&lt;=<span class="hljs-number">0</span>&amp;&amp;y&gt;<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">0</span>&amp;&amp;y&lt;=<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<span class="hljs-keyword">if</span>(x&gt;=<span class="hljs-number">0</span>&amp;&amp;y&lt;<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">4</span>;<br>&#125;<br>&#125;;<br><span class="hljs-comment">//以x升序排列，其次以y升序排列  </span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">sortXupYup</span><span class="hljs-params">(point u,point v)</span></span>&#123;  <br>    <span class="hljs-keyword">if</span>(u.x!=v.x) <span class="hljs-keyword">return</span> u.x&lt;v.x;  <br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> u.y&lt;v.y;  <br>&#125;  <br><span class="hljs-comment">//以y升序排列，其次以x升序排列  </span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">sortYupXup</span><span class="hljs-params">(point u,point v)</span></span>&#123;  <br>    <span class="hljs-keyword">if</span>(u.y!=v.y) <span class="hljs-keyword">return</span> u.y&lt;v.y;  <br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> u.x&lt;v.x;  <br>&#125;  <br><span class="hljs-comment">//对点进行极角排序</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">sortPointAngle</span><span class="hljs-params">(point a,point b)</span></span>&#123;<br><span class="hljs-keyword">if</span>(a.<span class="hljs-built_in">quad</span>()!=b.<span class="hljs-built_in">quad</span>()) <span class="hljs-keyword">return</span> a.<span class="hljs-built_in">quad</span>()&lt;b.<span class="hljs-built_in">quad</span>();<br><span class="hljs-keyword">return</span> (a^b)&gt;<span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//向量取模</span><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">norm</span><span class="hljs-params">(point u)</span></span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">sqrt</span>(u.x*u.x+u.y*u.y);<br>&#125;<br><span class="hljs-comment">//点到点的距离  </span><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">disPointPoint</span><span class="hljs-params">(point u,point v)</span></span>&#123;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">sqrt</span>((u.x-v.x)*(u.x-v.x)+(u.y-v.y)*(u.y-v.y));  <br>&#125;  <br><span class="hljs-comment">//向量的旋转  </span><br><span class="hljs-function">point <span class="hljs-title">SpinPoint</span><span class="hljs-params">(point u,<span class="hljs-type">double</span> zhita)</span></span>&#123;  <span class="hljs-comment">// 向量u绕原点旋转zhita角  </span><br>    <span class="hljs-comment">//逆时针旋转zhita角  </span><br>    <span class="hljs-type">double</span> r=<span class="hljs-built_in">sqrt</span>(u.x*u.x+u.y*u.y);  <br>    <span class="hljs-type">double</span> sinphi=u.y/r,cosinphi=u.x/r; <span class="hljs-comment">// 向量u的原始角度的正弦和余弦值  </span><br>    <span class="hljs-type">double</span> sinr=sinphi*<span class="hljs-built_in">cos</span>(zhita)+cosinphi*<span class="hljs-built_in">sin</span>(zhita); <span class="hljs-comment">// 旋转后角度的正弦值  </span><br>    <span class="hljs-type">double</span> cosr=cosinphi*<span class="hljs-built_in">cos</span>(zhita)-sinphi*<span class="hljs-built_in">sin</span>(zhita); <span class="hljs-comment">// 旋转后角度的余弦值  </span><br>    point v;  <br>    v.x=r*cosr;v.y=r*sinr;  <br>    <span class="hljs-keyword">return</span> v;  <br>&#125;  <br><span class="hljs-comment">// 求一组点中的最小距离 a为点的数组 size为数组大小 u,v表示这两个点 返回最小距离  </span><br><span class="hljs-comment">//分治法的入口,分治前需要排序  </span><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">mindisset1</span><span class="hljs-params">(point* a,<span class="hljs-type">int</span> size,<span class="hljs-type">int</span> &amp;u,<span class="hljs-type">int</span> &amp;v)</span></span>&#123;  <br>    <span class="hljs-comment">//函数起始入口  </span><br>    <span class="hljs-type">double</span> minn=<span class="hljs-number">1e18</span>; <span class="hljs-comment">// 初始化最小距离为一个非常大的数  </span><br>    <span class="hljs-built_in">sort</span>(a+<span class="hljs-number">1</span>,a+<span class="hljs-number">1</span>+size,sortXupYup); <span class="hljs-comment">// 对点集按照x坐标升序，y坐标升序进行排序  </span><br>    <span class="hljs-built_in">Nearestpoint</span>(a,<span class="hljs-number">1</span>,size,u,v,minn); <span class="hljs-comment">// 调用分治法函数求解最近点对  </span><br>    <span class="hljs-keyword">return</span> minn; <span class="hljs-comment">// 返回最小距离  </span><br>&#125;  <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Nearestpoint</span><span class="hljs-params">(point *a,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> &amp;u,<span class="hljs-type">int</span> &amp;v,<span class="hljs-type">double</span> &amp;d)</span></span>&#123;  <br>    <span class="hljs-comment">/*a点的数组 l左边界 r右边界 uv最近的两个点的index d最小距离  </span><br><span class="hljs-comment">      应当注意距离的定义形式，如果为平方的形式，      则代码中绝对值的部分也应当改为平方  </span><br><span class="hljs-comment">     */</span>    <span class="hljs-keyword">if</span>(l==r) <span class="hljs-keyword">return</span> ; <span class="hljs-comment">// 如果只有一个点，则没有最近点对，直接返回  </span><br>    <span class="hljs-keyword">if</span>(l+<span class="hljs-number">1</span>==r) &#123; <span class="hljs-comment">// 如果只有两个点，直接计算它们之间的距离  </span><br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">disPointPoint</span>(a[l],a[r])&lt;d) &#123; <span class="hljs-comment">// 这两个点的距离小于当前最小距离d  </span><br>            d = <span class="hljs-built_in">disPointPoint</span>(a[l], a[r]); <span class="hljs-comment">// 更新最小距离  </span><br>            u = l, v = r; <span class="hljs-comment">// 更新最近点对的索引  </span><br>        &#125;  <br>        <span class="hljs-keyword">return</span> ;  <br>    &#125;  <br>    <span class="hljs-type">int</span> mid=l+r&gt;&gt;<span class="hljs-number">1</span>,m=<span class="hljs-number">0</span>;  <br>    <span class="hljs-built_in">Nearestpoint</span>(a,l,mid,u,v,d),<span class="hljs-built_in">Nearestpoint</span>(a,mid+<span class="hljs-number">1</span>,r,u,v,d);  <br>    point b[r-l+<span class="hljs-number">10</span>]; <span class="hljs-comment">// 定义一个临时数组，用于存储中间区域附近的点  </span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=l;i&lt;=r;i++)&#123;  <br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">abs</span>(a[i].x-a[mid].x)&lt;d) <span class="hljs-comment">// 如果点a[i]到中间垂线的距离小于当前最小距离d  </span><br>            b[++m]=a[i]; <span class="hljs-comment">// 将点a[i]加入临时数组  </span><br>    &#125;  <br>    <span class="hljs-built_in">sort</span>(b+<span class="hljs-number">1</span>,b+<span class="hljs-number">1</span>+m,sortYupXup); <span class="hljs-comment">// 按照y坐标升序，x坐标升序对临时数组进行排序  </span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;  <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i+<span class="hljs-number">1</span>;j&lt;=m&amp;&amp;<span class="hljs-built_in">abs</span>(b[i].y-b[j].y)&lt;d;j++)&#123; <span class="hljs-comment">// 在临时数组中查找最近点对  </span><br>            <span class="hljs-keyword">if</span>(d&gt;<span class="hljs-built_in">disPointPoint</span>(b[i],b[j])) &#123; <span class="hljs-comment">// 找到更近的点对  </span><br>                d = <span class="hljs-built_in">disPointPoint</span>(b[i], b[j]); <span class="hljs-comment">// 更新最小距离  </span><br>                u = i, v = j; <span class="hljs-comment">// 更新最近点对的索引  </span><br>            &#125;  <br>        &#125;  <br>    &#125;  <br>    <span class="hljs-keyword">return</span> ;  <br>&#125;<br></code></pre></td></tr></table></figure><h5 id="maybe凸包相关">maybe凸包相关</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//余弦定理 计算cosC ab为邻边 c为对边  </span><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">cosinesLaw</span><span class="hljs-params">(<span class="hljs-type">double</span> a,<span class="hljs-type">double</span> b,<span class="hljs-type">double</span> c)</span></span>&#123;  <br>    <span class="hljs-keyword">return</span> (a*a+b*b-c*c)/(<span class="hljs-number">2</span>*a*b);  <br>&#125;  <br><span class="hljs-comment">//求三角形面积  </span><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">triarea</span><span class="hljs-params">(point u,point v,point w)</span></span>&#123;  <br>    <span class="hljs-comment">//叉积方法  </span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">abs</span>((v-u)^(w-u))/<span class="hljs-number">2.0</span>;  <br>&#125;  <br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">triarea</span><span class="hljs-params">(<span class="hljs-type">double</span> a,<span class="hljs-type">double</span> b,<span class="hljs-type">double</span> c)</span></span>&#123; <span class="hljs-comment">// abc为三角形边长  </span><br>    <span class="hljs-comment">//海伦公式  </span><br>    <span class="hljs-type">double</span> p=(a+b+c)/<span class="hljs-number">2</span>;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">sqrt</span>(p*(p-a)*(p-b)*(p-c));  <br>&#125;  <br><span class="hljs-comment">//求多边形的面积  </span><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">polygonArea</span><span class="hljs-params">(point *u,<span class="hljs-type">int</span> size)</span></span>&#123;  <br>    <span class="hljs-type">double</span> area=<span class="hljs-number">0</span>;  <br>    point begin=u[<span class="hljs-number">0</span>];  <br>    <span class="hljs-comment">/*  </span><br><span class="hljs-comment">      由第一个点起始的顺序叉积，其中，点可以无序，  </span><br><span class="hljs-comment">      面积值为边之间连线的封闭部分，叉积能够计算容斥部分  </span><br><span class="hljs-comment">     */</span>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;size;i++) area+=((u[i<span class="hljs-number">-1</span>]-begin)^(u[i]-begin))/<span class="hljs-number">2</span>;  <br>    <span class="hljs-keyword">return</span> area;  <br>&#125;  <br><span class="hljs-comment">//判断一个点是否在多边形内 u需要判断的点 v多边形顶点数组 size多边形顶点数量  </span><br><span class="hljs-comment">// 多边形的顶点按照顺时针或逆时针顺序排列（先调用凸包中的sort和cmp按照极角给点排序）  </span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Isinside</span><span class="hljs-params">(point u,point *v,<span class="hljs-type">int</span> size)</span></span>&#123;  <br>    <span class="hljs-comment">// 检查点u是否在以v[1]为起点的两条边界线的同一侧，如果不在同一侧，则点u不在多边形内  </span><br>    <span class="hljs-keyword">if</span>(((v[size]-v[<span class="hljs-number">1</span>])^(u-v[<span class="hljs-number">1</span>]))&gt;<span class="hljs-number">0</span>||((v[<span class="hljs-number">2</span>]-v[<span class="hljs-number">1</span>])^(u-v[<span class="hljs-number">1</span>]))&lt;<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <br>    <span class="hljs-type">int</span> l=<span class="hljs-number">2</span>,r=size; <span class="hljs-comment">// 初始化二分查找的左右边界  </span><br>    <span class="hljs-keyword">while</span>(l&lt;=r)&#123; <span class="hljs-comment">// 进行二分查找，找到点u在多边形边界上的位置  </span><br>        <span class="hljs-type">int</span> mid=l+r&gt;&gt;<span class="hljs-number">1</span>;  <br>        <span class="hljs-comment">// 判断点u相对于以v[1]为起点的边界线的位置  </span><br>        <span class="hljs-keyword">if</span>(((v[mid]-v[<span class="hljs-number">1</span>])^(u-v[<span class="hljs-number">1</span>]))&lt;<span class="hljs-number">0</span>) l=mid+<span class="hljs-number">1</span>; <span class="hljs-comment">// 点u在边界线的左侧，调整左边界  </span><br>        <span class="hljs-keyword">else</span> r=mid<span class="hljs-number">-1</span>; <span class="hljs-comment">// 点u在边界线的右侧或在线上，调整右边界  </span><br>    &#125;  <br>    <span class="hljs-comment">// 检查点u是否在以v[r]和v[l]为端点的边界线的同一侧或线上，如果是，则点u在多边形内  </span><br>    <span class="hljs-keyword">if</span>(((v[r]-v[l])^(u-v[l]))&gt;=<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <br>&#125;<br></code></pre></td></tr></table></figure><h5 id="直线相关">直线相关</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//直线结构定义和直线的极角排序  </span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">line</span>&#123;  <br>    <span class="hljs-comment">//ax+by+c=0  </span><br>    <span class="hljs-type">double</span> a,b,c;  <br>    <span class="hljs-comment">//u为直线上一点，v为方向向量  </span><br>    point u,v;  <br>    <span class="hljs-built_in">line</span>()&#123;&#125;  <br>    <span class="hljs-comment">//两点确定的直线方程  </span><br>    <span class="hljs-built_in">line</span>(point p,point q)&#123;  <br>        a=p.y-q.y;b=q.x-p.x;c=p.x*q.y-q.x*p.y;<span class="hljs-comment">// 根据两点式求直线方程系数  </span><br>        <span class="hljs-comment">//保证u、v两点逆时针排列  </span><br>        <span class="hljs-keyword">if</span>((p^q)&lt;<span class="hljs-number">0</span>) <span class="hljs-built_in">swap</span>(p,q);  <br>        u=p;v=q-p;  <br>    &#125;  <br>&#125;;  <br><span class="hljs-comment">//对直线进行极角排序 极角是指直线方向向量与x轴正方向的夹角  </span><br><span class="hljs-comment">// 调用：sort(lines.begin(), lines.end(), sortLineAngle);  </span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">sortLineAngle</span><span class="hljs-params">(line a,line b)</span></span>&#123;  <br>    <span class="hljs-comment">// 首先比较两条直线的方向向量所在象限  </span><br>    <span class="hljs-keyword">if</span>(a.v.<span class="hljs-built_in">quad</span>()!=b.v.<span class="hljs-built_in">quad</span>()) <span class="hljs-keyword">return</span> a.v.<span class="hljs-built_in">quad</span>()&lt;b.v.<span class="hljs-built_in">quad</span>();  <br>    <span class="hljs-comment">// 如果方向向量在同一象限，则比较它们的叉积  </span><br>    <span class="hljs-keyword">else</span> <span class="hljs-built_in">return</span> (a.v^b.v)==<span class="hljs-number">0</span>?(a.v^(a.u-b.u))&gt;<span class="hljs-number">0</span>:(a.v^b.v)&gt;<span class="hljs-number">0</span>;  <br>&#125;  <br>  <br><span class="hljs-comment">//点、线运算  </span><br>  <br><span class="hljs-comment">//点u到直线l的距离  </span><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">disPointLine</span><span class="hljs-params">(point u,line l)</span></span>&#123;  <br>    <span class="hljs-type">double</span> length;  <br>    length = <span class="hljs-built_in">abs</span>(l.a*u.x+l.b*u.y+l.c)/(<span class="hljs-built_in">sqrt</span>(l.a*l.a+l.b*l.b));  <br>    <span class="hljs-keyword">return</span> length;  <br>&#125;  <br><span class="hljs-comment">//点u在直线l上的投影点 返回投影点v  </span><br><span class="hljs-function">point <span class="hljs-title">proPointLine</span><span class="hljs-params">(point u,line l)</span></span>&#123;  <br>    point v;  <br>    <span class="hljs-comment">// 计算投影点坐标的参数t  </span><br>    <span class="hljs-type">double</span> t=(-u.x*l.a-u.y*l.b-l.c)/(l.a*l.a+l.b*l.b);  <br>    <span class="hljs-comment">// 根据参数t和直线方程计算投影点坐标  </span><br>    v.x=u.x+l.a*t;  <br>    v.y=u.y+l.b*t;  <br>    <span class="hljs-keyword">return</span> v;  <br>&#125;  <br><span class="hljs-comment">// 点到线段的距离 点u到线段vw的距离 返回点到线段的距离  </span><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">disPointSeg</span><span class="hljs-params">(point u, point v, point w)</span> </span>&#123;  <br>    <span class="hljs-comment">// d1是向量uv在向量vw上的投影长度的平方  </span><br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> d1 = (u.x - v.x) * (w.x - v.x) + (u.y - v.y) * (w.y - v.y);  <br>    <span class="hljs-comment">// 如果投影长度小于等于0，说明点u在v点或v点延长线上，直接计算uv的距离  </span><br>    <span class="hljs-keyword">if</span> (d1 &lt;= <span class="hljs-number">0.0</span>) <span class="hljs-keyword">return</span> <span class="hljs-built_in">sqrt</span>((u.x - v.x) * (u.x - v.x) + (u.y - v.y) * (u.y - v.y));  <br>    <span class="hljs-comment">// d2是向量vw的长度的平方  </span><br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> d2 = (v.x - w.x) * (v.x - w.x) + (v.y - w.y) * (v.y - w.y);  <br>    <span class="hljs-comment">// 如果投影长度大于等于d2，说明点u在w点或w点延长线上，直接计算uw的距离  </span><br>    <span class="hljs-keyword">if</span> (d1 &gt;= d2) <span class="hljs-keyword">return</span> <span class="hljs-built_in">sqrt</span>((u.x - w.x) * (u.x - w.x) + (u.y - w.y) * (u.y - w.y));  <br>    <span class="hljs-comment">// 计算点u在vw上的投影点坐标  </span><br>    <span class="hljs-type">double</span> r = <span class="hljs-number">1.0</span> * d1 / d2;  <br>    <span class="hljs-type">double</span> px = v.x + (w.x - v.x) * r;  <br>    <span class="hljs-type">double</span> py = v.y + (w.y - v.y) * r;  <br>    <span class="hljs-comment">// 返回点u到其投影点的距离  </span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">sqrt</span>((u.x - px) * (u.x - px) + (u.y - py) * (u.y - py));  <br>&#125;  <br><span class="hljs-comment">// 求两直线的交点 线段l1l2 返回交点p  </span><br><span class="hljs-function">point <span class="hljs-title">itsLineLine</span><span class="hljs-params">(line l1, line l2)</span> </span>&#123;  <br>    point p;  <br>    <span class="hljs-comment">// k是两直线方程系数的行列式，用于判断两直线是否平行  </span><br>    <span class="hljs-type">double</span> k = l1.a * l2.b - l1.b * l2.a;  <br>    <span class="hljs-comment">// 计算交点坐标，使用克莱姆法则解线性方程组  </span><br>    p.x = -(l1.c * l2.b - l1.b * l2.c) / k;  <br>    p.y = -(l1.a * l2.c - l1.c * l2.a) / k;  <br>    <span class="hljs-keyword">return</span> p;  <br>&#125;  <br>  <br><span class="hljs-comment">// 计算多个半平面的交集，并返回交集区域的多边形顶点  </span><br><span class="hljs-type">const</span> line bd[<span class="hljs-number">4</span>] = &#123;<span class="hljs-comment">// 定义四个边界直线，形成一个无限大的矩形，用于限制半平面的范围  </span><br>        <span class="hljs-built_in">line</span>(point&#123;-INF,-INF&#125;,point&#123;INF,-INF&#125;),<span class="hljs-built_in">line</span>(point&#123;INF,-INF&#125;,point&#123;INF,INF&#125;),  <br>        <span class="hljs-built_in">line</span>(point&#123;INF,INF&#125;,point&#123;-INF,INF&#125;),<span class="hljs-built_in">line</span>(point&#123;-INF,INF&#125;,point&#123;-INF,-INF&#125;),  <br>&#125;;  <br><span class="hljs-function">vector&lt;point&gt; <span class="hljs-title">HalfPlaneInter</span><span class="hljs-params">(vector&lt;line&gt; k)</span></span>&#123; <span class="hljs-comment">// 计算多个半平面的交集，返回交集的多边形顶点  </span><br>    <span class="hljs-comment">// 将边界直线添加到半平面直线集合中  </span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) k.<span class="hljs-built_in">push_back</span>(bd[i]);  <br>    <span class="hljs-comment">// 按照直线的极角进行排序  </span><br>    <span class="hljs-built_in">sort</span>(k.<span class="hljs-built_in">begin</span>(), k.<span class="hljs-built_in">end</span>(), sortLineAngle);  <br>  <br>    deque&lt;line&gt; q; <span class="hljs-comment">// 存储当前考虑的直线  </span><br>    deque&lt;point&gt; c; <span class="hljs-comment">// 存储交点  </span><br>    vector&lt;point&gt; ans; <span class="hljs-comment">// 存储最终的多边形顶点  </span><br>    <span class="hljs-type">int</span> m = <span class="hljs-number">0</span>; <span class="hljs-comment">// 用于去除重复的直线  </span><br>    <span class="hljs-comment">// 去除方向向量相同的直线  </span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; k.<span class="hljs-built_in">size</span>(); i++) <span class="hljs-keyword">if</span> ((k[m].v ^ k[i].v) != <span class="hljs-number">0</span>) k[++m] = k[i];  <br>  <br>    <span class="hljs-comment">// 初始化队列  </span><br>    q.<span class="hljs-built_in">push_back</span>(k[<span class="hljs-number">0</span>]);  <br>    <span class="hljs-comment">// 遍历所有直线，构建半平面交集  </span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;  <br>        <span class="hljs-comment">// 维护队列，确保队列中的直线形成的多边形是有效的  </span><br>        <span class="hljs-keyword">while</span> (c.<span class="hljs-built_in">size</span>() &amp;&amp; ((c.<span class="hljs-built_in">back</span>() - k[i].u) ^ k[i].v) &gt;= <span class="hljs-number">0</span>) &#123;  <br>            q.<span class="hljs-built_in">pop_back</span>();  <br>            c.<span class="hljs-built_in">pop_back</span>();  <br>        &#125;  <br>        <span class="hljs-keyword">while</span> (c.<span class="hljs-built_in">size</span>() &amp;&amp; ((c.<span class="hljs-built_in">front</span>() - k[i].u) ^ k[i].v) &gt;= <span class="hljs-number">0</span>) &#123;  <br>            q.<span class="hljs-built_in">pop_front</span>();  <br>            c.<span class="hljs-built_in">pop_front</span>();  <br>        &#125;  <br>        <span class="hljs-comment">// 计算当前直线与队列中最后一条直线的交点，并添加到队列中  </span><br>        c.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">itsLineLine</span>(k[i], q.<span class="hljs-built_in">back</span>()));  <br>        q.<span class="hljs-built_in">push_back</span>(k[i]);  <br>    &#125;  <br>    <span class="hljs-comment">// 清理队列中的无效直线和交点  </span><br>    <span class="hljs-keyword">while</span> (c.<span class="hljs-built_in">size</span>() &amp;&amp; ((c.<span class="hljs-built_in">back</span>() - q.<span class="hljs-built_in">front</span>().u) ^ q.<span class="hljs-built_in">front</span>().v) &gt;= <span class="hljs-number">0</span>) &#123;  <br>        q.<span class="hljs-built_in">pop_back</span>();  <br>        c.<span class="hljs-built_in">pop_back</span>();  <br>    &#125;  <br>    <span class="hljs-comment">// 将交点添加到答案中  </span><br>    <span class="hljs-keyword">while</span> (c.<span class="hljs-built_in">size</span>()) &#123;  <br>        ans.<span class="hljs-built_in">push_back</span>(c.<span class="hljs-built_in">front</span>());  <br>        c.<span class="hljs-built_in">pop_front</span>();  <br>    &#125;  <br>    <span class="hljs-comment">// 如果队列中有多于一条直线，添加最后两条直线的交点  </span><br>    <span class="hljs-keyword">if</span> (q.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span>) ans.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">itsLineLine</span>(q.<span class="hljs-built_in">front</span>(), q.<span class="hljs-built_in">back</span>()));  <br>    <span class="hljs-keyword">return</span> ans;  <br>&#125;<br></code></pre></td></tr></table></figure><h5 id="圆相关">圆相关</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//圆结构  </span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">circle</span>&#123;  <br>    <span class="hljs-comment">//圆心  </span><br>    point cc;  <br>    <span class="hljs-comment">//半径  </span><br>    <span class="hljs-type">double</span> radius;  <br>&#125;;  <br><span class="hljs-comment">//求三点uvw所确定的圆c  </span><br><span class="hljs-function">circle <span class="hljs-title">concyclic</span><span class="hljs-params">(point u, point v, point w)</span> </span>&#123;  <br>    circle c;  <br>    point o;  <br>    <span class="hljs-comment">// 计算圆心坐标的系数k  </span><br>    <span class="hljs-type">double</span> k = <span class="hljs-number">2</span> * (v.x - u.x) * (w.y - v.y) - <span class="hljs-number">2</span> * (v.y - u.y) * (w.x - v.x);  <br>    <span class="hljs-comment">// 计算圆心o的x坐标  </span><br>    o.x = (w.y - v.y) * (v.x * v.x + v.y * v.y - u.x * u.x - u.y * u.y) - (v.y - u.y) * (w.x * w.x + w.y * w.y - v.x * v.x - v.y * v.y);  <br>    <span class="hljs-comment">// 计算圆心o的y坐标  </span><br>    o.y = (v.x - u.x) * (w.x * w.x + w.y * w.y - v.x * v.x - v.y * v.y) - (w.x - v.x) * (v.x * v.x + v.y * v.y - u.x * u.x - u.y * u.y);  <br>    o.x /= k; o.y /= k; <span class="hljs-comment">// 除以系数k得到圆心坐标  </span><br>    c.cc = o; <span class="hljs-comment">// 设置圆心  </span><br>    c.radius = <span class="hljs-built_in">disPointPoint</span>(o, u); <span class="hljs-comment">// 计算半径并设置  </span><br>    <span class="hljs-keyword">return</span> c;  <br>&#125;  <br><span class="hljs-comment">//求圆c与直线l的交点ans  </span><br><span class="hljs-function">vector&lt;point&gt; <span class="hljs-title">itsStrCir</span><span class="hljs-params">(line l, circle c)</span> </span>&#123;  <br>    <span class="hljs-type">double</span> k = l.u * l.v; <span class="hljs-comment">// 计算直线与圆心的向量点积  </span><br>    <span class="hljs-type">double</span> a = <span class="hljs-built_in">norm</span>(l.u), b = <span class="hljs-built_in">norm</span>(l.v); <span class="hljs-comment">// 计算直线向量的模的平方  </span><br>    <span class="hljs-type">double</span> r = c.radius; <span class="hljs-comment">// 圆的半径  </span><br>    <span class="hljs-type">double</span> d = k * k - b * b * (a * a - r * r); <span class="hljs-comment">// 计算判别式  </span><br>    vector&lt;point&gt; ans;  <br>    <span class="hljs-comment">// 判别式为0，有一个交点  </span><br>    <span class="hljs-keyword">if</span> (d == <span class="hljs-number">0</span>) ans.<span class="hljs-built_in">push_back</span>(l.u + l.v * (-k / (b * b)));  <br>    <span class="hljs-comment">// 判别式大于0，有两个交点  </span><br>    <span class="hljs-keyword">else</span> &#123;  <br>        ans.<span class="hljs-built_in">push_back</span>(l.u + l.v * ((-k + d) / (b * b)));  <br>        ans.<span class="hljs-built_in">push_back</span>(l.u + l.v * ((-k - d) / (b * b)));  <br>    &#125;  <br>    <span class="hljs-comment">// 返回交点集合  </span><br>    <span class="hljs-keyword">return</span> ans;  <br>&#125;  <br><span class="hljs-comment">// 求两圆c1c2的交点ans  </span><br><span class="hljs-function">vector&lt;point&gt; <span class="hljs-title">itsCirCir</span><span class="hljs-params">(circle c1, circle c2)</span> </span>&#123;  <br>    vector&lt;point&gt; ans;  <br>    point o1 = c1.cc, o2 = c2.cc; <span class="hljs-comment">// 圆心o1和o2  </span><br>    point a = o2 - o1; <span class="hljs-comment">// 向量a从o1指向o2  </span><br>    point b; <span class="hljs-comment">// 向量b垂直于a  </span><br>    b.x = a.y; b.y = -a.x;  <br>    <span class="hljs-type">double</span> r1 = c1.radius, r2 = c2.radius; <span class="hljs-comment">// 两圆的半径  </span><br>    <span class="hljs-type">double</span> d = <span class="hljs-built_in">disPointPoint</span>(o1, o2); <span class="hljs-comment">// 圆心距离  </span><br>    <span class="hljs-type">double</span> S = <span class="hljs-built_in">triarea</span>(r1, r2, d); <span class="hljs-comment">// 两圆半径和圆心距离构成的三角形面积  </span><br>    <span class="hljs-type">double</span> h = <span class="hljs-number">2</span> * S / d; <span class="hljs-comment">// 交点连线的中垂线到圆心连线的距离  </span><br>    <span class="hljs-type">double</span> t = <span class="hljs-built_in">sqrt</span>(r1 * r1 - h * h);  <br>    <span class="hljs-keyword">if</span> (r1 * r1 + d * d &lt; r2 * r2) t = -t; <span class="hljs-comment">// 如果两圆内含，调整t的符号  </span><br>    <span class="hljs-comment">// 计算交点  </span><br>    <span class="hljs-keyword">if</span> (h == <span class="hljs-number">0</span>) &#123;  <br>        <span class="hljs-comment">// 如果h为0，两圆相切，只有一个交点  </span><br>        ans.<span class="hljs-built_in">push_back</span>(o1 + a * t / <span class="hljs-built_in">norm</span>(a));  <br>    &#125; <span class="hljs-keyword">else</span> &#123;  <br>        <span class="hljs-comment">// 否则有两组交点  </span><br>        ans.<span class="hljs-built_in">push_back</span>(o1 + a * t / <span class="hljs-built_in">norm</span>(a) + b * h / <span class="hljs-built_in">norm</span>(b));  <br>        ans.<span class="hljs-built_in">push_back</span>(o1 + a * t / <span class="hljs-built_in">norm</span>(a) - b * h / <span class="hljs-built_in">norm</span>(b));  <br>    &#125;  <br>    <span class="hljs-keyword">return</span> ans;  <br>&#125;  <br><span class="hljs-comment">// 求一点u与圆c的切线ans  </span><br><span class="hljs-function">vector&lt;line&gt; <span class="hljs-title">tlPointCircle</span><span class="hljs-params">(point u, circle c)</span> </span>&#123;  <br>    vector&lt;line&gt; ans;  <br>    <span class="hljs-comment">// 构造一个辅助圆，圆心为u和c.cc的中点，半径为u到c.cc距离的一半  </span><br>    circle o;  <br>    o.cc = (c.cc + u) / <span class="hljs-number">2</span>;  <br>    o.radius = <span class="hljs-built_in">disPointPoint</span>(c.cc, u) / <span class="hljs-number">2</span>;  <br>    <span class="hljs-comment">// 求辅助圆与原圆的交点  </span><br>    vector&lt;point&gt; p = <span class="hljs-built_in">itsCirCir</span>(o, c);  <br>    <span class="hljs-comment">// 如果只有一个交点，则切线只有一条  </span><br>    <span class="hljs-keyword">if</span> (p.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>) &#123;  <br>        point v;  <br>        v.x = (u - c.cc).y; v.y = -(u - c.cc).x;  <br>        ans.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">line</span>(u, u + v));  <br>    &#125;  <br>    <span class="hljs-comment">// 如果有两个交点，则切线有两条  </span><br>    <span class="hljs-keyword">if</span> (p.<span class="hljs-built_in">size</span>() == <span class="hljs-number">2</span>) &#123;  <br>        ans.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">line</span>(p[<span class="hljs-number">0</span>], u));  <br>        ans.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">line</span>(p[<span class="hljs-number">1</span>], u));  <br>    &#125;  <br>    <span class="hljs-keyword">return</span> ans;  <br>&#125;  <br><span class="hljs-comment">// 求两圆c1c2的公切线ans  </span><br><span class="hljs-function">vector&lt;line&gt; <span class="hljs-title">comTangent</span><span class="hljs-params">(circle c1, circle c2)</span> </span>&#123;  <br>    vector&lt;line&gt; ans, q;  <br>    <span class="hljs-type">int</span> r1 = c1.radius, r2 = c2.radius; <span class="hljs-comment">// 两圆的半径  </span><br>    <span class="hljs-type">int</span> d = <span class="hljs-built_in">disPointPoint</span>(c1.cc, c2.cc); <span class="hljs-comment">// 两圆心之间的距离  </span><br>    point u, v, a = c2.cc - c1.cc, t; <span class="hljs-comment">// 向量a从c1的圆心指向c2的圆心  </span><br>    <span class="hljs-comment">// 如果两圆半径相等，则有两条外公切线和两条内公切线  </span><br>    <span class="hljs-keyword">if</span> (r1 == r2) &#123;  <br>        u = c1.cc - c2.cc;  <br>        v.x = u.y; v.y = -u.x; <span class="hljs-comment">// v是u的垂直向量  </span><br>        <span class="hljs-comment">// 添加两条外公切线  </span><br>        ans.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">line</span>(c1.cc + v * r1 / <span class="hljs-built_in">norm</span>(v), c1.cc + v * r1 / <span class="hljs-built_in">norm</span>(v) + u));  <br>        ans.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">line</span>(c1.cc - v * r1 / <span class="hljs-built_in">norm</span>(v), c1.cc - v * r1 / <span class="hljs-built_in">norm</span>(v) + u));  <br>    &#125; <span class="hljs-keyword">else</span> &#123;  <br>        <span class="hljs-comment">// 内侧切线（内公切线）  </span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">triarea</span>(r1, r2, d) == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 如果两圆内切  </span><br>            t = c1.cc + a * r1 / r2; <span class="hljs-comment">// 计算切点  </span><br>            q = <span class="hljs-built_in">tlPointCircle</span>(t, c1); <span class="hljs-comment">// 求切线  </span><br>            <span class="hljs-keyword">while</span> (q.<span class="hljs-built_in">size</span>()) &#123; ans.<span class="hljs-built_in">push_back</span>(q.<span class="hljs-built_in">back</span>()); q.<span class="hljs-built_in">pop_back</span>(); &#125; <span class="hljs-comment">// 添加到答案中  </span><br>        &#125;  <br>        <span class="hljs-comment">// 外侧切线（外公切线）  </span><br>        t = c1.cc + a * r1 / (r1 - r2); <span class="hljs-comment">// 计算切点  </span><br>        q = <span class="hljs-built_in">tlPointCircle</span>(t, c1); <span class="hljs-comment">// 求切线  </span><br>        <span class="hljs-keyword">while</span> (q.<span class="hljs-built_in">size</span>()) &#123; ans.<span class="hljs-built_in">push_back</span>(q.<span class="hljs-built_in">back</span>()); q.<span class="hljs-built_in">pop_back</span>(); &#125; <span class="hljs-comment">// 添加到答案中  </span><br>    &#125;  <br>    <span class="hljs-keyword">return</span> ans;  <br>&#125;  <br><span class="hljs-comment">// 最小圆覆盖 给定点集u和点的数量size，求最小的圆c能够覆盖所有点  </span><br><span class="hljs-function">circle <span class="hljs-title">Smallestcir</span><span class="hljs-params">(point *u, <span class="hljs-type">int</span> size)</span> </span>&#123;  <br>    <span class="hljs-built_in">random_shuffle</span>(u + <span class="hljs-number">1</span>, u + <span class="hljs-number">1</span> + size); <span class="hljs-comment">// 随机打乱点集  </span><br>    point o = u[<span class="hljs-number">1</span>]; <span class="hljs-comment">// 初始圆心为第一个点  </span><br>    <span class="hljs-type">double</span> r = <span class="hljs-number">0</span>; <span class="hljs-comment">// 初始半径为0  </span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= size; i++) &#123;  <br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">disPointPoint</span>(o, u[i]) &lt;= r) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// 如果点在当前圆内，跳过  </span><br>        o = (u[i] + u[<span class="hljs-number">1</span>]) / <span class="hljs-number">2</span>; <span class="hljs-comment">// 更新圆心为i和1号点的中点  </span><br>        r = <span class="hljs-built_in">disPointPoint</span>(u[i], u[<span class="hljs-number">1</span>]) / <span class="hljs-number">2</span>; <span class="hljs-comment">// 更新半径为i和1号点距离的一半  </span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">2</span>; j &lt; i; j++) &#123;  <br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">disPointPoint</span>(u[j], o) &lt;= r) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// 如果点在当前圆内，跳过  </span><br>            o = (u[i] + u[j]) / <span class="hljs-number">2</span>; <span class="hljs-comment">// 更新圆心为i和j号点的中点  </span><br>            r = <span class="hljs-built_in">disPointPoint</span>(u[i], u[j]) / <span class="hljs-number">2</span>; <span class="hljs-comment">// 更新半径为i和j号点距离的一半  </span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k &lt; j; k++) &#123;  <br>                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">disPointPoint</span>(u[k], o) &lt;= r) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// 如果点在当前圆内，跳过  </span><br>                circle c = <span class="hljs-built_in">concyclic</span>(u[i], u[j], u[k]); <span class="hljs-comment">// 求通过i、j、k三点的圆  </span><br>                o = c.cc; r = c.radius; <span class="hljs-comment">// 更新圆心和半径  </span><br>            &#125;  <br>        &#125;  <br>    &#125;  <br>    circle c;  <br>    c.cc = o; c.radius = r;  <br>    <span class="hljs-keyword">return</span> c;  <br>&#125;<br></code></pre></td></tr></table></figure><h5 id="快速幂取余">快速幂取余</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 快速幂取模函数 计算 (a^b) % m 的结果res  </span><br><span class="hljs-function">ll <span class="hljs-title">fast_pow_mod</span><span class="hljs-params">(ll a, ll b, ll m)</span></span>&#123;  <br>    a %= m; <span class="hljs-comment">// 对a取模，减少后续计算中的数值大小  </span><br>    ll res = <span class="hljs-number">1</span>; <span class="hljs-comment">// 初始化结果为1（任何数的0次幂都是1）  </span><br>    <span class="hljs-keyword">while</span> (b &gt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 当指数b大于0时，进行循环  </span><br>        <span class="hljs-comment">// 如果b的当前最低位为1，则将当前a乘到结果中  </span><br>        <span class="hljs-keyword">if</span> (b &amp; <span class="hljs-number">1</span>) res = res * a % m;  <br>        a = a * a % m; <span class="hljs-comment">// 将a平方，用于下一轮循环  </span><br>        b &gt;&gt;= <span class="hljs-number">1</span>; <span class="hljs-comment">// 将b右移一位，相当于除以2  </span><br>    &#125;  <br>    <span class="hljs-keyword">return</span> res;  <br>&#125;<br></code></pre></td></tr></table></figure><h5 id="快速打质数表">快速打质数表</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 生成小于等于n的所有素数列表prime_list  </span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">generate_prime_list</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;  <br>    <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">2</span>) <span class="hljs-comment">// 如果n小于等于2，返回只包含2的列表  </span><br>        <span class="hljs-keyword">return</span> vector&lt;<span class="hljs-type">int</span>&gt;&#123;<span class="hljs-number">2</span>&#125;;  <br>    <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">3</span>) <span class="hljs-comment">// 如果n小于等于3，返回包含2和3的列表  </span><br>        <span class="hljs-keyword">return</span> vector&lt;<span class="hljs-type">int</span>&gt;&#123;<span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;  <br>    <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">5</span>) <span class="hljs-comment">// 如果n小于等于5，返回包含2、3和5的列表  </span><br>        <span class="hljs-keyword">return</span> vector&lt;<span class="hljs-type">int</span>&gt;&#123;<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>&#125;;  <br>    vector&lt;<span class="hljs-type">int</span>&gt; prime_list = &#123;<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>&#125;; <span class="hljs-comment">// 初始化素数列表，包含最小的三个素数2、3和5  </span><br>    <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; <span class="hljs-comment">// 初始化循环变量i  </span><br>    <span class="hljs-type">int</span> x;  <br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;  <br>        x = <span class="hljs-number">6</span> * i + <span class="hljs-number">1</span>; <span class="hljs-comment">// 计算6i+1，这是除了2和3之外素数的可能形式之一  </span><br>        <span class="hljs-keyword">if</span> (x &gt; n) <span class="hljs-comment">// 如果x大于n，则不再继续查找  </span><br>            <span class="hljs-keyword">break</span>;  <br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">is_prime</span>(x, prime_list)) <span class="hljs-comment">// 如果x是素数，则添加到素数列表中  </span><br>            prime_list.<span class="hljs-built_in">push_back</span>(x);  <br>  <br>        x = <span class="hljs-number">6</span> * i + <span class="hljs-number">5</span>; <span class="hljs-comment">// 计算6i+5，这是除了2和3之外素数的另一种可能形式  </span><br>        <span class="hljs-keyword">if</span> (x &gt; n) <span class="hljs-comment">// 如果x大于n，则不再继续查找  </span><br>            <span class="hljs-keyword">break</span>;  <br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">is_prime</span>(x, prime_list)) <span class="hljs-comment">// 如果x是素数，则添加到素数列表中  </span><br>            prime_list.<span class="hljs-built_in">push_back</span>(x);  <br>  <br>        i++; <span class="hljs-comment">// 增加i，用于下一轮计算  </span><br>    &#125;  <br>    <span class="hljs-keyword">return</span> prime_list;  <br>&#125;  <br>  <br><span class="hljs-comment">// 判断一个数x是否为素数，利用已知的素数列表prime_list进行判断  </span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">is_prime</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt; &amp;prime_list)</span> </span>&#123;  <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> u: prime_list)&#123; <span class="hljs-comment">// 遍历素数列表中的每个素数u  </span><br>        <span class="hljs-keyword">if</span>(x % u == <span class="hljs-number">0</span>) <span class="hljs-comment">// 如果x能被u整除，则x不是素数  </span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <br>        <span class="hljs-keyword">if</span>(u * u &gt; x) <span class="hljs-comment">// 如果u的平方大于x，则x是素数  </span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <br>    &#125;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 如果没有找到能整除x的素数，则x是素数  </span><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="单调栈">单调栈</h5><ul><li><p>寻找<strong>左</strong>侧第一个比当前元素<strong>大</strong>的元素：从左到右遍历元素，构造<strong>单调递增栈</strong>（从栈顶到栈底递增）一个元素左侧第一个比它大的元素就是将其「<strong>插入单调递增栈</strong>」时的栈顶元素。如果插入时的栈为空，则说明左侧不存在比当前元素大的元素。</p></li><li><p>寻找<strong>左</strong>侧第一个比当前元素<strong>小</strong>的元素：从左到右遍历元素，构造<strong>单调递减栈</strong>（从栈顶到栈底递减）一个元素左侧第一个比它小的元素就是将其「<strong>插入</strong>单调递减栈」时的栈顶元素。如果插入时的栈为空，则说明左侧不存在比当前元素小的元素。</p></li><li><p>寻找<strong>右</strong>侧第一个比当前元素<strong>大</strong>的元素：从左到右遍历元素，构造<strong>单调递增栈</strong>（从栈顶到栈底递增）一个元素右侧第一个比它大的元素就是将其「<strong>弹出</strong>单调递增栈」时即将插入的元素。如果该元素没有被弹出栈，则说明右侧不存在比当前元素大的元素。</p></li><li><p>寻找<strong>右</strong>侧第一个比当前元素<strong>小</strong>的元素：从左到右遍历元素，构造<strong>单调递减栈</strong>（从栈顶到栈底递减）一个元素右侧第一个比它小的元素就是将其「<strong>弹出</strong>单调递减栈」时即将插入的元素。如果该元素没有被弹出栈，则说明右侧不存在比当前元素小的元素。</p></li><li><p>查找 <strong>「比当前元素大的元素」</strong> 就用<strong>单调递增栈</strong>，查找<strong>「比当前元素小的元素」</strong> 就用<strong>单调递减栈</strong>。</p></li><li><p>从 <strong>「左侧」</strong> 查找就看 <strong>「插入栈」</strong>时的栈顶元素，从 <strong>「右侧」</strong> 查找就看<strong>「弹出栈」</strong> 时即将插入的元素。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX (300000+10)  </span><br>  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">monoIncreaseStack</span><span class="hljs-params">(<span class="hljs-type">int</span> height, <span class="hljs-type">int</span> id)</span></span>;  <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> height, <span class="hljs-type">long</span> <span class="hljs-type">long</span> id)</span></span>;  <br><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span></span>;  <br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">student</span>&#123;  <br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> id;  <br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> height;  <br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> leftBigId, rightBigId; <span class="hljs-comment">// 左侧第一个比当前元素的height大的数的id 右侧...  </span><br>&#125;;  <br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">student</span> stacks[MAX]; <span class="hljs-comment">// 栈  </span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">student</span> students[MAX]; <span class="hljs-comment">// 所有的学生  </span><br><span class="hljs-type">int</span> Top = <span class="hljs-number">-1</span>;<span class="hljs-comment">// 栈指针  </span><br>  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;  <br>    <span class="hljs-type">int</span> t;  <br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;t);  <br>    <span class="hljs-keyword">while</span> (t--)&#123;  <br>        <span class="hljs-type">int</span> n;  <br>        Top = <span class="hljs-number">-1</span>;  <br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);  <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123; <span class="hljs-comment">// 读取所有height，单调栈处理  </span><br>            <span class="hljs-type">long</span> <span class="hljs-type">long</span> height;  <br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>, &amp;height);  <br>            students[i].height = height;  <br>            students[i].id = i;  <br>            <span class="hljs-built_in">monoIncreaseStack</span>(height, i);  <br>        &#125;  <br>        <span class="hljs-keyword">while</span>(Top != <span class="hljs-number">-1</span>)&#123;  <br>            <span class="hljs-comment">// 现在还在栈里的数的右侧都没有比它大的数  </span><br>            students[stacks[Top].id].rightBigId = n;  <br>            <span class="hljs-built_in">pop</span>();  <br>        &#125;  <br>    &#125;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">monoIncreaseStack</span><span class="hljs-params">(<span class="hljs-type">int</span> height, <span class="hljs-type">int</span> id)</span></span>&#123; <span class="hljs-comment">// 当前元素大小height index为id  </span><br>    <span class="hljs-comment">// 弹出所有比当前元素小的元素  </span><br>    <span class="hljs-keyword">while</span>(Top!=<span class="hljs-number">-1</span> &amp;&amp; height&gt;=stacks[Top].height)&#123;  <br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> popId = <span class="hljs-built_in">pop</span>();  <br>        students[popId].rightBigId = id; <span class="hljs-comment">// id是popId右侧第一个比它大的元素  </span><br>    &#125;  <br>    <span class="hljs-keyword">if</span>(Top == <span class="hljs-number">-1</span>)&#123;  <br>        students[id].leftBigId = <span class="hljs-number">-1</span>; <span class="hljs-comment">// id左侧没有比它大的元素  </span><br>    &#125;<span class="hljs-keyword">else</span>&#123;  <br>        students[id].leftBigId = stacks[Top].id;  <br>    &#125;  <br>    <span class="hljs-built_in">push</span>(height, id); <span class="hljs-comment">// 入栈  </span><br>&#125;  <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> height, <span class="hljs-type">long</span> <span class="hljs-type">long</span> id)</span></span>&#123;  <br>    stacks[++Top].height = height;  <span class="hljs-comment">// 入栈成功  </span><br>    stacks[Top].id = id;  <br>&#125;  <br><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span></span>&#123;  <br>    <span class="hljs-keyword">return</span> stacks[Top--].id;    <span class="hljs-comment">// 出栈成功  </span><br>&#125;<br></code></pre></td></tr></table></figure></p></li></ul><h5 id="秦九韶算法horner-规则">秦九韶算法/Horner 规则</h5><p><spanclass="math inline">\(A(x)=a_{n}x_{n}+a_{n−1}x_{n−1}+...+a_{1}x+a_{0}\)</span>在 <span class="math inline">\(x_{0}\)</span> 处的值相当于 <spanclass="math inline">\(a_0+x_0(a_{1}+...+x_{0}(a_{n−1}+x_{0}a_{n}))\)</span></p><h5 id="大数相乘">大数相乘</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java">#include &lt;stdio.h&gt;  <br>#include &lt;string.h&gt;  <br>  <br>#define MAX <span class="hljs-number">1000005</span>  <br><span class="hljs-type">char</span> s1[MAX], s2[MAX];  <br><span class="hljs-type">int</span> a1[MAX], a2[MAX], ans[MAX];  <br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-type">int</span> n;  <br>    scanf(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);  <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> z=<span class="hljs-number">0</span>; z&lt;n; z++)&#123;  <br>        <span class="hljs-type">int</span> i, j, len1, len2;  <br>        scanf(<span class="hljs-string">&quot;%s%s&quot;</span>, s1, s2);  <br>        len1 = strlen(s1);  <br>        len2 = strlen(s2);  <br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; len1; i++) &#123; <span class="hljs-comment">// 转化成数字后逆序存储</span><br>            a1[i] = s1[len1 - <span class="hljs-number">1</span> - i] - <span class="hljs-string">&#x27;0&#x27;</span>;  <br>        &#125;  <br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; len2; i++) &#123; <span class="hljs-comment">// 转化成数字后逆序存储</span><br>            a2[i] = s2[len2 - <span class="hljs-number">1</span> - i] - <span class="hljs-string">&#x27;0&#x27;</span>;  <br>        &#125;  <br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; len1; i++) &#123;  <br>            <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; len2; j++) &#123;  <br>                ans[i + j] += a1[i] * a2[j];  <br>            &#125;  <br>        &#125;  <br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; i &lt; len1 + len2; i++) &#123;  <br>            ans[i] += j;  <br>            j = ans[i] / <span class="hljs-number">10</span>; <span class="hljs-comment">// 8进制就把10换成8</span><br>            ans[i] %= <span class="hljs-number">10</span>; <span class="hljs-comment">// 8进制就把10换成8</span><br>        &#125;  <br>        <span class="hljs-type">int</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;  <br>        <span class="hljs-keyword">for</span> (; ans[i] == <span class="hljs-number">0</span>; i--)&#123; <span class="hljs-comment">//跳过前面的0  </span><br>            <span class="hljs-keyword">if</span>(i&lt;<span class="hljs-number">0</span>)&#123; <span class="hljs-comment">// 大数相乘结果本身就是0</span><br>                printf(<span class="hljs-string">&quot;0&quot;</span>);  <br>                puts(<span class="hljs-string">&quot;&quot;</span>);  <br>                flag = <span class="hljs-number">1</span>;  <br>                <span class="hljs-keyword">break</span>;  <br>            &#125;  <br>        &#125;       <br>        <span class="hljs-keyword">if</span>(flag == <span class="hljs-number">0</span>)&#123;  <br>            <span class="hljs-keyword">for</span> (; i &gt;= <span class="hljs-number">0</span>; i--) &#123; <span class="hljs-comment">// 逆序输出</span><br>                printf(<span class="hljs-string">&quot;%d&quot;</span>, ans[i]);  <br>                ans[i] = <span class="hljs-number">0</span>;  <br>            &#125;  <br>            puts(<span class="hljs-string">&quot;&quot;</span>);  <br>        &#125;  <br>    &#125;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></td></tr></table></figure><h5 id="随机数">随机数</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 生成0-99的随机数</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">Rand</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">rand</span>()%<span class="hljs-number">100</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="模逆元">模逆元</h5><p>模逆元：<span class="math inline">\(a×x≡1 (mod m)\)</span>如果p是一个质数，a是任意整数，且a不是p的倍数，那么a的模逆元可以表示为：<spanclass="math inline">\(a^{-1} \equiv a^{p-2} \ (\text{mod} \ p)\)</span>即 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">qmi</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> mom, <span class="hljs-type">long</span> <span class="hljs-type">long</span> b, <span class="hljs-type">long</span> <span class="hljs-type">long</span> mod)</span></span>&#123; <span class="hljs-comment">// 快速幂函数</span><br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> res = <span class="hljs-number">1</span>;  <br>    <span class="hljs-keyword">while</span>(b)&#123;  <br>        <span class="hljs-keyword">if</span>(b &amp; <span class="hljs-number">1</span>) res = res * mom % mod;  <br>        b &gt;&gt;= <span class="hljs-number">1</span>;  <br>        mom = mom * mom % mod;  <br>    &#125;  <br>    <span class="hljs-keyword">return</span> res;  <br>&#125;<br>x = <span class="hljs-built_in">qmi</span>(a, MOD<span class="hljs-number">-2</span>, MOD); <span class="hljs-comment">//x是a在mod MOD下的逆元</span><br></code></pre></td></tr></table></figure></p><h5 id="more">MORE……</h5><ul><li>双指针 left 和 right</li></ul>]]></content>
    
    
    <categories>
      
      <category>学习经验</category>
      
      <category>大二上</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习经验</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【学习经验】电位差预习报告</title>
    <link href="/2024/10/25/jwsy-dianWeiCha/"/>
    <url>/2024/10/25/jwsy-dianWeiCha/</url>
    
    <content type="html"><![CDATA[<h1 id="自组电位差计实验">1 自组电位差计实验</h1><h3 id="实验器材">1.1 实验器材</h3><h4 id="直流稳压电源">直流稳压电源</h4><p><img src="/img/jwsy-dwc/1.png" /></p><ul><li>有两路输出，TRACKING键都弹出时各路输出可单独使用</li><li>按下<strong>power键</strong>打开电源开关，面板显示额定输出电压和额定输出电流，可使用<strong>电压/电流调节旋钮</strong>调节。外电路连接完毕检查无误后按下<strong>output键</strong>，此时电源对外电路才有输出。</li><li>注意，在检查线路故障或拆线前先要关闭<strong>output</strong>，实验结束关闭<strong>电源开关</strong>。</li></ul><h4 id="标准电池和电阻箱">标准电池和电阻箱</h4><p><img src="/img/jwsy-dwc/2.png" /> <imgsrc="/img/jwsy-dwc/3.png" /></p><h4 id="指针式检流计">指针式检流计</h4><p><img src="/img/jwsy-dwc/4.png" /> +使用时将<strong>制动旋钮</strong>逆时针旋转到白色标记处解锁指针，<strong>调零</strong>。+检测电路中是否有电流<strong>通过</strong>：按下<strong>电计键</strong>。+电路中电流较弱，指针<strong>不会满偏</strong>时：顺时针旋转锁定<strong>电计键</strong>。+ 使指针<strong>快速稳定</strong>下来：按下<strong>短路键</strong> +使用完毕：弹起<strong>电计键</strong>，<strong>制动旋钮</strong>放在红锁标记处以锁定指针（为了保护检流计的指针）</p><h4 id="点触式大电阻">点触式大电阻</h4><p><img src="/img/jwsy-dwc/5.png" /> + 开关弹起，串联 <spanclass="math inline">\(30k\Omega\)</span> + 开关按下，<spanclass="math inline">\(30k\Omega\)</span> 电阻短路</p><h3 id="实验设计">1.2 实验设计</h3><p><img src="/img/jwsy-dwc/6.png" /></p><h3 id="实验步骤">1.3 实验步骤</h3><h4 id="自组电位差计测干电池电动势">自组电位差计测干电池电动势</h4><ol type="1"><li>调节工作电流<ol type="1"><li>计算 <span class="math inline">\(E_{N} \approxE_{20}-3.99\times10^{-5}(t-20℃)-0.94\times10^{-6}(t-20℃)^2+9\times10^{-9}(t-20)^3\)</span></li><li>计算并设置 <spanclass="math inline">\(R_{1}=\frac{E_{N}}{I_{0}}\)</span></li><li>计算并设置 <span class="math inline">\(R_{2} \approx\frac{E-E_{N}}{I_{0}}\)</span> ，</li><li>接通<strong>辅助回路</strong>和<strong>第一补偿回路</strong>，使用带有大电阻的<strong>点触式开关</strong>，调节<span class="math inline">\(R_{2}\)</span>，使<strong>检流计</strong>无偏转（按下<strong>点触式开关</strong>，按下<strong>电计键</strong>，若<strong>检流计</strong>向右偏转，<spanclass="math inline">\(R_2\)</span>调大；若<strong>检流计</strong>向左偏转，<spanclass="math inline">\(R_2\)</span> 调小）</li><li><strong>检流计</strong>不偏转时，记录 <spanclass="math inline">\(R_{1}, R_{2}\)</span> ，有表达式 <spanclass="math inline">\(E_{N} = R_{1}I_{0} = \frac{R_{1}}{R_{1}+R_{2}}E\(1)\)</span></li></ol></li><li>测量待测电压<ol type="1"><li>接通<strong>辅助回路</strong>和<strong>第二补偿回路</strong></li><li>保持<span class="math inline">\(I_{0} = 1mA\)</span> 不变，同时调节<span class="math inline">\(R_{1},R_{2}\)</span>使<strong>检流计</strong>不偏转（按下<strong>点触式开关</strong>，按下<strong>电计键</strong>，若<strong>检流计</strong>向右偏转，<spanclass="math inline">\(R_2\)</span> 调大 <spanclass="math inline">\(R_1\)</span>调小；若<strong>检流计</strong>向左偏转，<spanclass="math inline">\(R_2\)</span> 调小 <spanclass="math inline">\(R_1\)</span> 调大）</li><li>记录 <spanclass="math inline">\(R_{1}&#39;,R_{2}&#39;\)</span>，有表达式 <spanclass="math inline">\(E_{X}=R_{1}&#39;I_{0}=\frac{R_{1}&#39;}{R_{1}&#39;+R_{2}&#39;}E\ (2)\)</span></li><li>由表达式 <span class="math inline">\((1)(2)\)</span> 计算 <spanclass="math inline">\(E_{X} =\frac{E_{N}(R_{1}+R_{2})}{R_{1}(R_{1}&#39;+R_{2}&#39;)}R_{1}&#39;\)</span></li></ol></li></ol><h4 id="测量自组电位差计的灵敏度">测量自组电位差计的灵敏度</h4><ol type="1"><li>保持<span class="math inline">\(I_{0} = 1mA\)</span> 不变，同时调节<span class="math inline">\(R_{1},R_{2}\)</span>使<strong>检流计</strong>偏转 <spanclass="math inline">\(10-14div\)</span>（按下<strong>点触式开关</strong>，按下<strong>电计键</strong>，若<strong>检流计</strong>向右偏转，<spanclass="math inline">\(R_2\)</span> 调大 <spanclass="math inline">\(R_1\)</span>调小；若<strong>检流计</strong>向左偏转，<spanclass="math inline">\(R_2\)</span> 调小 <spanclass="math inline">\(R_1\)</span> 调大）</li><li>记录电阻箱1和2的阻值分别为 <spanclass="math inline">\(R_{1}&#39;&#39;, R_{2}&#39;&#39;\)</span>，</li><li>计算灵敏度 <span class="math inline">\(S =\frac{检流计偏转格数}{I_{0}|R_{1}&#39;-R_{2}&#39;|}(div/V)\)</span></li><li>计算灵敏度误差 <span class="math inline">\(\Delta_{灵}(E_{X}) =\frac{0.2div}{S}(V)\)</span></li></ol><h3 id="数据处理">1.4 数据处理</h3><p>计算自组电位差计的<strong>测量结果</strong>及其<strong>不确定度</strong>误差来源：电阻箱的仪器误差、实验环境温度的变化、灵敏度误差</p><h2 id="箱式电位差计实验">2 箱式电位差计实验</h2><h3 id="实验器材-1">2.1 实验器材</h3><h4 id="uj25型箱式电位差计">UJ25型箱式电位差计</h4><p>测量上限：1.911110V 准确度等级：0.01级 工作电流：<spanclass="math inline">\(I_{0}= 0.1mA\)</span> <imgsrc="/img/jwsy-dwc/7.png" /> + <spanclass="math inline">\(R_{AB}\)</span>：修正不同温度下标准电池 <spanclass="math inline">\(E_N\)</span> 的小数点后第四位和第五位的数值 +<span class="math inline">\(R_{P}\)</span>：调节工作电流 <spanclass="math inline">\(I_0\)</span> + <spanclass="math inline">\(I_{0}R_{CD}\)</span>：测量未知电压的值 +左侧的功能转换开关 + 断：电位差计不工作 + 标准：接入标准电池 <spanclass="math inline">\(E_N\)</span> +未知1/未知2：测未知1或未知2的位置电压</p><ul><li>左下角的按钮：检流计的控制开关<ul><li>通常断开</li><li>粗：接入电路，串联一大电阻，用以在远离补偿的情况下，保护检流计</li><li>细：检流计直接接入电路</li><li>短路：阻尼开关，使线圈迅速停止摆动</li></ul></li></ul><h4 id="电子检流计">电子检流计</h4><p><img src="/img/jwsy-dwc/8.png" /> +不使用时<strong>功能档转换旋钮</strong>转至表头保护位置 +使用时先<strong>打开背板开关</strong>，在无电流输入检流计的情况下把功能挡转换旋钮调至<strong>调零位置</strong>，用<strong>调零旋钮</strong>调节指针为0+功能挡转换旋钮调至<strong>补偿位置</strong>，用<strong>补偿旋钮</strong>进一步指针调0+测量时，如果检流计待测电流大小未知，可使用<strong>非线性档粗调</strong>，此时量程无穷大，将待测电流调整到0点附近再进行测量。+ 顺时针旋转功能档，检流计量程由1微安到3纳安逐步变小 +实验完毕，功能档归位到表头保护位置，并关闭电源</p><h3 id="实验步骤-1">2.2 实验步骤</h3><ol type="1"><li>检流计<strong>机械调零</strong></li><li>计算 <span class="math inline">\(E_N\)</span>，功能转换开关旋至“<strong>标准</strong>”档，调节 <spanclass="math inline">\(R_{AB}\)</span> 修正 <spanclass="math inline">\(E_{N}\)</span> 的后两位</li><li>按左下角按钮“粗”“细”，调节 <spanclass="math inline">\(R_{P}\)</span> 的粗中细微四个旋钮至检流计指0</li><li>功能转换开关旋至“未知1”或“未知2”，分别按左下角按钮“粗”“细”，调节<span class="math inline">\(R_{CD}\)</span>至检流计指0，示值即为待测电动势 <spanclass="math inline">\(E_X\)</span></li></ol><h2 id="选做箱式电位差计测电阻">3（选做）箱式电位差计测电阻</h2><p><img src="/img/jwsy-dwc/9.png" /></p><h3 id="实验步骤-2">实验步骤</h3><ol type="1"><li>接线路： <span class="math inline">\(R_N\)</span> 接“未知1”，<spanclass="math inline">\(R_X\)</span> 接“未知2”</li><li>检流计机械调零</li><li>计算 <span class="math inline">\(E_N\)</span>，功能转换开关旋至“标准”档，调节 <spanclass="math inline">\(R_{AB}\)</span> 修正 <spanclass="math inline">\(E_{N}\)</span> 的后两位</li><li>按左下角按钮“粗”“细”，调节 <spanclass="math inline">\(R_{P}\)</span> 的粗中细微四个旋钮至检流计指0</li><li>功能转换开关旋至“未知1”，分别按左下角按钮“粗”“细”，调节 <spanclass="math inline">\(R_{CD}\)</span> 至检流计指0，示值即为 <spanclass="math inline">\(R_N\)</span></li><li>功能转换开关旋至“未知2”，分别按左下角按钮“粗”“细”，调节 <spanclass="math inline">\(R_{CD}\)</span> 至检流计指0，示值即为 <spanclass="math inline">\(R_X\)</span></li></ol>]]></content>
    
    
    <categories>
      
      <category>学习经验</category>
      
      <category>基物实验</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习经验</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【学习经验】分光仪预习报告</title>
    <link href="/2024/10/25/jwsy-fenGuangYi/"/>
    <url>/2024/10/25/jwsy-fenGuangYi/</url>
    
    <content type="html"><![CDATA[<h1 id="实验器材">实验器材</h1><p><img src="/img/jwsy-fenGuangYi/1.png" /></p><h1 id="实验1-分光仪的调整">实验1 分光仪的调整</h1><h2 id="实验步骤">1 实验步骤</h2><ol type="1"><li>目测粗调<ul><li>步骤：调节<strong>望远镜俯仰螺钉</strong>，目测望远镜垂直主轴，调节<strong>载物台下方3只螺钉</strong>伸出等长</li><li>目标现象：旋转平面镜180°前后均可见绿十字</li></ul></li><li>望远镜的调整<ol type="1"><li>调节<strong><em>望远镜聚焦于无限远</em></strong>（使望远镜接受平行光，叉丝分划板在物镜焦平面上）<ul><li>依据：自准直原理 <img src="/img/jwsy-fenGuangYi/2.png" /></li><li>步骤：<ul><li>将平面镜置于载物台上，平面镜镜面与载物台上径线OA平行 <imgsrc="/img/jwsy-fenGuangYi/3.png" /></li><li>调节目镜与叉丝分划板之间距离（使用<strong>目镜调节手轮</strong>）至叉丝清晰</li><li>调节物镜与叉丝之间距离至绿十字清晰</li></ul></li><li>目标现象：绿十字与叉丝无视差（像不模糊） <imgsrc="/img/jwsy-fenGuangYi/4.png" /></li></ul></li><li>调望远镜光轴垂直于主轴（<strong><em>使观察平面与刻度盘平行</em></strong>）<ul><li>方法：半调法（逐次逼近调节法）</li><li>步骤：<ul><li>调节<strong>望远镜俯仰螺钉</strong>，使绿十字与上叉丝的偏离减少一半</li><li>调节<strong>载物台螺钉b或c</strong>，使绿十字与上叉丝重合</li><li>旋转载物台180°，重复以上步骤直到正反两面绿十字均与上叉丝重合</li></ul></li><li><span style="background:#ff4d4f">注意</span>：<ul><li>调好后望远镜的焦距和俯仰不可再动</li><li>调望远镜还是载物台？<ul><li>若转了180°之后绿十字一上一下，调<strong>载物台</strong> <imgsrc="/img/jwsy-fenGuangYi/5.png" /></li><li>若转了180°之后绿十字高度没动，调望远镜 <imgsrc="/img/jwsy-fenGuangYi/6.png" /></li></ul></li></ul></li><li>目标现象：反射镜正反两面绿十字均与上叉丝重合</li></ul></li></ol></li><li>平行光管的调整<ol type="1"><li>调<strong><em>平行光管聚焦于无限远</em></strong><ul><li>依据：透镜成像原理（狭缝处于透镜平面时出射平行光）</li><li>方法：拿下平面镜，打开外置光源，前后移动<strong>狭缝套筒</strong>，调节平行光管物距</li><li>目标现象：狭缝像与叉丝无视差（狭缝像边缘清晰）</li></ul></li><li>调平行光管光轴处置于主轴<ul><li>原理：平行光管与望远镜共轴，则其与主轴垂直</li><li>方法：调节平行光管俯仰螺钉，使狭缝像中点与中心叉丝重合；或旋转狭缝套筒90°，使狭缝像的固定边与中心叉丝重合<img src="/img/jwsy-fenGuangYi/7.png" /><imgsrc="/img/jwsy-fenGuangYi/8.png" /></li><li>目标现象：狭缝像中点与中心叉丝重合</li></ul></li></ol></li><li>三棱镜的调整（<strong><em>使待测光路平面平行于观察平面</em></strong>）<ul><li>原理：自准直原理（使望远镜与两光学面垂直）</li><li>步骤：<ol type="1"><li>如图放置三棱镜，保证两边与平台上径线平行（<spanclass="math inline">\(AB//ob,AC//oc\)</span>） <imgsrc="/img/jwsy-fenGuangYi/9.png" /><imgsrc="/img/jwsy-fenGuangYi/10.png" /></li><li>望远镜对转光学面（AB），调整另一光学面（AC）平行径线下的<strong>载物台螺钉</strong>（c），使绿十字与上叉丝重合<img src="/img/jwsy-fenGuangYi/11.png" /></li><li>望远镜对准光学面（AC），调整另一光学面（AB）平行径线下的<strong>载物台螺钉</strong>（b），使绿十字与上叉丝重合<img src="/img/jwsy-fenGuangYi/12.png" /></li></ol></li><li>目标现象：两光学面的绿十字均与上叉丝重合</li></ul></li></ol><h1 id="实验2-三棱镜顶角的测量">实验2 三棱镜顶角的测量</h1><p><img src="/img/jwsy-fenGuangYi/13.png" /></p><ul><li>读第一个数（望远镜在AB左边），左边游标读数 <spanclass="math inline">\(\alpha_1\)</span>，右边游标读数 <spanclass="math inline">\(\beta_1\)</span>；望远镜转到AC右边，左边游标读数<span class="math inline">\(\alpha_2\)</span>，右边游标读数 <spanclass="math inline">\(\beta_2\)</span></li><li>重复六次</li><li>望远镜转过角度 <span class="math inline">\(\theta =\frac{\alpha_{2}-\alpha_{1}+\beta_{2}-\beta_{1}}{2}\)</span></li><li>三棱镜顶角 <span class="math inline">\(A =\frac{\theta}{2}\)</span></li></ul><h1 id="实验3-最小偏向角法测量棱镜折射率">实验3最小偏向角法测量棱镜折射率</h1><p><img src="/img/jwsy-fenGuangYi/14.png" /></p><ul><li>如图放置三棱镜，旋转望远镜找到平行光。用望远镜在AC面观察折射光线，沿某方向缓慢转动载物平台（改变入射角），可看到谱线随平台转动向一个方向移动，当移到某个位置时突然折返。旋转望远镜使平行光出现在叉丝中间，在该位置有左边游标读数<span class="math inline">\(\alpha_1\)</span>，右边游标读数 <spanclass="math inline">\(\beta_1\)</span>；拿下三棱镜，旋转望远镜使叉丝出现在中间（望远镜在入射光对面），在该位置有左边游标读数<span class="math inline">\(\alpha_2\)</span>，右边游标读数 <spanclass="math inline">\(\beta_2\)</span>。</li><li>重复三次</li><li><span class="math inline">\(\theta_{1} = \alpha_2-\alpha_1,\\theta_2=\beta_2-\beta_1,\\delta_{min}=\frac{\theta_{1}+\theta_{2}}{2}\)</span></li><li><spanclass="math inline">\(n_{1}=\frac{sin\frac{\delta_{min}+A}{2}}{sin\frac{A}{2}}\)</span></li></ul><h1 id="实验4-掠入射法测量棱镜折射率">实验4 掠入射法测量棱镜折射率</h1><p><img src="/img/jwsy-fenGuangYi/15.png" /></p><ul><li>放置三棱镜使三棱镜一个平面与平行光管垂直</li><li>整体移动分光仪使光源在一个平面的延长线上</li><li>转动望远镜，在AC面寻找半明半暗交界线，在该位置有左边游标读数 <spanclass="math inline">\(\alpha_1\)</span>，右边游标读数 <spanclass="math inline">\(\beta_1\)</span>；</li><li>转动望远镜（在大概AC面的垂直位置），使绿十字与叉丝的竖直线重合，在该位置有左边游标读数<span class="math inline">\(\alpha_2\)</span>，右边游标读数 <spanclass="math inline">\(\beta_2\)</span>。</li><li>重复三次</li><li><span class="math inline">\(\theta_{1} = \alpha_2-\alpha_1,\\theta_2=\beta_2-\beta_1,\\delta_{min}=\frac{\theta_{1}+\theta_{2}}{2}\)</span></li><li><spanclass="math inline">\(n_{2}=\sqrt{(\frac{cosA+sin\delta_{min}}{sinA})^{2}+1}\)</span></li></ul>]]></content>
    
    
    <categories>
      
      <category>学习经验</category>
      
      <category>基物实验</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习经验</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【学习经验】示波器预习报告</title>
    <link href="/2024/09/19/jwsy-shiboqi/"/>
    <url>/2024/09/19/jwsy-shiboqi/</url>
    
    <content type="html"><![CDATA[<p>被无数次告知基物实验的痛苦后焦虑万分，上网努力搜索资料后整理了如下预习笔记。建议预习还是看视频看书，本人整理笔记只是防止过了一个周末自己忘得一干二净，不保证时效性和正确性。</p><p>特别鸣谢：<ahref="https://zhuanlan.zhihu.com/p/108465655">【1031】示波器的使用 -知乎 (zhihu.com)</a>、Only(AR)、zbyzby</p><hr /><h1 id="示波器的使用">示波器的使用</h1><p><ahref="https://www.bilibili.com/video/BV1Pg4y1a7HU?p=4&amp;vd_source=fc9422f088d6dd276399cc472e4f7182">示波器实验(物理老师制作，示波器原理讲解非常详细，非常适合初学者理解示波器原理与操作时使用)</a></p><h2id="利用校准信号对示波器进行校准测量">利用校准信号对示波器进行校准测量</h2><ol type="1"><li><p>示波器的预置：调节<strong>辉度</strong>（亮度）、<strong>聚焦</strong>（粗细）、<strong>水平位移</strong>、<strong>垂直位移</strong>，<strong>触发方式</strong>选择<em>AUTO</em>，使屏幕出现扫描线。<img src="/img/jwsy-sbq/1.png" /> <imgsrc="/img/jwsy-sbq/2.png" /></p></li><li><p>连接示波器上信号输出端和通道（CH1或CH2，书上为<em>CH1</em>）</p></li><li><p>关闭所有<strong>微调</strong>（扫描时间和衰减开关，全部顺时针旋转到底）<img src="/img/jwsy-sbq/3.png" /></p></li><li><p><strong>"VAR"垂直微调旋钮</strong>（垂直偏转系数微调钮）分别调整至<em>顺时针转到底</em>、<em>中间位置</em>、<em>逆时针转到底</em>，<strong>VOLTS/DIV</strong>分别调整至为<em>0.5V/DIV</em>,<em>1V/DIV</em>,<em>2V/DIV</em>，测量3*3组数据。</p><p>其中y轴灵敏度为<strong>VOLTS/DIV</strong>上的示数，格数Y通过读两条线之间竖着的格子数量获得(<spanclass="math inline">\(MAX-MIN\)</span>)，k由公式计算得出(<spanclass="math inline">\(k =\frac{u_{pp}}{Y}\)</span>)，其中y轴微调校准位的k应与y轴灵敏度的值相同。<img src="/img/jwsy-sbq/4.png" /> <img src="/img/jwsy-sbq/5.png" /> <imgsrc="/img/jwsy-sbq/6.png" /></p></li></ol><h2id="观察各种波形并测量正弦波的电压与周期">观察各种波形并测量正弦波的电压与周期</h2><p><img src="/img/jwsy-sbq/7.png" /></p><ol type="1"><li>将DOS函数发生器的信号接入示波器通道，分别输出<strong>方波、三角波、正弦波</strong>，进行<strong>观察</strong></li><li>将正弦波发生器的f<sub>2</sub>和f<sub>4</sub>信号分别接入<em>CH1通道</em><img src="/img/jwsy-sbq/8.png" /><ol type="1"><li>测量两条横线之间格子数量（<spanclass="math inline">\(Y轴偏转格数\)</span>），与<spanclass="math inline">\(Y轴灵敏度\)</span>相乘获得<spanclass="math inline">\(u_{pp}\)</span>，<spanclass="math inline">\(电压有效值u_e =\frac{u_{pp}}{2\sqrt2}\)</span></li><li>测量一个周期的格子数量（<spanclass="math inline">\(X轴偏转格数\)</span>），与<spanclass="math inline">\(X轴灵敏度\)</span>相乘获得<spanclass="math inline">\(T\)</span>（记得单位换算），<spanclass="math inline">\(频率f = \frac 1 T\)</span></li></ol></li></ol><h2id="观察李萨如图形用李萨如图形测量正弦信号频率">观察李萨如图形，用李萨如图形测量正弦信号频率</h2><p><img src="/img/jwsy-sbq/9.png" /></p><p>将正弦波发生器的f<sub>2</sub>信号接入<em>CH1通道</em>，将DOS函数发生器的正弦信号接入<em>CH2通道</em>，将<strong>TIME/DIV旋钮</strong><em>逆时针旋转到头（X-Y档位）</em>，<strong>MODE</strong>置于<em>CH2档</em>，<strong>SOURCE（触发源）</strong>置于<em>CH1档</em>。<img src="/img/jwsy-sbq/10.png" /></p><p>调节DOS函数发生器正弦信号的<strong>频率(f<sub>y</sub>)</strong>，在屏上分别得到f<sub>y</sub>:f<sub>x</sub>为1:1、1:2、1:3、2:3的稳定图形，列表记下相应的图形、f<sub>y</sub>、图形与水平线相交的点数n<sub>x</sub>、图形与垂直线相交的点数n<sub>y</sub>，并计算出f<sub>x</sub>（<spanclass="math inline">\(f_x = f_y\times \frac {n_y} {n_x}\)</span>）。</p><h1 id="振幅法测声速">振幅法测声速</h1><p><ahref="https://www.bilibili.com/video/BV1pJ411i741?vd_source=fc9422f088d6dd276399cc472e4f7182">声速的测量</a></p><p><span class="math inline">\(声速v_s = f\lambda\)</span></p><p>其中<spanclass="math inline">\(f\)</span>由信号发生器给出，只需测得<spanclass="math inline">\(\lambda\)</span>即可得出声速<spanclass="math inline">\(v_s\)</span></p><ol type="1"><li>电信号极大值之间的距离均为<spanclass="math inline">\(\lambda/2\)</span></li><li>S<sub>1</sub>和S<sub>2</sub>之间间距越大极大值越小（振幅越小）</li></ol><h2 id="实验">实验</h2><ol type="1"><li>找共振频率<ol type="1"><li>调节<strong>频率粗调按钮</strong>，使振幅最大，若振幅超过显示范围，调节y方向的<strong>VOLTS/DIV</strong>。此时信号源显示的频率约为共振频率。</li><li>转动<strong>手轮</strong>使接收器远离发射器，移动到第一次的振幅较大处，再调节<strong>频率细调按钮</strong>，使振幅最大，此时信号源显示的频率即为共振频率，记录此时频率f<sub>1</sub></li></ol></li><li>连续测量第1-10个极大值的位置（波幅最大），记为x<sub>1</sub>至x<sub>10</sub>，再测量第31-40个极大值位置，记为x<sub>31</sub>至x<sub>40</sub>。</li><li>记录实验结束时信号源显示频率f<sub>2</sub>。</li><li>测量室温</li></ol><h2 id="数据处理">数据处理</h2><p><img src="/img/jwsy-sbq/11.png" /> <imgsrc="/img/jwsy-sbq/12.png" /></p><h1 id="相位法测声速">相位法测声速</h1><h2 id="实验-1">实验</h2><ol type="1"><li>记录此时频率f<sub>1</sub>。</li><li>将<strong>TIME/DIV旋钮逆时针</strong>旋转到头（<em>X-Y档位</em>），<strong><em>MODE置于CH2档，SOURCE（触发源）置于CH1档</em></strong>（存疑）。</li><li>相同相位（同方向倾斜的斜线）之间为一个<spanclass="math inline">\(\lambda\)</span>，数据测量同振幅法测声速。</li><li>记录实验结束时频率f<sub>2</sub>。</li></ol><h2 id="数据处理-1">数据处理</h2><p>同振幅法测声速（但无需计算不确定度）</p><h1 id="思考题">思考题</h1><p><img src="/img/jwsy-sbq/13.png" /></p>]]></content>
    
    
    <categories>
      
      <category>学习经验</category>
      
      <category>基物实验</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习经验</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【数据结构】ds笔记8-图</title>
    <link href="/2024/05/20/LE-ds8/"/>
    <url>/2024/05/20/LE-ds8/</url>
    
    <content type="html"><![CDATA[<p>本篇笔记总结<strong>DSPv2b_6(图) forstudent</strong>内的相关内容。配图太多不是因为不抽象，而是因为太抽象。最后，本人学艺不精，只是一边看着ppt一边敲敲改改，如有疏漏，欢迎提出喵~o(=∩ω∩= )m</p><figure><img src="/img/LE-ds8/1.png" alt="where is my tutu" /><figcaption aria-hidden="true">where is my tutu</figcaption></figure><h2 id="图的基本概念">1 图的基本概念</h2><h3 id="图的定义">1.1 图的定义</h3><ol type="1"><li><p>图是由顶点的非空有穷集合与顶点之间关系(边或弧)的集合构成的结构,通常表示为<code>G=(V,E)</code>。其中,<code>V</code>为顶点集合,<code>E</code>为关系(边或弧)的集合。</p></li><li><p>一条边或弧的表示</p><ol type="1"><li><p>图形</p><p><img src="/img/LE-ds8/2.png" /></p></li><li><p>符号</p><p>(v<sub>i</sub>, v<sub>j</sub>)或&lt;v<sub>i</sub>,v<sub>j</sub>&gt;</p></li><li><p>语言</p><p>顶点v<sub>i</sub>与v<sub>j</sub>是这条边的两个邻接点。</p><p>这条边依附于顶点v<sub>i</sub>和顶点v<sub>j</sub>。</p></li></ol></li><li><p>例：</p><p><img src="/img/LE-ds8/3.png" /></p></li></ol><h3 id="图的分类">1.2 图的分类</h3><ol type="1"><li>无向图：对于(v<sub>i</sub>, v<sub>j</sub>)∈E，必有(v<sub>i</sub>,v<sub>j</sub>)∈E，并且偶对中顶点的前后顺序无关。</li><li>有向图：&lt;v<sub>i</sub>,v<sub>j</sub>&gt;∈E是顶点的有序偶对。</li><li>网（络）：与边有关的数据称为<strong>权</strong>，边上带权的图称为<strong>网络</strong>。</li></ol><p><img src="/img/LE-ds8/4.png" /></p><h3 id="名词术语">1.3 名词术语</h3><ol type="1"><li><p>顶点的度：依附于顶点v<sub>i</sub>的边的数目，记为<strong>TD(v<sub>i</sub>)</strong></p><p>对于有向图来说，有：</p><ul><li>顶点的<strong>出度</strong>：以顶点v<sub>i</sub>为出发点的边的数目，记为OD(v<sub>i</sub>)。</li><li>顶点的<strong>入度</strong>：以顶点v<sub>i</sub>为终止点的边的数目，记为ID(v<sub>i</sub>)。</li><li>TD(v<sub>i</sub>) = OD(v<sub>i</sub>) + ID(v<sub>i</sub>)</li></ul><p>结论：</p><ul><li><p>对于具有n个顶点，e条边的图，有：</p><p><span class="math display">\[\frac{1}{2}e = \sum_{i=1}^{n}TD(v_{i})\]</span></p></li><li><p>具有n个顶点的无向图最多有n(n-1)/2条边。</p></li><li><p>具有n个顶点的有向图最多有n(n-1)条边。</p></li></ul><p>边的数目达到最大的图称为<strong>完全图</strong>。边的数目达到或接近最大的图称为<strong>稠密图</strong>，否则，称为<strong>稀疏图</strong>。</p></li><li><p>路径和路径长度</p><p>顶点v<sub>x</sub>到v<sub>y</sub>之间有<strong>路径P(v<sub>x</sub>,v<sub>y</sub>)</strong>的充分必要条件为：存在顶点序列v<sub>x</sub>,v<sub>i1</sub>, v<sub>i2</sub>, …, v<sub>im</sub>,v<sub>y</sub>，并且序列中相邻两个顶点构成的顶点偶对分别为图中的一条边。</p><p>出发点与终止点相同的路径称为<strong>回路</strong>或<strong>环</strong>；顶点序列中顶点不重复出现的路径称为<strong>简单路径</strong>。不带权的图的<strong>路径长度</strong>是指路径上所经过的边的数目，带权图的<strong>路径长度</strong>是指路径上经过的边上的权值之和。</p></li><li><p>子图</p><p>对于图G=(V,E)与G'=(V',E'),若有V'⊆V,E'⊆E,则称G'为G的一个<strong>子图</strong>。</p><p><img src="/img/LE-ds8/5.png" /></p><p>如图，G<sub>1</sub>'和G<sub>2</sub>'是G的子树</p></li><li><p>图的联通(Connected)</p><ol type="1"><li><p>无向图(Digraph)的联通</p><p>无向图中顶点v<sub>i</sub>到v<sub>j</sub>有路径,则称顶点v<sub>i</sub>与v<sub>j</sub>是连通的。若无向图中任意两个顶点都连通,则称该无向图是连通的（称为<strong>连通图</strong>）。</p><p><strong>连通分量</strong>：无向图中的极大连通子图。</p><p><img src="/img/LE-ds8/6.png" /></p></li><li><p>有向图(Directed Graph)的连通</p><p>若有向图中顶点v<sub>i</sub>到v<sub>j</sub>有路径,并且顶点v<sub>j</sub>到v<sub>i</sub>也有路径，则称顶点v<sub>i</sub>与v<sub>j</sub>是连通的。若有向图中任意两个顶点都连通，则称该有向图是<strong>强连通</strong>的。</p><p><strong>强连通分量</strong>：有向图的极大强连通子图。</p><p><img src="/img/LE-ds8/7.png" /></p></li></ol></li><li><p>生成树</p><p>包含具有n个顶点的连通图G的全部n个顶点,仅包含其n-1条边的极小连通子图称为G的一个生成树。</p><p><img src="/img/LE-ds8/8.png" /></p><p>性质：</p><ol type="1"><li><p>包含n个顶点的图：<strong>连通</strong>且仅有n-1条边</p><p>&lt;=&gt;<strong>无回路</strong>且仅有n-1条边</p><p>&lt;=&gt;无回路且连通</p><p>&lt;=&gt;是一棵树</p></li><li><p>n个顶点的图中只要少于n-1条边，就不连通</p></li><li><p>如果n个顶点的图中有多于n-1条边，图将有环（回路）</p></li><li><p>一般情况下，生成树不唯一</p></li></ol></li></ol><h2 id="图的存储方法">2 图的存储方法</h2><h3 id="图需要存储的信息">2.0 图需要存储的信息</h3><ol type="1"><li>所有顶点的数据信息</li><li>顶点之间关系（边或弧）的信息</li><li>权的信息（对于网络）</li></ol><h3 id="邻接矩阵存储方法">2.1 邻接矩阵存储方法</h3><h4 id="核心思想">2.1.1 核心思想</h4><p>采用两个数组存储一个图</p><ol type="1"><li><p>定义一个一维数组<code>VERTEX[0...n-1]</code>存放图中所有顶点的数据信息(若顶点信息为0,1,2,3,...,此数组可略)。（称为<strong>顶点数组</strong>）</p></li><li><p>定义一个二维数组<code>A[0...n-1, 0...n-1]</code>存放图中所有顶点之间关系的信息（该数组成为<strong>邻接矩阵</strong>），有<span class="math display">\[A[i][j]=  \begin{cases}    1, &amp; \text当顶点v_{i}到顶点v_{j}有边时\\    0,&amp; \text当顶点v_{i}到顶点v_j无边时  \end{cases}\]</span> 对于<strong>带权的图</strong>，有 <spanclass="math display">\[A[i][j]=  \begin{cases}    W_{ij}, &amp; \text当顶点v_{i}到顶点v_{j}有边时，且边的权为W_{ij}\\    ∞,&amp; \text当顶点v_{i}到顶点v_j无边时  \end{cases}\]</span> <img src="/img/LE-ds8/9.png" /></p></li></ol><h4 id="特点">2.1.2 特点</h4><ul><li>无向图的邻接矩阵一定是一个对称矩阵。</li><li>不带权的有向图的邻接矩阵一般是稀疏矩阵。</li><li>无向图的邻接矩阵的第i行(或第i列)非0或非∞元素的个数为第i个顶点的<strong>度数</strong>。</li><li>有向图的邻接矩阵的<strong>第i行</strong>非0或非∞元素的个数为第i个顶点的<strong>出度</strong>；<strong>第i列</strong>非0或非∞元素的个数为第i个顶点的<strong>入度</strong>。</li><li><strong>空间复杂度：O(n<sup>2</sup>)</strong></li></ul><h4 id="代码实现">2.1.3 代码实现</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MaxV <span class="hljs-string">&lt;最大顶点个数&gt;</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">edge</span>&#123;</span><span class="hljs-comment">// 定义边类型</span><br><span class="hljs-type">int</span> weight;<br>&#125;Edge;<br>Vertype Vertex[MaxV];<span class="hljs-comment">// 顶点信息数组</span><br>Edge G[MaxV][MaxV];<span class="hljs-comment">// 邻接矩阵</span><br></code></pre></td></tr></table></figure><h3 id="邻接表存储方法">2.2 邻接表存储方法</h3><h4 id="核心思想-1">2.2.1 核心思想</h4><p>建立n个线性链表存储该图</p><ol type="1"><li><p>每一个链表前面设置一个头结点,用来存放一个顶点的数据信息,称之为<strong>顶点结点</strong>。其构造为<imgsrc="/img/LE-ds8/10.png" /></p><p>其中，<code>vertex</code>域存放某个顶点的数据信息；<code>link</code>域存放某个链表中第一个节点的地址。<strong>n个头结点构成一个数组</strong>。</p></li><li><p>第i个链表中的每一个链结点（称之为<strong>边结点</strong>）表示以第i个顶点为<strong>出发点</strong>的一条边；边结点的构造为<imgsrc="/img/LE-ds8/11.png" /></p><p>其中，<code>next</code>域为指针域；<code>weight</code>域为权值域（若图不带权，则无此域）；<code>adjvex</code>域存放以第i个顶点为出发点的一条边的另一端在头结点数组中的位置。</p><p><img src="/img/LE-ds8/12.png" /></p></li></ol><h4 id="特点-1">2.2.2 特点</h4><ul><li>无向图的第i个链表中边结点个数是第i个顶点<strong>度数</strong>。</li><li>有向图的第i个链表中边结点个数是第i个顶点的<strong>出度</strong>。</li><li>无向图的边结点个数一定为偶数；边结点个数为奇数的图一定是有向图。</li></ul><h4 id="代码实现-1">2.2.3 代码实现</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MaxV <span class="hljs-string">&lt;最大顶点个数&gt;</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">edge</span>&#123;</span><span class="hljs-comment">// 定义边结点类型</span><br>    <span class="hljs-type">int</span> adjvex;<br>    <span class="hljs-type">int</span> weight;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">edge</span> *<span class="hljs-title">next</span>;</span><br>&#125;ELink;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ver</span>&#123;</span><span class="hljs-comment">// 定义顶点结点类型</span><br>    vertype vertex;<br>    ELink *link;<br>&#125;VLink;<br>VLink G[MaxV];<br></code></pre></td></tr></table></figure><h4 id="逆邻接表">2.2.4 逆邻接表</h4><p>第i个链表中的每一个链结点（称之为边结点）表示以第i个顶点为<strong>终止点</strong>的一条边。</p><p><img src="/img/LE-ds8/13.png" /></p><h3 id="稀疏矩阵三元组存储方法">2.3 *（稀疏矩阵）三元组存储方法</h3><ol type="1"><li>三元组(i, j, value)</li><li>三元组表示适合存储稀疏矩阵（稀疏图），针对图来说，是一种按边存储的方式，又称为<strong>边集数组</strong>，特别适合于图的按边访问应用。当然，若按顶点来访问图将不是很方便。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MaxV <span class="hljs-string">&lt;最大顶点个数&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MaxE <span class="hljs-string">&lt;最大边数&gt;</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">edge</span>&#123;</span><span class="hljs-comment">// 定义边类型</span><br>    <span class="hljs-type">int</span> v1, v2;<br>    <span class="hljs-type">int</span> weight;<br>&#125;Edge;<br>Vertype Vertex[MaxV];<span class="hljs-comment">// 顶点信息数组</span><br>Edge G[MaxE];<span class="hljs-comment">// 边集数组（三元组）</span><br></code></pre></td></tr></table></figure><h3 id="图的基本操作">2.4 图的基本操作</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">createGraph();<span class="hljs-comment">// 创建一个图</span><br>destoryGraph();<span class="hljs-comment">// 删除一个图</span><br>insertVex(v);<span class="hljs-comment">// 在图中插入一个顶点v</span><br>deleteVex(v);<span class="hljs-comment">// 在图中删除一个顶点v</span><br>insertEdge(v,w);<span class="hljs-comment">// 在图中插入一条边&lt;v,w&gt;</span><br>deleteEdge(v,w);<span class="hljs-comment">// 在图中删除一条边&lt;v,w&gt;</span><br>traverseGraph();<span class="hljs-comment">// 遍历一个图</span><br></code></pre></td></tr></table></figure><p>例：</p><p>若有如下输入： 8 0 2 4 … -1 1 3 6 8 … -1 …</p><p>第一行为图的顶点个数，从第二行开始第一个数为顶点序号，第二个数字开始为该顶点的邻接顶点，每行以-1结束，则创建一个邻接表存储的图算法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MaxV 256</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">edge</span>&#123;</span> <br>    <span class="hljs-type">int</span> adj;<br>    <span class="hljs-type">int</span> wei;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">edge</span> *<span class="hljs-title">next</span>;</span><br>&#125;Elink;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ver</span>&#123;</span><br>ELink *link;<br>&#125;Vlink;<br>VLink G[MaxV];<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">createGraph</span><span class="hljs-params">(VLink graph[])</span>&#123;<br><span class="hljs-type">int</span> i, n, v1, v2;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;n; i++)&#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>, &amp;v1, &amp;v2);<br>        <span class="hljs-keyword">while</span>(v2 != <span class="hljs-number">-1</span>)&#123;<br>            graph[v1].link = insertEdge(graph[v1].link, v2);<br>            graph[v2].link = insertEdge(graph[v2].link, v1);<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;v2);<br>        &#125;<br>    &#125;<br>&#125; <br><span class="hljs-comment">//在链表尾插入一个节点</span><br>Elink *<span class="hljs-title function_">insertEdge</span><span class="hljs-params">(ELink *head, <span class="hljs-type">int</span> avex)</span>&#123;<br>    ELink *e,*p;<br>    e = (ELink *) <span class="hljs-built_in">malloc</span> (<span class="hljs-keyword">sizeof</span>(ELink));<br>    e-&gt;adj = avex;<br>    e-&gt;wei = <span class="hljs-number">1</span>;<br>    e-&gt;next = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">NULL</span>)&#123;<br>        head = e;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(p=head; p-&gt;next != <span class="hljs-literal">NULL</span>; p=p-&gt;next)<br>        ;<br>    p-&gt;next = e;  <br>    <span class="hljs-keyword">return</span> head;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="有向图的十字链表存储方法">2.4 *有向图的十字链表存储方法</h3><p><ahref="https://blog.csdn.net/m0_68805093/article/details/131903854?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=有向图的十字链表存储方法&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-131903854.142%5Ev100%5Epc_search_result_base5&amp;spm=1018.2226.3001.4187">有向图的十字链表存储方法1-CSDN博客</a></p><p><ahref="https://blog.csdn.net/weixin_39956356/article/details/80371735?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=有向图的十字链表存储方法&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-1-80371735.142%5Ev100%5Epc_search_result_base5&amp;spm=1018.2226.3001.4187">有向图的十字链表存储方法2；深度优先、广度优先遍历-CSDN博客</a></p><h3 id="无向图的多重邻接表存储方法">2.5 *无向图的多重邻接表存储方法</h3><p><ahref="https://blog.csdn.net/ZER00000001/article/details/125350055?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=无向图的多重邻接表存储方法&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-3-125350055.142%5Ev100%5Epc_search_result_base5&amp;spm=1018.2226.3001.4187">无向图的多重邻接表存储方法1-CSDN博客</a></p><p><ahref="https://blog.csdn.net/zw547779770/article/details/112913962?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=无向图的多重邻接表存储方法&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-112913962.142%5Ev100%5Epc_search_result_base5&amp;spm=1018.2226.3001.4187">无向图的多重邻接表存储方法2-CSDN博客</a></p><h2 id="图的遍历">3 图的遍历</h2><p>从图中某个指定的顶点出发, 按照某一原则对图中所有顶点都访问一次,得到一个由图中所有顶点组成的序列,这一过程称为<strong>图的遍历</strong>。</p><h3 id="深度优先遍历depth-first-search-dfs">3.1 深度优先遍历(Depth FirstSearch, DFS)</h3><ol type="1"><li>原则：从图中某个指定的顶点v出发，先访问顶点v，然后从顶点v未被访问过的一个邻接点出发，继续进行深度优先遍历，直到图中与v相通的所有顶点都被访问；若此时图中还有未被访问过的顶点，则从另一个未被访问过的顶点出发重复上述过程，直到遍历全图。</li><li>算法：</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> Visited[N] = &#123;&#125;; <span class="hljs-comment">//标识顶点是否被访问过，N为顶点数</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">travelDFS</span><span class="hljs-params">(VLink G[ ], <span class="hljs-type">int</span> n)</span>&#123;<br><span class="hljs-type">int</span> i;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;n; i++)<br>        Visited[i] = <span class="hljs-number">0</span> ;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;n; i++)<br>        <span class="hljs-keyword">if</span>( !Visited[i] )<br>            DFS(G, i);<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">DFS</span><span class="hljs-params">(VLink G[ ], <span class="hljs-type">int</span> v)</span>&#123;<br>    ELink *p;<br>    Visited[v] = <span class="hljs-number">1</span>; <span class="hljs-comment">//标识某顶点被访问过</span><br>    VISIT(G, v); <span class="hljs-comment">//访问某顶点</span><br>    <span class="hljs-keyword">for</span>(p=G[v].link; p !=<span class="hljs-literal">NULL</span>;  p=p-&gt;next)<br>         <span class="hljs-keyword">if</span>( !Visited[p-&gt;adjvex] )<br>             DFS(G, p-&gt;adjvex);<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3" type="1"><li>算法分析：如果图中具有n个顶点、e条边，则<ul><li>若采用<strong>邻接表</strong>存储该图,由于邻接表中有2e个或e个边结点，因而扫描边结点的时间为O(e)；而所有顶点都递归访问一次，所以，算法的时间复杂度为<strong>O(n+e)</strong>。</li><li>若采用<strong>邻接矩阵</strong>存储该图，则查找每一个顶点所依附的所有边的时间复杂度为O(n)，因而算法的时间复杂度为<strong>O(n<sup>２</sup>)</strong>。</li></ul></li></ol><h3 id="广度优先遍历breadth-first-search-bfs">3.2 广度优先遍历(BreadthFirst Search, BFS)</h3><ol type="1"><li>原则：从图中某个指定的顶点v出发，先访问顶点v，然后依次访问顶点v的各个未被访问过的邻接点，然后又从这些邻接点出发，按照同样的规则访问它们的那些未被访问过的邻接点，如此下去，直到图中与v相通的所有顶点都被访问（完成一个连通分量的遍历）;若此时图中还有未被访问过的顶点,则从另一个未被访问过的顶点出发重复上述过程，直到遍历全图（完成所有连通分量的遍历）。</li><li>算法</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> Visited[N] = &#123;&#125;; <span class="hljs-comment">//标识顶点是否被访问守，N为顶点数</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">travelBFS</span><span class="hljs-params">(VLink G[ ], <span class="hljs-type">int</span> n)</span>&#123;<br><span class="hljs-type">int</span> i;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;n; i++)<br>        Visited[i] = <span class="hljs-number">0</span> ;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;n; i++)<br>        <span class="hljs-keyword">if</span>( !Visited[i] )<br>            BFS(G, i);<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">BFS</span><span class="hljs-params">(VLink G[ ], <span class="hljs-type">int</span> v)</span>&#123;<br>    ELink *p;<br>    Visited[v] = <span class="hljs-number">1</span>; <span class="hljs-comment">//标识某顶点已入队</span><br>    enQueue(Q, v);<br>    <span class="hljs-keyword">while</span>( !emptyQ(Q) )&#123;<br>         v = deQueue(Q);  <span class="hljs-comment">//取出队头元素</span><br>         VISIT(G, v); <span class="hljs-comment">//访问当前顶点</span><br>         <span class="hljs-keyword">for</span>(p=G[v].link; p!=<span class="hljs-literal">NULL</span>; p=p-&gt;next ) <span class="hljs-comment">//访问该顶点的每个邻接顶点</span><br><span class="hljs-keyword">if</span>( !Visited[p-&gt;adjvex] )&#123;<br>                    Visited[p-&gt;adjvex] = <span class="hljs-number">1</span>; <span class="hljs-comment">//标识某顶点入队</span><br>                    enQueue(G, p-&gt;adjvex);<br>&#125;<br>     &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3" type="1"><li>算法分析：<ul><li>邻接表：<strong>O(n+e)</strong></li><li>邻接矩阵：<strong>O(n<sup>2</sup>)</strong></li></ul></li></ol><h3 id="dfs与bfs">3.3 DFS与BFS</h3><p>对比这两个图的遍历算法，其实它们在时间复杂度上是一样的，不同之处仅仅在于对顶点的访问的顺序不同。具体用哪个取决于具体问题。通常DFS更适合目标比较明确，以<strong>找目标为主要目的</strong>的情况，而BFS更适合在不断扩大遍历范围时找到相对最优解的情况。</p><h3 id="例独立路径计算">3.4 例：独立路径计算</h3><ol type="1"><li><p>题目</p><p><img src="/img/LE-ds8/14.png" /></p></li><li><p>分析</p><p>本问题的实质：给定起点，对图进行遍历，并在遍历图的过程中找到到达终点的所有情况。前面介绍的DFS和BFS算法都是从源点出发对邻接顶点的遍历。而问题是本文中两个点间可能有多个边（如图所示）。</p><p>算法策略是对DFS算法（或BFS）进行改进，在原来按邻接顶点进行遍历，改为按邻接顶点的边进行遍历（即从一个顶点出发遍历其邻接顶点时，按邻接顶点的边进行深度遍历，即<strong>只有当某顶点的所有邻接顶点的所有边都遍历完才结束该结点的遍历</strong>）。</p></li><li><p>代码实现</p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXSIZE 512</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">edge</span>&#123;</span><span class="hljs-comment">//边结点结构</span><br><span class="hljs-type">int</span> eno;<span class="hljs-comment">//边序号</span><br><span class="hljs-type">int</span> adjvex;<span class="hljs-comment">//邻接顶点</span><br><span class="hljs-type">int</span> weight;<span class="hljs-comment">//边的权重（可为距离或时间），本文中为1</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">edge</span> *<span class="hljs-title">next</span>;</span><br> &#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ver</span>&#123;</span><span class="hljs-comment">//顶点结构，邻接表下标即为顶点序号</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">edge</span> *<span class="hljs-title">link</span>;</span><br>&#125;; <br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ver</span> <span class="hljs-title">G</span>[<span class="hljs-title">MAXSIZE</span>];</span><span class="hljs-comment">//由邻接表构成的图</span><br><span class="hljs-type">char</span> Visted[MAXSIZE] = &#123;&#125;;<span class="hljs-comment">//标识相应顶点是否被访问 </span><br><span class="hljs-type">int</span> paths[MAXSIZE]; <span class="hljs-comment">//独立路径</span><br></code></pre></td></tr></table></figure><h2 id="最小生成树">4 最小生成树</h2><h3 id="什么是最小生成树">4.1 什么是最小生成树</h3><ol type="1"><li>最小生成树：包含着连通图的全部n个顶点，仅包含其n-1条边的极小连通子图。</li><li>生成树性质：<ol type="1"><li>包含n个顶点的图：<strong>连通</strong>且有n-1条边&lt;=&gt;<strong>无回路</strong>且有n-1条边 &lt;=&gt;无回路且连通&lt;=&gt;是一棵树</li><li>如果n个顶点的图中只有少于n-1条边，图将不连通</li><li>如果n个顶点的图中有多于n-1条边，图将有环（回路）</li><li>一般情况下，生成树不唯一</li></ol></li><li>带权连通图中，总的权值之和最小的带权生成树为最小生成树。<strong>最小生成树</strong>也称<strong>最小代价生成树</strong>,或<strong>最小花费生成树</strong>。</li><li>构造最小生成树的基本原则<ol type="1"><li>只能利用图中的边来构造最小生成树；</li><li>只能使用、且仅能使用图中的n-1条边来连接图中的n个顶点；</li><li>不能使用图中产生回路的边。</li></ol></li></ol><h3 id="求最小生成树">4.2 求最小生成树</h3><h4 id="普利姆prim算法">4.2.1 普利姆(Prim)算法</h4><ol type="1"><li><p>基本思想：设G=(V, GE)为具有n个顶点的带权连通图；T=(U,TE)为生成的最小生成树，初始时，TE=空，U={v}，v∈V。</p><p>依次在G中选择一条一个顶点<strong>仅在V中</strong>，另一个顶点在U中，并且权值最小的边加入集合TE，同时将该边仅在V中的那个顶点加入集合U。重复上述过程n–1次，使得U=V，此时T为G的最小生成树。</p></li><li><p>Prim算法数据结构说明</p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> weights[MAXVER][MAXVER];<br><span class="hljs-comment">// 当图G中存在边(i,j)，则weights[i][j]为其权值，否则为一个INFINITY</span><br><span class="hljs-type">int</span> edges[MAXVER];<br><span class="hljs-comment">// 存入生成的最小生成树的边，如 ：(i, edges[i]) 为最小生成树的一条边，应有n-1条边</span><br><span class="hljs-type">int</span> minweight[MAXVER];<br><span class="hljs-comment">// 存放未确定为生成树的顶点至已确定的生成树上顶点的边权重，</span><br><span class="hljs-comment">// minweight[i]表示顶点i至生成树上顶点的边权重， minweight[i] = 0 表示顶点i已确定为最小生成树顶点</span><br></code></pre></td></tr></table></figure><ol start="3" type="1"><li>代码实现</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXVER 512</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INFINITY 32767</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">Prim</span><span class="hljs-params">(<span class="hljs-type">int</span> weights[][MAXVER], <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> src, <span class="hljs-type">int</span> edges[ ])</span>&#123;<br>    <span class="hljs-comment">//weights为权重数组、n为顶点个数、src为最小树的第一个顶点、edge为最小生成树边</span><br>    <span class="hljs-type">int</span> minweight[MAXVER], min;<br>    <span class="hljs-type">int</span> i, j, k;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;n; i++)&#123;<span class="hljs-comment">//初始化相关数组</span><br>    minweight[i] = weights[src][i];<span class="hljs-comment">//将src顶点与之有边的权值存入数组</span><br>        edges[i] = src;<span class="hljs-comment">//初始时所有顶点的前序顶点设为src，(src,i）</span><br>    &#125;<br>    minweight[src] = <span class="hljs-number">0</span>;<span class="hljs-comment">//将第一个顶点src顶点加入生成树</span><br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>; i&lt; n; i++)&#123;<br>    min = INFINITY;<br>        <span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>, k=<span class="hljs-number">0</span>; j&lt;n; j++)<br>        <span class="hljs-keyword">if</span>(minweight[j] !=<span class="hljs-number">0</span> &amp;&amp; minweight[j]&lt;min)&#123;<span class="hljs-comment">//在数组中找最小值，其下标为k</span><br>            min = minweigth[j];<br>k = j;<br>            &#125;<br>        minweight[k] = <span class="hljs-number">0</span>;  <span class="hljs-comment">//找到最小树的一个顶点</span><br>        <span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>; j&lt;n; j++) <br>        <span class="hljs-keyword">if</span>(minweight[j]!=<span class="hljs-number">0</span> &amp;&amp; weights[k][j]&lt;minweight[j])&#123;<br>minweight[j] = weights[k][j];<span class="hljs-comment">//将小于当前权值的边(k,j)权值加入数组中</span><br>edges[j] = k;<span class="hljs-comment">//将边(j,k)信息存入边数组中</span><br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="克鲁斯卡尔kruskal方法">4.2.2 克鲁斯卡尔(Kruskal)方法</h4><ol type="1"><li><p>基本思想：设G=(V, GE)为具有n个顶点的带权连通图；T=(U,TE)为生成的最小生成树。初始时，TE=空，U={v}，v∈V。</p><p>从G中选择一条当前未选择过的、且边上的权值最小的边加入TE，若加入TE后使得T未产生回路,则本次选择有效，如使得T产生回路，则本次选择无效，放弃本次选择的边。重复上述选择过程直到TE中包含了G的n-1条边，此时的T为G的最小生成树。</p></li><li><p>*算法：</p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 参考：https://onlyar.site/2022/01/24/Cpp-template/#kruskal-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> V_MAX 300005</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> E_MAX 500005</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Edge</span> &#123;</span><br>    <span class="hljs-type">int</span> x, y, w;<br>&#125; e[E_MAX];<br><br><span class="hljs-type">int</span> v[V_MAX];<span class="hljs-comment">// 并查集(查源数组)    v[x]表示x的无数个前驱中的某一个</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">cmp</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *p1, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *p2)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">Find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">isUnion</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">Union</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span>;<span class="hljs-comment">//合并</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">makeSet</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span>;<span class="hljs-comment">//初始化并查集(查源数组)</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> n, m;<span class="hljs-comment">// n个结点，m条边</span><br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);<br>    makeSet(n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;m; i++)<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;e[i].x, &amp;e[i].y, &amp;e[i].w);<br>    qsort(e, n, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> Edge), cmp);<span class="hljs-comment">// 按照w从小到大排序</span><br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>    ll sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; cnt&lt;n<span class="hljs-number">-1</span>; i++)&#123;<br>        <span class="hljs-keyword">if</span>(isUnion(e[i].x, e[i].y))<span class="hljs-comment">// 形成回路了，看下一条边</span><br>            <span class="hljs-keyword">continue</span>;<br>        cnt++;<br>        sum += e[i].w;<br>        Union(e[i].x, e[i].y);<span class="hljs-comment">// y的源头=x的源头</span><br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld&quot;</span>, sum);      <span class="hljs-comment">// 输出最小生成树的权值</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">cmp</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *p1, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *p2)</span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Edge</span> *<span class="hljs-title">d1</span> =</span> (<span class="hljs-keyword">struct</span> Edge *)p1;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Edge</span> *<span class="hljs-title">d2</span> =</span> (<span class="hljs-keyword">struct</span> Edge *)p2;<br>    <span class="hljs-keyword">if</span>(d1-&gt;w &lt; d2-&gt;w)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">makeSet</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)<br>        v[i] = i;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">Find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>    <span class="hljs-keyword">if</span> (v[x]==x)<span class="hljs-comment">// 如果v[x] == x，则x本身就是“源头”</span><br>        <span class="hljs-keyword">return</span> x;<br>    <span class="hljs-keyword">return</span> v[x] = Find(v[x]);<span class="hljs-comment">// 否则x的源头就是x的前驱(v[x])的源头</span><br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">isUnion</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123;<br>    <span class="hljs-keyword">if</span>(Find(x) == Find(y))&#123;<span class="hljs-comment">// 二者源头相同，相当于x和y在同一条线上，如果连上xy则会形成回路</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">Union</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123; v[Find(y)] = Find(x); &#125;<br></code></pre></td></tr></table></figure><h3 id="例">4.3 例</h3><h4 id="判断题们">4.3.1 判断题们</h4><ol type="1"><li>任意连通图中，假设没有相同权值的边存在，则权值最小的边一定是其最小生成树中的边。(√)</li><li>任意连通图中，假设没有相同权值的边存在，则权值最大的边一定不是其最小生成树中的边。(╳)</li><li>任意连通图中，假设没有相同权值的边存在，则与同一顶点相连的权值最小的边一定是其最小生成树中的边。(√)</li><li>采用克鲁斯卡尔算法求最小生成树的过程中，判断一条待加入的边是否形成回路，只需要判断该边的两个顶点是否都已经加入到集合U中。(╳)</li></ol><h4 id="问题北航网络中心铺设光缆">4.3.2 问题：北航网络中心铺设光缆</h4><p>设计考虑：</p><ol type="1"><li>可用邻接矩阵存储网络图数据结构：</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">edge</span>&#123;</span><br><span class="hljs-type">int</span> id;<br><span class="hljs-type">int</span> wei;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">edge</span> <span class="hljs-title">graph</span>[<span class="hljs-title">MAXVER</span>][<span class="hljs-title">MAXVER</span>];</span><span class="hljs-comment">//邻接矩阵</span><br><span class="hljs-type">int</span> edges[MAXVER]=&#123;<span class="hljs-number">0</span>&#125;;<span class="hljs-comment">//生成树数组</span><br><span class="hljs-comment">// 根据输入值对&lt;id,v1,v2,wei&gt;构造图：</span><br>graph[v1][v2].id = id;<br>graph[v1][v2].weight = wei;<br>graph[v2][v1].id = id;<br>graph[v2][v1].weight = wei;<br></code></pre></td></tr></table></figure><ol start="2" type="1"><li>调用Prim算法得到最小生成树，存放在edges数组中</li><li>根据生成树数组edges可得到生成树边序号为<code>graph\[i][edges[i]].id</code>的边，其权重为：<code>graph\[i][edges[i]].wei</code></li><li>最小生成树按边序号进行排序输出.</li></ol><h2 id="最短路径问题dijkstra算法单原点问题">5最短路径问题(Dijkstra算法)——单原点问题</h2><h3 id="路径长度的定义">5.1 路径长度的定义</h3><ol type="1"><li>不带权的图：路径上所经过的边的数目</li><li>带权的图：路径上经过的边上的权值之和</li></ol><h3 id="问题的提出">5.2 问题的提出</h3><p>设出发顶点为v(通常称为源点)。</p><p>求：单源点最短路径；每对顶点之间的最短路径；求图中第1短、第2短、...的最短路径</p><h3 id="解决问题所需要确定的数据结构">5.3解决问题所需要确定的数据结构</h3><ol type="1"><li><p>图的存储</p><p>以0~n-1分别代表n个顶点,采用邻接矩阵存储该图,有 <spanclass="math display">\[A[i][j] =\begin{cases}    W_{ij}, &amp; \text当顶点v_{i}到顶点v_{j}有边时，且边的权为W_{ij}\\    ∞,&amp; \text当顶点v_{i}到顶点v_j无边时\\    0, &amp; \text当v_i=v_j时\end{cases}\]</span></p></li></ol><h3 id="dijkstra算法">5.4 Dijkstra算法</h3><p>（本质上也是一种<strong>贪婪算法(greedy algorithm)</strong>）</p><p>设<code>v0</code>为源顶点，<code>Weights</code>为顶点间权重数组（邻接矩阵），<code>Sweight</code>为v0到相应顶点最小权重数组，<code>Spath</code>为最短路径数组，<code>wfound</code>表示某顶点是否已确定最短路径(0未确定，1已确定)，有如下定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> Weigths[VNUM][VNUM], Spath[VNUM]=&#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-type">int</span> Sweight[VNUM], wfound[VNUM]; <br></code></pre></td></tr></table></figure><ol type="1"><li><p>初始化数组<code>Sweight</code>,使得<code>Sweight[i] = Weigths[v0][i]</code>。</p></li><li><p>初始化<code>Sweight[v0]=0, Spath[i]=v0, wfound[v0] = 1</code>。</p></li><li><p>查找与<code>v0</code>间权重最小且没有确定最短路径的顶点<code>v</code>，即在<code>Sweight</code>数组中查找权重最小且没有确定最短路径的顶点。</p></li><li><p>标记v为已找到最短路径的顶点。</p></li><li><p>对于图G中每个从顶点<code>v0</code>到其最短路径还未找到，且存在边<code>(v,w)</code>，如果从<code>v0</code>通过<code>v</code>到<code>w</code>的路径权值小于它当前的权值，则更新w的权值为：v的权值+边(v,w)的权值，即：<code>Sweight[w] = Sweight[v]+Weights[v][w]</code>。</p></li><li><p>重复上述过程的第3至第5步n–1次。</p></li></ol><p>注：最短路径数组<code>Spath</code>含义为<code>Spath[v]</code>表示顶点v在最短路径上的直接前驱顶点。假设某最短路径由顶点v0,v1,v2,v3组成，则有：<code>v2=Spath[v3], v1=Spath[v2], v0=Spath[v1]</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c">Dijkstra(<span class="hljs-type">int</span> v0)&#123;<br><span class="hljs-type">int</span> i, j, v, minweight;<br>    <span class="hljs-type">char</span> wfound[VNUM] = &#123;&#125;;<span class="hljs-comment">// 用于标记从v0到相应顶点是否找到最短路径，0未找到，1找到</span><br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;VNUM; i++)&#123;<br>        Sweight[i] = Weights[v0][i];<br>        Spath[i] = v0;<br>    &#125;<span class="hljs-comment">// 初始化数组Sweight和Spath</span><br>    Sweight[v0] = <span class="hljs-number">0</span>;<br>    wfound[v0] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt; VNUM<span class="hljs-number">-1</span>; i++)&#123;<span class="hljs-comment">// 迭代VNUM-1次</span><br>minweight = INFINITY;<br><span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>; j&lt;VNUM; j++)<span class="hljs-comment">// 找到未标记的最小权重值顶点 </span><br><span class="hljs-keyword">if</span>( !wfound[j] &amp;&amp; ( Sweight[j]&lt;minweight) )&#123;<br>v = j; <br>minweight = Sweight[v];<br>&#125;<br>wfound[v] = <span class="hljs-number">1</span>;<span class="hljs-comment">// 标记该顶点为已找到最短路径</span><br><span class="hljs-keyword">for</span>(j =<span class="hljs-number">0</span>; j &lt; VNUM; j++)<span class="hljs-comment">// 找到未标记顶点且其权值大于v的权值+(v,j)的权值，更新其权值</span><br><span class="hljs-keyword">if</span>( !wfound[j]  &amp;&amp;  (minweight + Weights[v][j] &lt; Sweight[j] )) &#123;<br>Sweight[j] = minweight + Weights[v][j];<br>Spath[j] = v;<span class="hljs-comment">// 记录前驱顶点</span><br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>问：对于给定的带权连通无向图，从某源点到图中各顶点的最短路径构成的生成树是否是该图的最小生成树？</p><p>答：<ahref="https://blog.csdn.net/weixin_43715601/article/details/105858771">Dijkstra最短路径算法构造的生成树不一定为最小生成树</a></p><p>*Dijkstra算法的局限性：无法正确处理含负权边的图。（ppt没看懂，待更新）</p><h3 id="北京地铁乘坐线路查询">5.5 北京地铁乘坐线路查询</h3><h4 id="题目">5.5.1 题目</h4><p>文件bgstations.txt为数据文件，包含了北京地铁的所有线路及所有车站信息。其格式如下：12 1 23 苹果园 0 古城 0 … 公主坟 1 … 四惠东 1 2 19 西直门 1 积水潭 0 …西直门说明：表明目前北京地铁共开通12条线，其中1号线有23个车站，分别为苹果园，非换乘站；…；公主坟，换乘站…。2线共有19个站，分别为西直门，换乘站，…。</p><p>输入： 起始站：西土城 目的站：北京西站</p><p>输出：西土城-10(1)-知春路-13(2)-西直门-4(2)-国家图书馆-9(4)-北京西站</p><h4 id="方案一">5.5.2 方案一</h4><ol type="1"><li>算法<ol type="1"><li>初始化地铁线路图(initMap()函数)<ol type="1"><li>将站信息加入到站信息数组中（注意：站名是唯一的，每个站在该数组中的下标即为图的顶点编号）（即图的顶点数组）</li><li>将每条线路的当前站和其前序站构成的边(v1,v2)加入到图顶点权重数组中（注：在权重数组中权重信息包括两站间的站数（缺省为1）以及所属线路）</li></ol></li><li>分别读入起始站和目的站</li><li>按照Dijkstra算法在图中查找最短路径(Dijkstra()函数)</li><li>依据最短路径按按照格式要求输出换乘路径(printPath()函数)</li></ol></li><li>代码实现</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXNUM 512<span class="hljs-comment">//地铁最大站数</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXLEN 16<span class="hljs-comment">//地铁站名的最大长度</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INFINITY 32767</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">station</span>&#123;</span> <span class="hljs-comment">//车站信息</span><br><span class="hljs-type">char</span> sname[MAXLEN];<span class="hljs-comment">//车站名</span><br>    <span class="hljs-type">int</span> ischange;<span class="hljs-comment">//是否为换乘站，0-否，1-换乘</span><br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">weight</span>&#123;</span><br>    <span class="hljs-type">int</span> wei;<span class="hljs-comment">//两个站间的权重，即相差站数，缺省为1</span><br>    <span class="hljs-type">int</span> lno;<span class="hljs-comment">//两个顶点所在的线号</span><br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">station</span> <span class="hljs-title">BGvertex</span>[<span class="hljs-title">MAXNUM</span>];</span><span class="hljs-comment">//地铁网络图顶点数组</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">weight</span> <span class="hljs-title">BGweights</span>[<span class="hljs-title">MAXNUM</span>][<span class="hljs-title">MAXNUM</span>];</span><span class="hljs-comment">//网络图权重数组，邻接矩阵</span><br><span class="hljs-type">int</span> Vnum = <span class="hljs-number">0</span>;<span class="hljs-comment">//实际地铁总站数</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">initMap</span><span class="hljs-params">()</span>&#123;<br>    FILE *fp;<br>    <span class="hljs-type">int</span> i, j, snum, lno, lnum, v1, v2;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">station</span> <span class="hljs-title">st</span>;</span><br>    …<br>    <span class="hljs-built_in">fscanf</span>(fp, <span class="hljs-string">&quot;%d&quot;</span>, &amp;snum);<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;snum; i++)&#123;<br>        <span class="hljs-built_in">fscanf</span>(fp, <span class="hljs-string">&quot;%d %d&quot;</span>, &amp;lno, &amp;lnum);<br>        v1 = v2 = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>; j&lt;lnum; j++)&#123;<br>        <span class="hljs-built_in">fscanf</span>(fp, <span class="hljs-string">&quot;%s %d&quot;</span>, st.sname, &amp;st.ischange);<br>        v2 = addVertex(st); <span class="hljs-comment">//将该站加到站信息数组中，返回其下标</span><br>        <span class="hljs-keyword">if</span>(v1 != <span class="hljs-number">-1</span>)&#123;<br>            BGweights[v1][v2].wei = BGweights[v2][v1].wei = <span class="hljs-number">1</span>;<br>            BGweights[v1][v2].lno = BGweights[v2][v1].lno = lno;<br>        &#125;<br>        v1 = v2;<br>        &#125;<br>    &#125;<br>    fclose(fp);<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="方案二">5.5.3 方案二</h4><p>算法</p><ol type="1"><li>构造一个北京地铁换乘网络图（只由换乘节点组成）</li><li>根据用户输入的源和目的车站，将两个顶点加到网络图中</li><li>按最短路径算法在图中查找由源到目的车站的最短路径。</li></ol><h3 id="dijkstra算法单源点问题与floyd算法多源点问题">5.6*Dijkstra算法（单源点问题）与Floyd算法（多源点问题）</h3><p>Dijkstra算法和Floyd算法时间复杂度都为O(n<sup>3</sup>)，但Floyd更简洁</p><p>链接阅读：</p><ol type="1"><li><ahref="https://blog.csdn.net/weixin_56154577/article/details/135726811">Floyd算法-c实现-CSDN博客</a></li><li><ahref="https://blog.csdn.net/Wang_Dou_Dou_/article/details/119485893">Floyd算法-CC++ matlab 实现-CSDN博客</a></li><li><ahref="https://blog.csdn.net/weixin_43004044/article/details/134427313">Floyd算法-反正不是c实现-CSDN博客</a></li><li><ahref="https://zhuanlan.zhihu.com/p/106909361">Floyed算法及证明-c++实现-知乎(zhihu.com)</a></li><li><ahref="https://zhuanlan.zhihu.com/p/339542626">Floyd算法-java实现-知乎(zhihu.com)</a></li><li><ahref="https://www.bilibili.com/video/BV1hP4y1t7PE/?share_source=copy_web&amp;vd_source=5016af564e05d9a924daab02b04629e2">数据结构1800题型-Floyd算法求最短路径_哔哩哔哩_bilibili</a></li></ol><h2 id="aov网与拓扑排序">6 *AOV网与拓扑排序</h2><h3 id="aov网">6.1 AOV网</h3><p>以顶点表示活动，以有向边表示活动之间的优先关系的有向图称为<strong>顶点表示活动的网(ActivityOn Vertex Network)</strong>,简称<strong>AOV网</strong>。</p><p>在AOV网中，若顶点i到顶点j之间有路径,则称顶点i为顶点j的<strong>前驱</strong>，顶点j为顶点i的<strong>后继</strong>；若顶点i到顶点j之间为一条有向边，则称顶点i为顶点j的<strong>直接前驱</strong>，顶点j为顶点i的<strong>直接后继</strong>。</p><blockquote><p>AOV网通常用于描述工程的进行顺序（如下图）。我们可以通过对AOV网进行操作来判断工程能否正常进行。</p><p><img src="/img/LE-ds8/15.png" /></p><p>检测工程能否正常进行，首先要判断对应的AOV网中是否存在回路，达到该目的最有效的方法之一是对AOV网构造其顶点的拓扑序列，即对AOV网进行<strong>拓扑排序</strong>（由某个集合上的一个偏序得到该集合上的一个全序的操作称为<strong>拓扑排序</strong>）。</p><p>设G=(V,E)是一个具有n个顶点的有向图，V中的顶点序列v1,v2,…,vn，满足若从顶点vi到vj有一条路径，则在顶点序列中顶点vi必在顶点vj之前，则称这样的顶点序列为一个<strong>拓扑序列</strong>。构造拓扑序列的过程就是<strong>拓扑排序</strong>。</p></blockquote><h3 id="拓扑排序">6.2 拓扑排序</h3><p>构造AOV网的一个顶点序列，使得该顶点序列满足下列条件：</p><ol type="1"><li>若在AOV网中,顶点i优先于顶点j，则在该序列中顶点i仍然优先于顶点j；</li><li>若在AOV网中，顶点i与顶点j之间不存在优先关系,则在该序列中建立它们的优先关系,即顶点i优先于顶点j，或者顶点j优先于顶点i；</li><li>若能构造出这样的拓扑序列，则拓扑序列包含AOV网的全部顶点，说明<strong>AOV网中没有回路</strong>；反之，若构造不出这样的序列，说明AOV网中存在回路。</li></ol><h3 id="拓扑排序方法">6.3 拓扑排序方法</h3><ol type="1"><li>从AOV网中任意选择一个没有前驱的顶点；</li><li>从AOV网中去掉该顶点以及以该顶点为出发点的所有边；</li><li>重复上述过程，直到AOV网中的所有顶点都被去掉（说明AOV网中无回路），或者AOV网中还有顶点，但不存在入度为0的顶点（说明AOV网中有回路）。</li></ol><h3 id="自然语言描述的拓扑排序算法">6.4 自然语言描述的拓扑排序算法</h3><ol type="1"><li>首先建立一个入度为0的顶点栈，将网中所有入度为0的顶点分别进栈。</li><li>当堆栈不空时，反复执行以下动作：<ol type="1"><li>从顶点栈中退出一个顶点，并输出它；</li><li>从AOV网中删去该顶点以及以它发出的所有边，并分别将这些边的终点的入度减1；</li><li>若此时边的终点的入度为0，则将该终点进栈；</li></ol></li><li>若输出的顶点个数少于AOV网中的顶点个数，则报告网中存在回路，否则，说明该网中不存在回路。</li></ol><h3 id="拓扑排序算法的c实现">6.5 拓扑排序算法的c实现</h3><p><ahref="https://blog.csdn.net/weixin_51496226/article/details/131443268?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=拓扑排序实现c&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-1-131443268.142%5Ev100%5Epc_search_result_base5&amp;spm=1018.2226.3001.4187">C语言实现拓扑排序与关键路径_c语言拓扑排序-CSDN博客</a></p><h2 id="aoe网与关键路径">7 *AOE网与关键路径</h2><h3 id="aoe网">7.1 AOE网</h3><blockquote><p>与AOV网相比，AOE网更关心每个活动持续多少时间/完成整个工程至少需要多少时间/哪些活动是关键活动。</p><p><img src="/img/LE-ds8/16.png" /></p></blockquote><p>AOE(Activity OnEdge)网为一个带权的有向无环图，其中，以顶点表示<strong>事件</strong>，有向边表示<strong>活动</strong>，边上的权值表示活动持续的<strong>时间</strong>。正常情况下，AOE网中只有一个入度为0的顶点，称之为<strong>源点</strong>；有一个出度为0的顶点，称之为<strong>终点</strong>。</p><p>AOE网的特点：</p><ol type="1"><li>只有在某个顶点所代表的事件发生以后,该顶点引发的活动才能开始。</li><li>进入某事件的所有边代表的活动都已完成,该顶点代表的事件才能发生。</li></ol><h3 id="aoe网的存储方法">7.2 AOE网的存储方法</h3><p>采用<strong>邻接矩阵</strong>存储方法</p><h3 id="关键路径">7.3 关键路径</h3><ol type="1"><li>定义：从源点到终点的路径中具有最大长度的路径为关键路径；关键路径上的活动称为关键活动。</li><li>特点：<ol type="1"><li>关键路径的长度(路径上的边的权值之和)为完成整个工程所需要的<strong>最短时间</strong>。</li><li>关键路径的长度变化(即任意关键活动的权值变化)将影响整个工程的进度，而其他非关键活动在一定范围内的变化不会影响工期。</li></ol></li></ol><h3 id="求关键路径">7.4 求关键路径</h3><p>思路： <code>e[i]</code> — 活动a<sub>i</sub>的最早开始时间；<code>l[i]</code> — 活动a<sub>i</sub>的最晚开始时间；若<code>l[i]–e[i]=0</code>，则说明活动a<sub>i</sub>为一个关键活动。<code>ee[k]</code> — 事件k的最早发生时间； <code>le[k]</code> —事件k的最晚发生时间；通过<code>ee[k]</code>和<code>le[k]</code>求出<code>e[i]</code>和<code>l[i]</code>，若<code>e[i] = l[i]</code>则活动a<sub>i</sub>为一个关键活动</p><ol type="1"><li><p>计算时间k的最早发生时间<code>ee[k]</code></p><p>事件k的最早发生时间决定了由事件k出发的所有活动的最早开始时间；该时间是指从源点到顶点(事件)k的最大路径长度。</p><p>计算方法： <span class="math display">\[ee[0] = 0\\ee[k] = \max_{&lt;j, k&gt;∈P(k)}ee[j]+&lt;j, k&gt;的权\]</span> 例：<img src="/img/LE-ds8/17.png" /></p></li><li><p>计算事件k的最晚发生时间<code>le[k]</code></p><p>所谓事件k的最晚发生时间是指不影响整个工期的前提下事件k必须发生的最晚时间，它必须保证从事件k发出的所有活动的终点事件（k的后继事件）的最迟发生时间。</p><p>计算方法： <span class="math display">\[le[n-1] = n-1\\le[k] = \min_{&lt;k, j&gt;∈S(k)}le[j]-&lt;k, j&gt;的权\]</span> <img src="/img/LE-ds8/18.png" /></p></li><li><p>计算活动i的最早开始时间<code>e[i]</code></p><p>所谓活动i的最早开始时间实际上是事件k发生的最早时间，即只有事件k发生，活动i才能开始。</p><p>计算方法： <span class="math display">\[e[i] = ee[k]\]</span> <img src="/img/LE-ds8/19.png" /></p></li><li><p>计算活动i的最晚开始时间<code>l[i]</code></p><p>所谓活动i的最晚开始时间是指不推迟整个工期的前提下活动i开始的最晚时间。</p><p>计算方法： <span class="math display">\[l[i] = le[j]-&lt;k, j&gt;的权\]</span> <img src="/img/LE-ds8/20.png" /></p></li><li><p>求出关键活动与关键路径</p><p>计算方法： <span class="math display">\[l[i] = e[i]\]</span> <img src="/img/LE-ds8/21.png" /></p></li></ol><h3 id="关键路径计算的c实现">7.5 关键路径计算的c实现</h3><p><ahref="https://blog.csdn.net/m0_73070900/article/details/131029666?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=关键路径计算的c实现&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-1-131029666.142%5Ev100%5Epc_search_result_base5&amp;spm=1018.2226.3001.4187">【C语言】关键路径（求解过程及算法实现）_已知关键事件求关键路径-CSDN博客</a></p><p><ahref="https://blog.csdn.net/qq_40463117/article/details/112472674?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=关键路径计算的c实现&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-2-112472674.142%5Ev100%5Epc_search_result_base5&amp;spm=1018.2226.3001.4187">【C语言】关键路径/最长路径模拟实现_关键路径和最长路径区别-CSDN博客</a></p><h2 id="网络流量问题">8 *网络流量问题</h2><h3 id="相关概念">8.1 相关概念</h3><p>设给定边容量为c<sub>v,w</sub>的有向图G=(V,E)（容量可以表示通过一个管道的水、电、交通、网络等最大流量）。有两个顶点，一个是s称为<strong>源点</strong>(source)，一个是t称为<strong>汇点</strong>(sink)。对于任一条边(v,w)，最多有“流”的c<sub>v,w</sub>个单位（容量）可以通过。<strong>在既不是源点s又不是汇点t的任一顶点v，总的进入流必须等于总的发出的流</strong>。每条边上的流满足下面两个条件：</p><ul><li>通过边的流不能大于边的容量（<strong>容量约束</strong>）</li><li>到达顶点v的流的总和与从v流出的总和相同，其中v不是源点或汇点（<strong>流守恒</strong>）</li></ul><p><strong>最大流问题</strong>：确定从s到t可以通过的最大流量。</p><h3 id="最大流算法原理">8.2 最大流算法原理</h3><p>算法设有3个图（原图G、<strong>流图</strong>Gf、<strong>残余图</strong>Gr），在其上分阶段进行。Gf表示在算法的任意阶段已经达到的流，算法终止时其包含最大流；Gr称为残余图（residualgraph），它表示每条边还能再添加上多少流（即还残余多少流），对于Gr中每条边（称为残余边，residualedge）可以从其容量中减去当前流来计算其残余流。</p><ol type="1"><li>初始时Gf所有边都没有流（流为0），Gr与G相同；</li><li>每个阶段，先从Gr中找一条从s到t的路径（称为增长路径augmentingpath）；<ol type="1"><li>将该路径上最小边的流量作为整个路径的流（权），并将路径加至流图Gf中；</li><li>将该权值路径从Gr中减去，若某条边权值为0，则从Gr中除去；</li><li>将具有该权的反向路径加到Gr中；</li><li>重新执行步骤2，直到Gr中无从s到t的路径；</li></ol></li><li>将Gf中顶点t的每条入边流值相加得到最大流。</li></ol>]]></content>
    
    
    <categories>
      
      <category>学习经验</category>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习经验</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【数据结构】ds笔记7-排序</title>
    <link href="/2024/05/13/LE-ds7/"/>
    <url>/2024/05/13/LE-ds7/</url>
    
    <content type="html"><![CDATA[<p>本篇笔记总结<strong>DSPv2b_8(排序) forstudent</strong>内的相关内容。没有配图不是因为不抽象，而是因为太抽象，照片没用，建议直接看PPT的动画。最后，本人学艺不精，只是一边看着ppt一边敲敲改改，如有疏漏，欢迎提出喵~o(=∩ω∩= )m</p><h2 id="排序的基本概念">1 排序的基本概念</h2><ol type="1"><li><p>排序的定义</p><p>对于含有n个记录的序列{ R<sub>1</sub>, R<sub>2</sub>, ...,R<sub>n</sub>}, 对应的关键字序列为{k<sub>1</sub>, k<sub>2</sub>, ...,k<sub>n</sub>}, 确定一种置换关系 s(1), s(2), ...,s(n)，使得关键字序列满足： k<sub>s(1)</sub> ≤ k<sub>s(2)</sub> ≤ ... ≤k<sub>s(n)</sub> 或者 k<sub>s(1)</sub> ≥ k<sub>s(2)</sub> ≥ ... ≥k<sub>s(n)</sub>，相应文件成为按关键字值有序的文件{ R<sub>s(1)</sub>,R<sub>s(2)</sub>, ... ,R<sub>s(n)</sub>}，这一过程称为<strong>排序</strong>。简单来讲，就是<strong>将一个按值任意的数据元素序列转换为一个按值有序的数据元素序列</strong>。</p></li><li><p>排序的功能</p><ol type="1"><li>能够将记录按关键字值任意排列的数据文件转换为一个记录按关键字值有序排列的数据文件。或者能够将一个按值任意排列的数据元素序列转换为一个按值有序排列的数据元素序列。</li><li>能够<strong>提高查找的时间效率</strong>。</li></ol></li><li><p>排序的分类（按存储器的结构分）</p><ol type="1"><li><p>内排序</p><p>参加排序的数据量不大，以致于能够一次将参加排序的数据全部装入内存实现排序。</p></li><li><p>外排序</p><p>当参加排序的数据量很大，以致于不能够一次将参加排序的数据全部装入内存，排序过程中需要不断地通过内存与外存之间的数据交换达到排序目的。</p></li></ol></li><li><p>排序的性能</p><ol type="1"><li><p>时间性能</p><p>排序过程中元素之间的比较次数与元素的移动次数。</p></li><li><p>空间性能</p><p>除了存放参加排序的元素之外，排序过程中所需要的其他辅助空间。</p></li><li><p>稳定性</p><p>对于值相同的两个元素，排序前后的先后次序不变，则称该方法为<strong>稳定性排序方法</strong>，否则，称为<strong>非稳定性排序方法</strong>。</p></li></ol></li><li><p>名词解释——趟</p><p>将具有n个数据元素(关键字)的序列转换为一个按照值的大小有序排列（如从小到大）的序列，通常要经过若干趟(Pass)。</p></li></ol><h2 id="插入insert排序法">2 插入(insert)排序法</h2><ol type="1"><li><p>核心思想</p><p>第i趟排序将序列的第i+1个元素<strong>插入</strong>到一个大小为i、且已经按值有序的子序列(k<sub>i-1,1</sub>,k<sub>i-1,2</sub>, …,k<sub>i-1,i</sub>)的合适位置，得到一个大小为i+1、且仍然按值有序的子序列(k<sub>i,1</sub>,k<sub>i,2</sub>, …,k<sub>i,i+1</sub>)。其中k<sub>i,j</sub>表示第i趟排序结束时序列的第j个元素，1≤i≤n-1，1≤j≤n</p></li><li><p>算法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">insertSort</span><span class="hljs-params">(keytype k[ ],<span class="hljs-type">int</span> n)</span>&#123;<br>    <span class="hljs-type">int</span> i, j;<br>    keytype temp;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;n;i++)&#123;<br>        temp=k[i];<br>        <span class="hljs-keyword">for</span>(j=i<span class="hljs-number">-1</span>; j&gt;=<span class="hljs-number">0</span> &amp;&amp; temp&lt;k[j]; j--) <br>        k[j+<span class="hljs-number">1</span>]=k[j];<br>        k[j+<span class="hljs-number">1</span>]=temp;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>思考题</p><ol type="1"><li><p>排序的时间效率与什么直接有关？</p><p>主要与排序过程中元素之间的比较次数直接有关。</p></li><li><p>若原始序列为一个按值递增的序列，则排序过程中一共要经过多少次元素之间的比较？</p><p>由于每一趟排序只需要经过一次元素之间的比较就可以找到被插入元素的合适位置，因此，整个n-1趟排序一共要经过n-1次元素之间的比较。</p></li><li><p>若原始序列为一个按值递减的序列，则排序过程中一共要经过多少次元素之间的比较？</p><p>由于第i趟排序需要经过i次元素之间的比较才能找到被插入元素的合适位置,因此,整个n-1趟排序一共要经过<span class="math display">\[\sum_{i=1}^{n-1}i = n(n-1)/2\]</span> 次元素之间的比较。</p></li></ol></li><li><p><strong>时间复杂度：最差O(n<sup>2</sup>) 最佳O(n)平均O(n<sup>2</sup>)</strong></p><p><strong>空间复杂度：O(1)</strong></p><p><strong>稳定</strong></p></li></ol><h2 id="选择select排序法">3 选择(select)排序法</h2><ol type="1"><li><p>核心思想</p><p>第i趟排序从序列的后<strong>n-i+1</strong>个元素中<strong>选取</strong>一个值最小的元素，将其置于该n-i+1个元素</p><p>的最前面。</p></li><li><p>算法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">selectSort</span><span class="hljs-params">(keytype k[ ],<span class="hljs-type">int</span> n)</span>&#123;<br>    <span class="hljs-type">int</span> i, j, d;<br>    keytype  temp;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;n<span class="hljs-number">-1</span>;i++)&#123;<br>    d=i;<span class="hljs-comment">// 寻找值最小的元素并记录其位置</span><br>    <span class="hljs-keyword">for</span>(j=i+<span class="hljs-number">1</span>;j&lt;n;j++)<br>    <span class="hljs-keyword">if</span>(k[j]&lt;k[d])<br>    d=j;<br>        <span class="hljs-keyword">if</span>(d!=i)&#123;    <br>            <span class="hljs-comment">/* 最小值元素非未排序元素的第一个元素时 */</span><br>            temp=k[d] ;<br>            k[d]=k[i];<br>            k[i]=temp;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>思考题</p><p>若原始序列为一个按值递增的序列，则排序过程中一共要经过多少次元素之间的比较？若原始序列为一个按值递减的序列，则排序过程中要经过多少次元素之间的比较？</p><p>无论原始序列为什么状态，第i趟排序都需要经过n-i次元素之间的比较，因此，整个排序过程中元素之间的比较次数为<span class="math display">\[\sum_{i=1}^{n-1}(n-i) = n(n-1)/2\]</span>即选择排序法的元素之间的比较次数与原始序列中元素的分布状态<strong>无关</strong>。</p></li><li><p><strong>时间复杂度：O(n<sup>2</sup>)</strong></p><p><strong>空间复杂度：O(1)</strong></p><p><strong>不稳定</strong></p></li></ol><h2 id="冒泡bubble排序法">4 冒泡(bubble)排序法</h2><ol type="1"><li><p>核心思想</p><p>第i趟排序对序列的前<strong>n-i+1</strong>个元素从第一个元素开始依次作如下操作:相邻的两个元素比较大小，若前者大于后者,则两个元素交换位置，否则不交换位置。</p><p>即值大的元素往后“<strong>沉</strong>”，值小的元素向前“<strong>浮</strong>”。</p><p>效果：该n-i+1个元素中最大值元素移到该n-i+1个元素的最后。</p></li><li><p>算法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">bubbleSort</span><span class="hljs-params">(keytype k[ ],<span class="hljs-type">int</span> n)</span>&#123;<br>    <span class="hljs-type">int</span> i, j, flag=<span class="hljs-number">1</span>;<br>    keytype temp;<br>    <span class="hljs-keyword">for</span>(i=n<span class="hljs-number">-1</span>; i&gt;<span class="hljs-number">0</span> &amp;&amp; flag==<span class="hljs-number">1</span>; i--)&#123;<br>        flag=<span class="hljs-number">0</span>;                        <span class="hljs-comment">/* 每趟排序前标志flag置0 */</span> <br>        <span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>; j&lt;i; j++) <br>            <span class="hljs-keyword">if</span>(k[j]&gt;k[j+<span class="hljs-number">1</span>])&#123;<br>                temp=k[j];<br>                k[j]=k[j+<span class="hljs-number">1</span>];<br>                k[j+<span class="hljs-number">1</span>]=temp;  <span class="hljs-comment">/* 交换两个元素的位置 */</span>     <br>                flag=<span class="hljs-number">1</span>;              <span class="hljs-comment">/* 标志flag置1 */</span> <br>            &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>泡排序方法比较适合于参加排序的序列的原始状态基本有序的情况。</p></li><li><p><strong>时间复杂度：一般O(n<sup>2</sup>) 最少O(n)</strong></p><p><strong>空间复杂度：O(1)</strong></p><p><strong>稳定</strong></p></li></ol><h2 id="谢尔shell排序法">5 谢尔(Shell)排序法</h2><ol type="1"><li><p>核心思想</p><p>首先确定一个元素的间隔数gap。将参加排序的元素按照gap分隔成若干个子序列（即分别把那些位置相隔为gap的元素看作一个子序列），然后对各个子序列采用<em>某一种排序方法</em>进行排序；此后减小gap值，重复上述过程，直到gap&lt;1。</p><p>一种减小gap的方法： gap<sub>1</sub> = ⌊n/2⌋; gap<sub>i</sub> =⌊gap<sub>i-1</sub>/2⌋ i=2,3,...</p></li><li><p>算法</p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 1 利用冒泡排序</span><br><span class="hljs-comment">// 1.1 法1</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">shellSort</span><span class="hljs-params">(keytype k[ ],<span class="hljs-type">int</span> n)</span>&#123;<br>    <span class="hljs-type">int</span> i, j, flag, gap=n;<br>    keytype temp; <br>    <span class="hljs-keyword">while</span>(gap &gt; <span class="hljs-number">1</span>)&#123;<br>        gap = gap/<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">do</span>&#123;<br>            flag = <span class="hljs-number">0</span>;                  <span class="hljs-comment">/* 每趟排序前,标志flag置0 */</span> <br>            <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;n–gap; i++)&#123;<br>                j = i+gap;<br>                <span class="hljs-keyword">if</span>(k[i] &gt; k[j])&#123;<br>                    temp = k[i];<br>                    k[i] = k[j];<br>                    k[j] = temp;<br>                    flag = <span class="hljs-number">1</span>;  <br>                &#125;<br>            &#125;<br>        &#125;<span class="hljs-keyword">while</span>(flag!=<span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 1.2 法2</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">shellSort</span><span class="hljs-params">(<span class="hljs-type">int</span> v[ ], <span class="hljs-type">int</span> n)</span>&#123;<span class="hljs-comment">//from K &amp; R</span><br><span class="hljs-type">int</span> gap, i, j, temp;<br><span class="hljs-keyword">for</span>(gap=n/<span class="hljs-number">2</span>; gap&gt;<span class="hljs-number">0</span>; gap/=<span class="hljs-number">2</span>)<br><span class="hljs-keyword">for</span>(i=gap; i&lt;n; i++)<br><span class="hljs-keyword">for</span>(j=i-gap; j&gt;=<span class="hljs-number">0</span> &amp;&amp; v[j]&gt;v[j+gap]; j -= gap)&#123;<br>                temp = v[j];<br>                v[j] = v[j+gap];<br>                v[j+gap] = temp;<br>            &#125;<br>&#125;<br><br><span class="hljs-comment">// 2 利用插入排序</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">shellSort</span><span class="hljs-params">(keytype k[ ],<span class="hljs-type">int</span> n)</span>&#123;<br>    <span class="hljs-type">int</span> i, j, gap = n;<br>    keytype temp; <br>    <span class="hljs-keyword">while</span>(gap&gt;<span class="hljs-number">1</span>)&#123;<br>        gap = gap/<span class="hljs-number">2</span>;<br>        <br>        <span class="hljs-comment">// 使用插入排序实现子序列排序</span><br>        <span class="hljs-keyword">for</span>(i=gap; i&lt;n; i++)&#123;<br>            temp = k[i];<br>            <span class="hljs-keyword">for</span> (j=i; j&gt;=gap &amp;&amp; k[j-gap]&gt;temp; j-=gap)<br>            k[j] = k[j-gap];<br>            k[j] = temp;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="4" type="1"><li><p><strong>时间复杂度：O(nlog<sub>2</sub>n)与O(n<sup>2</sup>)之间，通常＜O(n<sup>2</sup>)</strong></p><p><strong>空间复杂度：O(1)</strong></p><p><strong>不稳定</strong></p></li></ol><h2 id="堆heap排序法">6 堆(Heap)排序法</h2><ol type="1"><li><p>堆的定义</p><p>n个元素的序列(k1, k2, … , kn)，当且仅当满足 <spanclass="math display">\[(1)\begin{cases}\begin{aligned}k_i \ge k_{2i}\\k_i \ge k_{2i+1}\end{aligned}\end{cases}\quad 或者\quad(2)\begin{cases}\begin{aligned}k_i \le k_{2i}\\k_i \le k_{2i+1}\end{aligned}\end{cases}\\i=1, 2, 3, …, \lfloor n/2 \rfloor\]</span>称该序列为一个<strong>堆积</strong>(heap)，简称<strong>堆</strong>。称满足条件(1)的堆为<strong>大顶推</strong>，称满足条件(2)的堆为<strong>小顶堆</strong>。</p><p>例：一个大顶堆：50 23 41 20 19 36 4 12 18</p><ul><li>堆是一棵完全二叉树，二叉树中任何一个分支结点的值都大于或者等于它的孩子结点的值，并且每一棵子树也满足堆的特性。</li></ul></li><li><p>排序的核心思想</p><p>第i趟排序将序列的前n-i+1个元素组成的子序列<strong>转换</strong>为一个<strong>堆积</strong>，然后将堆的第一</p><p>个元素与堆的最后那个元素交换位置。</p></li><li><p>排序步骤</p><ol type="1"><li>将原始序列转换为第一个堆。</li><li>将堆的第一个元素与堆积的最后那个元素交换位置。(即“去掉”最大值元素）</li><li>将“去掉”最大值元素后剩下的元素组成的子序列重新<strong>转换</strong>一个新的堆。</li><li>重复上述过程的第2至第3步n-1次。</li></ol></li><li><p>调整子算法</p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">功能：向下调整结点i的位置，使得其祖先结点值都比其大。如果一棵树仅根结点i不满足堆条件，通过该函数可将其调整为一个堆。</span><br><span class="hljs-comment">K :序列</span><br><span class="hljs-comment">i :被调整的二叉树的根的序号</span><br><span class="hljs-comment">n :被调整的二叉树的结点数目</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">adjust</span><span class="hljs-params">(keytype k[ ], <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> n)</span>&#123;<br>    <span class="hljs-type">int</span> j;<br>    keytype temp;<br>    temp = k[i];<br>    j = <span class="hljs-number">2</span>*i+<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(j &lt; n)&#123;<br>        <span class="hljs-keyword">if</span>(j+<span class="hljs-number">1</span>&lt;n &amp;&amp; k[j]&lt;k[j+<span class="hljs-number">1</span>])<br>        j++;<br>        <span class="hljs-keyword">if</span>(temp &lt; k[j]) &#123;<br>            k[(j<span class="hljs-number">-1</span>)/<span class="hljs-number">2</span>] = k[j];<br>            j = <span class="hljs-number">2</span>*j+<span class="hljs-number">1</span>;<br>        &#125;<span class="hljs-keyword">else</span><br>           <span class="hljs-keyword">break</span>;<br>    &#125;<br>    k[(j<span class="hljs-number">-1</span>)/<span class="hljs-number">2</span>] = temp;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="5" type="1"><li><p>建初始堆</p><p>从二叉树的最后那个分支结点(编号为i=⌊n/2-1⌋)开始，依次将编号为i的结点为根的二叉树转换为一个堆，每转换一棵子树，做一次i减1，重复上述过程，直到将i=0的结点为根的二叉树转换为堆。</p></li><li><p>堆排序算法</p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">heapSort</span><span class="hljs-params">(keytype k[ ],<span class="hljs-type">int</span> n)</span>&#123;<br>    <span class="hljs-type">int</span> i,<br>    keytype temp;<br>    <span class="hljs-keyword">for</span>(i=n/<span class="hljs-number">2</span><span class="hljs-number">-1</span>; i&gt;=<span class="hljs-number">0</span>; i--)<span class="hljs-comment">// 建初始堆积</span><br>    adjust(k, i, n);<br>    <span class="hljs-keyword">for</span>(i=n<span class="hljs-number">-1</span>; i&gt;=<span class="hljs-number">1</span>; i--)&#123;<span class="hljs-comment">// 具体排序</span><br>        temp = k[i];<br>        k[i] = k[<span class="hljs-number">0</span>];<br>        k[<span class="hljs-number">0</span>] = temp;<br>        adjust(k, <span class="hljs-number">0</span>, i);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="7" type="1"><li><p><strong>时间复杂度：O(nlog<sub>2</sub>n)</strong></p><p><strong>空间复杂度：O(1)</strong></p><p><strong>不稳定</strong></p></li></ol><h2 id="二路归并merge排序法">7 二路归并(Merge)排序法</h2><ol type="1"><li><p><strong>二路归并</strong>：将两个位置相邻、并且各自按值有序的子序列合并为一个按值有序的子序列的过程称为二路归并。<span class="math display">\[\underbrace{(K_s, K_{s+1}, K_{s+2}, ..., K_u)(K_{u+1}, K_{u+2},K_{u+3},..., K_v)}_{\text{Xs, Xs+1, Xs+2, Xs+3,...,Xv}}\\其中K_s \le K_{s+1} \le K_{s+2} \le ... \le K_u \\K_{u+1} \le K_{u+2} \le K_{u+3} \le ... \le K_v \\X_s \le X_{s+1} \le X_{s+2} \le X_{s+3} \le ... \le X_v\]</span></p></li><li><p>合并算法</p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">merge</span><span class="hljs-params">(keytype x[ ], keytype tmp[ ], <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> leftend, <span class="hljs-type">int</span> rightend)</span>&#123;     <br>    <span class="hljs-type">int</span> i = left, j = leftend+<span class="hljs-number">1</span>, q = left;<br>    <span class="hljs-keyword">while</span>(i&lt;=leftend &amp;&amp; j&lt;=rightend)<br>    <span class="hljs-keyword">if</span>(x[i] &lt;= x[j]) <br>    tmp[q++] = x[i++];<br>    <span class="hljs-keyword">else</span><br>    tmp[q++] = x[j++];<br>    <span class="hljs-keyword">while</span>(i &lt;= leftend)<span class="hljs-comment">// 复制第一个子序列的剩余部分</span><br>    tmp[q++] = x[i++];<br>    <span class="hljs-keyword">while</span>(j &lt;= rightend)<span class="hljs-comment">// 复制第二个子序列的剩余部分</span><br>    tmp[q++] = x[j++];<br>    <span class="hljs-keyword">for</span>(i=left; i&lt;=rightend; i++)<span class="hljs-comment">// 将合并后内容复制回原数组</span><br>    x[i] = tmp[i];<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3" type="1"><li><p>核心思想</p><p>第i趟排序将序列的⌊n/2<sup>i-1</sup>⌋个长度为2<sup>i-1</sup>的按值有序的子序列依次两两合并为⌊n/2<sup>i</sup>⌋个长度为2<sup>i</sup>的按值有序的子序列。</p></li><li><p>算法（本质上是分治算法）</p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">mergeSort</span><span class="hljs-params">(keytype k[ ],<span class="hljs-type">int</span> n)</span>&#123;<br>keytype *tmp;<br>    tmp = (keytype *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(keytype) * n);<br>    <span class="hljs-keyword">if</span>(tmp != <span class="hljs-literal">NULL</span>) &#123;<br>        mSort(k, tmp, <span class="hljs-number">0</span>, n<span class="hljs-number">-1</span>);<br>        <span class="hljs-built_in">free</span>(tmp);<br>    &#125; <br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;No space for tmp array!!!\n&quot;</span>);<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">mSort</span><span class="hljs-params">(keytype k[], keytype tmp[], <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span>&#123;<br>    <span class="hljs-type">int</span> center;<br>    <span class="hljs-keyword">if</span>(left &lt; right)&#123;<br>        center = (left+right)/<span class="hljs-number">2</span>;<br>        mSort(k, tmp, left, center);<br>        mSort(k, tmp, center+<span class="hljs-number">1</span>, right);<br>        merge(k, tmp, left,center, right);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><ol start="5" type="1"><li><p><strong>时间复杂度：O(nlog<sub>2</sub>n)</strong>（不依赖于原式数据输入情况）</p><p><strong>空间复杂度：O(n)</strong></p><p><strong>稳定</strong></p></li></ol><h2 id="快速quick排序法即qsort">8 快速(Quick)排序法（即qsort）</h2><ol type="1"><li><p>核心思想</p><p>从当前参加排序的元素中任选一个元素(通常称之为<strong>分界元素pivot</strong>)与当前参加排序的那些元素进行比较，凡是小于分界元素的元素都移到分界元素的前面，凡是大于分界元的元素都移到分界元素的后面，分界元素将当前参加排序的元素分成前后两部分，而分界元素处在排序的最终位置。然后，分别对这两部分中大小大于1的部分重复上述过程，直到排序结束。</p></li><li><p>算法步骤</p><ol type="1"><li><p>算法中用到的变量：</p><p><code>left</code>：当前参加排序的那些元素的第一个元素在序列中的位置，初始值为0。</p><p><code>right</code>：当前参加排序的那些元素的最后那个元素在序列中的位置,初始值为n-1。</p><p><code>i</code>,<code>j</code>：两个位置变量，初始值分别为left与right+1。</p></li><li><p>步骤：</p><ol type="1"><li><p>反复执行动作<code>i=i+1</code>，直到<code>K[left]≤K[i]</code>或者<code>i=right</code>。</p><p>反复执行动作<code>j=j-1</code>，直到<code>K[left]≥K[j]</code>或者<code>j=left</code>。</p></li><li><p>若i&lt;j，则K[i]与K[j]交换位置，转到第1步。</p></li><li><p>若i≥j，则K[left]与K[j]交换位置,到此,分界元素K[left]的最终位置已经确定(j)，然后对被K[left]分成的两部分中个数大于1的部分重复上述过程，直到排序结束。</p></li></ol></li></ol></li><li><p>算法</p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// way1</span><br><span class="hljs-comment">// 主算法</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">quickSort</span><span class="hljs-params">(keytype k[],<span class="hljs-type">int</span> n)</span>&#123;<br>quick(K, <span class="hljs-number">0</span>, n<span class="hljs-number">-1</span>);<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">quick</span><span class="hljs-params">(keytype k[ ],<span class="hljs-type">int</span> left,<span class="hljs-type">int</span> right)</span>&#123;<br>    <span class="hljs-type">int</span> i, j;<br>    keytype pivot;<br>    <span class="hljs-keyword">if</span>(left &lt; right)&#123;<br>        i = left;<br>        j = right+<span class="hljs-number">1</span>;<br>        pivot = k[left];<br>        <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123; <br>            <span class="hljs-keyword">while</span>(k[++i]&lt;pivot &amp;&amp; i!=right) &#123; &#125;<br>            <span class="hljs-keyword">while</span>(k[--j]&gt;pivot &amp;&amp; j!=left) &#123; &#125;<br>            <span class="hljs-keyword">if</span>(i &lt; j)<br>            swap(&amp;k[i], &amp;k[j]);  <span class="hljs-comment">/*交换K[i]与K[j]的内容*/</span><br>            <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        swap(&amp;k[left], &amp;k[j]);      <span class="hljs-comment">/*交换K[s]与K[j]的内容*/</span><br>        quick(k, left, j<span class="hljs-number">-1</span>);       <span class="hljs-comment">/* 对前一部分排序 */</span><br>        quick(k, j+<span class="hljs-number">1</span>, right);       <span class="hljs-comment">/* 对后一部分排序 */</span><br>    &#125;<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(keytype *x, keytype *y)</span>&#123;<br>    keytype temp;<br>    temp = *x;<span class="hljs-comment">//取内容交换</span><br>    *x = *y;<br>    *y = temp;<br>&#125;<br><br><span class="hljs-comment">// way2 BY K&amp;R</span><br><span class="hljs-comment">// 主算法</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">quickSort</span><span class="hljs-params">(keytype k[],<span class="hljs-type">int</span> n)</span>&#123;<br>       qsort(k, <span class="hljs-number">0</span>, n<span class="hljs-number">-1</span>);<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">qsort</span><span class="hljs-params">(keytype v[ ],<span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span>&#123;<br>    <span class="hljs-type">int</span> i, last;<br>    <span class="hljs-keyword">if</span>(left &gt;= right)<br>        <span class="hljs-keyword">return</span>;<br>    swap(v, left, (left+right)/<span class="hljs-number">2</span>);<span class="hljs-comment">//move partition elem to v[0]</span><br>    last = left;<br>    <span class="hljs-keyword">for</span>(i=left+<span class="hljs-number">1</span>; i&lt;=right; i++)<span class="hljs-comment">//partition</span><br>        <span class="hljs-keyword">if</span>(v[i] &lt; v[left])<br>            swap(v, ++last, i);<br>    swap(v, left, last);<span class="hljs-comment">//restore partition elem</span><br>    qsort(v, left, last);  <br>    qsort(v, last+<span class="hljs-number">1</span>, right);<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(keytype v[ ],<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span>&#123;<br>    keytype tmp;<br>    tmp = v[i];<br>    v[i] = v[j];<br>    v[j] = tmp;<br> &#125;<br><br></code></pre></td></tr></table></figure><ol start="4" type="1"><li><p><strong>不稳定</strong></p><p><strong>最差情况：时间复杂度：O(n<sup>2</sup>)空间复杂度：O(n)</strong></p><p><strong>最佳情况：时间复杂度：O(nlog<sub>2</sub>n)空间复杂度：O(log<sub>2</sub>n)</strong></p><p><strong>平均情况：时间复杂度：O(nlog<sub>2</sub>n)空间复杂度：O(log<sub>2</sub>n)</strong></p></li></ol><h2 id="总结">9 总结</h2><p><img src="/img/LE-ds7/1.png" /></p><ol type="1"><li><p>从<strong>算法性质</strong>来看：</p><ol type="1"><li>简单算法：冒泡、选择、插入</li><li>改进算法：谢尔、堆、归并、快速</li></ol></li><li><p>从<strong>时间复杂度</strong>来看：</p><ol type="1"><li>平均情况：后3种改进算法 <strong>&gt;</strong> 谢尔 (远)&gt;简单算法</li><li>最好情况：冒泡和插入排序要更好一些</li><li>最坏情况：堆和归并排序要好于快速排序及简单排序</li></ol></li><li><p>从<strong>空间复杂度</strong>来看：</p><p>归并排序有额外空间要求，快速排序也有相应空间要求，堆排序则基本没有。</p></li><li><p>从<strong>稳定性</strong>来看：</p><p>除了简单排序，归并排序不仅速度快，而且还<strong>稳定</strong></p></li></ol><h2 id="桶bucket排序法计数排序">10 *桶(Bucket)排序法（计数排序）</h2><ol type="1"><li><p>核心思想</p><p>假设a<sub>1</sub>,a<sub>2</sub>,…,a<sub>n</sub>由小于M的正整数组成，桶排序的基本原理是使用一个大小为M的数组C(初始化为0，称为桶bucket)，当处理a<sub>i</sub>时，使C[a<sub>i</sub>]增1。最后遍历数组C输出排序后的表。（<em>感觉和Hash是一个感觉</em>）</p></li><li><p>算法</p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">bucketSort</span><span class="hljs-params">(<span class="hljs-type">int</span> K[ ], <span class="hljs-type">int</span> n)</span>&#123;<br><span class="hljs-type">int</span> C[M]=&#123;<span class="hljs-number">0</span>&#125;, i, j;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;n; i++)<br>    C[K[i]]++;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>,j=<span class="hljs-number">0</span>; i&lt;M; i++)<br>        <span class="hljs-keyword">if</span>(C[i])<br>            K[j++] = i;<br>&#125;  <br></code></pre></td></tr></table></figure><ol start="3" type="1"><li><p><strong>时间复杂度：O(M+N)</strong></p><p><strong>不稳定</strong></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>学习经验</category>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习经验</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【数据结构】ds笔记6-查找</title>
    <link href="/2024/05/07/LE-ds6/"/>
    <url>/2024/05/07/LE-ds6/</url>
    
    <content type="html"><![CDATA[<p>本篇笔记总结<strong>DSPv2b_7(查找) forstudent</strong>内的相关内容。（说到底为什么不先讲图而是先讲查找啊kuso）。依旧，大部分内容照搬ppt，但是<em>5B-树和B+树</em>中的<em>5.0说在前面</em>是本人依靠智谱清言写出来的（理直气壮）。起因是问了两位学长都表示“我不道啊”，但本人觉得这问题摆在那里实在难受，只得求助AIsama。</p><p>以及<em>3.3 插值查找</em>、<em>3.4斐波那契查找</em>和<em>4.5倒排索引</em>暂时只有一个标题，大概会在本周内进行更新。再以及，本人的ds笔记中的插图大部分是在是太过不好看，本人争取在下学期开学之前（xd）进行一个大更新。再再以及，祝各位期中顺利。再再再以及，昆明好玩，云南好玩，洋芋和烤蚂蚱都好吃，下辈子一定要投胎到云南！再再再再以及，夏天到了，天气热了，太阳晒了，蚊虫多了，我要躲进屋子里了（卒）</p><p>最后，本人学艺不精，只是一边看着ppt一边敲敲改改，如有疏漏，欢迎提出喵~o(=∩ω∩= )m</p><h2 id="trie树">1 Trie树</h2><h3 id="简介">1.1 简介</h3><ol type="1"><li>在二叉树遍历中通常是通过比较整个键值来进行的，即每个结点包含一个键值，该键值与要查找的键值进行比较从而在树中寻找正确的路径。而用<strong>键值的一部分</strong>来确定查找路径的树称为<strong>trie树</strong>（它来源于retrieval，也可称为<strong>字典树</strong>）。在访问速度要求很高的系统中，如<strong>拼写检查、词频统计</strong>中，Trie结构是一种非常好的选择。</li><li>主要应用：<ol type="1"><li>信息检索</li><li>用来存储英文字符串，特别是大规模的英文词典（在自然语言理解软件中经常用到，如词频统计、拼写检查）</li></ol></li></ol><h3 id="结构">1.2 结构</h3><ol type="1"><li><p>两个原则</p><ol type="1"><li>键值由固定的字符序列组成（如数字或字母），如Huffman码(只由0,1组成)、英文单词（只由26个字母组成）；</li><li>对应结点的分层标记。</li></ol></li><li><p>结构典型应用：<strong>字典树</strong></p><ol type="1"><li>字典树每个内部结点都有26个子结点——多叉树</li><li>树的高度为最长单词长度</li></ol></li><li><p>构造示例</p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 一种用于描述单词的trie结构定义</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tnode</span>&#123;</span><span class="hljs-comment">// word tree </span><br>    <span class="hljs-type">char</span> isword;<span class="hljs-comment">// is or not a word</span><br>    <span class="hljs-type">char</span> isleaf;<span class="hljs-comment">// is or not a leaf node</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tnode</span> *<span class="hljs-title">ptr</span>[26];</span><br>&#125;;<br><br><span class="hljs-comment">// 基于trie结构的单词树的构造</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">wordTree</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> tnode *root, <span class="hljs-type">char</span> *w)</span>&#123;<br>    <span class="hljs-comment">// install w at or below p</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tnode</span> *<span class="hljs-title">p</span>;</span><br>    <span class="hljs-keyword">for</span>(p=root; *w != <span class="hljs-string">&#x27;\0&#x27;</span>; w++)&#123;<br>        <span class="hljs-keyword">if</span>(p-&gt;ptr[*w-<span class="hljs-string">&#x27;a&#x27;</span>] == <span class="hljs-literal">NULL</span>)&#123;<br>            p-&gt;ptr[*w-<span class="hljs-string">&#x27;a&#x27;</span>] = talloc();<span class="hljs-comment">// 自己写的函数(tree alloc)</span><br>            p-&gt;isleaf = <span class="hljs-number">0</span>;<br>        &#125;<br>        p = p-&gt;ptr[*w-<span class="hljs-string">&#x27;a&#x27;</span>];<br>    &#125;<br>    p-&gt;isword = <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="例查家谱">1.3 例：查家谱</h3><ol type="1"><li><p>题目：同姓氏中国人见面常说的一句话是“我们五百年前可能是一家”。从当前目录下的文件in.txt中读入一家谱，从标准输入读入两个人的名字（两人的名字肯定会在家谱中出现），编程查找判断这两个人相差几辈，若同辈，还要查找两个人共同的最近祖先以及与他（她）们的关系远近。假设输入的家谱中每人最多有两个孩子，例如下图是根据输入形成的一个简单家谱。若要查找的两个人是wangqinian和wangguoan，从家谱中可以看出两人相差两辈；若要查找的两个人是wangping和wanglong，可以看出两人共同的最近祖先是wangguoan，和两人相差两辈。</p><p><img src="/img/LE-ds6/1.png" /></p></li><li><p>输入示例：</p><p>假设家谱文件中内容为：</p><p>6</p><p>wangliang wangguoping wangguoan</p><p>wangguoping wangtian wangguang</p><p>wangguoan wangxiang wangsong</p><p>wangtian wangqinian NULL</p><p>wangxiang wangping NULL</p><p>wangsong wanglong NULL</p><p>从标准输入读取：</p><p>wangping wanglong</p></li><li><p>输出示例</p><p>wangguoan wangping 2</p><p>wangguoan wanglong 2</p></li><li><p>说明：wangping和wanglong共同的最近祖先是wangguoan，该祖先与两人相差两辈。</p></li><li><p>问题分析与设计</p><ol type="1"><li><p>构造家谱（树）：如何利用结点之间的（父子）关系构造树（家谱）。一个简单直接的方法是：</p><p>结点插入法构造。利用前序遍历找到相应的父结点，然后将子结点插入。该方法简单，对结点顺序要求不高（但父结点要在子结点前输入）；该方法的核心就是结点查找。</p></li></ol></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">root = <span class="hljs-literal">NULL</span>;<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;n; i++)&#123; <span class="hljs-comment">//create a family tree</span><br>    <span class="hljs-built_in">fscanf</span>(in,<span class="hljs-string">&quot;%s%s%s&quot;</span>, name0, name1, name2);<br>    root = insert(root, name0, name1, name2);<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2" type="1"><li><p>查家谱：实际上就是查找相应结点。如果能得到结点至根的路径信息，就很容易计算出两个结点关系（如是否同辈、相差几辈、共同的祖先等）。</p><p>如何在查找一个结点时得到其（从根结点至该结点的）路径信息：</p><p>①在前序查找过程中设置一个栈来保存路径信息；</p><p>②一个简单的方法：为每个结点增加一个指向父结点的指针信息，这样在找到结点的同时，也就获得了相应的路径。</p></li></ol><h2 id="查找的基本概念">2 查找的基本概念</h2><h3 id="一些概念">2.1 一些概念</h3><ol type="1"><li>属性：描述一个客体某一方面特征的数据信息。</li><li>记录：反映一个客体数据信息的集合（属性的集合），就是数据元素。</li><li>查找表：具有相同属性定义的记录的集合。</li><li>关键字：区分不同记录的属性或属性组（或组合）。<ol type="1"><li>主关键字(Primary Key)：可以唯一的表示一个记录。</li><li>次关键字</li></ol></li></ol><h3 id="两种类型静态查找表和动态查找表">2.2两种类型：静态查找表和动态查找表</h3><ol type="1"><li><p>静态查找表(只进行查找操作)</p><p>如果只在查找表中确定某个特定记录是否存在或检索某个特定记录的属性，此类查找表为静态查找表(StaticSearch Table)</p></li><li><p>动态查找表（查找同时可能有插入或者删除操作）</p><p>如果在查找表中需要插入不存在的数据元素（记录）或需要删除检索到的数据元素（记录），此类查找表为动态查找表(DynamicSearch Table)</p></li></ol><h2 id="顺序表的查找">3 顺序表的查找</h2><h3 id="折半查找">3.1 折半查找</h3><ol type="1"><li><p>思路</p><ol type="1"><li>将要查找的关键字值与当前查找范围内位置居中的记录的关键字的值进行比较。</li><li>若匹配，则查找成功，给出被查到记录在查找表中的位置，查找结束。</li><li>若要查找的关键字值小于位置居中的记录的关键字值，则到当前查找范围的前半部分重复上述查找过程，否则，到当前查找范围的后半部分重复上述查找过程，直到查找成功或者失败。</li><li>若查找失败，则给出错误信息（如：-1）。</li></ol></li><li><p>变量含义</p><ul><li><p><code>n</code>：有序连续顺序查找表中记录的个数</p></li><li><p><code>low</code>：当前查找范围内第一个记录在查找表中的位置</p></li><li><p><code>high</code>：当前查找范围内最后一个记录在查找表中的位置</p></li><li><p><code>mid</code>：当前查找范围内位置居中的记录在查找表中的位置。</p><p><code>mid = (low + high) / 2</code></p></li></ul></li><li><p>算法</p><ol type="1"><li>递归算法</li></ol></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 算法的调用方式</span><br>low = <span class="hljs-number">0</span>;<br>high = n<span class="hljs-number">-1</span>;<br>pos = binsearch2(KEY, low, high, k);<br><br><span class="hljs-comment">// 算法</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">binsearch2</span><span class="hljs-params">(keytype key[], <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high, keytype k)</span>&#123;<br>    <span class="hljs-type">int</span> mid;<br>    <span class="hljs-keyword">if</span>(low&gt;high)<span class="hljs-comment">// 查找失败，返回-1。如有要求做插入操作，就在Low的位置</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">else</span>&#123; <br>        mid = (low+high)/<span class="hljs-number">2</span>;<span class="hljs-comment">// 取中</span><br>        <span class="hljs-keyword">if</span>(k == key[mid])<span class="hljs-comment">// 找到</span><br>            <span class="hljs-keyword">return</span> mid;<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">if</span>(k &lt; key[mid])<span class="hljs-comment">// 要找的元素小于中间元素，范围缩半到前半部分</span><br>                <span class="hljs-keyword">return</span> binsearch2(key, low, mid–<span class="hljs-number">1</span>, k);<br>            <span class="hljs-keyword">else</span> <span class="hljs-comment">// 要找的元素大于中间元素，范围缩半到后半部分</span><br>                <span class="hljs-keyword">return</span>  binsearch2(key, mid+<span class="hljs-number">1</span>, high, k);<br>&#125; <br></code></pre></td></tr></table></figure><pre><code class="hljs">  2. 非递归算法</code></pre><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">binsearch</span><span class="hljs-params">(keytype key[], <span class="hljs-type">int</span> n, keytype k)</span>&#123;<br><span class="hljs-comment">// 注意区分于递归算法的形式参数</span><br><span class="hljs-type">int</span> low=<span class="hljs-number">0</span>, high=n<span class="hljs-number">-1</span>, mid;<br><span class="hljs-keyword">while</span> (low &lt;= high) &#123;<span class="hljs-comment">// 查找结束的条件low &gt;high    </span><br>    mid = (low+high)/<span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span>(k == key[mid])<br>        <span class="hljs-keyword">return</span> mid;<span class="hljs-comment">// 查找成功</span><br>    <span class="hljs-keyword">if</span>(k &gt; key[mid])<br>        low = mid+<span class="hljs-number">1</span>;<span class="hljs-comment">// 准备查找后半部分</span><br>    <span class="hljs-keyword">else</span><br>        high = mid–<span class="hljs-number">1</span>;<span class="hljs-comment">// 准备查找前半部分</span><br>    &#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<span class="hljs-comment">// 查找失败</span><br>&#125;<br></code></pre></td></tr></table></figure><ol start="4" type="1"><li><p>判定树</p><p>若把当前查找范围内居中的记录的位置作为根结点，前半部分与后半部分记录的位置分别构成根结点的左子树与右子树,则由此得到一棵称为“判定树”的二叉树，利用它来描述折半查找的过程。</p><p><img src="/img/LE-ds6/2.png" /></p></li><li><p>平均查找长度ASL</p><p><img src="/img/LE-ds6/3.png" /></p></li><li><p>优点：</p><ol type="1"><li>查找原理和过程简单，易于理解。</li><li>查找的时间效率较高</li></ol></li><li><p>缺点：</p><ol type="1"><li>要求查找表中的记录按照关键字值有序排列（为了保持数据集为排序顺序数据集，在数据集中插入和删除记录时需要移动大量的其它记录）</li><li>对于查找表，只适用于有序连续顺序表</li></ol></li><li><p>使用场景：</p><p>静态查找表；数据元素按值有序排列；采用顺序存储结构</p></li><li><p>对于动态查找表，元素没有查找到时通常要进行插入操作，基于折半查找算法，如何获取元素的插入位置？</p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">insertElem</span><span class="hljs-params">(ElemType <span class="hljs-built_in">list</span>[ ], ElemType item)</span>&#123;<br>    <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>, j;<br>    <span class="hljs-keyword">if</span> (N == MAXSIZE)<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <br>    i = searchElem(<span class="hljs-built_in">list</span>, item);<span class="hljs-comment">// 寻找item的合适位置     </span><br>    <span class="hljs-keyword">for</span>(j=N<span class="hljs-number">-1</span>; j&gt;=i; j--)<br>        <span class="hljs-built_in">list</span>[j+<span class="hljs-number">1</span>] = <span class="hljs-built_in">list</span>[j];<br>    <span class="hljs-built_in">list</span>[i] = item;<span class="hljs-comment">// 将item插入表中</span><br>    N++;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">searchElem</span><span class="hljs-params">(ElemType <span class="hljs-built_in">list</span>[ ], ElemType item)</span>&#123;<br>    <span class="hljs-type">int</span> low=<span class="hljs-number">0</span>, high=N<span class="hljs-number">-1</span>, mid;<br>    <span class="hljs-keyword">while</span>(low &lt;= high)&#123;<br>        mid = (high + low) / <span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span>(item &lt; <span class="hljs-built_in">list</span>[mid])<br>high = mid – <span class="hljs-number">1</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(item &gt; <span class="hljs-built_in">list</span>[mid])<br>low = mid + <span class="hljs-number">1</span>;<br><span class="hljs-keyword">else</span><br><span class="hljs-keyword">return</span> (mid);<br>    &#125;<br>    <span class="hljs-keyword">return</span> low ;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="链接查找表的查找">3.2 链接查找表的查找</h3><ol type="1"><li><p>适合动态查找表，但查找效率低</p></li><li><p>链节点构造：<img src="/img/LE-ds6/4.png" /></p><p><code>key</code>是关键字值，<code>rec</code>是记录的存储位置</p></li><li><p>算法</p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span>&#123;</span><br>    keytype key;<br>    rectype rec;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> *<span class="hljs-title">link</span>;</span><br>&#125;;<br><span class="hljs-comment">// 从链表的入口指针开始，依次查找每个链结点</span><br><span class="hljs-keyword">struct</span> node *<span class="hljs-title function_">search</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> node *p, keytype k)</span>&#123;    <br><span class="hljs-keyword">for</span>(; p!=<span class="hljs-literal">NULL</span>; p=p-&gt;link)<br><span class="hljs-keyword">if</span>(p-&gt;key==k)<br><span class="hljs-keyword">return</span> p;<span class="hljs-comment">// 查找成功</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<span class="hljs-comment">// 查找失败</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="插值查找interpolation-search">3.3 *插值查找(InterpolationSearch)</h3><h3 id="斐波那契查找fibonacci-search">3.4 *斐波那契查找(FibonacciSearch)</h3><h2 id="索引">4 索引</h2><h3 id="索引的基本概念">4.1 索引的基本概念</h3><ol type="1"><li>索引：记录<strong>关键字值</strong>与记录的<strong>存储位置</strong>之间的对应关系。</li><li>索引文件（建立了索引的文件）：由<strong>基本数据</strong>与<strong>索引表</strong>两部分组成的数据集称为索引文件。</li><li>索引表的特点<ol type="1"><li>一般由基本数据表经处理产生；</li><li>表项按关键字值有序排列。</li></ol></li></ol><h3 id="稠密索引">4.2 稠密索引</h3><ol type="1"><li>特点：基本数据中的每一个记录在索引表中都占有一项。</li><li>在稠密索引文件中查找一个记录存在与否的过程是直接查找索引表。</li></ol><h3 id="非稠密索引分块索引">4.3 非稠密索引——分块索引</h3><ol type="1"><li><p>特点：将文件的基本数据中记录分成若干块(块与块之间记录按关键字值有序,块内记录是否按关键字值有序无所谓),索引表中为每一块建立一项。</p></li><li><p>在非稠密索引(分块)文件中查找一个记录存在与否的过程是：先查找索引表(确定被查找记录所在块)，然后在相应块中查找被查记录存在与否。</p></li></ol><h3 id="多级索引">4.4 多级索引</h3><p>当索引文件本身非常庞大时, 可以把索引文件再分块, 建立索引文件的索引,形成树形结构的多级索引结构。</p><h3 id="倒排索引">4.5 *倒排索引</h3><h2 id="b-树和b树">5 B-树和B+树</h2><h3 id="说在前面">5.0 说在前面</h3><p>我在看B-树（B树）和B+树的ppt时看着看着就晕了，为什么B树的叶结点不包含任何关键字信息，B-树和B+树的区别中的第二点是什么意思，特别的，B树节点中的<code>recptr[M+1]</code>究竟指向哪里。想要搞清这些问题，我们首先要搞清B树究竟是用来干什么的。</p><p><ahref="%5B智谱清言%20(chatglm.cn)%5D(https://chatglm.cn/main/toolsCenter)">智谱清言</a>告诉我，“B树是一种自平衡的树数据结构，它设计用于在磁盘存储或其他直接访问的辅助存储设备上高效地管理和访问大量数据。B树的节点通常对应于磁盘上的一个块，因此它可以减少磁盘I/O操作，提高数据检索的效率”。也就是说，B树的结点最终连接的并不是那堆<code>key</code>，那些<code>key</code>只是数据记录们的一个昵称，就像学号和学生本人一样。我们把数据记录们”翻译“成一个个<code>key</code>，再把每个<code>key</code>和数据记录的地址绑定在一起，这样我们就能够通过对<code>key</code>进行操作来操作数据记录了。在我看来，我们可以把B树和Hash表进行类比，B树就是变成了树的Hash表。以上，我们可以解决刚刚提出的问题：</p><ol type="1"><li><p>B树节点中的<code>recptr[i]</code>究竟指向哪里？</p><p>它指向了<code>key[i]</code>对应的那堆数据记录，这些数据记录可能存储在磁盘上，也可能存储在内存中，取决于具体的B树实现和应用程序。</p></li><li><p>为什么B树的叶结点不包含任何关键字信息？</p><p>因为因为B树中的所有“有用的信息”（即关键字和对应的数据记录）都存放在数组<code>key</code>和数组<code>recptr</code>里。</p></li><li><p>B树和B+树的区别中的第二点是什么意思？</p><p>提到的这一点区别是“B-树的每个分支结点中含有指向关键字值对应记录的指针，而B+树只有叶结点有指向关键字值对应记录的指针”。</p><p>这句话的意思是，B树的每个分支结点都有<code>recptr</code>，指向<code>key</code>值对应的数据记录。而B+树的非叶结点的指针仅用于引导搜索过程，不指向<code>key</code>值对应的数据记录；只有其叶结点的指针指向<code>key</code>值对应的数据记录。这也是为什么B+树的叶结点包含了所有的关键字和对应的数据记录的指针，也是为什么B+树会有一个指针指向最左边的叶结点（B+树可以通过遍历所有叶结点来遍历所有的数据记录；但是由于B-树的叶结点全部为空，叶结点的父亲结点也不包括全部的关键字和对应的数据记录，无法通过遍历某一层的结点来遍历所有的数据记录）。</p></li></ol><h3 id="b-树的定义">5.1 B-树的定义</h3><p><img src="/img/LE-ds6/11.png" /></p><p>一个m阶的B-树为满足下列条件的m叉树：</p><ol type="1"><li><p>每个分支节点最多有m棵子树；</p></li><li><p>除根节点外，每个分支节点最少有⌈m/2⌉棵子树；</p></li><li><p>根结点最少有两棵子树（除非根为叶结点，此时B-树只有一个结点）；</p></li><li><p>所有“叶结点”都在同一层上，叶节点不包含任何关键字信息（可以把叶结点视为实际上不存在的外部结点，指向这些“叶结点”的指针为空）；</p></li><li><p>所有分支结点中包含下列信息：</p><p><strong>n, p<sub>0</sub>, key<sub>1</sub>, p<sub>1</sub>,key<sub>2</sub>, p<sub>1</sub>, ..., key<sub>n</sub>,p<sub>n</sub></strong></p><p>其中n为结点中关键字值的个数，<strong>n≤m-1</strong>；</p><p>key<sub>i</sub>为关键字，且满足key<sub>i</sub>&lt;key<sub>i+1</sub>，1≤i&lt;n；</p><p>p<sub>i</sub>为指向该结点的第i+1棵子树的根的指针，0≤i≤n，p<sub>i</sub>指的结点中所有关键字值都大于key<sub>i</sub>。</p></li></ol><h3 id="b-树的查找">5.2 B-树的查找</h3><ol type="1"><li><p>分析：首先将给定的关键字k在B-树的根结点的关键字集合中采用<strong>顺序查找法</strong>或者<strong>折半查找法</strong>进行查找，若有<strong>k=key<sub>i</sub>，则查找成功</strong>，根据相应的指针取得记录。否则，若<strong>k&lt;keyi,则在指针p<sub>i-1</sub>所指的结点中重复上述查找过程</strong>，直到在某结点中查找成功，或者有<strong>p<sub>i-1</sub>=NULL，查找失败</strong>。</p></li><li><p>算法</p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> M 1000</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> &#123;</span><br><span class="hljs-type">int</span> keynum;<br>keytype key[M+<span class="hljs-number">1</span>];<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> *<span class="hljs-title">ptr</span>[<span class="hljs-title">M</span>+1];</span><span class="hljs-comment">// 自引用的指针</span><br>rectype *recptr[M+<span class="hljs-number">1</span>];<span class="hljs-comment">// 关键字对应的存储地址，指向key对应的数据记录，这些数据记录可能存储在磁盘上，也可能存储在内存中，取决于具体的B树实现和应用程序</span><br>&#125; BNode;<br><br>keytype <span class="hljs-title function_">searchBTree</span><span class="hljs-params">(BNode *t,keytype k)</span>&#123;<br>    <span class="hljs-type">int</span> i, n;<br>    BNode *p = t;<br>    <span class="hljs-keyword">while</span>(p!=<span class="hljs-literal">NULL</span>)&#123;<br>        n = p-&gt;keynum;<span class="hljs-comment">// 一共有n个</span><br>        p-&gt;key[n+<span class="hljs-number">1</span>] = Maxkey;<br>        i = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(k &gt; p-&gt;key[i])<span class="hljs-comment">// 直到找到第一个≤k的key</span><br>        i++;<br>        <span class="hljs-keyword">if</span>(p-&gt;key[i] == k)<br>        <span class="hljs-keyword">return</span> p-&gt;key[i];<br>        <span class="hljs-keyword">else</span><br>        p = p-&gt;ptr[i<span class="hljs-number">-1</span>];           <br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="b-树的插入">5.3 B-树的插入</h3><ol type="1"><li><p>基本思想</p><p>若将k插入到某结点后使得该结点中关键字值数目<strong>超过m-1</strong>时，则要以该结点位置居中的那个关键字值为界将该结点<strong>一分为二</strong>，产生一个新结点，并把<strong>位置居中的那个关键字值插入到双亲结点中</strong>；如双亲结点也出现上述情况，则需要<strong>再次进行分裂</strong>。最坏情况下，需要一直分裂到根结点，以致于使得B-树的深度加1。</p></li><li><p>例</p><p><img src="/img/LE-ds6/5.png" /></p></li></ol><p><img src="/img/LE-ds6/6.png" /></p><h3 id="b树的定义">5.4 B+树的定义</h3><p>一个m阶的B+树为满足下列条件的m叉树：</p><ol type="1"><li><p>每个分支结点最多有m棵子树；</p></li><li><p>除根结点外，每个分支结点最少有⌈m/2⌉棵子树；</p></li><li><p>根结点最少有两棵子树(除非根为叶结点结点,此时B+树只有一个结点)；</p></li><li><p>具有n棵子树的结点中一定有n个关键字；</p></li><li><p>叶结点中存放记录的关键字以及指向记录的指针，或者数据分块后每块的最大关键字值及指向该块的指针，并且叶结点按关键字值的大小顺序链接成线性链表。<strong>key<sub>1</sub> p<sub>1</sub> key<sub>2</sub> p<sub>2</sub> ……key<sub>n</sub> p<sub>n</sub></strong></p></li><li><p>所有分支结点可以看成是索引的索引，结点中仅包含它的各个孩子结点中最大(或最小)关键字值和指向孩子结点的指针。</p><p><img src="/img/LE-ds6/7.png" /></p></li></ol><h3 id="b-树和b树的区别">5.5 B-树和B+树的区别</h3><ol type="1"><li>B-树的每个分支结点中含有该结点中关键字值的个数，B+树没有；</li><li>B-树的每个分支结点中含有指向关键字值对应记录的指针，而B+树只有叶结点有指向关键字值对应记录的指针；</li><li>B-树只有一个指向根结点的入口，而B+树的叶结点被链接成为一个不等长的链表，因此，B+树有两个入口，一个指向根结点，另一个指向最左边的叶结点(即最小关键字所在的叶结点)。</li></ol><h2 id="散列hash查找">6 散列(Hash)查找</h2><h3 id="三列查找的基本概念">6.1 三列查找的基本概念</h3><ol type="1"><li><p><code>A = H(k)</code></p><p>其中<code>k</code>为记录的关键字，<code>H(k)</code>称为散列函数，或哈希(Hash)函数，或杂凑函数。函数值<code>A</code>为<code>k</code>对应的记录在查找表中的位置</p></li><li><p>散列冲突</p><p>对于不同的关键字k<sub>i</sub>与k<sub>j</sub>，经过散列得到相同的散列地址，即有H(k<sub>i</sub>)= H(k<sub>j</sub>)，这种现象称为<strong>散列冲突</strong>。</p></li><li><p>什么是散列表</p><p>根据构造的散列函数与处理冲突的方法将一组关键字<strong>映射到一个有限的连续地址集合</strong>上，并以关键字在该集合中的“象”作为记录的存储位置，按照这种方法组织起来表称为<strong>散列表</strong>，或<strong>哈希表</strong>，或称<strong>杂凑表</strong>；建立表的过程称为哈希造表或者散列，得到的存储位置称为<strong>散列地址</strong>或者<strong>杂凑地址</strong>。</p></li></ol><h3 id="散列函数的构造">6.2 散列函数的构造</h3><ol type="1"><li><p>原则</p><ul><li>散列函数的定义域必须包括将要存储的全部关键字；若散列表允许有m个位置时，则函数的值域为[0.. m–1](地址空间)。</li><li>利用散列函数计算出来的地址应能尽可能均匀分布在整个地址空间中。</li><li>散列函数应该尽可能简单，应该在较短的时间内计算出结果。</li></ul></li><li><p>确立散列表的步骤</p><ul><li>确定散列的地址空间(地址范围)；</li><li>构造合适的散列函数；</li><li>选择处理冲突的方法。</li></ul></li><li><p>散列函数的构造方法</p><ul><li><p>直接定址法</p><p>一般形式：<code>H(k) = ak + b</code></p></li><li><p>数字分析法</p></li><li><p>平方取中法</p></li><li><p>叠加法</p></li><li><p>除留余数法</p><p><code>H(k) = k % p</code>，其中，若<code>m</code>（散列地址为[0...m-1]）为地址范围大小（或称表长），则<code>p</code>可为小于等于m的素数</p></li></ul></li></ol><h3 id="冲突的处理方法">6.3 冲突的处理方法</h3><p>所谓处理冲突，是在发生冲突时，为冲突的元素找到另一个散列地址以存放该元素。如果找到的地址仍然发生冲突，则继续为发生冲突的这个元素寻找另一个地址，直到不再发生冲突。</p><ol type="1"><li><p>开放地址法（闭散列方法）</p><p>所谓开放地址法是在散列表中的<strong>“空”地址向处理冲突开放</strong>。即当散列表未满时，处理冲突需要的“下一个”地址在该散列表中解决。</p><p><strong>D<sub>i</sub> = (H(k) + d<sub>i</sub>) % m</strong> (i = 1,2, 3, ...)</p><p>其中，H(k)为哈希函数，m为表长，d<sub>i</sub>为地址增量，有：</p><ol type="1"><li>d<sub>i</sub> = 1, 2, 3, …, m–1 称为线性探测再散列</li><li>d<sub>i</sub> = 1<sup>2</sup>, -1<sup>2</sup>, 2<sup>2</sup>,-2<sup>2</sup>, …, 称为二次探测再散列</li><li>d<sub>i</sub> = 伪随机数序列 称为伪随机再散列</li></ol><p><strong>聚集</strong>：散列地址不同的元素争夺同一个后继散列地址的现象</p><ul><li><p>产生聚集的主要原因：散列函数选择的不合适；负载因子过大</p></li><li><p>负载因子(α)：衡量散列表的饱满程度 <span class="math display">\[\alpha = \frac{散列表中实际存入的元素数}{散列表中基本区的最大容量}\]</span></p></li></ul><p>特点：</p><ul><li>“线性探测法”容易产生元素“聚集”的问题。</li><li>“二次探测法”可以较好地避免元素“聚集”的问题，但不能探测到表中的所有元素(至少可以探测到表中的一半元素)。</li><li>只能对表项进行逻辑删除(如做删除标记)，而不能进行物理删除。使得表面上看起来很满的散列表实际上存在许多未用位置。</li></ul></li><li><p>再散列法</p><p>D<sub>i</sub> = H<sub>i</sub>(k), i=1,2,3,...</p><p>其中，D<sub>i</sub>为散列地址，H<sub>i</sub>(k)为不同的散列函数。</p></li><li><p>链地址法</p><p>将所有散列地址相同的记录链接成一个<strong>线性链表</strong>。若散列范围为[0...m-1]，则定义指针数组bucket[0...m-1]分别存放m个链表的头指针。</p><p><img src="/img/LE-ds6/8.png" /></p><p>散列表查找与创建的算法实现：</p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span>&#123;</span>   <br>    ElemType data;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> *<span class="hljs-title">next</span>;</span><br>&#125;; <span class="hljs-comment">//list </span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> *<span class="hljs-title">Hashtab</span>[<span class="hljs-title">NHASH</span>];</span><br><br><span class="hljs-comment">// 散列表的查找和创建函数：</span><br><span class="hljs-comment">// lookup: find key in Hashtab</span><br><span class="hljs-keyword">struct</span> node *<span class="hljs-title function_">lookup</span><span class="hljs-params">(ElemType key, <span class="hljs-type">int</span> create)</span>&#123;<span class="hljs-comment">// create为1则创建，否则只查找</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> h;<br>    strcut node *p;<br>    h = hash(key);<span class="hljs-comment">// h为key的hash函数值</span><br>    <span class="hljs-keyword">for</span>(p=Hashtab[h]; p!=<span class="hljs-literal">NULL</span>; p=p-&gt;next)<span class="hljs-comment">// 遍历hash函数值为h的所有自变量</span><br>    <span class="hljs-keyword">if</span>(p-&gt;data == key)<br>    <span class="hljs-keyword">return</span> p;<br>    <span class="hljs-keyword">if</span>(create)&#123;<span class="hljs-comment">// create = 1</span><br>        p = (<span class="hljs-keyword">struct</span> node *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> node));<br>        p-&gt;data = key; p-&gt;next = Hashtab[h];  Hashtab[h] = p;<br>&#125;<br><span class="hljs-keyword">return</span> p;<br>&#125;<br><span class="hljs-comment">// 当散列出现冲突时，新插入的元素放在链表的头部，这样算法简洁，效率更高；</span><br><span class="hljs-comment">// 由于链表查找效率低，可使用一棵二叉查找树或另一个散列表来代替链表解决冲突。</span><br></code></pre></td></tr></table></figure><p>特点：</p><ul><li>处理冲突简单，不会产生元素“聚集”现象，平均查找长度较小。</li><li>适合建立散列表之前难以确定表长的情况。</li><li>建立的散列表中进行删除操作简单。</li><li>由于指针域需占用额外空间，当规模较小时，不如“开放地址法”节省空间。</li></ul><h3 id="散列表的典型应用">6.4 散列表的典型应用</h3><ol type="1"><li><p>符号表</p><p>散列表的一个典型应用是符号表（symbol），用于在<strong>数据值和动态符号（如变量名，关键码）集</strong>的成员间建立一种关联。符号表是编译系统中主要的数据结构，用于管理用户程序中各个变量的信息，通常编程系统使用散列表来组织符号表。散列表的思想就是把关键码送给一个散列函数，以产生一个散列值，这种值通常平均分布在一个适当的整数区间中，用作存储信息的表的下标。常见做法是为每一个散列值关联一个数据项的链表，这此项共有同一个散列值（散列冲突）。</p><p>符号表的定义使用：</p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">val</span>&#123;</span> <span class="hljs-comment">//符号散列表义：</span><br>    <span class="hljs-type">char</span> *name;<br>    <span class="hljs-type">int</span> value;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">val</span> *<span class="hljs-title">next</span>;</span><br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">val</span> *<span class="hljs-title">symtab</span>[<span class="hljs-title">NHASH</span>];</span><br><br><span class="hljs-comment">// 符号查找和创建函数：</span><br><span class="hljs-comment">// lookup: find name in symtab</span><br><span class="hljs-keyword">struct</span> val *<span class="hljs-title function_">lookup</span><span class="hljs-params">(<span class="hljs-type">char</span> *name, <span class="hljs-type">int</span> create)</span>&#123;<br><span class="hljs-type">int</span> h;<br>    strcut val *p;<br>    h = hash(name);<br>    <span class="hljs-keyword">for</span>(p=symtab[h]; p!=<span class="hljs-literal">NULL</span>; p=p-&gt;next)<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">strcmp</span>(name, p-&gt;name) == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> p;<br>    <span class="hljs-keyword">if</span>(create)&#123;<br>        p = (<span class="hljs-keyword">struct</span> val *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> val));<br>        p-&gt;name = name; p-&gt;next = symtab[h];  symtab[h] = p;<br>    &#125;<br>    <span class="hljs-keyword">return</span> p;<br>&#125;<br><br><span class="hljs-comment">// Hash函数：</span><br><span class="hljs-comment">// hash: compute hash value of string</span><br><span class="hljs-class"><span class="hljs-keyword">enum</span>&#123;</span> <br>    MULTIPLIER = <span class="hljs-number">31</span><br>&#125;; <span class="hljs-comment">//根据经验，对于ASCII串31,37很好</span><br><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hash</span><span class="hljs-params">(<span class="hljs-type">char</span> *str)</span>&#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> h=<span class="hljs-number">0</span>; <br>    <span class="hljs-type">char</span> *s;<br>    <span class="hljs-keyword">for</span>(s=str; *s!=<span class="hljs-string">&#x27;\0&#x27;</span>; s++)<br>        h = MULTIPLIER * h + *s;<br>    <span class="hljs-keyword">return</span> h%NHASH;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2" type="1"><li>一个针对字符串好的Hash函数：</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// ( from Data Structures and Algorithm Analysis in C – Mark Allen Weiss)</span><br><span class="hljs-comment">// hash: compute hash value of string</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hash</span><span class="hljs-params">(<span class="hljs-type">char</span> *str)</span>&#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> h=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(*str != <span class="hljs-string">&#x27;\0&#x27;</span>)<br>        h = (h&lt;&lt;<span class="hljs-number">5</span>) + *str++;<br>    <span class="hljs-keyword">return</span> h%TableSize;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="例词频统计hash表">6.5 例：词频统计——Hash表</h3><ol type="1"><li><p>问题：编写程序统计一个文件中每个单词的出现次数（词频统计），并按字典序输出每个单词及出现次数。</p></li><li><p>算法分析：基本上只有查找和插入操作。</p><p><img src="/img/LE-ds6/9.png" /></p><p>本问题有如下特点：</p><ol type="1"><li><p>问题规模不知（即需要统计的单词数量末知），有可很大，如对一本小说进行词频统计；</p></li><li><p>单词表在查找时需要频繁的执行插入操作，是一种典型的动态查找表。</p></li></ol><p>针对上述问题，在“线性表”一章采用了顺序表、链表来实现；在“树”一章中采用了二叉排序树（BST）来实现。BST实现方式虽然查找效率较高，但由于树并不是理想的平衡树，查找效率不如折半查找。有没有更好的方法提高查找效率？</p><p><img src="/img/LE-ds6/10.png" /></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>学习经验</category>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习经验</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【数据结构】ds笔记5-树</title>
    <link href="/2024/04/23/LE-ds5/"/>
    <url>/2024/04/23/LE-ds5/</url>
    
    <content type="html"><![CDATA[<p>本篇笔记总结<strong>DSPv2b_5(树与二叉树) forstudent</strong>内的相关内容。更加的抽象，更多的图片……程序员上辈子是伐木工吗，这辈子种树还债。最后，本人学艺不精，只是一边看着ppt一边敲敲改改，如有疏漏，欢迎提出喵~o(=∩ω∩= )m</p><h2 id="树的基本概念">1 树的基本概念</h2><h3 id="树的定义">1.1 树的定义</h3><p>树是由n&gt;=0个结点组成的有穷集合(不妨用符号<code>D</code>表示)以及结点之间关系组成的集合构成的结构，记为<code>T</code>。当n=0时，称T为空树。在任何一棵非空的树中,有一个特殊的结点t∈D，称之为该树的根结点;其余结点D–{t}被分割成m&gt;0个不相交的子集D1,D2, …,Dm,其中,每一个子集D<sub>i</sub>分别构成一棵树,称之为t的<strong>子树</strong>。</p><p><img src="/img/LE-ds5/1.png" /></p><h3 id="树的特点">1.2 树的特点</h3><ol type="1"><li>有且仅有一个结点没有前驱结点,该结点为树的<strong>根结点</strong>；</li><li>除了根结点外,每个结点有且仅有<strong>一个直接前驱结点</strong>；</li><li>包括根结点在内，每个结点可以有<strong>多个后继结点</strong>。</li></ol><h3 id="树的逻辑表示方式">1.3 树的逻辑表示方式</h3><ol type="1"><li><p>文氏图表示法</p><p><img src="/img/LE-ds5/2.png" /></p></li><li><p>凹入表示法</p><p><img src="/img/LE-ds5/3.png" /></p></li><li><p>嵌套括号法（广义表表示法）</p><p>A(B(E, F), C(G(K)), D(H, I, J))</p></li><li><p>树形表示法</p><p><img src="/img/LE-ds5/4.png" /></p></li></ol><h3 id="基本名词术语">1.4 基本名词术语</h3><ol type="1"><li><p>结点的度：该结点拥有的子树的数目。</p></li><li><p>树的度：树中结点度的最大值。</p></li><li><p>叶结点<em>（终端结点）</em>：度为0的结点。</p></li><li><p>分支结点<em>（非终端结点）</em>：度非0的结点。</p></li><li><p>树的层次：根结点在第1层，若某结点在第i层，则其孩子结点（若存在）为第i+1层。</p></li><li><p>树的深度/高度：树中结点所处的最大层次数。</p></li><li><p>路径：对于树中任意两个结点d<sub>i</sub>和d<sub>j</sub>，若在树中存在一个结点序列d<sub>1</sub>,d<sub>2</sub>, ..., d<sub>i</sub>, ..,d<sub>j</sub>，使得d<sub>i</sub>是d<sub>i+1</sub>的双亲（1&lt;=i&lt;j），则称该结点序列是从d<sub>i</sub>到d<sub>j</sub>的一条路径。路径长度为<strong>路径结点数-1</strong>。</p></li><li><p>祖先与子孙：若树中结点d到d<sub>s</sub>存在一条路径，则称d是d<sub>s</sub>的祖先，d<sub>s</sub>和d的子孙。</p><p><em>从根结点到树中其余结点均分别存在一条唯一路径。</em></p><p><em>一个结点的祖先是从根结点到该结点路径上所经过的所有结点；而一个结点的子孙则是以该结点为根的子树上的所有其他结点。</em></p></li><li><p>树林（森林）：m&gt;=0棵不相交的树组成的树的集合。</p></li><li><p>树的有序性：若树中结点的子树的相对位置不能随意改变，则称该树为<strong>有序树</strong>，否则称该树为<strong>无序树</strong>。</p></li></ol><h2 id="树的存储结构">2 树的存储结构</h2><p>分为<strong>顺序存储结构</strong>和<strong>链式存储结构</strong>（居多）。</p><h3 id="多重链表结构">2.1 多重链表结构</h3><h4 id="定长结点的多重链表结构">2.1.1 定长结点的多重链表结构</h4><p><img src="/img/LE-ds5/5.png" /></p><ul><li><p>缺点：存储空间比较浪费</p></li><li><p>对于具有n个结点且度为k的树，空指针域的数目为n*(k-1)+1</p></li></ul><p><img src="/img/LE-ds5/6.png" /></p><h4 id="不定长结点的多重链表结构">2.1.2 不定长结点的多重链表结构</h4><p><img src="/img/LE-ds5/7.png" /></p><ul><li><p>缺点：对数的操作不方便</p><p><img src="/img/LE-ds5/8.png" /></p></li></ul><h3 id="三重链表结构">2.2 三重链表结构</h3><p><img src="/img/LE-ds5/9.png" /></p><ul><li><code>data</code>为数据域；</li><li><code>child</code>为指针域，指向该节点的第一个孩子结点；</li><li><code>parent</code>为指针域，指向该结点的双亲结点；</li><li><code>brother</code>为指针域，指向右边的第一个兄弟结点。</li></ul><p><img src="/img/LE-ds5/10.png" /></p><h2 id="二叉树">3 二叉树</h2><h3 id="二叉树的定义">3.1 二叉树的定义</h3><ul><li><p><strong>二叉树</strong>是n&gt;=0个结点的有穷集合D与D上关系的集合R构成的结构，记为<code>T</code>。当n=0时，称T为空二叉树；否则,它为包含了一个根结点以及两棵不相交的、分别称之为<strong>左子树</strong>与<strong>右子树</strong>的二叉树。</p></li><li><p>二叉树是有序树。</p></li><li><p>二叉树的基本形态：</p><p><img src="/img/LE-ds5/11.png" /></p></li><li><p>辨析：</p><ul><li><ol start="24" type="a"><li>度为2的树是二叉树。</li></ol></li><li><ol start="24" type="a"><li>度为2的有序树是二叉树。</li></ol></li><li><p>(√) 子树有严格的左右之分且度&lt;=2的树是二叉树。</p></li><li><p>具有3个结点的二叉树可以有<strong>5种</strong>形态。</p><p><img src="/img/LE-ds5/12.png" /></p></li><li><p>具有3个结点的树可以有<strong>1种</strong>形态。</p><p><img src="/img/LE-ds5/13.png" /></p></li></ul></li></ul><h3 id="两种特殊形态的二叉树">3.2 两种特殊形态的二叉树</h3><ol type="1"><li><p>满二叉树</p><p>若一棵二叉树中的结点，或者为叶结点，或者具有<strong>两棵非空子树</strong>,并且叶结点<strong>都集中在二叉树的最下面一层</strong>。这样的二叉树为满二叉树。</p></li><li><p>完全二叉树</p><p>若一棵二叉树中只有<strong>最下面两层</strong>的结点的度可以小于2,并且最下面一层的结点(叶结点)依次排列在该层<strong>从左至右</strong>的位置上.这样的二叉树为完全二叉树。</p></li></ol><h3 id="二叉树的性质">3.3 二叉树的性质</h3><ol type="1"><li><p>具有n个结点的非空二叉树共有<strong>n-1</strong>个分支。</p><p><img src="/img/LE-ds5/14.png" /></p></li><li><p>非空二叉树的第i层最多有2<sup>i–1</sup>个结点(i&gt;=1)。</p><p><img src="/img/LE-ds5/15.png" /></p></li><li><p>深度为h的非空二叉树最多有2<sup>h</sup>–1个结点。深度为h的完全二叉树至少有2<sup>h-1</sup>个结点。</p><p><img src="/img/LE-ds5/16.png" /></p></li><li><p>若非空二叉树有n0个叶结点，有n2个度为2的结点，则n0=n2+1。</p><p><img src="/img/LE-ds5/17.png" /></p></li><li><p>具有n个结点的非空完全二叉树的深度为h= ⌊log2n⌋+1。</p><p><img src="/img/LE-ds5/18.png" /></p></li><li><p>若对具有n个结点的<strong>完全二叉树</strong>按照层次从上到下,每层从左到右的顺序进行编号,则编号为i(i≥1)的结点具有以下性质:</p><ol type="1"><li><p>当i=1,则编号为i的结点为二叉树的根结点；</p><p>若i&gt;1,则编号为i的结点的双亲的编号为<strong>⌊i/2⌋</strong>；</p></li><li><p>若2i&gt;n,则编号为i的结点<strong>无左子树</strong>;</p><p>若2i&gt;n,则编号为i的结点的左孩子的编号为<strong>2i</strong>；</p></li><li><p>若2i+1&gt;n,则编号为i的结点<strong>无右子树</strong>;</p><p>若2i+1≤n,则编号为i的结点的右孩子的编号为<strong>2i+1</strong>。</p></li></ol><p><img src="/img/LE-ds5/19.png" /></p></li><li><p>若对具有n个结点的完全二叉树按照层次从上到下,每层从左到右的顺序进行编号,则编号为i(i≥0)的结点具有以下性质:</p><ol type="1"><li><p>当i=0,则编号为i的结点为二叉树的根结点；</p><p>若i&gt;0,则编号为i的结点的双亲的编号为<strong>⌊(i-1)/2⌋</strong>；</p></li><li><p>若2i+1≥n,则编号为i的结点<strong>无左子树</strong>;</p><p>若2i+1&lt;n,则编号为i的结点的左孩子的编号为<strong>2i+1</strong>；</p></li><li><p>若2i+2≥n,则编号为i的结点<strong>无右子树</strong>;</p><p>若2i+2&lt;n,则编号为i的结点的右孩子的编号为<strong>2i+2</strong>。</p></li></ol><p><img src="/img/LE-ds5/20.png" /></p><p>例：<img src="/img/LE-ds5/21.png" /></p></li></ol><h3 id="二叉树的基本操作">3.4 二叉树的基本操作</h3><ol type="1"><li><p><code>INITAL(T)</code> ：初始（创建）一棵二叉树。</p></li><li><p><code>ROOT(T)</code>或<code>ROOT(x)</code>：求二叉树T的根结点，或求结点x所在二叉树的根结点。</p></li><li><p><code>PARENT(T, x)</code>：求二叉树T中结点x的双亲结点。<em>若x是二叉树的根结点，或二叉树中不存在结点x，则返回“空”。</em></p></li><li><p><code>LCHILD(T, x)</code>或<code>RCHILD(T, x)</code>：分别求二叉树T中结点x的左孩子结点或右孩子结点。</p></li><li><p><code>LDELETE(T, x)</code>或<code>RDELETE(T, x)</code>：分别删除二叉树T中以结点x为根的左子树或右子树。</p></li><li><p><strong><code>TRAVERSE(T)</code>：按照某种次序（或原则）依次访问二叉树T中各个结点，得到由该二叉树的所有结点组成的序列。</strong></p></li><li><p><code>LAYER(T, x)</code>：求二叉树中结点x所处的层次。</p></li><li><p><code>DEPTH(T)</code>：求二叉树T的深度。</p></li><li><p><code>DESTROY(T)</code>：销毁一棵二叉树。<em>删除T的所有结点，并释放结点空间,使之成为一棵空二叉树。</em></p></li></ol><h3 id="二叉树与树树林之间的转换">3.5 *二叉树与树、树林之间的转换</h3><ol type="1"><li><p>树-&gt;二叉树</p><ol type="1"><li>在所有相邻的兄弟结点之间分别加一条连线；</li><li>对于每一个分支结点，除了其最左孩子外，删除该结点与其他孩子结点之间的连线；</li><li>以根结点为轴心，顺时针旋转45。</li></ol><p><img src="/img/LE-ds5/22.png" /></p></li><li><p>树林-&gt;二叉树</p><ol type="1"><li>分别将树林中每一棵树转换为一棵二叉树；</li><li>从最后那一棵二叉树开始，依次将<strong>后一棵二叉树的根结点作为前一棵二叉树的根结点的右孩子</strong>，直到所有二叉树都这样处理。这样得到的二叉树的根结点是树林中第一棵二叉树的根结点。</li></ol><p><img src="/img/LE-ds5/23.png" /></p></li><li><p>二叉树还原为树<em>（前提：由一棵树转换而来）</em></p><ol type="1"><li>若某结点是其双亲结点的左孩子，则将<strong>该结点的右孩子以及当且仅当连续地沿此右孩子的右子树方向的所有结点</strong>都分别与该结点的双亲结点用一根虚线连接；</li><li>去掉二叉树中所有双亲结点与其<strong>右孩子</strong>的连线；</li><li>规整图形(即使各结点按照层次排列),并将虚线改成实线。</li></ol><p><img src="/img/LE-ds5/24.png" /></p></li></ol><h2 id="二叉树的存储结构">4 二叉树的存储结构</h2><h3 id="二叉树的顺序存储结构">4.1 二叉树的顺序存储结构</h3><ol type="1"><li><p>完全二叉树的顺序存储结构</p><p>根据完全二叉树的<strong>性质6</strong>，对于深度为h的完全二叉树，将树中所有结点的数据信息按照编号的顺序依次存储到一维数组<strong>BT[0...2<sup>h</sup>-2]</strong>中，由于编号与数组下标一一对应，该数组就是该完全二叉树的顺序存储结构。</p><p>对于一个<strong>下标为i</strong>的结点，其<strong>父结点</strong>下标为<strong>(i-1)/2</strong>；其<strong>子结点</strong>下标为：<strong>2i+1,2i+2</strong></p></li><li><p>一般二叉树的顺序存储结构</p><p>对于一般二叉树,只须在二叉树中“添加”一些实际上二叉树中并不存在的<strong>“虚结点”</strong>(可以认为这些结点的数据信息为空),使其在形式上成为一棵“完全二叉树”,然后按照完全二叉树的顺序存储结构的构造方法将所有结点的数据信息依次存放于数组<strong>BT[0..2<sup>h</sup>-2]</strong>中。</p></li><li><p>结论：</p><ol type="1"><li>顺序存储结构比较适合<strong>满二叉树</strong>，或者接近于满二叉树的<strong>完全二叉树</strong>，对于一些称为“<strong>退化二叉树</strong>”的二叉树,顺序存储结构的空间开销浪费的缺点表现比较突出。</li><li><strong>顺序存储结构便于结点的检索</strong>（由双亲查子、由子查双亲）。</li><li>顺序存储结构由于需要事先分配存储空间，对于<strong>动态数据容易溢出</strong>。</li></ol></li></ol><h3 id="二叉树的链式存储结构">4.2 二叉树的链式存储结构</h3><ol type="1"><li><p>二叉链表</p><ol type="1"><li><p>定长结点的多重链表结构</p><ol type="1"><li><p>链结点的构造： <img src="/img/LE-ds5/25.png" /></p><p>其中<code>data</code>为数据域；<code>left</code>和<code>right</code>分别为指向左、右子树的指针域。</p></li><li><p>结点类型定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span>&#123;</span><br>    Datatype data;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> *<span class="hljs-title">left</span>, *<span class="hljs-title">right</span>;</span><br>&#125;;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> <span class="hljs-title">BTNode</span>;</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> *<span class="hljs-title">BTNodeptr</span>;</span><br>BTNodeptr T, p, q;<br></code></pre></td></tr></table></figure><p><img src="/img/LE-ds5/26.png" /></p></li></ol></li><li><p>不定长结点的多重链表结构</p><p><img src="/img/LE-ds5/27.png" /></p></li></ol></li><li><p>*三叉链表</p><ul><li><p>链结点的构造：<img src="/img/LE-ds5/28.png" /></p><p>其中，<code>data</code>为数据域，<code>parent</code>为指向双亲结点的指针；<code>left</code>和<code>right</code>分别为指向左、右孩子结点的指针。</p></li><li><p>优点：当找到一个结点时，可以很方便的得到<strong>其所有祖先结点</strong>，或得到从<strong>根到该结点的路径</strong>。<imgsrc="/img/LE-ds5/29.png" /></p></li></ul></li></ol><h2 id="典型操作遍历等">5 典型操作（遍历等）</h2><h3 id="二叉树的遍历">5.1 二叉树的遍历</h3><ul><li><p>定义：按照一定的顺序(原则)对二叉树中每一个结点都访问一次(仅访问一次)，得到一个由该二叉树的所有结点组成的序列，这一过程称为<strong>二叉树的遍历</strong>。</p></li><li><p>常用的遍历方法</p><ul><li>前序遍历（DLR）</li><li>中序遍历（LDR）</li><li>后序遍历（LRD）</li><li>按层次遍历</li></ul><p>其中L表示遍历左子树，R表示遍历右子树，D表示访问根结点。前序、中序及后序遍历实质为<strong>深度优先算法（DFS）</strong>，层次遍历为一种<strong>广度优先算法（BFS）</strong>。</p></li><li><p>可以利用<strong>前序序列和中序序列</strong>恢复二叉树，可以利用<strong>中序序列和后序序列</strong>恢复二叉树，<strong>不能</strong>利用前序序列和后序序列恢复二叉树。</p></li></ul><h4 id="前序遍历">5.1.2 前序遍历</h4><p>原则：若被遍历的二叉树非空，则</p><ol type="1"><li>访问根结点</li><li>以前序遍历原则遍历根结点的左子树；</li><li>以前序遍历原则遍历根结点的右子树。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">perorder</span><span class="hljs-params">(BTNodeptr t)</span>&#123;<br>    <span class="hljs-keyword">if</span>(t!=<span class="hljs-literal">NULL</span>)&#123;<br>        VISIT(t);       <span class="hljs-comment">// 访问t指向结点</span><br>        preorder(t-&gt;left);<br>        preorder(t-&gt;right);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="中序遍历">5.1.3 中序遍历</h4><p>原则：若被遍历的二叉树非空，则</p><ol type="1"><li>以中序遍历原则遍历根结点的左子树；</li><li>访问根结点；</li><li>以中序遍历原则遍历根结点的右子树。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">inorder</span><span class="hljs-params">(BTNodeptr t)</span>&#123;<br>    <span class="hljs-keyword">if</span>(t!=<span class="hljs-literal">NULL</span>)&#123;<br>        inorder(t-&gt;left);<br>        VISIT(T);       <span class="hljs-comment">// 访问T指结点</span><br>        inorder(t-&gt;right);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="后序遍历">5.1.4 后序遍历</h4><p>原则：若被遍历的二叉树非空，则</p><ol type="1"><li>以后序遍历原则遍历根结点的左子树；</li><li>以后序遍历原则遍历根结点的右子树；</li><li>访问根结点。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">postorder</span><span class="hljs-params">(BTNodeptr t)</span>&#123;<br>    <span class="hljs-keyword">if</span>(t!=<span class="hljs-literal">NULL</span>)&#123;<br>        postorder(t-&gt;left);<br>        postorder(t-&gt;right);<br>        VISIT(T);       <span class="hljs-comment">// 访问T指结点</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="按层次遍历">5.1.5 按层次遍历</h4><p>原则：若被遍历的二叉树非空，则按照层次从上到下，每一层从左到右依次访问节点。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 把根结点为p的树转化为非循环队列</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NodeNum 100</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">layerorder</span><span class="hljs-params">(BTNodeptr t)</span>&#123;<br>    BTNodeptr <span class="hljs-built_in">queue</span>[NodeNum], p;<br>    <span class="hljs-type">int</span> front, rear;<br>    <span class="hljs-keyword">if</span>(t!=<span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-built_in">queue</span>[<span class="hljs-number">0</span>]=t;<br>        front=<span class="hljs-number">0</span>;<br>        rear=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(front&lt;=rear)&#123;<span class="hljs-comment">// 若队列不空</span><br>            p=<span class="hljs-built_in">queue</span>[front++]; <br>            VISIT(p);<span class="hljs-comment">// 访问p指结点</span><br>            <span class="hljs-keyword">if</span>(p-&gt;left!=<span class="hljs-literal">NULL</span>)<span class="hljs-comment">// 若左孩子非空</span><br>            <span class="hljs-built_in">queue</span>[++rear]=p-&gt;left;<br>            <span class="hljs-keyword">if</span>(p-&gt;right!=<span class="hljs-literal">NULL</span>)<span class="hljs-comment">// 若右孩子非空</span><br>            <span class="hljs-built_in">queue</span>[++rear]=p-&gt;right;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 转化为循环队列</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">layerorder</span><span class="hljs-params">(BTNodeptr t)</span>&#123;<br>    BTNodeptr p;<br>    <span class="hljs-keyword">if</span>(t!=<span class="hljs-literal">NULL</span>)&#123;<br>        enQueue(t);<br>        <span class="hljs-keyword">while</span>(!isEmpty())&#123;                      <br>            p=deQueue(); <br>            VISIT(p);                              <br>            <span class="hljs-keyword">if</span>(p-&gt;lchild!=<span class="hljs-literal">NULL</span>)           <br>            enQueue(p-&gt;left);<br>            <span class="hljs-keyword">if</span>(p-&gt;rchild!=<span class="hljs-literal">NULL</span>)           <br>            enQueue(p-&gt;right);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="由遍历序列恢复二叉树">5.1.6 由遍历序列恢复二叉树</h4><ol type="1"><li><p>已知前序序列和中序序列，恢复二叉树：<strong>在前序序列中确定根;到中序序列中分左右</strong>。</p></li><li><p>已知中序序列和后序序列，恢复二叉树：<strong>在后序序列中确定根;到中序序列中分左右</strong>。</p></li></ol><h3 id="树的遍历">5.2 树的遍历</h3><ol type="1"><li><p>前序遍历</p><p>原则：若被遍历的树非空,则</p><ol type="1"><li>访问根结点；</li><li>依次按前序遍历方式遍历根结点每一棵子树。</li></ol></li><li><p>后序遍历</p><p>原则：若被遍历的树非空,则</p><ol type="1"><li>依次按后序遍历方式遍历根结点每一棵子树；</li><li>访问根结点。</li></ol></li><li><p>深度优先遍历算法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXD 3   <span class="hljs-comment">//树的度</span></span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span>&#123;</span><br>    Datatype data;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> *<span class="hljs-title">next</span>[<span class="hljs-title">MAXD</span>];</span><br> &#125;;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> <span class="hljs-title">TNode</span>;</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> *<span class="hljs-title">TNodeptr</span>;</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">DFStree</span><span class="hljs-params">(TNodeptr t)</span>&#123;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-keyword">if</span>(t!=<span class="hljs-literal">NULL</span>)&#123;<br>        VISIT(t);       <span class="hljs-comment">/* 访问t指向结点  */</span><br>        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;MAXD; i++)<br>        <span class="hljs-keyword">if</span>(t-&gt;next[i] != <span class="hljs-literal">NULL</span>)<br>        DFStree(t-&gt;next[i]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>广度优先遍历算法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXD 3   <span class="hljs-comment">//树的度</span></span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span>&#123;</span><br>    Datatype data;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> *<span class="hljs-title">next</span>[<span class="hljs-title">MAXD</span>];</span><br> &#125;;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> <span class="hljs-title">TNode</span>;</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> *<span class="hljs-title">TNodeptr</span>;</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">BFStree</span><span class="hljs-params">(TNodeptr t)</span>&#123;<br>    TNodeptr p;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-keyword">if</span>(t!=<span class="hljs-literal">NULL</span>)&#123;<br>        enQueue(t);<br>        <span class="hljs-keyword">while</span>(!isEmpty())&#123;<span class="hljs-comment">// 若队列不空</span><br>            p= deQueue(); <br>            VISIT(p);    <br>            <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;MAXD; i++)<span class="hljs-comment">// 依次访问p指向的子结点</span><br>            <span class="hljs-keyword">if</span>(p-&gt;next[i] != <span class="hljs-literal">NULL</span>)   <br>            enQueue(p);<br>        &#125;<br>    &#125;    <br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="二叉树的拷贝">5.3 二叉树的拷贝</h3><p>树拷贝时先拷贝当前结点，再拷贝子结点（同<strong>前序遍历</strong>）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c">BTNodeptr <span class="hljs-title function_">copyTree</span><span class="hljs-params">(BTNodeptr src)</span>&#123;<br>    BTNodeptr obj;<br>    <span class="hljs-keyword">if</span>(src == <span class="hljs-literal">NULL</span>)&#123;<br>obj = <span class="hljs-literal">NULL</span>;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        obj = (BTNodeptr) <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(BTNode));<br>        obj-&gt;data = src-&gt;data;<br>        obj-&gt;left = copyTree(src-&gt;left);<br>        obj-&gt;right = copyTree(src-&gt;right);<br>    &#125;<br>    <span class="hljs-keyword">return</span> obj;<br>&#125;    <span class="hljs-comment">// 以前序遍历思路实现二叉树的拷贝</span><br></code></pre></td></tr></table></figure><h3 id="二叉树的删除">5.4 二叉树的删除</h3><p>树删除时先删除子结点，再删除当前结点。（同<strong>后序遍历</strong>）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">destoryTree</span><span class="hljs-params">(BTNodeptr  p)</span>&#123;<br>    <span class="hljs-keyword">if</span>(p != <span class="hljs-literal">NULL</span>)&#123;<br>         destoryTree(p-&gt;left);<br>         destoryTree(p-&gt;right);<br>         <span class="hljs-built_in">free</span>(p);<br>         p = <span class="hljs-literal">NULL</span>; <br>    &#125;<br>&#125;    <span class="hljs-comment">//二叉树删除，采用后序遍历的思路</span><br></code></pre></td></tr></table></figure><h3 id="二叉树的高度">5.5 二叉树的高度</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">max</span><span class="hljs-params">(x,y)</span>&#123;<br>    <span class="hljs-keyword">if</span>(x&gt;y)<br>        <span class="hljs-keyword">return</span> x;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> y;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">heightTree</span><span class="hljs-params">(BTNodeptr p)</span>&#123;<br>    <span class="hljs-keyword">if</span>(p == <span class="hljs-literal">NULL</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + max(heightTree(p-&gt;left), heightTree(p-&gt;right));<br> &#125;     <span class="hljs-comment">//计算树的高度</span><br></code></pre></td></tr></table></figure><h2 id="线索二叉树threaded-binary-tree">6 *线索二叉树(Threaded BinaryTree)</h2><h3 id="基本概念">6.1 基本概念</h3><p>利用二叉链表中空的指针域指出结点在某种遍历序列中的直接前驱或直接后继。指向前驱和后继的指针称为<strong>线索</strong>,加了线索的二叉树称为<strong>线索二叉树</strong>。</p><h3 id="线索二叉树的构造">6.2 线索二叉树的构造</h3><p>利用链结点的<strong>空的左指针域</strong>存放该结点的直接前驱的地址，<strong>空的右指针域</strong>存放该结点直接后继的地址；而非空的指针域仍然存放结点的左孩子或右孩子的地址。</p><p><img src="/img/LE-ds5/30.png" /></p><ul><li><p>指针与线索的区分</p><ul><li>法1：<img src="/img/LE-ds5/31.png" /></li><li>法2：不改变链结点的构造,而是在作为线索的地址前加一个负号,即“负地址”表示线索，“正地址”表示指针。</li></ul></li><li><p>线索二叉树链结点类型定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span>&#123;</span><br>    Datatype data;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> *<span class="hljs-title">left</span>, *<span class="hljs-title">right</span>;</span><br>    <span class="hljs-type">char</span> lbit, rbit;<br>&#125;;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> <span class="hljs-title">TBTNode</span>;</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> *<span class="hljs-title">TBTNodeptr</span>;</span><br></code></pre></td></tr></table></figure><p><img src="/img/LE-ds5/32.png" /></p></li></ul><h3 id="线索二叉树的应用">6.3 线索二叉树的应用</h3><p>为中序线索二叉树确定地址为x的结点的直接后继</p><ul><li><p>规律：</p><ul><li>当<code>x-&gt;rbit=0</code>时,<code>x-&gt;right</code>指出的结点就是x的直接后继结点。</li><li>当<code>x-&gt;rbit=1</code>时，沿着x的右子树的根的左子树方向查找,直到某结点的<code>left</code>域为线索时,此结点就是<code>x</code>结点直接后继结点。</li></ul></li><li><p>代码实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 确定x的直接后继</span><br>TBTNodeptr <span class="hljs-title function_">insucc</span><span class="hljs-params">(TBTNodeptr x)</span>&#123;<br>    TBTNodeptr s;<br>    s=x-&gt;right;<br>    <span class="hljs-keyword">if</span>(x-&gt;rbit==<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">while</span> (s-&gt;lbit==<span class="hljs-number">1</span>)<br>    s=s-&gt;left;<br>    <span class="hljs-keyword">return</span>(s);<br>&#125;<br><br><span class="hljs-comment">// 利用上面函数实现非递归中序遍历</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">torder</span><span class="hljs-params">(TBTNodeptr head)</span>&#123;    <br>    TBTNodeptr  p=head;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>        p=insucc(p);<br>        <span class="hljs-keyword">if</span>(p==head)<br>        <span class="hljs-keyword">break</span>;<br>        VISIT(p);<br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="线索二叉树的建立">6.4 线索二叉树的建立</h3><ul><li><p>建立线索的规矩：</p><ul><li><p><code>prior</code>：指向前一次访问结点</p><p><code>p</code>：指向当前访问结点</p></li><li><p>若当前访问的结点的<strong>左指针域</strong>为空，则它指向<code>prior</code>指的结点，同时置<code>lbit</code>为0，否则，置<code>lbit</code>为1；</p></li><li><p>若<code>prior</code>所指结点的<strong>右指针域</strong>为空，则它指向当前访问的结点，同时置<code>rbit</code>为0，否则，置<code>rbit</code>为1。</p></li><li><p><code>p=NULL</code>时遍历结束，将<code>prior-&gt;right</code>指向头结点，并置<code>prior-&gt;rbit</code>为0。</p></li></ul></li><li><p>代码实现（对根结点<code>root</code>引领的树进行中序线索化）</p><p>递归版本</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c">TBTNodeptr piror;<br>TBTNodeptr <span class="hljs-title function_">threading</span><span class="hljs-params">(TBTNodeptr  root)</span>&#123;<br>    TBTNodeptr head;<br>    head = (TBTNodeptr)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(TBTNode));<br>    head-&gt;left = root; head-&gt;right = head; head-&gt;lbit = head-&gt;rbit=<span class="hljs-number">1</span>;<br>    piror = head;<br>    inThreading(root);<br>    piror-&gt;right = head; piror-&gt;rbit = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> head;<br>&#125;<br><br><span class="hljs-comment">// 中序遍历进行中序线索化piror是一个全局变量，初始时，piror指向树head结点</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">inThreading</span><span class="hljs-params">(TBTNodeptr p)</span>&#123;<br>    <span class="hljs-keyword">if</span>(p != <span class="hljs-literal">NULL</span>) &#123;<br>    inThreading(p-&gt;left);  <span class="hljs-comment">//递归左子树线索化</span><br>        <span class="hljs-keyword">if</span>(p-&gt;left == <span class="hljs-literal">NULL</span>) &#123; <span class="hljs-comment">//没有左孩子</span><br>            p-&gt;lbit = <span class="hljs-number">0</span>;<span class="hljs-comment">//前驱线索</span><br>            p-&gt;left = prior;<span class="hljs-comment">//左孩子指针指向前驱</span><br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            p-&gt;lbit = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(prior-&gt;right == <span class="hljs-literal">NULL</span>) &#123; <span class="hljs-comment">//前驱没有右孩子</span><br>            prior-&gt;rbit = <span class="hljs-number">0</span>;<span class="hljs-comment">//后继线索</span><br>            prior-&gt;right = p;<span class="hljs-comment">//前驱右孩子指向后继</span><br>        &#125;<span class="hljs-keyword">else</span>&#123; <br>            prior-&gt;rbit = <span class="hljs-number">1</span>;<br>        &#125;<br>        prior = p;<span class="hljs-comment">//保持prior指向p的前驱</span><br>        inThreading(p-&gt;right); <span class="hljs-comment">//递归右子树线索化</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>非递归版本</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> NodeNum 100<span class="hljs-comment">// 定义二叉树中结点最大数目</span></span><br>TBTNodeptr <span class="hljs-title function_">inthread</span><span class="hljs-params">(TBTNodeptr t)</span>&#123;  <br>    TBTNodeptr  head, p=t, prior, <span class="hljs-built_in">stack</span>[NodeNum];<br>    <span class="hljs-type">int</span> top=<span class="hljs-number">-1</span>;<br>    head=(TBTNoteptr)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(TBNode));  <br>    <span class="hljs-comment">// 申请线索二叉树的头结点空间</span><br>    head-&gt;left=t;<br>head-&gt;right=head;<br>    head-&gt;lbit=<span class="hljs-number">1</span>;  <br>    prior=head;<span class="hljs-comment">// 假设中序序列的第1个结点的“前驱”为头结点</span><br>     <br>    <span class="hljs-keyword">do</span>&#123; <br>        <span class="hljs-keyword">for</span>(; p!=<span class="hljs-literal">NULL</span>; p=p-&gt;left)<span class="hljs-comment">// p移到左孩子结点</span><br>        <span class="hljs-built_in">stack</span>[++top]=p;<span class="hljs-comment">// p指结点的地址进栈 </span><br>        p=<span class="hljs-built_in">stack</span>[top--];<span class="hljs-comment">// 退栈</span><br>        <br>        <span class="hljs-keyword">if</span>(p-&gt;left==<span class="hljs-literal">NULL</span>)&#123;        <span class="hljs-comment">// 若当前访问结点的左孩子为空</span><br>            p-&gt;left=prior; <span class="hljs-comment">// 当前访问结点的左指针域指向前一次访问结点</span><br>            p-&gt;lbit=<span class="hljs-number">0</span>;  <span class="hljs-comment">// 当前访问结点的左标志域置0(表示地址为线索)</span><br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>        p-&gt;lbit=<span class="hljs-number">1</span>;      <span class="hljs-comment">// 当前访问结点的左标志域置1(表示地址为指针)</span><br>        &#125;<br>        <span class="hljs-keyword">if</span>(prior-&gt;right==<span class="hljs-literal">NULL</span>)&#123;     <span class="hljs-comment">// 若前一次访问的结点的右孩子为空</span><br>            prior-&gt;right=p;<br>            <span class="hljs-comment">// 前一次访问结点的右指针域指向当前访问结点</span><br>            prior-&gt;rbit=<span class="hljs-number">0</span>;<br>            <span class="hljs-comment">// 前一次访问结点的右标志域置0(表示地址为线索)</span><br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>        prior-&gt;rbit=<span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 前一次访问结点的右标志域置1(表示地址为指针)</span><br>        &#125;<br>        <br>        prior=p;<span class="hljs-comment">// 记录当前访问的结点的地址</span><br>        p=p-&gt;right;<span class="hljs-comment">// p移到右孩子结点</span><br>    &#125;<span class="hljs-keyword">while</span>(!(p==<span class="hljs-literal">NULL</span> &amp;&amp; top==<span class="hljs-number">-1</span>));<br>     <br>    prior-&gt;right=head;<span class="hljs-comment">// 设中序序列的最后结点的后继为头结点</span><br>    prior-&gt;rbit=<span class="hljs-number">0</span>;<span class="hljs-comment">// prior指结点的右标志域置0(表示地址为线索)</span><br>    <span class="hljs-keyword">return</span> head;<span class="hljs-comment">// 返回线索二叉树的头结点指针</span><br>&#125; <br></code></pre></td></tr></table></figure></li><li><p>二叉树线索化的好处：线索化二叉树等于将一棵二叉树转变成了一个<strong>双向链表</strong>，这为二叉树结点的插入、删除和查找带来了方便。在实际问题中，如果所用的二叉树需要<strong>经常遍历或查找结点时需要访问结点的前驱和后继</strong>，则采用线索二叉树结构是一个很好的选择。将二叉树线索化可以实现不用栈的树深度优先遍历算法。</p></li></ul><h2 id="二叉查找树二叉搜索树二叉排序树binary-search-tree-bst">7二叉查找树（二叉搜索树、二叉排序树）(Binary Search Tree, BST)</h2><p>适合于<strong>数据量大</strong>且<strong>无序</strong>的数据，如单词词频统计（单词索引）等。</p><h3 id="二叉查找树的定义">7.1 二叉查找树的定义</h3><p>二叉查找树或者为空二叉树, 或者为具有以下性质的二叉树:</p><ul><li>若根结点的左子树不空, 则左子树上所有结点的值都小于根结点的值;</li><li>若根结点的右子树不空,则右子树上所有结点的值都大于或等于根结点的值;</li><li>每一棵子树分别也是二叉查找树。</li></ul><h3 id="二叉查找树的建立逐点插入法">7.2二叉查找树的建立（逐点插入法）</h3><ol type="1"><li><p>规律</p><p>设K=( k<sub>1</sub>, k<sub>2</sub>, k<sub>3</sub>, … , k<sub>n</sub>)为具有n个数据元素的序列。从序列的第一个元素开始，依次取序列中的元素，每取一个元素k<sub>i</sub>，按照下述原则将k<sub>i</sub>插入到二叉树中:</p><ol type="1"><li>若二叉树为空，则k<sub>i</sub>作为该二叉树的根结点；</li><li>若二叉树非空，则将k<sub>i</sub>与该二叉树的根结点的值进行比较，若k<sub>i</sub>小于根结点的值,则将k<sub>i</sub>插入到根结点的左子树中；否则，将k<sub>i</sub>插入到根结点的右子树中。</li><li>将k<sub>i</sub>插入到左子树或者右子树中仍然遵循上述原则(递归)。</li></ol></li><li><p>代码实现（将一个数据元素<code>item</code>插入到根指针为<code>root</code>的二叉排序树中）</p><p>递归算法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> Datatype;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> &#123;</span><br>    Datatype data;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> *<span class="hljs-title">left</span>, *<span class="hljs-title">right</span>;</span><br>&#125;;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> <span class="hljs-title">BTNode</span>, *<span class="hljs-title">BTNodeptr</span>;</span><br>BTNodeptr <span class="hljs-title function_">insertBST</span><span class="hljs-params">(BTNodeptr p, Datatype item)</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">int</span> i, item;<br>    BTNodeptr  root=<span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">10</span>; i++)&#123; <span class="hljs-comment">//构造一个有10个元素的BST树</span><br><span class="hljs-built_in">scanf</span>(“%d”, &amp;item);<br>root = insertBST(root, item);<br>&#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br>BTNodeptr <span class="hljs-title function_">insertBST</span><span class="hljs-params">(BTNodeptr p, Datatype item)</span>&#123;<br>    <span class="hljs-keyword">if</span>(p == <span class="hljs-literal">NULL</span>)&#123;<span class="hljs-comment">// 如果二叉树为空</span><br>        p = (BTNodeptr)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(BTNode));<br>        p-&gt;data = item;<br>        p-&gt;left = p-&gt;right = <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(item &lt; p-&gt;data)<span class="hljs-comment">// 小于根结点放左边</span><br>        p-&gt;left = insertBST(p-&gt;left, item);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(item &gt; p-&gt;data)<span class="hljs-comment">// 大于根结点放右边</span><br>p-&gt;right = insertBST(p-&gt;right,item);<br>    <span class="hljs-keyword">else</span>   <br><span class="hljs-keyword">do</span>-something; <span class="hljs-comment">//树中存在该元素</span><br>    <span class="hljs-keyword">return</span> p;<br>&#125; <br></code></pre></td></tr></table></figure><p>非递归算法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c">BTNodeptr  Root=<span class="hljs-literal">NULL</span>; <span class="hljs-comment">//Root是一个全局变量</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">insertBST</span><span class="hljs-params">(Typedata item)</span>&#123;<br>    BTNodeptr p, q;<br>    p=(BTNodeptr)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(BTNode));<br>    p-&gt;data=item;<br>    p-&gt;left=<span class="hljs-literal">NULL</span>;<br>    p-&gt;right=<span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">if</span>(Root==<span class="hljs-literal">NULL</span>)&#123;<span class="hljs-comment">// 根结点为空</span><br>Root=p;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>    q=Root;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<span class="hljs-comment">/* 比较值的大小 */</span><br>         <span class="hljs-comment">/* ，大于向右 */</span><br><span class="hljs-keyword">if</span>(item &lt; q-&gt;data)&#123;<span class="hljs-comment">// 小于向左</span><br><span class="hljs-keyword">if</span>(q-&gt;left == <span class="hljs-literal">NULL</span>)&#123;<br>                    q-&gt;left=p;<br>                    <span class="hljs-keyword">break</span>;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>                q = q-&gt;left;<br>                &#125;<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(item &gt; q-&gt;data)&#123;<span class="hljs-comment">// 大于向右</span><br>                <span class="hljs-keyword">if</span>(q-&gt;right==<span class="hljs-literal">NULL</span>)&#123;<br>                    q-&gt;right=p;<br>                    <span class="hljs-keyword">break</span>;     <br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>q=q-&gt;right;<br>                &#125;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-comment">/* do-something */</span> <br>            &#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>通过调用非递归插入算法建立二叉查找树的（主）算法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">BTNodeptr Root=<span class="hljs-literal">NULL</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">sortTree</span><span class="hljs-params">(Datatype k[ ], <span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;n; i++)<br>    insertBST(k[i]);<br>    <span class="hljs-keyword">return</span> ;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="二叉查找树的删除">7.3 二叉查找树的删除</h3><ol type="1"><li>被删除节点为叶节点，则直接删除；</li><li>被删除结点无左子树，则用右子树的根结点取代被删除结点；</li><li>被删除结点无右子树，则用左子树的根结点取代被删除结点。</li><li>被删除结点的左、右子树都存在，则用被删除结点的右子树中值最小的结点（或被删除结点的左子树中值最大的结点)取代被删除结点。</li></ol><ul><li>懒惰删除(lazydeletion)：当一个元素要被删除时，它仍留在树中，而是只做一个被删除的记号。如果删除的次数不多，则通常使用的策略是<strong>懒惰删除</strong>。</li></ul><h3 id="二叉查找树的查找">7.4 二叉查找树的查找</h3><ol type="1"><li><p>查找过程</p><ul><li>若二叉查找树为空,则查找失败,查找结束。</li><li>若二叉查找树非空，则将被查找元素与二叉排序树的根结点的值进行比较,<ul><li>若等于根结点的值,则查找成功，结束；</li><li>若小于根结点的值,则到根结点的左子树中重复上述查找过程;</li><li>若大于根结点的值,则到根结点的右子树中重复上述查找过程;</li><li>直到查找成功或者失败。</li></ul></li><li>若查找成功，给出被查找元素所在结点的地址；若查找失败，给出信息NULL。</li></ul></li><li><p>代码实现</p><p>非递归算法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c">BTNodeptr <span class="hljs-title function_">searchBST</span><span class="hljs-params">(BTNodeptr t,Datatype  key)</span>&#123;<br>    BTNodeptr p = t;<br>    <span class="hljs-keyword">while</span>(p!=<span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-keyword">if</span>(key == p-&gt;data)  <br>            <span class="hljs-keyword">return</span> p;<span class="hljs-comment">// 查找成功</span><br>        <span class="hljs-keyword">if</span>(key &gt; p-&gt;data)<br>            p=p-&gt;right;<span class="hljs-comment">// 将p移到右子树的根结点</span><br>        <span class="hljs-keyword">else</span><br>            p=p-&gt;left;<span class="hljs-comment">// 将p移到左子树的根结点</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<span class="hljs-comment">// 查找失败</span><br>&#125;<br></code></pre></td></tr></table></figure><p>递归算法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c">BTNodeptr <span class="hljs-title function_">searchBST</span><span class="hljs-params">( BTNodeptr t, Datatype key )</span>&#123;<br>    <span class="hljs-keyword">if</span>(t!=<span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-keyword">if</span>(key == t-&gt;data) <br>            <span class="hljs-keyword">return</span> t;<span class="hljs-comment">// 查找成功</span><br>        <span class="hljs-keyword">if</span>(key &gt; t-&gt;data)<br>            <span class="hljs-keyword">return</span> searchBST(t-&gt;right, key);<span class="hljs-comment">// 查找T的右子树   </span><br>        <span class="hljs-keyword">else</span><br><span class="hljs-keyword">return</span> searchBST(t-&gt;left, key);<span class="hljs-comment">// 查找T的左子树</span><br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<span class="hljs-comment">// 查找失败</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>查找效率</p><p>平均查找长度ASL：确定一个元素在树中位置所需要进行的元素间的比较次数的期望值（平均值）。<span class="math display">\[ASL = \sum_{i=1}^{k} p_ic_i\]</span>其中n表示二叉树中结点的总数；p<sub>i</sub>表示查找第i个元素的概率；c<sub>i</sub>表示查找第i个元素需要进行的元素之间的比较次数。</p></li></ol><h2 id="平衡二叉树adelson-velskii-and-landis-avl">8平衡二叉树(Adelson-Velskii and Landis, AVL)</h2><ul><li><p>二叉查找树的缺陷：树的形态无法预料、随意性大。得到的可能是一个不平衡的树，即树的深度差很大。丧失了利用二叉树组织数据带来的好处。</p></li><li><p>平衡二叉树又称AVL树。它或者是一棵空树，或者是具有下列性质的二叉树：</p><p>它的左子树和右子树都是平衡二叉树，且左子树和右子树的深度之差的绝对值不超过1。若将二叉树的平衡因子定义为该结点<strong>左子树深度减去右子树深度</strong>，则平衡二叉树上所有结点的平衡因子只可能是-1、0和1。</p></li></ul><hr /><h2 id="例">例</h2><h3id="已知二叉查找树采用二叉链表存储结构根结点地址为t请写一非递归算法打印数据信息为item的结点的所有祖先结点设该结点存在祖先结点">1已知二叉查找树采用二叉链表存储结构，根结点地址为T，请写一非递归算法，打印数据信息为item的结点的所有祖先结点。（设该结点存在祖先结点）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">searchBST</span><span class="hljs-params">(BTNodeptr t, Datatype item)</span>&#123;<br>    BTNodeptr  p = t;<br>    <span class="hljs-keyword">while</span>(p!=<span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-keyword">if</span>(item == p-&gt;data) <br>        <span class="hljs-keyword">break</span>;                      <span class="hljs-comment">// 查找结束</span><br>        <span class="hljs-keyword">if</span>(item &gt; p-&gt;data)&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,p-&gt;data);<br>            p=p-&gt;right;          <span class="hljs-comment">// 将p 移到右子树的根结点</span><br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,p-&gt;data);<br>            p=p-&gt;left;           <span class="hljs-comment">// 将p 移到左子树的根结点</span><br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li>若需要保存祖先结点序列（即结点路径），可以设一个<strong>栈</strong>保存路径节点，或设一个指向<strong>父结点</strong>的指针</li></ul><h3 id="获取一个普通二叉树的数据信息为item的结点的所有祖先结点">2获取一个普通二叉树的数据信息为item的结点的所有祖先结点。</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">perorder</span><span class="hljs-params">(BTNodeptr t, Datatype item)</span>&#123;<br>    <span class="hljs-keyword">if</span>(t!=<span class="hljs-literal">NULL</span>)&#123;<br>        push(t);      <br>        <span class="hljs-keyword">if</span>(item == t-&gt;data) <br>        弹出栈中所有元素； <br>        preorder(t-&gt;left);<br>        preorder(t-&gt;right);<br>        pop();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="词频统计二叉查找树">3 词频统计——二叉查找树</h3><h4 id="问题">3.1 问题</h4><p>编写程序统计一个文件中每个单词的出现次数（词频统计），并按字典序输出每个单词及出现次数。</p><h4 id="算法分析">3.2 算法分析</h4><p>本问题算法很简单，基本上只有<strong>查找</strong>和<strong>插入</strong>操作。</p><p><img src="/img/LE-ds5/33.png" /></p><h4 id="代码实现">3.3 代码实现</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXWORD  100</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tnode</span> &#123;</span><br>    <span class="hljs-type">char</span> word[MAXWORD];<br>    <span class="hljs-type">int</span> count;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tnode</span> *<span class="hljs-title">left</span>,*<span class="hljs-title">right</span>;</span><br>&#125; ; <span class="hljs-comment">//BST,单词树结构</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">getword</span><span class="hljs-params">(FILE *bfp,<span class="hljs-type">char</span> *w)</span>;<br><span class="hljs-keyword">struct</span> tnode *<span class="hljs-title function_">addtree</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> tnode *p,<span class="hljs-type">char</span> *w)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">treeprint</span><span class="hljs-params">( <span class="hljs-keyword">struct</span> tnode *p)</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">char</span> filename[<span class="hljs-number">32</span>], word[MAXWORD];<br>    FILE *bfp;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tnode</span> *<span class="hljs-title">root</span>=</span><span class="hljs-literal">NULL</span>; <span class="hljs-comment">//BST树根节点指针</span><br><br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, filename);<br>    <span class="hljs-keyword">if</span>((bfp = fopen(filename, <span class="hljs-string">&quot;r&quot;</span>)) == <span class="hljs-literal">NULL</span>)&#123; <span class="hljs-comment">//打开一个文件</span><br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;%s can’t open!\n&quot;</span>,filename);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-keyword">while</span>( getword(bfp,word) != EOF) <span class="hljs-comment">//从文件中读入一个单词</span><br>        root = addtree(root, word);<br>    treeprint(root);  <span class="hljs-comment">//遍历输出单词树</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br></code></pre></td></tr></table></figure><h4 id="拓展">3.4 拓展</h4><p>如果对统计好的词频按单词频率序输出该怎么办（如何对非线性数据进行排序？）（实际应用通常是这么要求的）</p><h2 id="堆heap二叉树的应用">9 *堆(heap)——二叉树的应用</h2><h3 id="堆的基本性质">9.1 堆的基本性质</h3><ol type="1"><li><p>堆是一种特殊类型的二叉树，具有以下两个性质：</p><ol type="1"><li>每个节点的值大于（或小于）等于其每个子节点的值；</li><li>该树完全平衡，其最后一层的叶子都处于最左侧的位置。</li></ol><p>满足上面两个性质定义的是<strong>大顶堆(maxheap)</strong>(或<strong>小顶堆(minheap)</strong>)。即大顶堆的根节点包含了最大的元素，小顶堆的根节点包含了最小的元素。</p></li><li><p>由于堆是一个完全树，一般采用数组实现，对于一个下标为i的结点:</p><ol type="1"><li>其父结点下标为：<strong>(i-1)/2</strong></li><li>其子结点下标为：<strong>2i+1, 2i+2</strong></li><li>（如果是大顶堆）：heap[i] ≧heap[2*i+1]; heap[i] ≧heap[2*i+2]</li></ol></li><li><p>堆结构的最大好处是元素查找、插入和删除效率高（O(log2n)）</p></li><li><p>堆的主要应用：</p><ol type="1"><li>可用来实现优先队列（Priority Queue）</li><li>用来实现一种高效排序算法-堆排序（HeapSort），在排序一讲中详细介绍</li></ol></li></ol><h3 id="堆的基本操作以大顶堆为例">9.2 堆的基本操作（以大顶堆为例）</h3><ol type="1"><li><p>插入算法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">heapInsert(e)<br>    将e放在堆的末尾;<br>    <span class="hljs-keyword">while</span> e 不是根 &amp;&amp; e &gt; parent(e)<br>        e 与其父节点交换;<br></code></pre></td></tr></table></figure></li><li><p>删除算法（获取堆顶元素，并从堆中删除）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c">heapDelete()   <span class="hljs-comment">//取堆顶（树根）元素</span><br>    从根节点提取元素;<br>    将最后一个叶节点中的元素放到要删除的元素位置;<br>    删除最后一个叶节点;<br>    <span class="hljs-comment">//根的两个子树都是堆</span><br>    p = 根节点;<br>    <span class="hljs-keyword">while</span> p 不是叶节点 &amp;&amp; p &lt; 它的任何子节点<br>        p与其较大的子节点交换;<br></code></pre></td></tr></table></figure></li></ol><h3 id="堆的构造">9.3 堆的构造</h3><ol type="1"><li>自顶向下：从空堆开始，按顺序向堆中添加（用<code>headinsert</code>函数）元素</li><li>自底向上：首先从底层开始构造较小的堆，然后再重复构造较大的堆。（算法将在堆排序一节中介绍）</li></ol><h3 id="堆的典型应用">9.4 堆的典型应用</h3><ol type="1"><li>优先队列（Priorityqueue）：与传统队列不同的是下一个服务对象是队列中优先级最高的元素。优先队列常用的实现方式是用堆，其最大好处是管理元素的效率高（O(log2N)）。<em>优先队列是计算机中常用的一种数据结构，如操作系统中进程调度就是基于优先队例。</em></li><li>堆排序（Heap sort）：一种基于堆的高效（O(nlog2 n)）的排序算法。</li></ol><h2 id="表达式树expression-tree二叉树的应用">10 表达式树(expressiontree)——二叉树的应用</h2><h3 id="表达式树的定义">10.1 表达式树的定义</h3><ol type="1"><li><p>表达式树是一种特殊类型的树，其叶结点是操作数(operand)，而其它结点为操作符(operator)：</p><ol type="1"><li>由于操作符一般都是双目的，通常情况下该树是一棵二叉树；</li><li>对于单目操作符（如++），其只有一个子结点。</li></ol><p>例：<img src="/img/LE-ds5/34.png" /></p></li><li><p>主要应用：编译器用来处理程序中的表达式</p></li></ol><h3 id="表达式树的构造">10.2 表达式树的构造</h3><p>表达式树是这样一种树，非叶节点为操作符，叶节点为操作数，对其进行遍历可计算表达式的值。由<strong>后缀表达式生成表达式树</strong>的方法如下：</p><ol type="1"><li>从左至右从后缀表达式中读入一个符号：<ol type="1"><li>如果是操作数，则建立一个单节点树并将指向该节点的指针推入栈中；（栈中元素为树节点的指针）</li><li>如果是运算符，就从栈中弹出指向两棵树T1和T2的指针（T1先弹出）并形成一棵新树，树根为该运算符，它的左、右子树分别指向T2和T1，然后将新树的指针压入栈中。</li></ol></li><li>重复步骤1，直到后缀表达式处理完。</li></ol><h2 id="哈夫曼huffman树及其应用">11 哈夫曼(Huffman)树及其应用</h2><h3 id="哈夫曼树的基本概念">11.1 哈夫曼树的基本概念</h3><ol type="1"><li><p>一些定义</p><ul><li><p>结点之间的路径：这两个结点之间的分支</p></li><li><p>路径长度：路径上经过的分支数目</p></li><li><p>树的路径长度：根结点到所有结点的路径长度之和</p></li><li><p><strong>树的带权路径长度</strong>：若给具有m个叶结点的二叉树的每个叶结点赋予一个权值，则该二叉树的带权路径长度定义为<span class="math display">\[WPL =\sum_{i=1}^{M} w_il_i\]</span>其中，w<sub>i</sub>为第i个叶结点被赋予的权值，l<sub>i</sub>为第i个叶结点的路径长度。</p></li></ul></li><li><p>哈夫曼树的定义：给定一组权值，构造出的具有最小带权路径长度的二叉树称为哈夫曼树。</p></li><li><p>哈夫曼树的特点</p><ol type="1"><li><strong>权值越大</strong>的叶结点离根结点<strong>越近</strong>，权值越小的叶结点离根结点越远；</li><li>无度为1的结点</li><li>哈夫曼树不是唯一的</li></ol></li></ol><h3 id="哈夫曼树的构造">11.2 哈夫曼树的构造</h3><ol type="1"><li><p>对于给定的权值W={ w<sub>1</sub>, w<sub>2</sub>,...,w<sub>m</sub>}，构造出树林F={ T<sub>1</sub>, T<sub>2</sub>,...,T<sub>m</sub>}，其中，Ti(1≤i≤m)为左、右子树为空，且根结点(叶结点)的权值为w<sub>i</sub>的二叉树。</p></li><li><p>将F中根结点权值最小的两棵二叉树合并成为一棵新的二叉树，即把这两棵二叉树分别作为新的二叉树的左、右子树，并令新的二叉树的根结点权值为这两棵二叉树的根结点的权值之和，将新的二叉树加入F的同时从F中删除这两棵二叉树。</p></li><li><p>重复步骤2，直到F中只有一棵二叉树。</p></li></ol><h3 id="例-huffman编码">11.3 例 Huffman编码</h3><h4 id="背景huffman编码">11.3.1 背景：Huffman编码</h4><p><img src="/img/LE-ds5/35.png" /></p><h4 id="问题提出">11.3.2 问题提出</h4><ul><li>编写一个程序采用Huffman编码实现对一个文件的压缩。</li><li>要求：首先读取文件，对文件中出现的每个字符进行字符频率统计，然后根据频率采用Huffman方法对每个字符进行编码，最后根据新字符编码表输出文件。</li></ul><h4 id="问题分析">11.3.3 问题分析</h4><p><img src="/img/LE-ds5/36.png" /></p><h4 id="算法设计">11.3.4 算法设计</h4><ol type="1"><li><p>定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXSIZE 32</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cc</span> &#123;</span> <span class="hljs-comment">//字符及出现次数结构</span><br>    <span class="hljs-type">char</span> c;<br>    <span class="hljs-type">int</span> count;<br>&#125; ;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tnode</span> &#123;</span> <span class="hljs-comment">//Huffman树结构</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cc</span> <span class="hljs-title">ccount</span>;</span> <span class="hljs-comment">//字符及出现次数</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tnode</span> *<span class="hljs-title">left</span>, *<span class="hljs-title">right</span>;</span>  <span class="hljs-comment">//树的左右节点指针</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tnode</span> *<span class="hljs-title">next</span>;</span>  <span class="hljs-comment">//一个有序链表的节点指针</span><br>&#125; ; <br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tnode</span> *<span class="hljs-title">Head</span> =</span> <span class="hljs-literal">NULL</span>; <span class="hljs-comment">//一个有序链表的头节点，也是最后Huffman树的根节点</span><br><span class="hljs-type">char</span> Huffman[MAXSIZE]; <span class="hljs-comment">//用于生成Huffman编码</span><br><span class="hljs-type">char</span> HCode[<span class="hljs-number">128</span>][MAXSIZE]; <span class="hljs-comment">//字符的Huffman编码，Hcode[0]为文件结束符的编码</span><br><br>例如：Hcode[<span class="hljs-string">&#x27;a&#x27;</span>]表示字符a的Huffman编码串。 <br><br></code></pre></td></tr></table></figure></li><li><p>为了生成Huffman树，首先根据字符统计结果生成一个有序链表:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 字符频率统计：</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cc</span> <span class="hljs-title">ccount</span>[128];</span><br><span class="hljs-keyword">while</span>( (c=fgetc(fp)) != EOF)&#123;<br>ccount[c].c=c;<br>    ccount[c].count++;<br>&#125;<br><span class="hljs-comment">// 根据字符统计结果生成一个有序链表：</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tnode</span> *<span class="hljs-title">p</span>;</span><br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">128</span>; i++)&#123;<br>    <span class="hljs-keyword">if</span>(ccount[i].count != <span class="hljs-number">0</span>)&#123;<br>        p = (<span class="hljs-keyword">struct</span> tnode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> tnode));<br>        p-&gt;ccount = ccount[i];<br>        p-&gt;left = p-&gt;right = p-&gt;next = <span class="hljs-literal">NULL</span>;<br>        insertSortLink(p);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>按Huffman树生成算法，由有序表构造Huffman树：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">while</span>(Head-&gt;next != <span class="hljs-literal">NULL</span>)&#123;<br>    p = (<span class="hljs-keyword">struct</span> tnode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> tnode));  <br>    p -&gt;ccount.count = Head-&gt;ccount.count + Head-&gt;next-&gt;ccount.count;<br>    p-&gt;left = Head;<br>    p-&gt;right = Head-&gt;next;  <span class="hljs-comment">/*将新树的根结点加入到有序结点链表中*/</span><br>    p-&gt;next = <span class="hljs-literal">NULL</span>;<br>    Head = Head-&gt;next-&gt;next; <br>    insertSortLink(p);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>遍历（前序）Huffman树，为每个叶结点生成Huffman编码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">createHCode</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> tnode *p, <span class="hljs-type">char</span> code, <span class="hljs-type">int</span> level)</span>&#123;<br>    <span class="hljs-keyword">if</span>(level != <span class="hljs-number">0</span>)<br>        Huffman[level<span class="hljs-number">-1</span>] = code;  <br>    <span class="hljs-keyword">if</span>(p-&gt;left == <span class="hljs-literal">NULL</span> &amp;&amp; p-&gt;right == <span class="hljs-literal">NULL</span>)&#123;<br>        Huffman[level] =<span class="hljs-string">&#x27;\0&#x27;</span>;<br>        <span class="hljs-built_in">strcpy</span>(HCode[p-&gt;ccount.c], Huffman);<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        createHCode(p-&gt;left,<span class="hljs-string">&#x27;0&#x27;</span>, level+<span class="hljs-number">1</span>);<br>        createHCode(p-&gt;right,<span class="hljs-string">&#x27;1&#x27;</span>, level+<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>第四步：根据Huffman编码，遍历源文件，生成相应压缩文件：</p><p>下面通过实例来说明：</p><p>原始文件input.txt中内容以“Iwill…”开始，依据所生成的Huffman码表，字母I对应的Huffman编码串为“0101111”，空格对应“111”，w对应“1001110”，i对应“01010”，l对应“11001”。因此，将其转换后得到一个Huffman编码串“01011111111001110010101100111001…”，由于在C中，最小输出单位是字节（共8位），因此，要通过C语言的位操作符将每8个01字符串放进一个字节中，如第一个8字符串“01011111”中的每个0和1放入到一个字符中十六进制（即<code>printf(”%x”,c)</code>输出时，屏幕上将显示5f）（如下图所示）。</p><p><img src="/img/LE-ds5/37.png" /></p><p>下面程序段将Huffman编码串每8个字符串放入一个字节（字符变量<code>hc</code>）中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> hc;<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; s[i] != <span class="hljs-string">&#x27;\0&#x27;</span>; i++)&#123;<br>    hc = (hc &lt;&lt; <span class="hljs-number">1</span>) | (s[i]-<span class="hljs-string">&#x27;0&#x27;</span>);<br>    <span class="hljs-keyword">if</span>((i+<span class="hljs-number">1</span>)%<span class="hljs-number">8</span> == <span class="hljs-number">0</span>) &#123;<br>        fputc(hc, obj); <span class="hljs-comment">//输出到目标（压缩）文件中</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%x&quot;</span>, hc);<span class="hljs-comment">//按十六进制输出到屏幕上</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>完整代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">madeHZIP</span><span class="hljs-params">(FILE *src, FILE *obj)</span>&#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *pc,hc=<span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> c=<span class="hljs-number">0</span>,i=<span class="hljs-number">0</span>;<br>    fseek(src,<span class="hljs-number">0</span>, SEEK_SET); <span class="hljs-comment">//从src文件头开始</span><br>    <span class="hljs-keyword">do</span>&#123;<br>        c=fgetc(src); <span class="hljs-comment">//依次获取源文件中每个字符</span><br>        <span class="hljs-keyword">if</span> (c == EOF) <br>            c=<span class="hljs-number">0</span>; <span class="hljs-comment">//源文件结束</span><br>        <span class="hljs-keyword">for</span>(pc = HCode[c]; *pc != <span class="hljs-string">&#x27;\0&#x27;</span>; pc++)&#123; <span class="hljs-comment">//转换为huffman码</span><br>            hc = (hc &lt;&lt; <span class="hljs-number">1</span>) | (*pc-<span class="hljs-string">&#x27;0&#x27;</span>); i++; <br>            <span class="hljs-keyword">if</span>(i==<span class="hljs-number">8</span>)&#123; <span class="hljs-comment">//每满8位输出一个字节</span><br>                fputc(hc,obj);<br>                i = <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(c==<span class="hljs-number">0</span> &amp;&amp; i!=<span class="hljs-number">0</span>)&#123; <span class="hljs-comment">//处理文件结束时不满一个字节的情况</span><br>             <span class="hljs-keyword">while</span>(i++&lt;<span class="hljs-number">8</span>) hc = (hc &lt;&lt; <span class="hljs-number">1</span>);<br>             fputc(hc,obj); <br>        &#125;<br>     &#125;<span class="hljs-keyword">while</span>(c); <span class="hljs-comment">//c=0时文件结束</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="多叉树及其应用">12 *多叉树及其应用</h2><h3 id="多叉树的基本概念">12.1 多叉树的基本概念</h3><p>​ 每个树节点可以有两个以上的子节点，称为m阶多叉树，或称为m叉树。</p><h3 id="多叉树的主要应用">12.2 多叉树的主要应用</h3><p>多叉树通常用于大数据的<strong>快速检索</strong>和<strong>信息更新</strong>。本课程将在查找(searching)一讲中介绍下面多叉树的应用：</p><ul><li>B树</li><li>Trie树</li></ul><h3 id="多叉树的遍历算法">12.3 多叉树的遍历算法</h3><ol type="1"><li><p>类型定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXD 3   <span class="hljs-comment">//树的度</span></span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span>&#123;</span><br>    Datatype data;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> *<span class="hljs-title">next</span>[<span class="hljs-title">MAXD</span>];</span><br> &#125;;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> <span class="hljs-title">TNode</span>;</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> *<span class="hljs-title">TNodeptr</span>;</span><br></code></pre></td></tr></table></figure></li><li><p>深度优先遍历算法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">DFStree</span><span class="hljs-params">(TNodeptr t)</span>&#123;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-keyword">if</span>(t != <span class="hljs-literal">NULL</span>)&#123;<br>        VISIT(t);       <span class="hljs-comment">// 访问t指向结点</span><br>        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;MAXD; i++)<br>        <span class="hljs-keyword">if</span>(t-&gt;next[i] != <span class="hljs-literal">NULL</span>)<br>        DFStree(t-&gt;next[i]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>广度优先遍历算法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">BFStree</span><span class="hljs-params">(TNodeptr t)</span>&#123;<br>    TNodeptr p;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-keyword">if</span>(t!=<span class="hljs-literal">NULL</span>)&#123;<br>        enQueue(t);<br>        <span class="hljs-keyword">while</span>(!isEmpty())&#123;<span class="hljs-comment">// 若队列不空</span><br>            p= deQueue(); <br>            VISIT(p);    <br>            <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;MAXD; i++)<span class="hljs-comment">// 依次访问p指向的子结点</span><br>            <span class="hljs-keyword">if</span>( p-&gt;next[i] != <span class="hljs-literal">NULL</span>)   <br>            enQueue(p);<br>        &#125;<br>    &#125;    <br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="总结">13 总结</h2><h3 id="树的构造方法总结">13.1 树的构造方法总结</h3><ol type="1"><li><p>自顶向下构造法</p><ol type="1"><li><p>结点插入法（常用）：按照树结点组成规则，找到插入位置，依次插入结点。如：BST树构造、堆构造。</p><p>基本原理：查找（插入位置）-&gt; 插入</p></li><li><p>按层构造法：通常利用一个<strong>队</strong>来依次按层构造树（参考BFS算法）。如输入数据按层组织。</p></li></ol></li><li><p>自底向上构造法</p><ol type="1"><li>按照树结点的组成规则依次自底向上构造，这类方法通常要用到<strong>栈</strong>或<strong>队</strong>等数据结构，如：表达式树构造（用到栈）、Huffman树构造（用到有序表或优先队列）</li></ol></li></ol><h3 id="递归问题的非递归算法的设计">13.2 递归问题的非递归算法的设计</h3><ol type="1"><li>递归算法的优点<ol type="1"><li>问题的数学模型或算法设计方法本身就是递归的，采用递归算法来描述它们非常自然；</li><li>算法的描述直观，结构清晰、简洁；算法的正确性证明比非递归算法容易。</li></ol></li><li>递归算法的不足<ol type="1"><li>算法的<strong>执行时间与空间开销</strong>往往比非递归算法要大，当问题规模较大时尤为明显；</li><li>对算法进行优化比较困难；</li><li>分析和跟踪算法的执行过程比较麻烦；</li><li>描述算法的语言不具有递归功能时，算法无法描述。</li></ol></li></ol><h4 id="例中序遍历的非递归算法">13.2.1 例：中序遍历的非递归算法</h4><ol type="1"><li><p>用自然语言表达的算法</p><ol type="1"><li>若p指向的结点非空，则将p指的结点的地址进栈，然后，将p指向左子树的根；</li><li>若p指向的结点为空，则从堆栈中退出栈顶元素p，访问该结点，然后,将p指向右子树的根；</li><li>重复上述过程，直到p为空，并且堆栈也为空。</li></ol></li><li><p>代码实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// STACK[0..M-1] -- 保存遍历过程中结点的地址；</span><br><span class="hljs-comment">// top -- 栈顶指针,初始为-1；</span><br><span class="hljs-comment">// p -- 为遍历过程中使用的指针变量，初始时指向根结点。</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">inorder</span><span class="hljs-params">(BTNodeptr t)</span>&#123;<br>    BTNodeptr <span class="hljs-built_in">stack</span>[M], p=t;<br>    <span class="hljs-type">int</span> top=<span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">if</span>(t!=<span class="hljs-literal">NULL</span>)  <br>        <span class="hljs-keyword">do</span> &#123;<br>            <span class="hljs-keyword">for</span>(; p!=<span class="hljs-literal">NULL</span>; p=p-&gt;left)<br>            <span class="hljs-built_in">stack</span>[++top]=p;       <br>            p=<span class="hljs-built_in">stack</span>[top– –];<br>            VISIT(p);<br>            p=p-&gt;right;<br>        &#125;<span class="hljs-keyword">while</span>(!(p==<span class="hljs-literal">NULL</span> &amp;&amp; top==<span class="hljs-number">-1</span>));<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h4id="例已知具有n个结点的完全二叉树采用顺序存储结构结点的数据信息依次存放于一维数组bt0..n-1中写出中序遍历二叉树的非递归算法">13.2.2例：已知具有n个结点的完全二叉树采用顺序存储结构,结点的数据信息依次存放于一维数组BT[0..n-1]中，写出中序遍历二叉树的非递归算法。</h4><ol type="1"><li><p>用自然语言表达的算法：</p><ol type="1"><li>若i指向的结点非空，则将i进栈，然后，将i指向左子树的根(i =2*i+1)；</li><li>若i指向的结点为空，则从堆栈中退出栈顶元素i，访问该结点，然后将i指向右子树的根(i= 2*i+1)；</li><li>重复上述过程，直到i指向的结点不存在，并且栈空。</li></ol></li><li><p>代码实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MaxSize  100</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">inorder</span><span class="hljs-params">(Datatype bt[],<span class="hljs-type">int</span> n)</span>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-built_in">stack</span>[MaxSize],i,top=<span class="hljs-number">-1</span>;<br>    i=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span>(n&gt;=<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">do</span>&#123;<br>            <span class="hljs-keyword">while</span>(i&lt;n)&#123;<br>                <span class="hljs-built_in">stack</span>[++top]=i;      <span class="hljs-comment">// bt[i]的位置i进栈</span><br>                i=i*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>;             <span class="hljs-comment">// 找到i的左孩子的位置</span><br>            &#125;<br>            i=STACK[top--];              <span class="hljs-comment">// 退栈</span><br>            VISIT(bt[i]);              <span class="hljs-comment">// 访问结点bt[i]</span><br>            i=i*<span class="hljs-number">2</span>+<span class="hljs-number">2</span>;                   <span class="hljs-comment">// 找到i的右孩子的位置</span><br>        &#125;<span class="hljs-keyword">while</span>(!(i&gt;n<span class="hljs-number">-1</span> &amp;&amp; top==<span class="hljs-number">-1</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h4id="例若某完全二叉树采用顺序存储结构结点存放的次序为abcdefghij请给出该二叉树的后序序列">13.2.3例：若某完全二叉树采用顺序存储结构，结点存放的次序为A,B,C,D,E,F,G,H,I,J，请给出该二叉树的后序序列。</h4><p><img src="/img/LE-ds5/38.png" /></p><p>答案：HIDJEBFGCA</p>]]></content>
    
    
    <categories>
      
      <category>学习经验</category>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习经验</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【数据结构】简短的新bank题思路分享</title>
    <link href="/2024/04/09/LE-ds4-1/"/>
    <url>/2024/04/09/LE-ds4-1/</url>
    
    <content type="html"><![CDATA[<p>关于如何利用ppt上给出的主要算法设计在没读懂题的情况下高效地写出bank题，又名究竟什么时候要更新窗口什么时候要入队什么时候出队我完全搞不懂，所以还是当成ppt修改题来写吧。也就是说，本文主打一个浑水摸鱼不求甚解，如果你想要真正搞懂bank题，建议去看看学长学姐们写的<ahref="https://kdocs.cn/l/chaygMiWEss2">数据结构debug手册</a>的4.2和<ahref="https://cool-wind.top/2023/04/24/关于新BANK和函数调用关系/">ghgg的博客</a></p><h2 id="ppt上的旧bank和作业的新bank有何不同">1PPT上的旧bank和作业的新bank有何不同</h2><p>唯一的区别：新bank中每个客户的办业务时间不同。</p><ul><li><p>这代表着可能先来的人后办完业务，也就是说不能出队一个客户就输出一个客户，需要<strong>等到办完所有业务再统一输出</strong>。</p></li><li><p>同时这代表着新bank的输入发生了变化，需要修改主要算法。</p><p>如何修改？</p><p>首先，原算法是在每一周期内读入本周期入队人数，但由于新bank先输入每一周期入队人数，再输入每个客户的业务时长，故不如改为<strong>直接读入每一周期的客户人数即每一位客户的业务时长</strong>，再进行主要算法的处理。</p><blockquote><p>旧bank主要算法：</p><p>for(clock=1; ; clock++) //在每个时间周期内</p><p>{</p><ol type="1"><li><p>If 客户等待队列非空</p><p>​ 将每个客户的等待时间增加一个时间单元；</p></li><li><p>If(clock &lt;= simulationtime)</p><p>​ 2.1如果有新客户到来（从输入中读入本周期内新来客户数），将其入队；</p><p>​ <strong>2.2</strong><strong>根据等待服务客户数重新计算服务窗口数；</strong></p></li><li><p>If 客户等待队列非空</p><p>​ 3.1从客户队列中取（出队）相应数目（按实际服务窗口数）客户获得服务；</p><p>​ <strong>3.2</strong><strong>然后根据等待服务客户数重新计算服务窗口数；</strong></p></li></ol><p>​ Else 结束模拟</p><p>}</p></blockquote><blockquote><p>新bank主要算法：</p><p>一 读入</p><p>二 改改旧bank（正式处理）</p><p>for(clock=1; ; clock++) //在每个时间周期内</p><p>{</p><ol type="1"><li><p>If 客户等待队列非空</p><p>​ 将每个客户的等待时间增加一个时间单元；</p></li><li><p>If(clock &lt;= simulationtime)</p><p>​ 2.1 如果有新客户到来，更新已经到来的人数和等待人数；</p><p>​ <strong>2.2</strong><strong>根据等待服务客户数重新计算服务窗口数；</strong>（只有可能增加）</p></li><li><p>If 客户等待队列非空</p><p>​ 3.1 从客户队列中取相应数目（按实际服务窗口数）客户获得服务；</p><p>​ <strong>3.2</strong><strong>然后根据等待服务客户数重新计算服务窗口数；</strong>（只有可能减少）</p></li></ol><p>​ Else 结束模拟</p><p>}</p><p>三 输出</p></blockquote></li></ul><h2 id="一些注意事项">2 一些注意事项</h2><ol type="1"><li><p>可以考虑用一个指针数组来指向正在办业务的客户们</p></li><li><p>客户结构体包括: <code>id</code>(第几个客户)<code>difficulty</code>(业务难度) <code>wtime</code>(等待时间)</p></li><li><p>在3.1中将正在办业务的客户的<code>difficulty</code>--，当<code>difficulty == 0</code>时客户办完业务，让下一个人来办业务</p></li><li><p>3.2中更新窗口数时小心出现下面情况：</p><p>原来开了4个窗口，分别是<code>win[0] win[1] win[2] win[3]</code>，窗口减少后只需要3个窗口。但空出的窗口是<code>win[0]</code>，即<code>win[0] == NULL</code>。</p><p>此时运用指针数组的优势就出现了，你可以从<code>win[3]</code>一直往下（0）遍历，找到值为<code>NULL</code>的指针时将其与<code>win[3]</code>进行交换，这样现在在办业务的窗口就还是<code>win[0] win[1] win[2]</code>了。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>学习经验</category>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习经验</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【数据结构】ds笔记4-栈和队</title>
    <link href="/2024/04/03/LE-ds4/"/>
    <url>/2024/04/03/LE-ds4/</url>
    
    <content type="html"><![CDATA[<h2 id="说在前面">说在前面</h2><p>本篇笔记总结<strong>DSPv2b_4(栈与队) forstudent</strong>内的相关内容。各位如果在学习过程中对于一些概念不理解，可以考虑问问AI们，从他们那里获得一些形象的描述来辅助理解。以及，如果实在de不出来bug了，也可以问问AI，虽然不一定有用，但是万一有什么bug被你忽略缺被AI发现了呢。最后，本人学艺不精，只是一边看着ppt一边敲敲改改，如有疏漏，欢迎提出喵~o(=∩ω∩= )m</p><hr /><h1 id="栈">栈</h1><h2 id="栈的基本概念">1 栈的基本概念</h2><h3 id="栈的定义">1.1 栈的定义</h3><ul><li><p>栈（Stack）是一种只允许在<strong>表的一端</strong>进行插入操作和删除操作的线性表。允许操作的一端称为<strong>顶</strong>，栈顶元素的位置由一个称为栈顶位置的变量给出。当表中没有元素时，称之为<strong>空栈</strong>。</p><p><img src="/img/LE-ds4/001.png" /></p></li><li><p>栈的特点</p><ul><li>元素间呈线性关系</li><li>插入删除在一端进行</li><li>后进先出(LIFO(Last-In-First-Out))</li></ul></li></ul><h3 id="栈的基本操作">1.2 栈的基本操作</h3><ul><li><p>特殊性：</p><ul><li><p>其操作仅仅是一般线性表的操作的一个子集</p></li><li><p>插入和删除操作的位置受到限制</p></li></ul></li><li><p>基本操作：</p><ul><li>插入（进栈、入栈、压栈）</li><li>删除（出栈、退栈、弹出）</li><li>测试栈是否为空</li><li>测试栈是否已满</li><li>获取栈顶元素</li></ul></li></ul><h2 id="栈的顺序存储结构顺序栈">2 栈的顺序存储结构（顺序栈）</h2><h3 id="构造原理">2.1 构造原理</h3><ul><li><p>利用一维数组<code>STACK[0...M–1]</code>来表示,同时定义一个整型变量(top)给出栈顶元素的位置。</p></li><li><p>溢出</p><ul><li>上溢(top = M-1)：栈已满时做入栈操作</li><li>下溢(top = -1)：栈为空时作出栈操作</li></ul></li><li><p>类型定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXSIZE 1000</span><br>ElemType STACK[MAXSIZE];<br><span class="hljs-type">int</span> Top = <span class="hljs-number">-1</span>;<br><span class="hljs-comment">// 由于Top变量需要在多个函数间共享，为了保持函数接口简洁，在此定义为全局变量</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="基本算法">2.2 基本算法</h3><h4 id="初始化堆栈">2.2.1 初始化堆栈</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">initStack</span><span class="hljs-params">( )</span>&#123;<br>Top= –<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="进栈">2.2.2 进栈</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(ElemType s[ ], ElmeType item )</span>&#123;<br><span class="hljs-keyword">if</span>(isFull())<br>Error(<span class="hljs-string">&quot;Full Stack!&quot;</span>);<br><span class="hljs-keyword">else</span><br>s[++Top] = item;<span class="hljs-comment">// 入栈成功</span><br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">Error</span><span class="hljs-params">(<span class="hljs-type">char</span> s[])</span>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, s);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="出栈">2.2.3 出栈</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">ElemType <span class="hljs-title function_">pop</span><span class="hljs-params">(ElemType s[ ])</span>&#123;<br><span class="hljs-keyword">if</span>(isEmpty())<br>Error(<span class="hljs-string">&quot;Empty Stack!&quot;</span>);<br><span class="hljs-keyword">else</span><br><span class="hljs-keyword">return</span> s[Top--];<span class="hljs-comment">// 出栈成功</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="测试栈是否为空">2.2.4 测试栈是否为空</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">( )</span>&#123;<span class="hljs-comment">// 栈空，返回1；否则，返回0</span><br><span class="hljs-keyword">return</span> Top == <span class="hljs-number">-1</span>;<br>&#125; <br></code></pre></td></tr></table></figure><h4 id="测试栈是否已满">2.2.5 测试栈是否已满</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">isFull</span><span class="hljs-params">( )</span>&#123;<span class="hljs-comment">// 栈满,返回1；否则,返回0。</span><br><span class="hljs-keyword">return</span> Top == MAXSIZE<span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="多栈共享连续空间问题以两个栈共享一个数组为例">2.3多栈共享连续空间问题——以两个栈共享一个数组为例</h3><p>已知数组<code>STACK[0...M-1]</code>、第一个与第二个栈的栈顶元素的位置<code>Top1, Top2</code></p><p><img src="/img/LE-ds4/2.png" /></p><p><img src="/img/LE-ds4/3.png" /></p><h4 id="进栈-1">2.3.1 进栈</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 规则：当i=1时，将item插入第1个栈；当i=2时，将item插入第2个栈。</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(ElemType s[ ], <span class="hljs-type">int</span> i, ElemType item)</span>&#123;<br>    <span class="hljs-keyword">if</span>(top1==top2–<span class="hljs-number">1</span>)&#123;<span class="hljs-comment">// 栈满</span><br>    Error(<span class="hljs-string">&quot;Full Stack!&quot;</span>);<br>    &#125;<span class="hljs-keyword">else</span>&#123; <br>        <span class="hljs-keyword">if</span>(i==<span class="hljs-number">1</span>)                    <span class="hljs-comment">// 插入第1个栈</span><br>        STACK[++top1]=item;<br>        <span class="hljs-keyword">else</span><span class="hljs-comment">// 插入第2个栈</span><br>        STACK[--top2]=item;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="出栈-1">2.3.2 出栈</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 规则：当i=1时，删除第1个栈的栈顶元素；当i=2时，删除第二个栈的栈顶元素</span><br>EleType <span class="hljs-title function_">pop</span><span class="hljs-params">(ElemType s[ ], <span class="hljs-type">int</span> i)</span>&#123;<br>    <span class="hljs-keyword">if</span>(i==<span class="hljs-number">1</span>)&#123;<span class="hljs-comment">// 对第一个栈做操作</span><br>        <span class="hljs-keyword">if</span>(top1==–<span class="hljs-number">1</span>) <br>        Error(<span class="hljs-string">&quot;Empty Stack1!&quot;</span>);<br>    <span class="hljs-keyword">else</span>   <br>    <span class="hljs-keyword">return</span> s[top1--];<br>    &#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">// 对第二个栈做操作</span><br>    <span class="hljs-keyword">if</span>(top2==MAXSIZE)<br>    Error(<span class="hljs-string">&quot;Empty Stack2!&quot;</span>); <br>    <span class="hljs-keyword">else</span><br>    <span class="hljs-keyword">return</span> s[top2++];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="栈的链式存储结构链接栈链栈">3栈的链式存储结构（链接栈）（链栈）</h2><h3 id="构造原理-1">3.1 构造原理</h3><ul><li><p>用一个<strong>线性链</strong>表来实现一个栈结构,同时设置一个指针变量(top)指出当前栈顶元素所在链结点的位置。栈为空时，有top=NULL。</p></li><li><p>链栈是一种特殊的链表，其结点的插入（进栈）和删除（出栈）操作始终在链表的头。</p></li><li><p>类型定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span>&#123;</span> <br>    ElmeType data;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> *<span class="hljs-title">link</span>;</span><br>&#125;;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> *<span class="hljs-title">Nodeptr</span>;</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> <span class="hljs-title">Node</span>;</span><br>Nodeptr Top;<span class="hljs-comment">//即为链表的头结点指针  </span><br></code></pre></td></tr></table></figure></li></ul><h3 id="基本算法-1">3.2 基本算法</h3><h4 id="初始化堆栈-1">3.2.1 初始化堆栈</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">initStack</span><span class="hljs-params">( )</span>&#123;<br>Top=<span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="进栈-2">3.2.2 进栈</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 等效于在链表前面插入一个新结点</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(ElemType item)</span>&#123;<br>    Nodeptr p;<br>    <span class="hljs-keyword">if</span>( (p=(Nodeptr)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Node)))==<span class="hljs-literal">NULL</span> )&#123;<br>    Error(<span class="hljs-string">&quot;No memory!&quot;</span>);  <br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        p-&gt;data=item;<span class="hljs-comment">// 将item送新结点数据域</span><br>        p-&gt;link=Top;<span class="hljs-comment">// 将新结点插在链表最前面</span><br>        Top=p;<span class="hljs-comment">// 修改栈顶指针的指向</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="出栈-2">3.2.3 出栈</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c">ElemType <span class="hljs-title function_">pop</span><span class="hljs-params">( )</span>&#123;<br>Nodeptr p;<br>    ElemType item;<br>    <span class="hljs-keyword">if</span>(isEmpty( ))&#123; <br>    Error(<span class="hljs-string">&quot;Empty Stack!&quot;</span>);<span class="hljs-comment">// 栈中无元素</span><br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        p=Top;<span class="hljs-comment">// 暂时保存栈顶结点的地址</span><br>        item=Top-&gt;data;<span class="hljs-comment">// 保存被删栈顶的数据信息</span><br>        Top=Top-&gt;link;<span class="hljs-comment">// 删除栈顶结点</span><br>        <span class="hljs-built_in">free</span>(p);<span class="hljs-comment">// 释放被删除结点</span><br>        <span class="hljs-keyword">return</span> item;<span class="hljs-comment">// 返回出栈元素</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="测试栈是否为空-1">3.2.4 测试栈是否为空</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">( )</span>&#123;<br><span class="hljs-keyword">return</span> Top==<span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="例题计算器表达式计算">4 例题：计算器（表达式计算）</h2><h3 id="提出问题">4.1 提出问题</h3><ul><li><p>问题描述：从标准输入中读入一个整数算术运算表达式，如<code>24 / ( 1 + 2 + 36 / 6 / 2 - 2) * ( 12 / 2 / 2 )=</code>，计算表达式结果，并输出。</p><p>要求：</p><ul><li>表达式运算符只有<code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>，表达式末尾的<code>=</code>字符表示表达式输入结束，表达式中可能会出现空格；</li><li>表达式中会出现圆括号，括号可能嵌套，不会出现错误的表达式；</li><li>出现除号<code>/</code>时，以整数相除进行运算，结果仍为整数，例如：5/3结果应为1。</li></ul></li><li><p>输入形式：从键盘输入一个以<code>=</code>结尾的整数算术运算表达式。</p></li><li><p>输出形式：在屏幕上输出计算结果（为整数）。</p></li><li><p>样例输入：24 / ( 1 + 2 + 36 / 6 / 2 - 2) * ( 12 / 2 / 2)=</p></li><li><p>样例输出：18</p></li></ul><h3 id="问题分析">4.2 问题分析</h3><ul><li><p>中缀表达式(infix)</p><p>对于一般形式的表达式通常称为中缀表达式，如<code>a+b*c + (d*e+f)/g</code></p><p>计算机计算表达式的值时面临如下问题：运算符有优先级、括号会改变计算的次序</p></li><li><p>后缀表达式(Postfix)</p><p>最大好处是没有括号且不用考虑运算符的优先级</p></li><li><p>中缀到后缀的转换规则</p><p>从左至右遍历中缀表达式中每个数字和符号：</p><ul><li><p>若是数字直接输出，即成为后缀表达式的一部分；</p></li><li><p>若是符号：</p><ul><li><p>若是<code>)</code>，则将栈中元素弹出并输出，直到遇到<code>(</code>,<code>(</code>弹出但不输出；</p></li><li><p>若是<code>(</code>,<code>+</code>,<code>*</code>等符号，则从栈中弹出并输出优先级高于当前的符号，直到遇到一个优先级低的符号；然后将当前符号压入栈中。</p><p>（优先级<code>+</code>,<code>-</code>最低,<code>*</code>,<code>/</code>次之,<code>(</code>最高）</p></li><li><p>遍历结束，将栈中所有元素依次弹出，直到栈为空。</p></li></ul></li></ul></li><li><p>后缀表达式计算</p><p>从左至右遍历后缀表达式中每个数字和符号：</p><ul><li>若是数字直接进栈；</li><li>若是运算符（<code>+</code>,<code>-</code>,<code>*</code>,<code>/</code>），则从栈中弹出两个元素进行计算（注意：后弹出的是左运算数），并将计算结果进栈。</li><li>遍历结束，将计算结果从栈中弹出（栈中应只有一个元素，否则表达式有错）。</li></ul></li></ul><h3 id="算法设计">4.3 算法设计</h3><p>对于问题3.1我们没有必要象编译程序那样先将中缀表达式转换为后缀表达式，然后再进行计算。我们可以设两个栈，一个为数据栈，另一个为运算符栈，在转换中缀表达式的同时进行表达式的计算。主要思路为：<strong>当一个运算符出栈时，即与数据栈中的数据进行相应计算，计算结果仍存至数据栈中</strong>。算法如下：</p><p>从输入（中缀表达式）中获取一项：</p><ul><li>若是数字则压入数据栈中；</li><li>若是符号：<ul><li>若是<code>)</code>，则将符号栈中元素弹出并与数据栈中元素进行计算、计算结果放回数据栈中，直到遇到<code>(</code>，<code>(</code>弹出但不计算；</li><li>若是<code>(</code>，<code>+</code>，<code>*</code>等符号，则从符号栈中弹出优先级高于当前的符号并与数据栈中元素进行计算、计算结果放回数据栈中，直到遇到一个优先级低的符号；然后将当前符号压入栈中。</li><li>若是<code>=</code>号，将符号栈中所有元素依次弹出并与数据栈中元素进行计算、计算结果放回数据栈中，直到符号栈为空，此时数据栈中为计算结果；否则继续从输入中获取一项。</li></ul></li></ul><p><img src="/img/LE-ds4/4.png" /></p><h3 id="代码实现">4.4 代码实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;ctype.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXSIZE 100</span><br><span class="hljs-keyword">typedef</span>  <span class="hljs-type">int</span>  DataType;  <span class="hljs-comment">//可以方便扩展为浮点型</span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">symbol</span> &#123;</span>NUM, OP, EQ, OTHER&#125;;<span class="hljs-comment">//符号类型</span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">oper</span> &#123;</span>EPT, ADD, MIN, MUL, DIV, LEFT, RIGHT&#125;; <span class="hljs-comment">//运算符，把括号和等号视为运算符</span><br><span class="hljs-type">int</span> Pri[]=&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>&#125;; <span class="hljs-comment">//运算符优先级</span><br><span class="hljs-class"><span class="hljs-keyword">union</span> <span class="hljs-title">sym</span> &#123;</span><br>    DataType num;<br>    <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">oper</span> <span class="hljs-title">op</span>;</span><br>&#125; ; <span class="hljs-comment">//符号有两类：运算数和运算符</span><br>DataType Num_stack[MAXSIZE]; <span class="hljs-comment">//数据栈</span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">oper</span> <span class="hljs-title">Op_stack</span>[<span class="hljs-title">MAXSIZE</span>];</span> <span class="hljs-comment">//符号栈</span><br><span class="hljs-type">int</span> Ntop=<span class="hljs-number">-1</span>; <span class="hljs-comment">//数据栈顶指示器，初始为空栈</span><br><span class="hljs-type">int</span> Otop=<span class="hljs-number">-1</span>; <span class="hljs-comment">//运算符栈顶指示器，初始为空栈</span><br><span class="hljs-keyword">enum</span> symbol <span class="hljs-title function_">getSym</span><span class="hljs-params">( <span class="hljs-keyword">union</span> sym *item)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">operate</span><span class="hljs-params">(<span class="hljs-keyword">enum</span> oper op )</span>;<span class="hljs-comment">//操作运算符</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">compute</span><span class="hljs-params">(<span class="hljs-keyword">enum</span> oper op )</span>; <span class="hljs-comment">//进行运算</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">pushNum</span><span class="hljs-params">(DataType num)</span>;<br>DataType <span class="hljs-title function_">popNum</span><span class="hljs-params">()</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">pushOp</span><span class="hljs-params">(<span class="hljs-keyword">enum</span> oper op)</span>;<br><span class="hljs-keyword">enum</span> oper <span class="hljs-title function_">popOp</span><span class="hljs-params">()</span>;<br><span class="hljs-keyword">enum</span> oper <span class="hljs-title function_">topOp</span><span class="hljs-params">()</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">union</span> <span class="hljs-title">sym</span> <span class="hljs-title">item</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">symbol</span> <span class="hljs-title">s</span>;</span><br>    <span class="hljs-comment">//下面读入等号前的运算数和运算符</span><br>    <span class="hljs-keyword">while</span>( (s = getSym(&amp;item)) != EQ)&#123;<br>        <span class="hljs-keyword">if</span>(s == NUM)&#123;       <span class="hljs-comment">// 运算数进数据栈</span><br>            pushNum(item.num);<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s == OP)&#123;      <span class="hljs-comment">// 对运算符分情况分别处理</span><br>            operate(item.op);<br>        &#125;<span class="hljs-keyword">else</span>&#123;      <span class="hljs-comment">// 不是运算符、运算数和等号，输入有问题</span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Error in the expression!\n&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 下面是读入了等号</span><br>    <span class="hljs-keyword">while</span>(Otop &gt;= <span class="hljs-number">0</span>)    <span class="hljs-comment">//将栈中所有运算符弹出计算</span><br>        compute(popOp());<br>    <span class="hljs-keyword">if</span>(Ntop == <span class="hljs-number">0</span>)  <span class="hljs-comment">//正常情况下，运算符栈为空，数据栈有一个数据</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, popNum());   <span class="hljs-comment">// 数据栈只有一个最后结果</span><br>    <span class="hljs-keyword">else</span>    <span class="hljs-comment">// 不然就是输入出问题啦</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Error in the expression!\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-keyword">enum</span> symbol <span class="hljs-title function_">getSym</span><span class="hljs-params">( <span class="hljs-keyword">union</span> sym *item)</span>&#123;<br>    <span class="hljs-type">int</span> c, n;<br>    <span class="hljs-keyword">while</span>((c = getchar()) != <span class="hljs-string">&#x27;=&#x27;</span>) &#123;<br>        <span class="hljs-keyword">if</span>(c &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="hljs-string">&#x27;9&#x27;</span>)&#123;<br>            <span class="hljs-keyword">for</span>(n=<span class="hljs-number">0</span>; c &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="hljs-string">&#x27;9&#x27;</span>; c= getchar())<br>            n = n*<span class="hljs-number">10</span> + c-<span class="hljs-string">&#x27;0&#x27;</span>;<br>            ungetc(c, <span class="hljs-built_in">stdin</span>);   <span class="hljs-comment">//回退到缓冲区</span><br>            item-&gt;num = n;<br>            <span class="hljs-keyword">return</span> NUM;<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">switch</span> (c) &#123;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;+&#x27;</span>:item-&gt;op = ADD;<span class="hljs-keyword">return</span> OP;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;-&#x27;</span>:item-&gt;op = MIN;<span class="hljs-keyword">return</span> OP;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;*&#x27;</span>:item-&gt;op = MUL;<span class="hljs-keyword">return</span> OP;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;/&#x27;</span>:item-&gt;op = DIV;<span class="hljs-keyword">return</span> OP;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;(&#x27;</span>:item-&gt;op = LEFT;<span class="hljs-keyword">return</span> OP;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;)&#x27;</span>:item-&gt;op = RIGHT;<span class="hljs-keyword">return</span> OP;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27; &#x27;</span>:<span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;\t&#x27;</span>:<span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;\n&#x27;</span>:<span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">default</span>:<span class="hljs-keyword">return</span> OTHER;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> EQ;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">operate</span><span class="hljs-params">(<span class="hljs-keyword">enum</span> oper op)</span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">oper</span> <span class="hljs-title">t</span>;</span><br>    <span class="hljs-keyword">if</span>(op != RIGHT)&#123;  <span class="hljs-comment">// 不是右括号</span><br>        <span class="hljs-keyword">while</span>(Pri[op] &lt;= Pri[topOp()] &amp;&amp; topOp() != LEFT)<br>            compute(popOp()); <span class="hljs-comment">//栈顶不是左括号且优先级大于等</span><br>        pushOp(op);<br>    &#125;<br>    <span class="hljs-keyword">else</span>    <span class="hljs-comment">// 读入的是右括号</span><br>        <span class="hljs-keyword">while</span>((t = popOp()) != LEFT)    <span class="hljs-comment">// 出栈的是左括号无操作</span><br>            compute(t);   <span class="hljs-comment">//读入是右括号时栈中左括号前的都计算掉</span><br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">compute</span><span class="hljs-params">(<span class="hljs-keyword">enum</span> oper op )</span>&#123;<br>    DataType tmp;<br>    <span class="hljs-keyword">switch</span>(op) &#123;<br>        <span class="hljs-keyword">case</span> ADD:<br>            pushNum(popNum() + popNum()); <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> MIN:<br>            tmp = popNum();<span class="hljs-comment">//先出栈的是右运算数</span><br>            pushNum(popNum() - tmp); <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span>  MUL:<br>            pushNum(popNum() * popNum()); <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> DIV:<br>            tmp = popNum();     <span class="hljs-comment">// 后出栈的是左运算数</span><br>            pushNum(popNum() / tmp); <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//数据栈操作</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">pushNum</span><span class="hljs-params">(DataType num)</span>&#123;<br>    <span class="hljs-keyword">if</span>(Ntop == MAXSIZE <span class="hljs-number">-1</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Data stack is full!\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    Num_stack[++Ntop] = num;<br>&#125;<br><br>DataType <span class="hljs-title function_">popNum</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">if</span>(Ntop == <span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Error in the expression!\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> Num_stack[Ntop--] ;<br>&#125;<br><br><span class="hljs-comment">// 运算符栈操作</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">pushOp</span><span class="hljs-params">(<span class="hljs-keyword">enum</span> oper op)</span>&#123;<br>    <span class="hljs-keyword">if</span>(Ntop == MAXSIZE <span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;operator stack is full!\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    Op_stack[++Otop] = op;<br>&#125;<br><br><span class="hljs-keyword">enum</span> oper <span class="hljs-title function_">popOp</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">if</span>(Otop != <span class="hljs-number">-1</span>)&#123;<br>        <span class="hljs-keyword">return</span> Op_stack[Otop--] ;<br>    &#125;<br>    <span class="hljs-keyword">return</span> EPT;<br>&#125;<br><br><span class="hljs-keyword">enum</span> oper <span class="hljs-title function_">topOp</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">return</span> Op_stack[Otop];<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="队">队</h1><h2 id="队的基本概念">1 队的基本概念</h2><h3 id="队的定义">1.1 队的定义</h3><p><strong>队列</strong>简称<strong>队</strong>。是一种只允许在表的一端进行插入操作，而在表的另一端进行删除操作的线性表（<strong>先进先出FIFO(First-In-First-Out)</strong>）。允许插入的一端称为<strong>队尾</strong>，队尾元素的位置由<code>rear</code>指出；允许删除的一端称为<strong>队头</strong>,队头元素的位置由<code>front</code>指出。</p><p>### 1.2 队的基本操作</p><ol type="1"><li>特殊性<ol type="1"><li>其操作仅是一般线性表的操作的一个子集</li><li>插入和删除操作的位置受到限制</li></ol></li><li>队的基本操作<ol type="1"><li>插入（进队、入队）</li><li>删除（出队、退队）</li><li>测试队是否为空</li><li>测试队是否为满</li><li>检索当前队头元素</li><li>创建一个空队</li></ol></li></ol><h2 id="队的顺序存储结构">2 队的顺序存储结构</h2><h3 id="构造原理-2">2.1 构造原理</h3><p>借助一个一维数组<code>QUEUE[0...M–1]</code>来描述队的顺序存储结构，同时，设置两个变量<code>front</code>与<code>rear</code>分别指出当前队头元素与队尾元素的位置，再设置变量<code>count</code>指出实际队中元素个数。</p><p>初始时队为空，<code>front = 0, rear = -1, count = 0</code>；测试队为空的条件为<code>count == 0</code></p><h3 id="循环队列">2.2 循环队列</h3><ul><li><p>把队列(数组)设想成<strong>头尾相连</strong>的循环表，使得数组前部由于删除操作而导致的无用空间尽可能得到重复利用，这样的队列称为循环队列。</p></li><li><p>类型定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXSIZE 1000</span><br>ElemType QUEUE[MAXSIZE];<br><span class="hljs-type">int</span> Front, Rear, Count;<br></code></pre></td></tr></table></figure></li></ul><h3 id="循环队列基本算法">2.3（循环队列）基本算法</h3><h4 id="初始化队列">2.3.1 初始化队列</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">initQueue</span><span class="hljs-params">( )</span> &#123;<br>    Front = <span class="hljs-number">0</span>;<br>    Rear = MAXSIZE<span class="hljs-number">-1</span>;<br>    Count = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="测试队列是否为空或满">2.3.2 测试队列是否为空或满</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">( )</span>&#123;<span class="hljs-comment">// 队空，返回1；否则，返回0</span><br><span class="hljs-keyword">return</span> Count == <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">isFull</span><span class="hljs-params">( )</span>&#123;<br><span class="hljs-keyword">return</span> Count == MAXSIZE;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="进队">2.3.3 进队</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">enQueue</span><span class="hljs-params">(ElemType <span class="hljs-built_in">queue</span>[ ], ElemType item)</span>&#123;<br>    <span class="hljs-keyword">if</span>(isFull())&#123;<span class="hljs-comment">// 队满，插入失败</span><br>    Error(“Full <span class="hljs-built_in">queue</span>!”);<br>    &#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">// 队未满，插入成功</span><br>        Rear = (Rear+<span class="hljs-number">1</span>) % MAXSIZE; <br>        <span class="hljs-built_in">queue</span>[Rear]=item;<br>        Count++;<br>    &#125;<br> &#125;<br></code></pre></td></tr></table></figure><h4 id="出队">2.3.3 出队</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c">ElemType <span class="hljs-title function_">deQueue</span><span class="hljs-params">(ElemType <span class="hljs-built_in">queue</span>[ ])</span>&#123; <br>    ElemType e;<br>    <span class="hljs-keyword">if</span>(isEmpty())&#123;<br>    Error(“Empty <span class="hljs-built_in">queue</span>!”);<span class="hljs-comment">// 队空，删除失败</span><br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        e=<span class="hljs-built_in">queue</span>[Front];<br>        Count--;<span class="hljs-comment">// 队非空，删除成功</span><br>        Front = (Front+<span class="hljs-number">1</span>)%MAXSIZE;<br>        <span class="hljs-keyword">return</span> e;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="队的链式存储结构">3 队的链式存储结构</h2><h3 id="构造原理-3">3.1 构造原理</h3><ul><li><p>队列的链式存储结构是用一个线性链表表示一个队列，指针<code>front</code>与<code>rear</code>分别指向实际队头元素与实际队尾元素所在的链结点。</p></li><li><p>类型定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span>&#123;</span> <br>    ElmeType data;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> *<span class="hljs-title">link</span>;</span><br>&#125;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> <span class="hljs-title">QNode</span>;</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> *<span class="hljs-title">QNodeptr</span>;</span><br>QNodeptr Front, Rear;  <br></code></pre></td></tr></table></figure></li></ul><h3 id="基本算法-2">3.2 基本算法</h3><h4 id="初始化队列-1">3.2.1 初始化队列</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">initQueue</span><span class="hljs-params">()</span>&#123;<br>    Front=<span class="hljs-literal">NULL</span>;<br>    Rear=<span class="hljs-literal">NULL</span>；<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="测试队列是否为空">3.2.2 测试队列是否为空</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span>&#123;<span class="hljs-comment">// 队空，返回1；否则，返回0</span><br><span class="hljs-keyword">return</span> Front==<span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="进队-1">3.2.3 进队</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">enLQueue</span><span class="hljs-params">(ElemType data)</span>&#123;     <br>    QNodeptr p;<br>    <span class="hljs-keyword">if</span>((p=(QNodeptr)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(QNode))) ==<span class="hljs-literal">NULL</span>)  <span class="hljs-comment">/* 申请链结点 */</span><br>    Error(<span class="hljs-string">&quot;No memory!&quot;</span>);<br>    p-&gt;data = data;<br>    p-&gt;link = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">if</span>(Front == <span class="hljs-literal">NULL</span>) <span class="hljs-comment">// 插入空队的情况</span><br>    Front = p;<br>    <span class="hljs-keyword">else</span><br>        Rear-&gt;link = p;<span class="hljs-comment">// 插入非空队的情况 </span><br>    Rear=p;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="出队-1">3.2.4 出队</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c">ElemType <span class="hljs-title function_">deLQueue</span><span class="hljs-params">( )</span>&#123;<br>    QNodeptr p;<br>    ElemType data;<br>    <span class="hljs-keyword">if</span>(isEmpty())&#123;<span class="hljs-comment">// 队为空，删除失败</span><br>    Error(<span class="hljs-string">&quot;Empty queue!&quot;</span>);<br>    &#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">// 队非空，删除成功</span><br>        p = Front;<br>        Front = Front-&gt;link;<br>        data = p-&gt;data;<br>        <span class="hljs-built_in">free</span>(p);     <br>        <span class="hljs-keyword">return</span> data;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="销毁一个队">3.2.5 销毁一个队</h4><p>所谓销毁一个队是指将队列所对应的链表中所有结点都删除，并且释放其存储空间，使队成为一个空队(空链表)。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">destroyLQueue</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">while</span>(Front != <span class="hljs-literal">NULL</span>)&#123;                    <span class="hljs-comment">/* 队非空时  */</span><br>        Rear=Front-&gt;link;    <br>        <span class="hljs-built_in">free</span>(Front);                 <span class="hljs-comment">/* 释放一个结点空间  */</span><br>        Front=Rear;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="例题银行排队模拟">4 例题：银行排队模拟</h2><h3 id="提出问题-1">4.1 提出问题</h3><ul><li><p>某银行网点有五个服务窗口，分别为三个对私、一个对公和一个外币窗口。通常对私业务人很多，其它窗口人则较少，可临时改为对私服务。假设当对私窗口客户平均排队人数超过7人时，客户将有抱怨，此时银行可临时将其它窗口中一个或两个改为对私服务，当客户少于7人时，将恢复原有业务。设计一个程序用来模拟银行服务。</p></li><li><p>输入：首先输入一个整数表示时间周期数，然后再依次输入每个时间周期中因私业务的到达客户数。注：一个时间周期指的是银行处理一笔业务的平均处理时间，可以是一分钟、三分钟或其它。例如：</p><p>6</p><p>2 5 13 11 15 9</p><p>说明：表明在6个时间周期内，第1个周期来了2个（ID分别为1,2），第2个来了5人（ID分别为3,4,5,6,7），以此类推。</p></li><li><p>输出：每个客户等待服务的时间周期数。</p></li></ul><h3 id="问题分析-1">4.2 问题分析</h3><p>在生产者-消费者应用中消费者显然是先来先得到服务。在此，显然可用一个队列来存放等待服务的客户队列。每个客户有二个基本属性：排队序号和等待时间（时间周期数）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cust</span> &#123;</span><br>    <span class="hljs-type">int</span> id;<span class="hljs-comment">//客户排队序号</span><br>    <span class="hljs-type">int</span> wtime;<span class="hljs-comment">//客户等待服务的时间（时间周期数）</span><br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cust</span> <span class="hljs-title">Cqueue</span>[<span class="hljs-title">MAXSIZE</span>];</span> <span class="hljs-comment">//等待服务的客户队列，一个循环队列</span><br></code></pre></td></tr></table></figure><p>为了简化问题，可用一个变量来表示银行当前提供服务的窗口数：<code>int snum;</code>在本问题中，该变量的取值范围为<code>3&lt;=snum&lt;= 5</code></p><h3 id="算法设计-1">4.3 算法设计</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c">主要算法：<br><span class="hljs-keyword">for</span>(clock=<span class="hljs-number">1</span>; ; clock++)&#123;<span class="hljs-comment">//在每个时间周期内</span><br>&#123;<br><span class="hljs-keyword">if</span>(客户等待队列非空)<br>将每个客户的等待时间增加一个时间单元；<br><span class="hljs-keyword">if</span>(clock &lt;= simulationtime)<br>如果有新客户到来（从输入中读入本周期内新来客户数），将其入队；<br>根据等待服务客户数重新计算服务窗口数；<br><span class="hljs-keyword">if</span>(客户等待队列非空)<br>从客户队列中取（出队）相应数目（按实际服务窗口数）客户获得服务；<br>然后根据等待服务客户数重新计算服务窗口数；<br><span class="hljs-keyword">else</span> 结束模拟<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="代码实现-1">4.4 代码实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span>  <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>  MAXSIZE 200  <span class="hljs-comment">//队列容量</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> THRESHOLD  7  <span class="hljs-comment">//窗口增加阈值</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXSVR  5   <span class="hljs-comment">//最大服务窗口数</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MINSVR  3    <span class="hljs-comment">//最小服务窗口数</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-type">int</span> id;<br>    <span class="hljs-type">int</span> wtime;<br>&#125; CustType;<br><span class="hljs-type">int</span> Winnum=MINSVR; <span class="hljs-comment">//提供服务的窗口数</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">updateCustqueue</span><span class="hljs-params">()</span>; <span class="hljs-comment">//更新等待队列中客户等待时间</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">enCustqueue</span><span class="hljs-params">(CustType c)</span>; <span class="hljs-comment">//客户入等待队列</span><br>CustType <span class="hljs-title function_">deCustqueue</span><span class="hljs-params">()</span>; <span class="hljs-comment">//客户出队</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">getCustnum</span><span class="hljs-params">()</span>;   <span class="hljs-comment">//获取队中等待客户人数</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">isFull</span><span class="hljs-params">()</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">arriveCust</span><span class="hljs-params">()</span>; <span class="hljs-comment">//获取新客户，并加至等待队列中</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">service</span><span class="hljs-params">()</span>; <span class="hljs-comment">//银行从队列中获取客户进行服务</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>  MAXSIZE 200  <span class="hljs-comment">//队列容量</span></span><br><span class="hljs-type">static</span> CustType Cqueue[MAXSIZE];<span class="hljs-comment">//客户等待队列</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> Cfront=<span class="hljs-number">0</span>; <span class="hljs-comment">//队头队尾指示器</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> Crear = <span class="hljs-number">-1</span>;   <span class="hljs-comment">//队尾</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> Cnum=<span class="hljs-number">0</span>;      <span class="hljs-comment">// 队中元素个数</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">int</span> clock, simulationtime;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;simulationtime);<br>    <span class="hljs-keyword">for</span>(clock = <span class="hljs-number">1</span>; ; clock++)&#123;<br>        updateCustqueue();<br>        <span class="hljs-keyword">if</span>(clock &lt;= simulationtime)<br>            arriveCust();<br>        <span class="hljs-keyword">if</span>(service()==<span class="hljs-number">0</span> &amp;&amp; clock&gt;simulationtime)<br>            <span class="hljs-keyword">break</span>;      <span class="hljs-comment">// 等待队列为空且不会有新客户</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">arriveCust</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">int</span> i,n;<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> count=<span class="hljs-number">1</span>;<br>    CustType c;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;n; i++)&#123;<br>        c.id = count++; c.wtime = <span class="hljs-number">0</span>;<br>        enCustqueue(c);<br>    &#125;<br>    <span class="hljs-keyword">while</span>((getCustnum() / Winnum) &gt;= THRESHOLD &amp;&amp; Winnum&lt;MAXSVR)  <span class="hljs-comment">//增加服务窗口</span><br>        Winnum++;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">service</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">int</span> i;<br>    CustType c;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;Winnum; i++)<br>        <span class="hljs-keyword">if</span>(isEmpty())&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            c = deCustqueue();<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d :%d\n&quot;</span>, c.id, c.wtime);<br>        &#125;<br>    <span class="hljs-keyword">if</span>((getCustnum() / Winnum) &lt; THRESHOLD &amp;&amp; Winnum&gt;MINSVR)<br>        Winnum--;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">enCustqueue</span><span class="hljs-params">(CustType c)</span>&#123;<br>    <span class="hljs-keyword">if</span>(isFull())&#123;   <span class="hljs-comment">// 队满，插入失败</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Full queue!&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>    &#125;<span class="hljs-keyword">else</span>&#123;      <span class="hljs-comment">// 队未满，插入成功</span><br>        Crear = (Crear+<span class="hljs-number">1</span>) % MAXSIZE;<br>        Cqueue[Crear] = c;<br>        Cnum++;<br>    &#125;<br>&#125;<br><br>CustType <span class="hljs-title function_">deCustqueue</span><span class="hljs-params">()</span>&#123;<br>    CustType c;<br>    <span class="hljs-keyword">if</span>(isEmpty())&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Empty queue!&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        c=Cqueue[Cfront];       <span class="hljs-comment">// 队非空，删除成功</span><br>        Cnum--;<br>        Cfront = (Cfront+<span class="hljs-number">1</span>)%MAXSIZE;<br>        <span class="hljs-keyword">return</span> c;<br>    &#125;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">updateCustqueue</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;Cnum; i++)<br>        Cqueue[(Cfront+i)%MAXSIZE].wtime++;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">return</span> Cnum == <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">isFull</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">return</span> Cnum == MAXSIZE;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">getCustnum</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">return</span> Cnum;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="其他">其他</h1><h2 id="枚举类型enum">1 枚举类型(enum)</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 1 定义形式：</span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> 枚举名 &#123;</span>值表&#125;<br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">color</span> &#123;</span>red, green, yellow, white, black&#125;<span class="hljs-comment">// 枚举值是标识符</span><br><span class="hljs-comment">// 2 枚举变量说明</span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">color</span> <span class="hljs-title">chair</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">color</span> <span class="hljs-title">suite</span>[10];</span><br><span class="hljs-comment">// 3 在表达式中使用枚举变量</span><br>chair = red;<br>suite[<span class="hljs-number">5</span>] = yellow;<br><span class="hljs-keyword">if</span>(chair == green)...<br><span class="hljs-comment">// 4 注意：对枚举变量的赋值并不是将标识符字符串传给它，而是把该标识符所对应的各值表中常数值赋与变量。C语言编译程序把值表中的标识符视为从0开始的连续整数。另外，枚举类型变量的作用范围与一般变量的定义相同。</span><br><span class="hljs-comment">// 如：</span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">color</span> &#123;</span> red, green, yellow = <span class="hljs-number">5</span>, white, black &#125;;<br><span class="hljs-comment">// 则：</span><br>red=<span class="hljs-number">0</span>, green=<span class="hljs-number">1</span>, yellow=<span class="hljs-number">5</span>, white=<span class="hljs-number">6</span>, black=<span class="hljs-number">7</span><br><span class="hljs-comment">// 5 枚举类型用途</span><br>    <span class="hljs-comment">// 用来说明变量取值为有限的一组值之一，如：</span><br>    <span class="hljs-keyword">enum</span> Boolean &#123; FALSE, TRUE &#125;;<br><span class="hljs-comment">// 用来定义整型常量，如：</span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span> SIZE=<span class="hljs-number">1024</span> &#125;;<br><span class="hljs-comment">// 符号类型变量可用于数组下标</span><br></code></pre></td></tr></table></figure><h2 id="静态变量static">2 静态变量(static)</h2><ul><li><p>内部静态变量</p><ul><li><p>在局部变量前加上<code>static</code>关键字就成为内部静态变量。</p></li><li><p>内部静态变量仍是局部变量，其作用域仍在定义它的函数内。但该变量采用静态存贮分配（在编译时分配空间），当函数执行完，返回调用点时，该变量的值将继续保留，下次再进入该函数时，其值仍存在。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 例：下列程序打印结果为：1 2 4 7 11</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">f</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123; <br>    <span class="hljs-type">int</span> i; <br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,f(i)); <br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">f</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span>&#123; <br><span class="hljs-type">static</span> <span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; <br>k += i; <br><span class="hljs-keyword">return</span> (k); <br>&#125; <br></code></pre></td></tr></table></figure></li></ul></li><li><p>外部静态变量</p><ul><li>在函数外部定义的变量前加上<code>static</code>关键字便成了外部静态变量。</li><li>作用域为定义它的文件，即成为该文件的的“私有”（private）变量，其它文件上的函数一律不得直接进行访问，除非通过它所在文件上的各种函数来对它进行操作，这可实现数据隐藏。(在C++中提供进一步的数据隐藏。)</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>学习经验</category>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习经验</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【数据结构】ds笔记3-广义表、矩阵与串</title>
    <link href="/2024/04/02/LE-ds3/"/>
    <url>/2024/04/02/LE-ds3/</url>
    
    <content type="html"><![CDATA[<h2 id="说在前面">说在前面</h2><p>本篇笔记总结了<strong>DSPv2b_3(广义表、矩阵与串) forstudent</strong>内的相关内容，按照ppt上内容，笔记顺序为矩阵、广义表、串。不过据说本节内容“不考”，“不讲不学不考但是说不定什么时候就用到了”。最后，本人学艺不精，只是一边看着ppt一边敲敲改改，如有疏漏，欢迎提出喵~o(=∩ω∩= )m</p><h1 id="矩阵">1 矩阵</h1><h2 id="特殊矩阵的压缩存储">1.1 特殊矩阵的压缩存储</h2><p>压缩存储：为多个值相同的元素,或者位置分布有规律的元素分配尽可能少的存储空间，而对0元素一般情况下不分配存储空间。</p><p>目的：节省存储空间</p><h3 id="对称矩阵的压缩存储">1.1.1 对称矩阵的压缩存储</h3><ol type="1"><li><p>对称矩阵：满足a<sub>ij</sub>=a<sub>ji</sub>(1&lt;=i,j&lt;=n)的n阶矩阵</p><p><img src="/img/LE-ds3/1.png" /></p></li></ol><h3 id="对角矩阵的压缩存储">1.1.2 对角矩阵的压缩存储</h3><ol type="1"><li><p>对角矩阵：一个矩阵中，值非0的元素对称地集中在主对角线两旁的一个带状区域中(该区域之外的元素都为0元素)</p></li><li><p>例：三对角矩阵</p><p><img src="/img/LE-ds3/2.png" /></p></li></ol><h2 id="稀疏矩阵的三元组表表示">1.2 稀疏矩阵的三元组表表示</h2><ol type="1"><li><p>稀疏矩阵：一个较大的矩阵中，零元素的个数相对于整个矩阵元素的总个数所占比例较大时，可以称该矩阵为一个稀疏矩阵。</p></li><li><p>三元组表示：<code>(i, j, value)</code></p><p><img src="/img/LE-ds3/3.png" /></p></li><li><p>一个特殊的三元组：<code>(m, n, t)</code></p><ul><li><p>其中m表示矩阵总行数，n表示矩阵总列数，t表示非零元素总个数。</p></li><li><p>若一个mxn阶稀疏矩阵具有t个非零元素，则用t+1个三元组来存储,其中第一</p><p>三元组分别用来给出稀疏矩阵的总行数m、总列数n以及非零元素的总个数t；第二个三元组到第t+1个三元组按行序为主序的方式依次存储t个非零元素。</p></li><li><p>例：<img src="/img/LE-ds3/4.png" /></p></li></ul></li><li><p>对于一个具有t个非零元素的mxn阶矩阵,若采用三元组表方法存储,则当t&lt;(mxn)/3-1,这样做才有意义。</p></li></ol><h2 id="稀疏矩阵的十字链表表示">1.3 稀疏矩阵的十字链表表示</h2><ul><li><p>十字链表：为稀疏矩阵的每一行设置一个单独的循环链表，同样为每一列设置一个单独的循环链表。矩阵中每一个非零元素同时包含在两个循环链表中，即包含在它所在的行链表所在的列链表中,即两个链表的交汇处。</p></li><li><p>普通链结点构造：<img src="/img/LE-ds3/5.png" /></p><p>其中，row, col,value分别表示某个非零元素所在的行号、列号和元素的值；down和right分别为向下与向右指针，分别用来链接同一列中的与同一行中的所有非零元素对应的链结点。</p></li><li><p>行链表表头结点和列链表表头结点构造：<imgsrc="/img/LE-ds3/6.png" /></p><p>对m个行链表，分别设置个行链表表头结点。表头结点的构造与链表中其他链结点一样，只是令row与col的值分别为0，right域指向相应行链表的第一个结链点。</p><p>同理,对n个列链表，分别设置n个列链表表头结点指向相应列链表的第一个结链点。</p></li><li><p>总头结点构造：<img src="/img/LE-ds3/7.png" /></p><p>通过value也即link域把所有头结点也连接成一个循环链表</p></li><li><p>例：<img src="/img/LE-ds3/8.png" /></p><p><img src="/img/LE-ds3/9.png" /></p></li></ul><h2 id="例">1.4 例</h2><h3 id="一元n阶多项式的数组表示">1.4.1 一元n阶多项式的数组表示</h3><ul><li><p>一个标准的一元n阶多项式的各项若按降幂排列，可以表示为如下形式:</p><p>A<sub>n</sub>(x) = a<sub>n</sub>x<sup>n</sup> +a<sub>n-1</sub>x<sup>n-1</sup> + ... + a<sub>1</sub>x +a<sub>0</sub></p></li><li><p>方法一：一维数组</p><p>定义一个一维数组A[0...n+1]来存储多项式，其中，A[0]用来存放多项式的阶数n;A[1]~A[n+1]依次用来存放多项式的n+1项的系数。</p><p><img src="/img/LE-ds3/10.png" /></p></li><li><p>方法2：压缩存储</p><p>定义一个一维数组A[0...2m]来存储多项式，其中，A[0]存放系数非零项的总项数m；A[1]~A[2m]依次存放系数非零项各项的系数与指数偶对(一共m个这样的偶对)。</p><p><img src="/img/LE-ds3/11.png" /></p></li></ul><h3 id="n阶魔方n为任意奇数">1.4.2 n阶“魔方”（n为任意奇数）</h3><ol type="1"><li><p>题目：以3阶模仿为例，将1~9不重复地填在3行3列的9个方格中，分别使得每一行、每一列、两个对角线上的元素之和都等于15。</p></li><li><p>算法：</p><ol type="1"><li>将用做“魔方”的二维数组的所有元素清0；</li><li>第一个数填在第一行居中的位置上(i=0，j=n/2)；</li><li>3.以后每填一个数后，将位置移到当前位置(i,j)的左上角，即做动作i=i-1，j=j-1；</li><li>根据不同情况对位置进行修正：<ol type="1"><li>若位置(i,j)上已经填数，或者i,j同时小于0，将位置修改为i=i+2，j=j+1；</li><li>若i小于0，但j不小于0，修改i为n-1；</li><li>若j小于0，但i不小于0，修改j为n-1。</li></ol></li></ol></li><li><p>代码实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">magic</span><span class="hljs-params">(<span class="hljs-type">int</span> a[], <span class="hljs-type">int</span> n)</span>&#123;<br>    <span class="hljs-type">int</span>  i, j, num;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;n; i++)<br>    <span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>; j&lt;n; j++) <br>    a[i][j]=<span class="hljs-number">0</span>;               <span class="hljs-comment">/* 魔方清0 */</span><br>    i=<span class="hljs-number">0</span>;<br>    j=n/<span class="hljs-number">2</span>;                               <span class="hljs-comment">/* 确定i与j的初始位置 */</span><br>    <span class="hljs-keyword">for</span>(num=<span class="hljs-number">1</span>; num&lt;=n*n; num++)&#123;<br>        <span class="hljs-keyword">if</span>(i&lt;<span class="hljs-number">0</span> &amp;&amp; j&lt;<span class="hljs-number">0</span> || a[i][j]!=<span class="hljs-number">0</span>)&#123;<br>            i+=<span class="hljs-number">2</span>;<br>            j++;<br>        &#125;<br>        a[i--][j--]=num;      <span class="hljs-comment">/* 填数，并且左上移一个位置 */</span><br>        <span class="hljs-keyword">if</span>(i&lt;<span class="hljs-number">0</span> &amp;&amp; j&gt;=<span class="hljs-number">0</span>)  <br>            i=n<span class="hljs-number">-1</span>;                   <span class="hljs-comment">/* 修正i的位置 */</span><br>        <span class="hljs-keyword">if</span>(j&lt;<span class="hljs-number">0</span> &amp;&amp; i&gt;=<span class="hljs-number">0</span>)  <br>            j=n<span class="hljs-number">-1</span>;                   <span class="hljs-comment">/* 修正j的位置 */</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h1 id="广义表">2 广义表</h1><h2 id="广义表的基本概念">2.1 广义表的基本概念</h2><ol type="1"><li><p>广义表的定义：一个长度为n≥0的广义表是一个数据结构。如<code>LS = ( a1, a2, ……, an-1, an )</code>。其中，LS为广义表的名字,ai为表中元素；ai可以是原子元素，也可以是一个子表。n为表的长度，长度为0的表称为空表。若ai为不可再分割的具体信息，则称ai为<strong>原子元素</strong>；若ai 为一个子表，则称ai为<strong>表元素</strong>。这里，<strong>用小写字母表示原子元素，用大写字母表示表元素</strong>。</p></li><li><p>广义表的例子</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">A = ();<span class="hljs-comment">// 长度为0的空表</span><br>B = (a);<span class="hljs-comment">// 长度为1，且只有一个原子元素的广义表</span><br>C = (a, (b, c));<span class="hljs-comment">// 长度为2的广义表</span><br>D = (A, B, c);<span class="hljs-comment">// 长度为3的广义表</span><br>E = (A, B, C);<span class="hljs-comment">// 长度为3的广义表</span><br>F = (a, F);<span class="hljs-comment">// 长度为2的递归的广义表</span><br></code></pre></td></tr></table></figure></li><li><p>广义表的特点</p><ol type="1"><li>广义表是多层结构的</li><li>广义表可为其他广义表所共享</li><li>广义表可以是嵌套的</li><li>广义表的深度——括号嵌套的重数</li></ol></li></ol><h2 id="广义表的存储结构">2.2 广义表的存储结构</h2><ol type="1"><li><p>链结点的构造</p><p><img src="/img/LE-ds3/12.png" /></p><p>其中，flag为标志位,flag=0时表示本结点为原子结点，info域存放相应原子元素的信息；flag=1时表示本结点为表结点，info域存放子表第一个元素对应的链结点的地址。link域存放元素同一层的下一个元素所在链结点的地址，当本元素为所在层的最后一个元素时,link域为NULL。</p></li><li><p>类型定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span>&#123;</span><br>    <span class="hljs-type">int</span> flag;<br>    <span class="hljs-class"><span class="hljs-keyword">union</span>&#123;</span><br>        DataType data;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> *<span class="hljs-title">pointer</span>;</span><br>    &#125;info;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> *<span class="hljs-title">link</span>;</span><br>&#125;BSNode, *BSLinkList;<br></code></pre></td></tr></table></figure></li><li><p>例</p><p><img src="/img/LE-ds3/13.png" /></p></li></ol><h2 id="例多元多项式的广义表表示">2.3 例：多元多项式的广义表表示</h2><p><img src="/img/LE-ds3/14.png" /></p><p><img src="/img/LE-ds3/15.png" /></p><h1 id="串">3 串</h1><h2 id="串的基本概念">3.1 串的基本概念</h2><ol type="1"><li>串是由n&gt;=0个字符组成的有限序列，记为<code>S='a1 a2 a3 … an-1 an'</code>其中,S表示串名（也称串变量）,一对引号括起来的字符序列称为串值,ai可以是字母、数字或其他允许的字符。n为串的长度，长度为0的串称为空串。</li><li>串值须用一对引号括起来，但引号不属于串值。</li></ol><h2 id="串的基本操作">3.2 串的基本操作</h2><p><img src="/img/LE-ds3/16.png" /></p><h2 id="串的存储结构">3.3 串的存储结构</h2><ol type="1"><li><p>顺式存储结构</p></li><li><p>链式存储结构</p><p>所谓<strong>链结点大小</strong>是指每个链结点的数据域中存放字符的个数。</p><p><img src="/img/LE-ds3/17.png" /></p></li></ol><h2 id="关于串的几个算法">3.4 关于串的几个算法</h2><h3 id="判断两个字符串是否相等">3.4.1 判断两个字符串是否相等</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">equal</span><span class="hljs-params">(<span class="hljs-type">char</span> s1[ ],<span class="hljs-type">char</span> s2[ ])</span> &#123;    <br>    <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; s1[i]!=<span class="hljs-string">&#x27;\0&#x27;</span> &amp;&amp;  s2[i]!=<span class="hljs-string">&#x27;\0&#x27;</span>; i++)<br>    <span class="hljs-keyword">if</span>(s1[i]!=s2[i])  <br>    <span class="hljs-keyword">return</span>  <span class="hljs-number">0</span>;        <span class="hljs-comment">/* 两个串不相等 */</span><br>    <span class="hljs-keyword">if</span>(s1[i]==<span class="hljs-string">&#x27;\0&#x27;</span> &amp;&amp; s2[i]==<span class="hljs-string">&#x27;\0&#x27;</span>)  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;               <span class="hljs-comment">/* 两个串相等 */</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="串的插入">3.4.2 串的插入</h3><ul><li><p>功能：在字符串s的第n个字符后面插入字符串t</p></li><li><p>前提：字符串s与t分别采用数组形式存储</p></li><li><p>约定：当n=0时，将t插在s的最前面；结果串由s指出</p></li><li><p>名词解释：</p><ul><li>子串：串中若干个连续的字符组成的子序列。</li><li>主串：包含子串的串</li><li>位置：<ul><li>单个字符在主串中的位置被定义为该字符在串中的序号。</li><li>子串在主串中的位置被定义为主串中<strong>首次出现</strong>的该子串的<strong>第一个字符</strong>在主串中的位置</li></ul></li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 代码实现1</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(<span class="hljs-type">char</span> s[ ], <span class="hljs-type">char</span> t[ ], <span class="hljs-type">int</span> n)</span>&#123;<br>    <span class="hljs-built_in">strcat</span>(t, s+n);<br>    s[n] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>    <span class="hljs-built_in">strcat</span>(s, t);<br>    <span class="hljs-keyword">return</span> n;<br>&#125;<br><br><span class="hljs-comment">// 代码实现2</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(<span class="hljs-type">char</span> s[ ],<span class="hljs-type">char</span> t[ ], <span class="hljs-type">int</span> n)</span> &#123;    <br>    <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;<br>    <span class="hljs-type">char</span> *p;<br>    p = (<span class="hljs-type">char</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">strlen</span>(s)+<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; s[i+n] != <span class="hljs-string">&#x27;\0&#x27;</span>; i++)<br>    p[i] = s[i+n];<br>    <span class="hljs-keyword">for</span>(i=n,j=<span class="hljs-number">0</span>; t[j] != <span class="hljs-string">&#x27;\0&#x27;</span>; i++,j++)<br>    s[i] = t[j];<br>    <span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>; p[j] != <span class="hljs-string">&#x27;\0&#x27;</span>; i++,j++)<br>    s[i] = p[j];<br>    <span class="hljs-built_in">free</span>(p);<br>    <span class="hljs-keyword">return</span> n;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="串的模式匹配pattern-matching">3.4.3 串的模式匹配(PatternMatching)</h3><ul><li>功能：字符串的定位。给定一个<strong>主字符串S</strong>和一个<strong>子串T(又称模式串)</strong>，长度分别为n和m。在主串S中，从起始位置开始查找，若在主串S中找到一个与子串T相等的子串，则返回T的第一个字符在主串中的位置序号。</li><li>串的简单模式匹配算法Brute-Force（布鲁特-福斯，又称朴素的模式匹配算法）算法：<ul><li>将主串S的第一个字符和模式串T的第1个字符比较。若相等，继续逐个比较后续字符；若不等，从主串S的下一字符起，重新与T第一个字符比较。</li></ul></li><li>直到主串S的一个连续子串字符序列与模式T相等。返回值为S中与T匹配的子序列第一个字符的序号，即匹配成功。否则，匹配失败，返回值–1。</li></ul><p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 代码实现1</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">index</span><span class="hljs-params">(<span class="hljs-type">char</span> s[ ], <span class="hljs-type">char</span> t[ ])</span>&#123;<br>    <span class="hljs-type">int</span> i, j, k;<br>    <span class="hljs-keyword">for</span>(i =<span class="hljs-number">0</span>; s[i] != ‘\<span class="hljs-number">0</span>’; i++)&#123;<br>        <span class="hljs-keyword">for</span>(j=i, k=<span class="hljs-number">0</span>; t[k]!=‘\<span class="hljs-number">0</span>’ &amp;&amp; s[j]==t[k]; j++, k++)<br>        ;<br>        <span class="hljs-keyword">if</span>(t[k] == <span class="hljs-string">&#x27;\0&#x27;</span>)<br>        <span class="hljs-keyword">return</span>(i);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ( <span class="hljs-number">-1</span>);<br>&#125;<br><br><span class="hljs-comment">// 代码实现2</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">index</span><span class="hljs-params">(<span class="hljs-type">char</span> S[ ], <span class="hljs-type">char</span> T[ ])</span> &#123;<br>    <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>, j=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (S[i]!=<span class="hljs-string">&#x27;\0&#x27;</span> &amp;&amp; T[j]!=<span class="hljs-string">&#x27;\0&#x27;</span>) &#123;<br>        <span class="hljs-keyword">if</span> (S[i] == T[j])&#123;<br>            i++;   <br>            j++ <br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            i = i-j +<span class="hljs-number">1</span>;<br>            j = <span class="hljs-number">0</span>; <br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(T[j] == <span class="hljs-string">&#x27;\0&#x27;</span>) <br>    <span class="hljs-keyword">return</span> i-j;  <br>    <span class="hljs-keyword">else</span>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;                   <br>&#125;<br><br><span class="hljs-comment">// 代码实现改进版</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">index</span><span class="hljs-params">(<span class="hljs-type">char</span> s[ ], <span class="hljs-type">char</span> t[ ])</span>&#123;<br>    <span class="hljs-type">int</span> i, j, k, n, m;<br>    n = <span class="hljs-built_in">strlen</span>(s); <br>    m = <span class="hljs-built_in">strlen</span>(t);<br>    <span class="hljs-keyword">for</span>(i =<span class="hljs-number">0</span>; n-i &gt;= m; i++)&#123;<span class="hljs-comment">// 当s中剩余字符数小于t中字符数时停止查找</span><br>        <span class="hljs-keyword">for</span>(j=i,k=<span class="hljs-number">0</span>;t[k]!=‘\<span class="hljs-number">0</span>’&amp;&amp;s[j]==t[k]; j++,k++)<br>        ;<br>        <span class="hljs-keyword">if</span>(t[k] == <span class="hljs-string">&#x27;\0&#x27;</span>)<br>        <span class="hljs-keyword">return</span> ( i);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ( <span class="hljs-number">-1</span>);<br>&#125;<br></code></pre></td></tr></table></figure></p><h2 id="例实现一个简化的linux命令grep">3.5例：实现一个简化的Linux命令grep</h2><h3 id="问题提出">3.5.1 问题提出</h3><ul><li><p>Linux系统中grep命令是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹配的行打印出来。grep全称是GlobalRegular ExpressionPrint。其格式为：<code>% grep [-acinv] [--color=auto] '搜寻字符串' filename</code>。实现一个简化版的grep命令，其格式为：<code># grep [-i] [-n] [-v] '搜寻字符串' filename</code></p><p>选项与参数：</p><p>-i ：忽略大小写的不同，所以大小写视为相同</p><p>-n ：顺便输出行号</p><p>-v ：反向选择，亦即显示出没有 '搜寻字符串' 内容的那一行！</p><p>不支持正则表达式搜索</p></li><li><p>例如：将文件<code>/etc/passwd</code>中有<code>root</code>出现的行取出来,同时显示这些行在<code>/etc/passwd</code>中的行号</p><p>输入：# grep -n root /etc/passwd</p><p>输出：</p><p>1:root​:x:0:0:root:/root:/bin/bash</p><p>30:operator​:x:11:0:operator:/root:/sbin/nologin</p></li></ul><h3 id="算法设计">3.5.2 算法设计</h3><p>该问题的算法关键是在一个字符串（行）中查找另一个字符串。设：<code>int index(char s[], char t[], int status)</code>。返回0表示没有找到；返回非0正整数时，表示模式匹配成功次数。当status为0时表示严格匹配；为1时表示大小写无关匹配。</p><h3 id="代码实现">3.5.3 代码实现</h3><ol type="1"><li>朴素的Brute-Force算法</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 由于缺少46行的print函数，代码无法运行，但主要函数都写出来了</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ctype.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;math.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXLEN 1024</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">issame</span><span class="hljs-params">(<span class="hljs-type">char</span> a, <span class="hljs-type">char</span> b, <span class="hljs-type">int</span> s)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">index</span><span class="hljs-params">(<span class="hljs-type">char</span> s[ ], <span class="hljs-type">char</span> t[ ], <span class="hljs-type">int</span> status )</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[ ])</span>&#123;<br>    <span class="hljs-type">char</span> line[MAXLEN], *pattern, *filename;<br>    <span class="hljs-type">int</span> ai=<span class="hljs-number">0</span>, an=<span class="hljs-number">0</span>, av=<span class="hljs-number">0</span>, lnum = <span class="hljs-number">0</span>, pos; <span class="hljs-comment">//对应参数-i,-n,-v</span><br>    FILE *fp;<br>    <span class="hljs-keyword">if</span>(argc&lt;<span class="hljs-number">3</span> || argc&gt;<span class="hljs-number">6</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;usage: grep [-i] [-n] [-v] pattern filename\n&quot;</span>);<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        pattern = argv[argc<span class="hljs-number">-2</span>];<br>        filename = argv[argc<span class="hljs-number">-1</span>];<br>        <span class="hljs-keyword">for</span>( ; argc&gt;<span class="hljs-number">3</span> ; argc--) &#123;<br>            <span class="hljs-keyword">if</span>(argv[argc<span class="hljs-number">-3</span>][<span class="hljs-number">0</span>] != <span class="hljs-string">&#x27;-&#x27;</span>) &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;usage:grep  [-i] [-n] [-v] pattern filename\n&quot;</span>);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">switch</span> (argv[argc - <span class="hljs-number">3</span>][<span class="hljs-number">1</span>]) &#123;<br>                    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;i&#x27;</span>:<br>                        ai = <span class="hljs-number">1</span>;<br>                        <span class="hljs-keyword">break</span>;<br>                    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;n&#x27;</span>:<br>                        an = <span class="hljs-number">1</span>;<br>                        <span class="hljs-keyword">break</span>;<br>                    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;v&#x27;</span>:<br>                        av = <span class="hljs-number">1</span>;<br>                        <span class="hljs-keyword">break</span>;<br>                    <span class="hljs-keyword">default</span>:<br>                        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;usage:  grep [-i] [-n] [-v] pattern filename\n&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>((fp = fopen(filename, <span class="hljs-string">&quot;r&quot;</span>)) == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Can open file\n&quot;</span>);<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">while</span>(fgets(line, MAXLEN<span class="hljs-number">-1</span>, fp) !=<span class="hljs-literal">NULL</span>)&#123;<br>            lnum++;<br>            pos =  index(line, pattern, ai);<br>            print(line,lnum,pos,an,av);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">index</span><span class="hljs-params">(<span class="hljs-type">char</span> s[ ], <span class="hljs-type">char</span> t[ ], <span class="hljs-type">int</span> status )</span>&#123; <span class="hljs-comment">//status为0：大小写敏感；status为1大小写无关</span><br>    <span class="hljs-type">int</span> i, j, k,n,m,count=<span class="hljs-number">0</span>;<br>    n = <span class="hljs-built_in">strlen</span>(s);<br>    m = <span class="hljs-built_in">strlen</span>(t);<br>    <span class="hljs-keyword">for</span>(i =<span class="hljs-number">0</span>; n-i &gt;= m; i++)&#123;<br>        <span class="hljs-keyword">for</span>(j=i,k=<span class="hljs-number">0</span>; t[k]!=<span class="hljs-string">&#x27;\0&#x27;</span> &amp;&amp; issame(s[j], t[k], status); j++,k++)<br>        ;<br>        <span class="hljs-keyword">if</span>(t[k] == <span class="hljs-string">&#x27;\0&#x27;</span>)<br>        count++; <span class="hljs-comment">//找到后，次数加1，继续查找</span><br>    &#125;<br>    <span class="hljs-keyword">return</span>  count;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">issame</span><span class="hljs-params">(<span class="hljs-type">char</span> a, <span class="hljs-type">char</span> b, <span class="hljs-type">int</span> s)</span>&#123;<br>    <span class="hljs-keyword">return</span> s?(<span class="hljs-built_in">tolower</span>(a) == <span class="hljs-built_in">tolower</span>(b)) : (a == b);<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2" type="1"><li><p>KMP算法</p><p><em>（不要求自己写，会用就行）（效率比strstr没有很明显的提高，除非明摆着卡时长，否则没必要KMP）</em></p><p>KMP算法理解：<ahref="https://blog.csdn.net/starstar1992/article/details/54913261">KMP算法最浅显理解——一看就明白-CSDN博客</a></p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ctype.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;math.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXLINE 1024</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">getnext</span><span class="hljs-params">(<span class="hljs-type">char</span> T[], <span class="hljs-type">int</span> next[])</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">KMPindex</span><span class="hljs-params">(<span class="hljs-type">char</span> S[ ], <span class="hljs-type">char</span> T[ ])</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">( )</span>&#123;<br>    <span class="hljs-type">char</span> filename[<span class="hljs-number">64</span>], t[<span class="hljs-number">81</span>], line[MAXLINE],*s;<br>    FILE *fp;<br>    <span class="hljs-type">int</span> n,pos=<span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s %s&quot;</span>, filename,t);<br>    <span class="hljs-keyword">if</span>((fp = fopen(filename, <span class="hljs-string">&quot;r&quot;</span>)) == <span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Can&#x27;t open file %s!\n&quot;</span>, filename);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(fgets(line, MAXLINE<span class="hljs-number">-1</span>, fp) != <span class="hljs-literal">NULL</span>)&#123;<br>        s = line;<br>        <span class="hljs-keyword">while</span>((n=KMPindex(s, t)) &gt;= <span class="hljs-number">0</span>)&#123;     <span class="hljs-comment">// 在s字符串查找t</span><br>            pos += n;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, pos);<br>            s = s+(n+<span class="hljs-number">1</span>);<br>            pos++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">getnext</span><span class="hljs-params">(<span class="hljs-type">char</span> T[], <span class="hljs-type">int</span> next[])</span>&#123;<br>    <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>, j=<span class="hljs-number">-1</span>;<br>    next[<span class="hljs-number">0</span>]=<span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">while</span>(T[i]!=<span class="hljs-string">&#x27;\0&#x27;</span>)&#123;<br>        <span class="hljs-keyword">if</span>(j==<span class="hljs-number">-1</span> || T[i]==T[j])&#123; <span class="hljs-comment">//i为后缀位置；j为前缀位置</span><br>            i++;<br>            j++;<br>            next[i]=j;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            j = next[j]; <span class="hljs-comment">//若字符不同，则j值回溯</span><br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">KMPindex</span><span class="hljs-params">(<span class="hljs-type">char</span> S[ ], <span class="hljs-type">char</span> T[ ])</span>&#123;<br>    <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>, j=<span class="hljs-number">0</span>, *next;<br>    next = (<span class="hljs-type">int</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>)*(<span class="hljs-built_in">strlen</span>(T)+<span class="hljs-number">1</span>));<br>    getnext(T, next);   <span class="hljs-comment">// 获得next[t]</span><br>    <span class="hljs-keyword">while</span>(S[i]!=<span class="hljs-string">&#x27;\0&#x27;</span> &amp;&amp; T[j]!=<span class="hljs-string">&#x27;\0&#x27;</span>)&#123;<br>        <span class="hljs-keyword">if</span>(S[i] == T[j])&#123;<br>            i++;<br>            j++;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            (j == <span class="hljs-number">0</span>) ? i++ :( j = next[j]); <span class="hljs-comment">//j回退到相应位置开始匹配，i值不变</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">free</span>(next);<br>    <span class="hljs-keyword">if</span> (T[j] == <span class="hljs-string">&#x27;\0&#x27;</span>) <span class="hljs-comment">//匹配成功，返回匹配位置</span><br>        <span class="hljs-keyword">return</span> i-j;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>学习经验</category>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习经验</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【数据结构】ds笔记2-线性表</title>
    <link href="/2024/03/23/LE-ds2/"/>
    <url>/2024/03/23/LE-ds2/</url>
    
    <content type="html"><![CDATA[<h2 id="说在前面">说在前面</h2><p>本篇笔记总结了<strong>DSPv2b_2(线性表) forstudent</strong>内的相关内容，依旧将ppt分为两个部分————知识点和例题。以及注意本次学习内容为线性表，而非链表，并不是作业中的所有题目都需要用链表来完成，也记得利用好数组喵。以及如果你还想进行一些训练——洛谷欢迎您(https://www.luogu.com.cn/training/141312#problems)。最后，本人学艺不精，只是一边看着ppt一边敲敲改改，如有疏漏，欢迎提出喵~o(=∩ω∩= )m</p><hr /><h2 id="知识点">知识点</h2><h3 id="外部全局变量">1 外部（全局）变量</h3><h4 id="简介">1.1 简介</h4><ol type="1"><li>外部变量（全局变量, global variable）：在函数外面定义的变量</li><li>作用于（scope）为整个程序，即可在程序的所有函数中使用</li><li>有隐含初值0</li><li>生存期（lifecycle）：外部变量（存储空间）在程序执行过程中始终存在。</li></ol><h4 id="外部变量说明extern">1.2 外部变量说明（extern）</h4><ol type="1"><li><p>C程序可以分别放在几个文件上，每个文件可作为一个编译单位分别编译。外部变量只需在某个文件上定义一次，<strong>其它文件若要引用此变量时，应用extern加以说明</strong>。（外部变量定义时不必加extern关键字）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 第一个文件</span><br><span class="hljs-type">int</span> N;<br>main()&#123;<br>       …<br>       N =  …<br>       …<br>&#125;<br><span class="hljs-comment">// 第二个文件</span><br><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> N;<br>fun()&#123;<br>    …<br>    N = …<br>    …<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>在同一文件中，<strong>若前面的函数要引用后面定义的外部（在函数之外）变量时，也应在函数前加以extern说明</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> N;<br>main()&#123;<br>    …<br>    N =  …<br>    …<br>&#125;<br><span class="hljs-type">int</span> N=<span class="hljs-number">0</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">fun</span><span class="hljs-params">()</span>&#123;<br>    … <br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h4 id="外部变量特点">1.3 外部变量特点</h4><ol type="1"><li><p>使用外部变量的原因</p><ol type="1"><li>解决函数单独编译的协调；</li><li>与变量初始化有关；</li><li>外部变量的值是永久的；</li><li>解决数据共享；</li></ol></li><li><p>外部变量的副作用</p><p>使用外部变量的函数独立性差，通常不能单独使用在其他的程序中。而且，如果多个函数都使用到某个外部变量，一旦出现差错，就很难发现问题是由哪个函数引起的。在程序中的某个部分引起外部变量的错误，很容易误以为是由另一部分引起的。</p></li><li><p>建议：<strong>少用或不用外部变量</strong></p></li></ol><h3 id="线性表">2 线性表</h3><h4 id="线性表的基本操作">2.1 线性表的基本操作</h4><ol type="1"><li>创建一个新的线性表</li><li>求线性表的长度</li><li>检索线性表中的第i个数据元素</li><li>根据数据元素的某数据项(通常称为关键字)的值求该数据元素在线性表中的位置（查找）。</li><li>在线性表的第i个位置上存入一个新的数据元素。</li><li>在线性表的第i个位置上插入一个新的数据元素。</li><li>删除线性表中第i个数据元素。</li><li>对线性表中的数据元素按照某一个数据项的值的大小做升序或者降序排序。</li><li>销毁一个线性表</li><li>复制一个线性表</li><li>按照一定的原则，将两个或两个以上的线性表合并成为一个线性表。</li><li>按照一定的原则，将一个线性表分解为两个或两个以上的线性表</li></ol><h4 id="线性表的顺序存储结构">2.2 线性表的顺序存储结构</h4><ol type="1"><li><p>地址连续</p></li><li><p>基本操作</p><ol type="1"><li><p>查找：确定元素item在长度为n的顺序表list中的位置</p><p>顺序查找、<strong>二分查找</strong></p></li><li><p>插入：在长度为n的顺序表list的第i个位置上插入一个新的数据元素item</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 假设N是顺序表的长度（元素个数），为全局变量</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">insertElem</span><span class="hljs-params">(ElemType <span class="hljs-built_in">list</span>[], <span class="hljs-type">int</span> i, ElemType item)</span>&#123;<br>    <span class="hljs-type">int</span> k;<br>    <span class="hljs-keyword">if</span>(N==MaxSize || i&lt;<span class="hljs-number">0</span> || i&gt;N)&#123;<span class="hljs-comment">// 插入失败</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(k=N<span class="hljs-number">-1</span>; k&gt;=i; k--)&#123;<span class="hljs-comment">// 元素依次后移一个位置</span><br>        <span class="hljs-built_in">list</span>[k+<span class="hljs-number">1</span>] = <span class="hljs-built_in">list</span>[k];<br>    &#125;<br>    <span class="hljs-built_in">list</span>[i] = item;<br>    N++;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>删除：删除长度为n的顺序表list的某个数据元素</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 假设N是顺序表的长度（元素个数），为全局变量</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">deleteElem</span><span class="hljs-params">(ElemType <span class="hljs-built_in">list</span>[], <span class="hljs-type">int</span> i)</span>&#123;<br>    <span class="hljs-type">int</span> k;<br>    <span class="hljs-keyword">if</span>(N==<span class="hljs-number">0</span> || i&lt;<span class="hljs-number">0</span> || i&gt;N<span class="hljs-number">-1</span>)&#123;<span class="hljs-comment">// 删除失败</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(k=i+<span class="hljs-number">1</span>; k&lt;N; k++)&#123;<span class="hljs-comment">// 元素依次前移一个位置</span><br>        <span class="hljs-built_in">list</span>[k<span class="hljs-number">-1</span>] = <span class="hljs-built_in">list</span>[k];<br>    &#125;<br>    N--;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ol></li><li><p>特点</p><ol type="1"><li>优点<ol type="1"><li>构造原理简单、直观</li><li><strong>读取速度快</strong></li><li>存储空间开销小</li><li><strong>查找效率高</strong></li></ol></li><li>缺点<ol type="1"><li>存储分配需要事先进行</li><li>需要一块地址连续的存储空间</li><li>基本操作（如插入、删除）的时间效率较低</li></ol></li></ol></li></ol><h4 id="线性表的链式存储结构">2.3 线性表的链式存储结构</h4><h5 id="构造原理">2.3.1 构造原理</h5><p>用一组地址任意的存储单元(连续的或不连续的)依次存储表中各个数据元素,数据元素之间的逻辑关系通过<strong>指针</strong>间接地反映出来。</p><h5 id="线性链表的定义">2.3.2 线性链表的定义</h5><ol type="1"><li><p>链表定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> &#123;</span>   <br>    ElemType data;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> *<span class="hljs-title">next</span>;</span><br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> *<span class="hljs-title">list</span>, *<span class="hljs-title">p</span>;</span><br></code></pre></td></tr></table></figure></li><li><p>类型定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> &#123;</span>   <br>    ElemType data;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> *<span class="hljs-title">next</span>;</span><br>&#125;;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> *<span class="hljs-title">Nodeptr</span>;</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> <span class="hljs-title">Node</span>;</span> <br>Nodeptr <span class="hljs-built_in">list</span>, p;<br><br></code></pre></td></tr></table></figure></li></ol><h5 id="线性链表的基本操作">2.3.3 线性链表的基本操作</h5><ol type="1"><li><p>建立一个线性链表</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c">Nodeptr <span class="hljs-title function_">createList</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span>  <span class="hljs-comment">/*创建一个具有n个结点的链表 */</span><br>&#123;<br><span class="hljs-comment">/* list是链表头指针, q指向新申请的结点，p指向最后一个结点*/</span><br>    Nodeptr  p, q, <span class="hljs-built_in">list</span>=<span class="hljs-literal">NULL</span>;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        q=(Nodeptr)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Node));<br>        q-&gt;data=read();     <span class="hljs-comment">/* 取一个数据元素 */</span> <br>        q-&gt;next=<span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">list</span>==<span class="hljs-literal">NULL</span>) <span class="hljs-comment">/*链表为空*/</span><br>            <span class="hljs-built_in">list</span>=p=q;<br>        <span class="hljs-keyword">else</span><br>            p-&gt;next=q;       <span class="hljs-comment">/* 将新结点链接在链表尾部 */</span><br>        p=q;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">list</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>求线性链表的长度</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 非循环链表</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">getLength</span><span class="hljs-params">(Nodeptr <span class="hljs-built_in">list</span>)</span>&#123;<br>    Nodeptr p;     <span class="hljs-comment">// p为遍历链表结点的指针</span><br>    <span class="hljs-type">int</span> n=<span class="hljs-number">0</span>;                  <span class="hljs-comment">// 链表的长度置初值0</span><br>    <span class="hljs-keyword">for</span>(p=<span class="hljs-built_in">list</span>; p!=<span class="hljs-literal">NULL</span>; p=p-&gt;next)<span class="hljs-comment">// p依次指向链表的下一结点</span><br>    n++;    　　<span class="hljs-comment">// 对链表结点累计计数</span><br>    <span class="hljs-keyword">return</span> n;                   <span class="hljs-comment">// 返回链表的长度n</span><br>&#125;<br><span class="hljs-comment">// 循环链表</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">getlength</span><span class="hljs-params">( Nodeptr <span class="hljs-built_in">list</span> )</span>&#123;<br>    Nodeptr p=<span class="hljs-built_in">list</span>;<br>    <span class="hljs-type">int</span> n=<span class="hljs-number">0</span>;                        <span class="hljs-comment">// 链表的长度置初值0</span><br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">list</span> == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <br>    <span class="hljs-keyword">do</span>&#123;<br>        p=p-&gt;link;<br>        n++;<br>    &#125;<span class="hljs-keyword">while</span>(p!=<span class="hljs-built_in">list</span>);<br>    <span class="hljs-keyword">return</span> n;                       <span class="hljs-comment">// 返回链表的长度n</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>输出一个表</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">printList</span><span class="hljs-params">(List L)</span> &#123;<br>    <span class="hljs-keyword">while</span> (L != <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, L-&gt;data);<br>        L = L-&gt;next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>删除</p><ol type="1"><li><p>注意事项</p><ol type="1"><li>特殊情况：链表为空；删除头结点</li><li><strong>在删除某个结点时，必须要知道该结点的前序结点指针</strong>，否则无法删除。</li><li>删除操作（函数）应返回头结点指针，如使用如下方式调用deleteNode删除函数，以保确头结点指向正确的结点：<code>list = deleteNode(list, item);</code></li><li><strong>结点删除后一定要释放</strong>。删除某个结点前，必须要事先保存指向该结点的指针，以便删除后能释放结点。</li></ol></li><li><p>删除p的下一个节点q（已知p的时候）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c">Nodeptr <span class="hljs-title function_">deleteNodepnext</span><span class="hljs-params">(Nodeptr <span class="hljs-built_in">list</span>, Nodeptr p,  Nodeptr q)</span>&#123;<br>    <span class="hljs-keyword">if</span>(q==<span class="hljs-built_in">list</span>)  <br>    <span class="hljs-built_in">list</span>=q-&gt;next;<span class="hljs-comment">/* 删除链表的第一个链结点*/</span><br>    <span class="hljs-keyword">else</span><br>    p-&gt;next=q-&gt;next;<span class="hljs-comment">/* 删除p指的链结点*/</span><br>    <span class="hljs-built_in">free</span>(q);<span class="hljs-comment">/* 释放被删除的结点空间*/</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">list</span>；<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/LE-ds2/1.jpg" /></p><p><em>图片来源：https://onlyar.site/img/C-LinkedList.assets/delete.png</em></p></li><li><p>删除p结点</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c">Nodeptr <span class="hljs-title function_">deleteNodep</span><span class="hljs-params">( Nodeptr <span class="hljs-built_in">list</span>, Nodeptr p )</span><br>&#123;<br>    Nodeptr r;<br>    <span class="hljs-keyword">if</span>(p==<span class="hljs-built_in">list</span>)&#123;                         <span class="hljs-comment">// 当删除链表第一个结点</span><br>        <span class="hljs-built_in">list</span>=<span class="hljs-built_in">list</span>-&gt;next;<br>        <span class="hljs-built_in">free</span>(p);                        <span class="hljs-comment">// 释放被删除结点的空间</span><br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">for</span>(r=<span class="hljs-built_in">list</span>; r-&gt;next!=p  &amp;&amp;  r-&gt;next!=<span class="hljs-literal">NULL</span>; r=r-&gt;next) <br>        ;                           <span class="hljs-comment">// 移向下一个链结点</span><br>        <span class="hljs-keyword">if</span>(r-&gt;next!=<span class="hljs-literal">NULL</span>)&#123; <span class="hljs-comment">// r-&gt;next == p</span><br>            r-&gt;next=p-&gt;next;<br>            <span class="hljs-built_in">free</span>(p);                  <br>        &#125;<br>    &#125; <br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">list</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>删除包含给定元素的结点</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c">Nodeptr <span class="hljs-title function_">deleteNode</span><span class="hljs-params">( Nodeptr <span class="hljs-built_in">list</span>, ElemType elem )</span>&#123;<br>    Nodeptr p, q;    <span class="hljs-comment">// p指向要删除的结点，q为p的前一个结点</span><br><span class="hljs-keyword">while</span>(p-&gt;next != <span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-keyword">for</span>(p=<span class="hljs-built_in">list</span>; p!=<span class="hljs-literal">NULL</span>; q=p,p=p-&gt;next) <br>            <span class="hljs-keyword">if</span>(p-&gt;data==elem)         <span class="hljs-comment">// 找到要删除的链结点</span><br>                <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">if</span>(p==<span class="hljs-built_in">list</span>)&#123;                         <span class="hljs-comment">// 删除头结点</span><br>            <span class="hljs-built_in">list</span> = <span class="hljs-built_in">list</span>-&gt;next;<br>            <span class="hljs-built_in">free</span>(p);                  <br>        &#125; <br>        <span class="hljs-keyword">if</span>(q-&gt;next != <span class="hljs-literal">NULL</span>)&#123;            <span class="hljs-comment">// 删除p指向的结点</span><br>            q-&gt;next = p-&gt;next;<br>            <span class="hljs-built_in">free</span>(p);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">list</span>;<br> &#125;<br></code></pre></td></tr></table></figure></li></ol></li><li><p>插入</p><ol type="1"><li><p>注意事项：</p><ol type="1"><li>特殊情况：链表为空；在头节点前插入</li><li><strong>在某结点前插入一个结点，必须要知道该结点的前序结点指针</strong>，否则无法插入</li><li>插入操作（函数）应返回头结点指针，如使用如下方式调用insertNode插入函数，以保确头结点指向正确的结点：<code>list = insertNode(list, item);</code></li></ol></li><li><p>在p后插入q</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">insertNode</span><span class="hljs-params">(Nodeptr p, ElemType item)</span>&#123;<br>    Nodeptr q;<br>    q = (Nodeptr) <span class="hljs-built_in">malloc</span> (<span class="hljs-keyword">sizeof</span>(Node));<br>    q-&gt;data = item;<br>    q-&gt;next = <span class="hljs-literal">NULL</span>;<br>    <br>    q-&gt;next = p-&gt;next;<br>    p-&gt;next = q;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/LE-ds2/2.jpg" /></p><p><em>图片来源：https://onlyar.site/img/C-LinkedList.assets/insert.png</em></p></li><li><p>在链表头插入元素</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c">Nodeptr <span class="hljs-title function_">insertFirst</span><span class="hljs-params">(Nodeptr <span class="hljs-built_in">list</span>, ElemType item)</span>&#123;<br>    <span class="hljs-comment">// list指向链表的第一个结点</span><br>    p = (Nodeptr) <span class="hljs-built_in">malloc</span> (<span class="hljs-keyword">sizeof</span>(Node));<br>    p-&gt;data = item;<span class="hljs-comment">//将item赋给新结点数据域</span><br>    p-&gt;next = <span class="hljs-built_in">list</span>;<span class="hljs-comment">//将新节点指向原链表第一个结点</span><br>    <span class="hljs-keyword">return</span> p;<span class="hljs-comment">//返回新的链表表头指针</span><br>&#125;<br><span class="hljs-comment">// 应使用如下方式调用insertFisrt函数：</span><br><span class="hljs-comment">// list = insertFirst(list, item);</span><br></code></pre></td></tr></table></figure></li><li><p>在<strong>有序</strong>线性链表中相应位置上插入一个数据信息为item的链结点</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 设list是一个有序增序链表，将元素elem插入到相应位置上 */</span><br>Nodeptr <span class="hljs-title function_">insertNode</span><span class="hljs-params">(Nodeptr <span class="hljs-built_in">list</span>, ElemType elem)</span>&#123; <br>    Nodeptr p,q, r;<br>    r = (Nodeptr)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Node)); <span class="hljs-comment">//创建一个数据项为elem的新结点</span><br>    r-&gt;data = elem;<br>    r-&gt;next = <span class="hljs-literal">NULL</span>;<br>    <br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">list</span> == <span class="hljs-literal">NULL</span>)  <span class="hljs-comment">// list是一个空表</span><br>        <span class="hljs-keyword">return</span> r;<br>    <span class="hljs-keyword">for</span>(p=<span class="hljs-built_in">list</span>; elem &gt; p-&gt;elem &amp;&amp; p != <span class="hljs-literal">NULL</span>;  q = p, p = p-&gt;next)<br>        <span class="hljs-comment">// 找到插入位置</span><br>    ;<br>    <br>    <span class="hljs-keyword">if</span>( p == <span class="hljs-built_in">list</span>)&#123; <span class="hljs-comment">// 在头结点前插入</span><br>        r-&gt;link = p;<br>        <span class="hljs-keyword">return</span> r;<br>    &#125;<span class="hljs-keyword">else</span>&#123; <span class="hljs-comment">// 在结点q后插入一个结点</span><br>        q-&gt;next = r;<br>        r-&gt;next = p;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">list</span>;<br>&#125;<br><span class="hljs-comment">//调用方式</span><br><span class="hljs-built_in">list</span> = insertNode(<span class="hljs-built_in">list</span>, item);<br></code></pre></td></tr></table></figure></li></ol></li><li><p>线性链表的逆转。</p></li><li><p>将两个线性链表合并为一个线性链表。</p></li><li><p>检索线性链表中的第i个链结点。</p></li><li><p>检索链表中数据信息</p></li><li><p>销毁一个表</p></li></ol><h5 id="表头结点header">2.3.4 表头结点(header)</h5><p>又称哑结点dummynode，是在构造链表时会给链表设置一个标志结点。<strong>设置表头结点的最大好处是对链表结点的插入及删除操作统一了（不用考虑是否是头结点）。</strong>其数据域一般无意义（有时也可存放链表的长度）。</p><p><img src="/img/LE-ds2/3.jpg" /></p><h5 id="特点">2.3.5 特点</h5><ol type="1"><li>优点<ol type="1"><li>存储空间动态分配，可以根据实际需要使用。</li><li>不需要地址连续的存储空间(不需要大块连续空间)。</li><li>插入/删除操作只须通过修改指针实现,不必移动数据元素，操作的时间效率高。（无论位于链表何处，无论链表的长度如何，插入和删除操作的时间都是O(1)。）</li></ol></li><li>缺点<ol type="1"><li>每个链结点需要设置指针域(占用存储空间小)。</li><li>是一种非连续存储结构，查找、定位等操作要通过顺序遍历链表实现，时间效率较低。（时间为O(n)）</li></ol></li></ol><h4 id="顺序存储结构和链式存储结构的比较">2.4顺序存储结构和链式存储结构的比较</h4><p>1.若线性表需要频繁查找（通讯录），较少进行插入和删除操作时，宜采用顺序存储结构。若需要频繁插入和删除时（如词频统计），宜采用链表结构。</p><p>2.当线性表中的元素个数变化较大或者根本不知道有多大时（如词频统计单词表），最好用链表结构。而如果事先知道线性的大致长度，用顺序结构次效率会高些。</p><h4 id="双向链表及其操作">2.5 双向链表及其操作</h4><h5 id="双向链表的构造">2.5.1 双向链表的构造</h5><ol type="1"><li><p>双向链表指链表的每一个结点中除了数据域以外设置两个指针域，其中之一指向结点的直接后继结点，另外一个指向结点的直接前驱结点。</p></li><li><p>双向链表的几种形式</p><p><img src="/img/LE-ds2/4.jpg" /></p></li><li><p>类型定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> &#123;</span> <br>    ElemType data;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> *<span class="hljs-title">rlink</span>, *<span class="hljs-title">llink</span>;</span><br>&#125;;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> *<span class="hljs-title">DNodeptr</span>;</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> <span class="hljs-title">DNode</span>;</span><br></code></pre></td></tr></table></figure></li></ol><h5 id="双向链表的基础操作">2.5.2 双向链表的基础操作</h5><ol type="1"><li><p>双向链表的构建（构造有n个结点的双向链表）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c">DNodeptr <span class="hljs-title function_">initDLink</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span>&#123;<br>    <span class="hljs-type">int</span> i;<br>    DNodeptr <span class="hljs-built_in">list</span>,p;<br>    <span class="hljs-built_in">list</span>=(DNodeptr) <span class="hljs-built_in">malloc</span> (<span class="hljs-keyword">sizeof</span>(DNode));<br>    READ(<span class="hljs-built_in">list</span>-&gt;data);<br>    <span class="hljs-built_in">list</span>-&gt;llink=<span class="hljs-built_in">list</span>;<br>    <span class="hljs-built_in">list</span>-&gt;rlink=<span class="hljs-built_in">list</span>;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;n;i++)&#123;<br>        p=(DNodeptr) <span class="hljs-built_in">malloc</span> (<span class="hljs-keyword">sizeof</span>(DNode));<br>        READ(p-&gt;data);            <span class="hljs-comment">/* 读入一元素 */</span><br>        insertNode(<span class="hljs-built_in">list</span>,p);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">list</span>;<br>&#125; <br></code></pre></td></tr></table></figure></li><li><p>双向链表的插入</p><ol type="1"><li><p>插入到头结点左边</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">insertNode</span><span class="hljs-params">(DNodeptr <span class="hljs-built_in">list</span>, Dnodeptr p)</span>&#123;<br>    <span class="hljs-built_in">list</span>-&gt;llink-&gt;rlink=p;<br>    p-&gt;llink=<span class="hljs-built_in">list</span>-&gt;llink;<br>    p-&gt;rlink=<span class="hljs-built_in">list</span>;<br>    <span class="hljs-built_in">list</span>-&gt;llink=p;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>某个数据域的内容为x的链结点右边插入一个数据信息为item的新结点</p><ol type="1"><li><p>原理</p><p><img src="/img/LE-ds2/5.jpg" /></p></li><li><p>算法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">insertDNode</span><span class="hljs-params">(DNodeptr <span class="hljs-built_in">list</span>, ElemType x, ElemType item)</span>&#123;<br>    DNodeptr p, q;<br>    <span class="hljs-keyword">for</span>(q=<span class="hljs-built_in">list</span>; q-&gt;rlink!=<span class="hljs-built_in">list</span> &amp;&amp; q-&gt;data!=x; q=q-&gt;rlink);<span class="hljs-comment">// 寻找满足条件的链结点</span><br>    <span class="hljs-keyword">if</span>(q-&gt;rlink == <span class="hljs-built_in">list</span> &amp;&amp; q-&gt;data != x)&#123;<span class="hljs-comment">// 没有找到满足条件的结点</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    p = (DNodeptr) <span class="hljs-built_in">malloc</span> (<span class="hljs-keyword">sizeof</span>(DNode));<span class="hljs-comment">// 申请一个新的结点</span><br>    p-&gt;data = item;<br>    p-&gt;llink = q;<br>    p-&gt;rlink = q-&gt;rlink;<br>    p-&gt;rlink-&gt;llink = p;<br>    q-&gt;rlink = p;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol></li></ol></li><li><p>双向链表的删除</p><ol type="1"><li><p>原理</p><p><img src="/img/LE-ds2/6.jpg" /></p></li><li><p>算法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">deletDNode</span><span class="hljs-params">(DNodeptr <span class="hljs-built_in">list</span>, ElemType x)</span>&#123;<br>    DNodeptr q;<br>    <span class="hljs-keyword">for</span>(q=<span class="hljs-built_in">list</span>; q-&gt;rlink!=<span class="hljs-built_in">list</span> &amp;&amp; q-&gt;data!=x; q=q-&gt;rlink);<span class="hljs-comment">// 找满足条件的链结点</span><br>    <span class="hljs-keyword">if</span>(q-&gt;rlink==<span class="hljs-built_in">list</span> &amp;&amp; q-&gt;data!=x)&#123;<span class="hljs-comment">// 没找到满足条件的结点</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    q-&gt;llink-&gt;rlink = q-&gt;rlink;<br>    q-&gt;rlink-&gt;llink = q-&gt;llink;<br>    <span class="hljs-built_in">free</span>(q);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol></li></ol><hr /><h2 id="例题">例题</h2><h3 id="例1-线性表的顺序存储结构">例1 线性表的顺序存储结构</h3><h4 id="题目">题目</h4><p>已知长度为n的非空线性表list采用顺序存储结构,并且数据元素按值的大小非递减排列(有序)，写一算法,在该线性表中插入一个数据元素item,使得线性表仍然保持按值非递减排列。</p><h4 id="分析">分析</h4><p>1.寻找插入位置：从表的第一个元素开始进行比较，若有item&lt;a<sub>i</sub> 则找到插入位置为表的第i个位置。</p><p>2.将第i个元素至第n个元素依次后移一个位置</p><p>3.将item插入表的第i个位置</p><p>4.表的长度增1。</p><h4 id="代码实现">代码实现</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXSIZE 1000</span><br><span class="hljs-keyword">typedef</span>  <span class="hljs-type">int</span>  ElemType;<br><span class="hljs-type">int</span> N=<span class="hljs-number">0</span>; <br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">int</span> i;<br>    ElemType  data,<span class="hljs-built_in">list</span>[MAXSIZE];<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;N);<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;N; i++)<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;<span class="hljs-built_in">list</span>[i]);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;data);<br>    <span class="hljs-keyword">if</span>(insertElem(<span class="hljs-built_in">list</span>, data ) == <span class="hljs-number">1</span>)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;OK\n&quot;</span>);<br>    <span class="hljs-keyword">else</span> <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Fail\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">insertElem</span><span class="hljs-params">(ElemType <span class="hljs-built_in">list</span>[ ],  ElemType item)</span>&#123;<br>    <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>,j;<br>    <span class="hljs-keyword">if</span>(N == MAXSIZE)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <br>    i = searchElem(<span class="hljs-built_in">list</span>, item);          <span class="hljs-comment">/* 寻找item的合适位置 */</span><br>    <span class="hljs-keyword">for</span>(j=N<span class="hljs-number">-1</span>; j&gt;=i; j--)<br>    <span class="hljs-built_in">list</span>[j+<span class="hljs-number">1</span>]=<span class="hljs-built_in">list</span>[j];<br>    <span class="hljs-built_in">list</span>[i]=item;                       <span class="hljs-comment">/* 将item插入表中 */</span><br>    N++;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">searchElem</span><span class="hljs-params">(ElemType <span class="hljs-built_in">list</span>[ ], ElemType item)</span>&#123;<br>    <span class="hljs-type">int</span> low=<span class="hljs-number">0</span>, high=n<span class="hljs-number">-1</span>, mid;<br>    <span class="hljs-keyword">while</span>(low &lt;= high)&#123;<br>    mid = (high + low) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>( item &lt; <span class="hljs-built_in">list</span>[mid])<br>        high = mid – <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( item &gt; <span class="hljs-built_in">list</span>[mid])<br>            low = mid + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">return</span> (mid);<br>    &#125;<br>    <span class="hljs-keyword">return</span> low ;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="例2-线性表的顺序存储结构">例2 线性表的顺序存储结构</h3><h4 id="题目-1">题目</h4><p>编写程序统计一个文件中每个单词的出现次数（词频统计），并按字典序输出每个单词及出现次数。</p><h4 id="分析-1">分析</h4><ol type="1"><li>首先构造一个空的有序（字典序）单词表；</li><li>每次从文件中读入一个单词；</li><li>在单词表中（折半）查找该单词，若找到，则单词次数加1，否则将该单词插入到单词表中相应位置，并设置出现次数为1；</li><li>重复步骤2，直到文件结束。</li></ol><h4 id="代码实现-1">代码实现</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ctype.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXWORD  32</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXSIZE  1024</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">lnode</span> &#123;</span><br>    <span class="hljs-type">char</span> word[MAXWORD];<br>    <span class="hljs-type">int</span> count;<br>&#125;;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">getWord</span><span class="hljs-params">(FILE *bfp,<span class="hljs-type">char</span> *w)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">searchWord</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> lnode <span class="hljs-built_in">list</span>[], <span class="hljs-type">char</span> *w)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">insertWord</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> lnode <span class="hljs-built_in">list</span>[ ],  <span class="hljs-type">int</span> pos, <span class="hljs-type">char</span> *w)</span>;<br><span class="hljs-type">int</span> N=<span class="hljs-number">0</span>; <span class="hljs-comment">//单词表中单词的实际个数</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">lnode</span> <span class="hljs-title">wordlist</span>[<span class="hljs-title">MAXSIZE</span>];</span><span class="hljs-comment">/*单词表*/</span><br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-type">char</span> filename[MAXWORD], word[MAXWORD];<br>    FILE *bfp;<br><br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, filename);<br>    <span class="hljs-keyword">if</span>((bfp = fopen(bname, <span class="hljs-string">&quot;r&quot;</span>)) == <span class="hljs-literal">NULL</span>)&#123;<span class="hljs-comment">// 文件打开失败</span><br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;%s  can’t open!\n&quot;</span>,filename);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>     &#125;<br>    <span class="hljs-keyword">while</span>(getWord(bfp,word) != EOF)<br>        <span class="hljs-keyword">if</span>(searchWord(wordlist, word) == <span class="hljs-number">-1</span>) &#123;<span class="hljs-comment">// 单词表满了</span><br>            <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Wordlist is full!\n&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;= N<span class="hljs-number">-1</span>; i++)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s  %d\n&quot;</span>, wordlist[i].word, wordlist[i].count);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br><br></code></pre></td></tr></table></figure><h3 id="例3-线性表的链式存储">例3 线性表的链式存储</h3><h4 id="题目-2">题目</h4><p>编写程序统计一个文件中每个单词的出现次数（词频统计），并按字典序输出每个单词及出现次数。</p><h4 id="分析-2">分析</h4><p><img src="/img/LE-ds2/7.jpg" /></p><h4 id="代码实现-2">代码实现</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 我的代码</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ctype.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;math.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list</span>&#123;</span><br>    <span class="hljs-type">char</span> s[<span class="hljs-number">100</span>];<br>    <span class="hljs-type">int</span> sum;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list</span> <span class="hljs-title">lists</span>[100000];</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">char</span> s[], <span class="hljs-type">int</span> ListNum)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">cmp</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *pa, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *pb)</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    FILE *in;       <span class="hljs-comment">// 为读写文件定义文件指针</span><br>    in = fopen(<span class="hljs-string">&quot;article.txt&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>);      <span class="hljs-comment">// 为输入打开一个给定文件&quot;input.txt&quot;；打开方式&quot;r&quot;为以只读方式打开一个文件</span><br>    <span class="hljs-type">char</span> c=<span class="hljs-string">&#x27;\0&#x27;</span>, s[<span class="hljs-number">100</span>]=&#123;&#125;;<br>    <span class="hljs-type">int</span> num=<span class="hljs-number">0</span>, ListNum=<span class="hljs-number">0</span>;   <span class="hljs-comment">// num是单词有几个字母 ListNum是有几个单词</span><br>    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">fscanf</span>(in, <span class="hljs-string">&quot;%c&quot;</span>, &amp;c) != EOF)&#123;    <span class="hljs-comment">//</span><br>        <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">isalpha</span>(c))&#123;        <span class="hljs-comment">// 空格，句号，换行</span><br>            <span class="hljs-keyword">if</span>(s[<span class="hljs-number">0</span>]!=<span class="hljs-string">&#x27;\0&#x27;</span>)&#123;<br>                s[num]=<span class="hljs-string">&#x27;\0&#x27;</span>;<br>                <span class="hljs-keyword">if</span>(!find(s, ListNum))&#123;       <span class="hljs-comment">// 没出现过本单词</span><br>                    <span class="hljs-built_in">strcpy</span>(lists[ListNum].s, s);<br>                    lists[ListNum].sum = <span class="hljs-number">1</span>;<br>                    ListNum++;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 初始化</span><br>            num = <span class="hljs-number">0</span>;<br>            <span class="hljs-built_in">strcpy</span>(s, <span class="hljs-string">&quot;\0&quot;</span>);<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            s[num] = <span class="hljs-built_in">tolower</span>(c);<br>            num++;<br>        &#125;<br>    &#125;<br><br>    qsort(lists, ListNum, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> <span class="hljs-built_in">list</span>), cmp);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;ListNum; i++)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s %d\n&quot;</span>, lists[i].s, lists[i].sum);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">char</span> s[], <span class="hljs-type">int</span> ListNum)</span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;ListNum; i++)&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">strcmp</span>(lists[i].s, s) == <span class="hljs-number">0</span>)&#123;<br>            lists[i].sum++;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">cmp</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *pa, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *pb)</span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list</span> *<span class="hljs-title">da</span> =</span> (<span class="hljs-keyword">struct</span> <span class="hljs-built_in">list</span> *)pa;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list</span> *<span class="hljs-title">db</span> =</span> (<span class="hljs-keyword">struct</span> <span class="hljs-built_in">list</span> *)pb;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">strcmp</span>(da-&gt;s, db-&gt;s) &lt; <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// ppt的代码</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#inlcude <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXWORD  32</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> &#123;</span><br>    <span class="hljs-type">char</span> word[MAXWORD];<br>    <span class="hljs-type">int</span> count;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> *<span class="hljs-title">link</span>;</span><br>&#125; ; <span class="hljs-comment">//单词表结构</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> *<span class="hljs-title">Wordlist</span> =</span> <span class="hljs-literal">NULL</span>; <span class="hljs-comment">//单词表头指针</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">getWord</span><span class="hljs-params">(FILE *bfp,<span class="hljs-type">char</span> *w)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">searchWord</span><span class="hljs-params">(<span class="hljs-type">char</span> *w)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">insertWord</span><span class="hljs-params">( <span class="hljs-keyword">struct</span> node *p, <span class="hljs-type">char</span> *w)</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">char</span> filename[<span class="hljs-number">32</span>], word[MAXWORD];<br>    FILE *bfp;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> *<span class="hljs-title">p</span>;</span><br><br>    <span class="hljs-built_in">scanf</span>(“%s”, filename);<br>    <span class="hljs-keyword">if</span>((bfp = fopen(filename, “r”)) == <span class="hljs-literal">NULL</span>)&#123; <span class="hljs-comment">//打开一个文件</span><br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, “%s  can’t open!\n”,filename);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(getWord(bfp,word) != EOF) <span class="hljs-comment">//从文件中读入一个单词</span><br>        <span class="hljs-keyword">if</span>(searchWord(word) == <span class="hljs-number">-1</span>) &#123; <span class="hljs-comment">//在单词表中查找插入单词</span><br>            <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, “Memory is full!\n”);<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br>    <span class="hljs-keyword">for</span>(p=Wordlist; p != <span class="hljs-literal">NULL</span>; p=p-&gt;link) <span class="hljs-comment">//遍历输出单词表</span><br>    <span class="hljs-built_in">printf</span>(“%s  %d\n”, p-&gt;word, p-&gt;count);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br><br><span class="hljs-comment">/*在链表中p结点后插入包含给定单词的结点，同时置次数为1*/</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">insertWord</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> node  *p, <span class="hljs-type">char</span> *w)</span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span>  *<span class="hljs-title">q</span>;</span><br><br>    q = (<span class="hljs-keyword">struct</span> node * )<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> node));<br>    <span class="hljs-keyword">if</span>(q == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">//没有内存空间</span><br>    <span class="hljs-built_in">strcpy</span>(q-&gt;word, w);<br>    q-&gt;count = <span class="hljs-number">1</span>;<br>    q-&gt;link = <span class="hljs-literal">NULL</span>;              <br>    <span class="hljs-keyword">if</span>(Wordlist == <span class="hljs-literal">NULL</span>)&#123; <span class="hljs-comment">//空链表</span><br>    Wordlist = q;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(p == <span class="hljs-literal">NULL</span>)&#123; <span class="hljs-comment">//插入到头结点前</span><br>        q-&gt;link = Wordlist;<br>        Wordlist = q;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        q-&gt;link = p-&gt;link;<br>        p-&gt;link = q;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/*在链表中查找一单词，若找到，则次数加1；否则将该单词插入到有序表中相应位置，同时次数置1*/</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">searchWord</span><span class="hljs-params">(<span class="hljs-type">char</span> *w)</span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span>  <span class="hljs-title">node</span> *<span class="hljs-title">p</span>, *<span class="hljs-title">q</span>=</span><span class="hljs-literal">NULL</span>; <span class="hljs-comment">//q为p的前序结点指针</span><br>    <span class="hljs-keyword">for</span>(p=Wordlist; p != <span class="hljs-literal">NULL</span>; q=p,p=p-&gt;link)&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">strcmp</span>(w, p-&gt;word) &lt; <span class="hljs-number">0</span>)&#123; <br>        <span class="hljs-keyword">break</span>;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-built_in">strcmp</span>(w, p-&gt;word) == <span class="hljs-number">0</span>)&#123;<br>            p-&gt;count++;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span> ;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> insertWord(q, w);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="例4-单向链表链表的合并">例4 单向链表、链表的合并</h3><h4 id="题目-3">题目</h4><ul><li><p>【问题描述】编写一个程序实现任意（最高指数为任意正整数）两个一元多项式相加。</p></li><li><p>【输入形式】从标准输入中读入两行以空格分隔的整数，每一行代表一个多项式，且该多项式中各项的系数均为0或正整数。对于多项式a<sub>n</sub>x<sup>n</sup>+ a<sub>n-1</sub>x<sup>n-1</sup>+ … + a<sub>1</sub>x<sup>1</sup> +a<sub>0</sub>x<sup>0</sup>的输入方法如下：a<sub>n</sub> na<sub>n-1</sub> n-1 … a<sub>1</sub> 1 a<sub>0</sub>0，即相邻两个整数分别表示表达式中一项的系数和指数。在输入中只出现系数不为0的项。</p></li><li><p>【输出形式】将运算结果输出到屏幕。将系数不为0的项按指数从高到低的顺序输出，每次输出其系数和指数，均以一个空格分隔。最后要求换行。</p></li><li><p>【样例输入】</p><p>54 8 2 6 7 3 25 1 78 0</p><p>43 7 4 2 8 1</p></li><li><p>【样例输出】</p><p>54 8 43 7 2 6 7 3 4 2 33 1 78 0</p></li><li><p>【样例说明】输入的两行分别代表如下表达式：</p><p>54x<sup>8</sup> + 2x<sup>6</sup> + 7x<sup>3</sup> + 25x + 78</p><p>43x<sup>7</sup> + 4x<sup>2</sup> + 8x</p><p>其和为 54x<sup>8</sup> + 43x<sup>7</sup> + 2x<sup>6</sup> +7x<sup>3</sup> + 4x<sup>2</sup> + 33x + 78</p></li></ul><h4 id="分析-3">分析</h4><p><img src="/img/LE-ds2/8.jpg" /></p><p><img src="/img/LE-ds2/9.jpg" /></p><h4 id="代码实现-3">代码实现</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//c3_4c.c</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-class"><span class="hljs-keyword">struct</span>  <span class="hljs-title">Node</span> &#123;</span> <span class="hljs-comment">//一个多项式节点结构</span><br>    <span class="hljs-type">int</span> coe; <span class="hljs-comment">//系数</span><br>    <span class="hljs-type">int</span> <span class="hljs-built_in">pow</span>; <span class="hljs-comment">//幂</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">next</span>;</span><br>&#125;; <br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">int</span> a,n;<br>    <span class="hljs-type">char</span> c;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">head</span>,*<span class="hljs-title">p</span>,*<span class="hljs-title">q</span>,*<span class="hljs-title">p0</span>;</span><br>    head = p = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">do</span> &#123;  <span class="hljs-comment">//创建一个链表存放第一个多项式</span><br>        <span class="hljs-built_in">scanf</span>(“%d%d%c”, &amp;a, &amp;n, &amp;c);<br>        q =  (<span class="hljs-keyword">struct</span> Node *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> Node));<br>        q-&gt;coe = a; q-&gt;<span class="hljs-built_in">pow</span> = n; q-&gt;next = <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">NULL</span>)&#123;<br>             head = p = q;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>            p-&gt;next = q;<br>            p = p-&gt;next;<br>    &#125;<br>    &#125; <span class="hljs-keyword">while</span> ( c != ‘\n’);<br>    <span class="hljs-keyword">do</span> &#123; <span class="hljs-comment">//将第二个多项式的每个项插入到第一个多项式链表中</span><br>        <span class="hljs-built_in">scanf</span>(“%d%d%c”, &amp;a, &amp;n, &amp;c);<span class="hljs-comment">//生成第二个多项式的一个节点</span><br>        q = (<span class="hljs-keyword">struct</span> Node *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> Node));<br>        q-&gt;coe = a; q-&gt;<span class="hljs-built_in">pow</span> = n; q-&gt;next = <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">for</span>(p=head; p!=<span class="hljs-literal">NULL</span>; p0=p,p=p-&gt;next) &#123;<br>            <span class="hljs-keyword">if</span>(q-&gt;<span class="hljs-built_in">pow</span> &gt; p-&gt;<span class="hljs-built_in">pow</span>) &#123; <br><span class="hljs-keyword">if</span>(p==head) &#123; q-&gt;next = head; head = q; <span class="hljs-keyword">break</span>; &#125;<span class="hljs-comment">//插入到头节点前</span><br><span class="hljs-keyword">else</span> &#123; q-&gt;next = p; p0-&gt;next = q; <span class="hljs-keyword">break</span>;&#125; <span class="hljs-comment">//将q插入到p前</span><br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(q-&gt;<span class="hljs-built_in">pow</span> == p-&gt;<span class="hljs-built_in">pow</span>)  &#123; p-&gt;coe += q-&gt;coe; <span class="hljs-keyword">break</span>;&#125;<span class="hljs-comment">//指数相等，系数相加</span><br>         &#125;<br>         <span class="hljs-keyword">if</span>(p== <span class="hljs-literal">NULL</span>)  p0-&gt;next = q;   <span class="hljs-comment">//将q插入到尾节点后</span><br>    &#125; <span class="hljs-keyword">while</span> ( c != ‘\n’);<br>    <span class="hljs-keyword">for</span>(p=head; p!=<span class="hljs-literal">NULL</span>; p=p-&gt;next)<span class="hljs-comment">//输出</span><br><span class="hljs-built_in">printf</span>(“%d  %d  “, p-&gt;coe,p-&gt;<span class="hljs-built_in">pow</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="例5-循环链表">例5 循环链表</h3><h4 id="题目-4">题目</h4><p>已知n个人（不妨分别以编号1,2,3,…,n代表）围坐在一张圆桌周围，编号为k的人从1开始报数,数到m的那个人出列，他的下一个人又从1开始继续报数,数到m的那个人出列,…,依此重复下去，直到圆桌周围的人全部出列。</p><h4 id="代码实现-4">代码实现</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ctype.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;math.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">link</span> &#123;</span><br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">link</span> *<span class="hljs-title">next</span>;</span><br>&#125;;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> n, m;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">link</span> *<span class="hljs-title">first</span>=</span><span class="hljs-literal">NULL</span>, *p,*q;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)&#123;<br>        q = (<span class="hljs-keyword">struct</span> link *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> link));<span class="hljs-comment">// 创建一个新的节点（本节点）</span><br>        q-&gt;i = i;<br>        q-&gt;next = <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">if</span>(first == <span class="hljs-literal">NULL</span>)&#123;<span class="hljs-comment">// 第一个节点</span><br>            first = p = q;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            p-&gt;next = q;<span class="hljs-comment">// 使前一个节点指向本节点（当前的最后一个节点）</span><br>            p = p-&gt;next;<span class="hljs-comment">// 指针p继续移动，指向当前的最后一个节点</span><br>        &#125;<br>    &#125;<br>    q-&gt;next = first;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">link</span> *<span class="hljs-title">flag</span> =</span> first;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;n; j++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;m; i++)&#123;<br>            <span class="hljs-keyword">if</span>( i!=m<span class="hljs-number">-1</span> )&#123;<br>                flag = flag-&gt;next;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                p = flag-&gt;next; <span class="hljs-comment">//第3个</span><br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, p-&gt;i);    <span class="hljs-comment">//第3个</span><br>                flag-&gt;next = flag-&gt;next-&gt;next;  <span class="hljs-comment">// 第二个的下一个是第四个</span><br>                <span class="hljs-built_in">free</span>(p);<br>                flag = flag-&gt;next;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="例6-循环链表">例6 循环链表</h3><h4 id="题目-5">题目</h4><p>问题：命令tail用来显示一个文件的最后n行。其格式为：<code>tail [-n] filename</code>其中：n表示需要显示的行数，省略时n的值为10；filename为给定文件名。如，命令<code>tail –20 example.txt</code>表示显示文件example.txt的最后20行。实现该程序，该程序应具有一定的错误处理能力，如能处理非法命令参数和非法文件名。</p><h4 id="分析-4">分析</h4><ol type="1"><li><p>如何得到需要显示的行数和文件名？</p><ul><li><p>使用命令行参数<code>int main(int argc, char *argv[])</code></p></li><li><p>行数<code>n = atoi(argv[1]+1)</code></p></li><li><p>文件名<code>filename = argv[2]</code></p></li></ul></li><li><p>如何得到最后n行？</p><p>使用n个节点的循环链表。链表中始终存放最近读入的n行。首先创建一个空的循环链表；然后再依次读入文件的每一行挂在链表上，最后链表上即为最后n行</p></li></ol><h4 id="代码实现-5">代码实现</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DEFLINES  10</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXLEN    81</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> &#123;</span><br>    <span class="hljs-type">char</span> *line;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">next</span>;</span><br>&#125;;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[ ])</span><br>&#123;<br>    <span class="hljs-type">char</span> curline[MAXLEN],*filename;<br>    <span class="hljs-type">int</span> n = DEFLINES, i;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">first</span>, *<span class="hljs-title">ptr</span>;</span><br>    FILE *fp;<br>    <span class="hljs-keyword">if</span>( argc == <span class="hljs-number">3</span> &amp;&amp; argv[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;-&#x27;</span>) &#123;<span class="hljs-comment">// 命令行输入中指定打印行数时，获取行数及文件名。如tail -20 test.txt</span><br>n = atoi(argv[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>);<br>        filename = argv[<span class="hljs-number">2</span>];<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( argc == <span class="hljs-number">2</span>)&#123;<br>        <span class="hljs-comment">// 命令行输入中没有指定打印行数时，获取文件名，此时行数为缺省10。如tail  test.txt</span><br>        filename = argv[<span class="hljs-number">1</span>];<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Usage: tail [-n] filename\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> (<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-keyword">if</span>((fp = fopen(filename, <span class="hljs-string">&quot;r&quot;</span>)) == <span class="hljs-literal">NULL</span>)&#123;<span class="hljs-comment">// 创建循环链表</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; Cann&#x27;t open file: %s !\n&quot;</span>, filename);<br><span class="hljs-keyword">return</span> (<span class="hljs-number">-1</span>);<br>&#125;<br>    first = ptr = (<span class="hljs-keyword">struct</span> Node *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span> ( <span class="hljs-keyword">struct</span> Node));<br>    first-&gt;line = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>; i&lt;n; i++)&#123;<br>        ptr-&gt;next = (<span class="hljs-keyword">struct</span> Node *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span> ( <span class="hljs-keyword">struct</span> Node));<br>        ptr = ptr-&gt;next;<br>        ptr-&gt;line = <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    ptr-&gt;next = first;<br>    ptr = first;<span class="hljs-comment">// 将链表的最后一个节点指向头节点，以构成一个循环链表。</span><br>    <br><span class="hljs-keyword">while</span>(fgets(curline, MAXLEN, fp) != <span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-keyword">if</span>(ptr-&gt;line != <span class="hljs-literal">NULL</span>)        <span class="hljs-comment">/*链表已经满了，需要释放掉不需要的行*/</span><br><span class="hljs-built_in">free</span>(ptr-&gt;line);<br>        ptr-&gt;line = (<span class="hljs-type">char</span> *) <span class="hljs-built_in">malloc</span> ( <span class="hljs-built_in">strlen</span>(curline)+<span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">strcpy</span>(ptr-&gt;line, curline);<br>        ptr = ptr-&gt;next;<br>&#125;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;n; i++) &#123;<br>        <span class="hljs-keyword">if</span>(ptr-&gt;line != <span class="hljs-literal">NULL</span>)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>,ptr-&gt;line);<br>        ptr = ptr-&gt;next;<br>    &#125;<br>    fclose(fp);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>学习经验</category>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习经验</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【学习经验】exe bat 和 PATH</title>
    <link href="/2024/03/15/LE-dialogue1/"/>
    <url>/2024/03/15/LE-dialogue1/</url>
    
    <content type="html"><![CDATA[<p>试着整理了一下对话内容，写成了对话体的学习笔记（或许会更容易理解一些？毕竟本人在对话发生时就是完全不懂的笨比一个呢（笑）），莫，就当做是和笨比猫娘的对话教学吧！本篇笔记记录了2024年3月12日晚的对话，有关<code>.exe</code>,<code>.bat</code>和<code>PATH</code>。</p><hr /><p>“你知道系统路径PATH是什么东西吗”</p><p>“不知道哦（乖巧）”</p><p>“那你知道可执行程序是什么吗”</p><p>“不知道哦（乖巧）”</p><p><strong>“（清嗓）<code>.exe</code>，也即可执行程序。其中的 exe 表示executable，是能直接运行的二进制文件（人类看不懂）。在命令行可直接用文件名执行。”</strong></p><p>“好喵”</p><p>“那你知道.bat脚本吗”</p><p>“不知道哦（乖巧）”</p><p><strong>“（清嗓）<code>.bat</code>也即批处理程序，其中的 bat 表示batch，是一种脚本，是用字符明文写的（人类也看得懂哦！）。”</strong></p><p>“好喵”</p><p><strong>“你可以写一写试试，比如，在博客文件夹里新建一个<code>update.bat</code>，里面写上<code>hexo clean &amp; hexo g &amp; hexo d</code>，这下只需输入<code>update.bat</code>，系统就会自动执行<code>hexo clean</code>,<code>hexo g</code>和<code>hexo d</code>了！”</strong></p><p>“强大！！！！！！！”</p><p><strong>“但是通常你打一个u按一下tab就出来了”</strong></p><p>“强大！！！！！！！！！！！！！”</p><p>"再比如在桌面打开一个命令行，然后随便输入一个桌面快捷方式的名字再回车<em>（格式：例如Typora的快捷方式为<code>.\Typora.lnk</code>）</em>，就能打开程序，和鼠标点击是一样的，这是<strong>快捷方式</strong>，<strong>是从某地方指向另一个地方的程序</strong>"</p><details><summary>等等，你说猫猫不知道怎么在桌面打开命令行？</summary>桌面空白处右键-在终端打开</details><p>“好喵”</p><p>“但是执行程序是有可见范围的限制的，只能在当前目录下，或者输入相对路径，或者输入绝对路径来执行，否则会找不到文件。但是像<code>gcc -v</code>或者<code>gcc xxx.c -o xxx</code>这种，明明该目录下没有<code>gcc</code>，但还是可以执行（实际上执行的就是某地方的<code>gcc.exe</code>）”</p><p>“等等，所以<code>gcc</code>是什么喵（老实巴交）”</p><p><strong>“是c语言的编译器，可以把.c编译成可执行文件”</strong></p><p>“好喵”</p><p>“所以为什么能执行呢（笑）？”</p><p>“为什么呢……（陷入沉思）”</p><p>“因为<code>gcc</code>在 PATH里面，凡是PATH里的东西，都是全局可见，也就是说你可以<strong>把目录添加到PATH里，让这个目录变成全局可见</strong>”</p><p>“好喵”</p><p>“你按<code>win</code>，然后搜索<code>控制面板</code>，再在控制面板里搜索<code>高级系统</code>，再点击<code>查看高级系统设置</code>，在<code>高级</code>板块下面点击<code>环境变量</code>，在双击<code>系统变量</code>里的<code>PATH</code>，找到如图所示的两行（当然一般都只有一行），打开这个文件夹看看“</p><p><img src="/img/010dialogue1/1.png" /></p><p>“哦哦哦好多东西——”</p><p>“里面是不是有一个<code>gcc.exe</code>”</p><p>“嗯”</p><p>“你可以试试把它删掉”</p><p>“尊嘟（紧张）？我感觉……”</p><p>“你先把文件路径复制一份，一会再加回来”</p><p>“啊不是删文件啊（升天），吓我一跳”</p><p>“我说删系统路径（），不过文件删了也没事，重装下 dev 就好了”</p><p>“（老实巴交）<code>C:\Program Files (x86)\mingw\bin</code>，存一下谢谢”</p><p>“建一个<code>test.c</code>，写个helloworld，然后在命令行输入<code>gcc test.c -o test</code>，你应该还能编译出<code>.exe</code>文件”</p><p>“诶！真的诶——为什么啊（挠头）”</p><p>“因为那两个里面各有一个gcc，删掉一个另一个还能用，把两个都删了才用不了”</p><p>“两条命！！！但是猫猫有九条命，猫猫比它还厉害哦！”</p><p>“诶？啊。反正就是，<strong>PATH里的文件夹，里面的可执行文件、脚本和快捷方式都是全局可见的，而且可以忽略后缀执行</strong>”</p><p>“好喵”</p><p>“所以你不需要打<code>gcc.exe</code>”</p><p>“对哦”</p><p>“但是把 PATH 删掉以后去执行，就需要加<code>.exe</code>”</p><p>“好喵，那我是不是可以吧 typora 也加到 PATH里面，这样就不用<code>.lnk</code>了”</p><p>“错误的，你应该加的是Desktop，顺带一提，在桌面右键打开终端，就能显示你桌面的绝对路径”</p><p>（许久以后）</p><p>“你不会真去试了吧”</p><p>“没有哦，在摸鱼看番（戳手）”</p><p>（完）</p>]]></content>
    
    
    <categories>
      
      <category>学习经验</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习经验</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【数据结构】ds笔记1-数据结构基础</title>
    <link href="/2024/03/09/LE-ds1/"/>
    <url>/2024/03/09/LE-ds1/</url>
    
    <content type="html"><![CDATA[<h2 id="说在前面">说在前面</h2><p>本篇笔记总结了<strong>DSPv2b_1(数据结构基础) forstudent</strong>内的相关内容，将ppt分为两个部分————知识点和例题，其中例题并不包括ppt中的全部内容（删减了一些本人认为难度较小的例题，才...才不是因为懒得写呢）。如果代码中出现了全角字符，请原谅喵，因为有的代码我没有cv到clion里面去检查（戳手）。以及本人学艺不精，只是一边看着ppt一边敲敲改改，如有疏漏，欢迎提出喵~o(=∩ω∩= )m</p><hr /><h2 id="知识点">知识点</h2><h3 id="递归">2.1 递归</h3><p>使用递归的基本法则：</p><ul><li>基本实例(basecase)：问题的解包含一个或多个基本实例，如<code>0! = 1</code>，它们<strong>不用递归就能直接求解</strong></li><li>递进(makingprogress)：问题的解可以简化为包含比当前问题更简单一步的问题的解，并且最终问题可归结到基本实例，如<code>n! = n*(n-1)!</code>；或者一个问题可分解为若干子问题来解决（分治），如树遍历或快速排序等，但最终也要归结到基本实例。即<strong>递归调用必须朝着产生基本实例的方向推进</strong></li></ul><h3 id="数组">2.2 数组</h3><h4 id="数组作为函数参数">2.2.1 数组作为函数参数</h4><ul><li><p>数组作为参数传递给函数，实际上传递的是<strong>数组的首地址</strong>，即他们是一个数组，在函数中对数组的操作会在函数外有所体现。</p></li><li><p>非字符数组作为参数时，函数的定义形式（字符数组还需要在形参中置顶数组元素个数）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">fun</span><span class="hljs-params">(<span class="hljs-type">int</span> <span class="hljs-built_in">array</span>[], <span class="hljs-type">int</span> size)</span>&#123;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>数组作为参数时，函数的调用形式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">int</span> a[<span class="hljs-number">10</span>];<br>    ...<br>    fun(a, <span class="hljs-number">10</span>);<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="二维多维数组使用">2.2.2 二维（多维）数组使用</h4><ul><li><p>如果把一个二维数组作为参数，则在函数定义中，形参数组的说明中必须指明列的数目，而行的数目可空着不写。以此类推，对于三维及以上数组，其作为参数传递时，形参说明中<strong>只能省略最内层的维数</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">( )</span>&#123;<br><span class="hljs-type">float</span> a[<span class="hljs-number">4</span>][<span class="hljs-number">3</span>], b[<span class="hljs-number">3</span>][<span class="hljs-number">4</span>], c[<span class="hljs-number">4</span>][<span class="hljs-number">4</span>];<br>    ...<br>fun(a, b, c);<br>    ...<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">fun</span><span class="hljs-params">(<span class="hljs-type">float</span> x[ ][<span class="hljs-number">3</span>], <span class="hljs-type">float</span> y[ ][<span class="hljs-number">4</span>], <span class="hljs-type">float</span> z[ ][<span class="hljs-number">4</span>])</span>&#123;<br>...<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="指针">2.3 指针</h3><h4 id="指针-1">2.3.1 指针</h4><ol type="1"><li><p>指针变量的定义：<code>&lt;类型&gt; *&lt;变量&gt;</code>，例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> *pc;<span class="hljs-comment">//指向字符型的指针</span><br><span class="hljs-type">char</span> *acp[<span class="hljs-number">10</span>];<span class="hljs-comment">//由指向字符的指针构成的数组，即指针数组</span><br><span class="hljs-type">char</span> (*pac)[<span class="hljs-number">10</span>];<span class="hljs-comment">//指向字符数组的指针，即数组指针</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">f</span><span class="hljs-params">( )</span>;<span class="hljs-comment">//返回值为整型的函数</span><br><span class="hljs-type">int</span> *<span class="hljs-title function_">fpi</span><span class="hljs-params">( )</span>;<span class="hljs-comment">//返回值为指向整型的指针的函数，即指针函数</span><br><span class="hljs-type">int</span> (*pfi)();<span class="hljs-comment">//指向一个返回值为整型的函数的指针，函数指针</span><br></code></pre></td></tr></table></figure></li><li><p>指针运算符：<code>&amp;</code>取地址运算符，<code>*</code>取内容运算符。</p></li><li><p><strong>使用任何指针变量之前必须先给它赋一个所指合法具体对象的地址值。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//错误示范</span><br><span class="hljs-type">int</span> x = <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> *px;<br>*px = x;<br><span class="hljs-comment">//错误示范</span><br><span class="hljs-type">char</span> *<span class="hljs-built_in">string</span>;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, <span class="hljs-built_in">string</span>);<br><span class="hljs-built_in">strcpy</span>(<span class="hljs-built_in">string</span>, <span class="hljs-string">&quot;Hello&quot;</span>);<br></code></pre></td></tr></table></figure></li><li><p>如何使一个指针指向一个具体对象：</p><ol type="1"><li><p>通过<code>&amp;</code>运算符使指针指向某个对象。如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> n=<span class="hljs-number">10</span>, *px;<br>px = &amp;n;<br></code></pre></td></tr></table></figure></li><li><p>将另一个同类型的（已指向具体对象的）指针赋给它以获得值，两指针指向同一对象。如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> n=<span class="hljs-number">10</span>, *px,*py;<br><span class="hljs-type">char</span> str[<span class="hljs-number">10</span>],*pstr;<br>px = &amp;n; <br>py = px;<br>pstr = str; <br></code></pre></td></tr></table></figure></li><li><p>使用<code>malloc</code>或<code>alloc</code>等函数给指针分配一个具体空间（动态存储分配）。如:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">p = (<span class="hljs-type">char</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">strlen</span>(s)+<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><details><summary><p>动态内存管理（malloc与free）</p></summary><ul type="disc"><li><p>在C语言中可以使用标准库函数malloc动态为指针变量申请一块内存空间（以字节为单位）（用于初始化指针变量），并返回该空间首地址。</p></li><li><p>函数原型为：<code>void * malloc ( size_t size );</code></p></li><li><p>使用malloc初始化指针变量的常见用法：</p><pre><code class="hljs">char *s; int *intptr;s = (char *)malloc(32); // s指向大小为32个字节（字符）的空间s = (char *)malloc(strlen(p)+1);// s指向能正好存放字符串p的空间intptr = (int *)malloc(sizeof(int)*10);// ptr指向能存放10个整型元素的空间</code></pre></li><li><p>使用malloc申请到的动态空间在不用时应使用函数free释放。如，free(s);</p></li><li><p>使用malloc和free函数要用：</p><pre><code class="hljs">#include stdlib.h</code></pre></li></ul></details></li></ol></li><li><p>指针运算</p><ol type="1"><li><p>指针和整型量可以进行+-。其结果同指针<strong>所指对象类型</strong>相关。如果p是指向数组某一元素的指针，则p+1及p++为数组下一元素的指针。</p></li><li><p>指向同一数组成员的指针可以相减。其结果为两指针间相差元素的个数。如，p指向数组第一个元素，q指向数组最后一个元素,则q– p+1表示数组长度。</p></li><li><p>指向同一类型的指针可以赋值。</p></li><li><p>指向同一类型的指针可以进行==, &gt;,&lt;等关系运算。用于比较地址</p></li><li><p><strong>指针不能相加</strong>。如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> a[<span class="hljs-number">100</span>], *start = &amp;a, *end = &amp;a[<span class="hljs-number">99</span>];<br>mid = (low+high)/<span class="hljs-number">2</span>;<span class="hljs-comment">//错误！！！</span><br>mid = low+(high-low)/<span class="hljs-number">2</span>;<span class="hljs-comment">//正确</span><br></code></pre></td></tr></table></figure></li><li><p>tips：</p><ol type="1"><li><p><code>p++</code>和<code>p+1</code>的区别；</p><p>p++结果为p指向下一元素；p+1结果为下一元素的指针，但p本身不变。</p></li><li><p><code>y = (*px)++</code>和<code>y = *px++</code>的区别；</p><p><code>(*px)++为</code>先取<code>px</code>所指对象内容进行运算，然后对其加1；<code>px++</code>为先取<code>px</code>所指对象内容进行运算，然后指针<code>px</code>加1，其等价于<code>*(px++)</code>。</p></li></ol></li></ol></li><li><p>指针作为函数参数</p><ol type="1"><li><p>c语言中函数的参数传递方式为“传值”，使得函数调用不会改变实参变量的值。但可以<strong>将指针作为函数参数来改变实参内容</strong>，如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//通过函数swap交换实参变量a和b</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">swap</span> <span class="hljs-params">( <span class="hljs-type">int</span> *px, <span class="hljs-type">int</span> *py)</span>&#123;<br>    <span class="hljs-type">int</span> temp;<br>    temp = *px;  <span class="hljs-comment">/*间接取*/</span><br>    *px = *py;<span class="hljs-comment">/*间接取，间接存*/</span><br>    *py = temp;<span class="hljs-comment">/*间接存*/</span><br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">( )</span>&#123;<br>    <span class="hljs-type">int</span> a =<span class="hljs-number">2</span>, b = <span class="hljs-number">3</span>;<br>    swap ( &amp;a, &amp;b);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>因此，<strong>在一定要改变实参变量内容时，应把函数的形参显式地说明为指向实参变量（类型）的指针，相应地调用时应该用变量的地址值作为参数。</strong></p></li></ol></li></ol><h4 id="函数指针">2.3.2 函数指针</h4><ul><li><p>简介</p><ul><li><p>即指向函数的指针</p></li><li><p>函数指针说明形式为<code>类型 (*标识符)( );</code>，如<code>int(*fp)();</code></p></li><li><p>辨析：<code>int(*fp)();</code>与<code>int *fp();</code>不同，前者是一个指针，指向一个返回值类型是<code>int</code>的函数；后者是一个函数，其返回值的类型是<code>int*</code></p></li><li><p>函数指针的复制：<code>函数指针 = 函数名</code>，（在c语言中，函数名是作为该函数的指针来处理，也就是说<strong>函数名就是指向函数的指针</strong>）</p></li><li><p>在c语言中，通过函数指针调用一个函数时，<code>(*fnptr)(2000)</code>与<code>fnptr(2000)</code>用法等价</p></li><li><p>例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">leapyear</span><span class="hljs-params">( <span class="hljs-type">int</span> year)</span>;<br>main( )&#123;<br>    <span class="hljs-type">int</span> (*fnptr)( ),result;<br>    fnptr = leapyear;<br>    result = (*fnptr)(<span class="hljs-number">2000</span>);<span class="hljs-comment">// 与调用leapyear(2000)完全等价</span><br>&#125;<br> <br><span class="hljs-type">int</span> <span class="hljs-title function_">leapyear</span><span class="hljs-params">( <span class="hljs-type">int</span> year)</span>&#123;<br>    <span class="hljs-keyword">if</span>(((year % <span class="hljs-number">4</span> == <span class="hljs-number">0</span>) &amp;&amp; (year % <span class="hljs-number">100</span> != <span class="hljs-number">0</span>)) || (year % <span class="hljs-number">400</span>) == <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> ( <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">else</span><br>    <span class="hljs-keyword">return</span> ( <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>作用</p><ul><li><p>函数派遣表</p><p>指向函数的指针（函数指针）通常用于设计所谓函数派遣表（dispatch）,即通过下标数字来访问某个函数，这常见于菜单系统的设计中。如，<code>index</code>变量为0~9，当<code>index</code>为0时，调用函数<code>fn0</code>；为1时调用函数<code>fn1</code>…，则可设计如下：</p><p><code>int fn0( ), fn1( ), fn2( ), … fn9( );</code></p><p><code>int (*dispatch[ ])( ) = &#123;fn0, fn1, fn2, … fn9&#125;;</code></p><p>调用形式为：</p><p><code>(*dispatch[index])( );</code></p><ul><li><p>例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">New</span><span class="hljs-params">()</span>, <span class="hljs-title function_">Open</span><span class="hljs-params">()</span>, <span class="hljs-title function_">Save</span><span class="hljs-params">()</span>…;<br><span class="hljs-type">int</span> (*menu[ ])( ) = &#123;New, Open, Save, … Close &#125;;<br></code></pre></td></tr></table></figure></li><li><p><img src="/img/009ds1/1.png" /></p></li></ul></li><li><p>作为函数参数：函数作为参数传递，可扩展一个函数的功能。</p></li></ul></li></ul><h4 id="指针与数组">2.3.3 指针与数组</h4><ol type="1"><li><p>数组名是常量，指针是变量，即可以写<code>pa = a</code>，但不能写<code>a = pa; a++</code>等，即<strong>数组一经定义，其首地址将不允许改变。</strong></p></li><li><p>字符串常量、字符串数组、字符串指针</p><ol type="1"><li><p>对于字符串常量，可以把它看成一个无名字符数组，C编译程序会自动为它分配一个空间来存放这个常量，字符串常量的值是指向这个无名数组的第一个字符的指针，其类型是字符指针。所以，<code>printf("a constant character string\n");</code>传递给函数的是字符串第一个字符的指针。</p></li><li><p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> a[]=<span class="hljs-string">&quot;hello&quot;</span>, *p=<span class="hljs-string">&quot;hello&quot;</span>;<br>a[<span class="hljs-number">0</span>] = ‘b’;   <span class="hljs-comment">/*正确 */</span><br>*p = ‘b’;  <span class="hljs-comment">/*错误，不能修改常量值*/</span><br></code></pre></td></tr></table></figure></p></li><li><p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span>  *char_ptr, word[<span class="hljs-number">20</span>];<br>char_ptr = <span class="hljs-string">&quot;point to me&quot;</span>;<br><span class="hljs-comment">// 正确，把字符串常量第一个字符指针赋给指针变量。</span><br>word = <span class="hljs-string">&quot;you can&#x27;t do this&quot;</span>;<br><span class="hljs-comment">// 错误，正确做法为:strcpy(word, &quot;…&quot;);</span><br></code></pre></td></tr></table></figure></p></li></ol></li><li><p>在函数定义中形参形式<code>char s[ ]</code>和<code>char *s</code>完全等价，即指向某类型的指针与该类型没有指明长度的数组是同一回事。用哪个取决于在函数里表达式的写法。</p></li><li><p>两种方式拷贝指针</p><ol type="1"><li><p>通过<strong>指针</strong>赋值，如:<code>px = py</code>;两指针指向同一对象。该拷贝的最大负作用是当其中的一个指针被释放，另一个指针将成为无所指对象（指针悬挂）。(Shallowcopy-浅拷贝)</p><p>通过<strong>strcpy</strong>函数，如：<code>strcpy(px, py);</code>这种拷贝使得两个指针所指内容相同，但存放在各自的空间中。(Deepcopy-深拷贝)</p></li></ol></li><li><p>数组与指针</p><ol type="1"><li><p>数组可以按指针方式使用，如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> a[<span class="hljs-number">10</span>],*p; <br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;n; i++) <br>    …*(a+i)…;<br></code></pre></td></tr></table></figure></li><li><p>指针亦可按数组形式访问，如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">fun</span><span class="hljs-params">(<span class="hljs-type">int</span> p[])</span>&#123; <br>…p[i]…<br></code></pre></td></tr></table></figure></li></ol></li></ol><h4 id="指针数组">2.3.4 指针数组</h4><ol type="1"><li><p>指针数组与二维数组的区别</p><ol type="1"><li><p>二者存储形式不同，但初始化形式与使用方式上是相通的，如：无论是指针数组，还是二维数组，下面两种形式访问的都是同一个元素，结果都是字符串”Friday”中的字符’y’：<code>(days[5]+5) = days[5][5] = ‘y’</code>；无论是二维数组还是指针数组，<code>days[5]</code>访问的都是字符串(即指向字符串的指针)”Friday</p></li><li><p>使用指针数组来存放不同长度的字符串可以节省存贮空间</p></li><li><p>二维数组</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 定义</span><br><span class="hljs-type">char</span> days[<span class="hljs-number">7</span>][<span class="hljs-number">10</span>] = &#123;<span class="hljs-string">&quot;Sunday&quot;</span>, <span class="hljs-string">&quot;Monday&quot;</span>, <span class="hljs-string">&quot;Tuesday&quot;</span>, <span class="hljs-string">&quot;Wednesday&quot;</span>, <span class="hljs-string">&quot;Thursday&quot;</span>, <span class="hljs-string">&quot;Friday&quot;</span>, <span class="hljs-string">&quot;Saturday&quot;</span>&#125;;<br><br><span class="hljs-comment">// 使用方式</span><br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, days[i]);<br>gets(days[i]);<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">strcmp</span>(days[i], <span class="hljs-string">&quot;Friday&quot;</span>)==<span class="hljs-number">0</span>)&#123;&#125;<br><br><span class="hljs-comment">// 存储形式</span><br></code></pre></td></tr></table></figure><p><img src="/img/009ds1/2.png" /></p></li><li><p>指针数组</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 定义</span><br><span class="hljs-type">char</span> *days[<span class="hljs-number">7</span>] = &#123;<span class="hljs-string">&quot;Sunday&quot;</span>, <span class="hljs-string">&quot;Monday&quot;</span>, <span class="hljs-string">&quot;Tuesday&quot;</span>, <span class="hljs-string">&quot;Wednesday&quot;</span>, <span class="hljs-string">&quot;Thursday&quot;</span>, <span class="hljs-string">&quot;Friday&quot;</span>, <span class="hljs-string">&quot;Saturday&quot;</span>&#125;;<br><br><span class="hljs-comment">// 使用方式</span><br><span class="hljs-type">char</span> buf[<span class="hljs-number">32</span>],*days[<span class="hljs-number">7</span>];<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, buf);<br>days[i] = (<span class="hljs-type">char</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">strlen</span>(buf)+<span class="hljs-number">1</span>);<br><span class="hljs-built_in">strcpy</span>(days[i], buf);<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">strcmp</span>(days[i], buf)==<span class="hljs-number">0</span>)<br><br><span class="hljs-comment">// 存储形式</span><br></code></pre></td></tr></table></figure><p><img src="/img/009ds1/3.png" /></p></li></ol></li></ol><h3 id="malloc和free">2.4 malloc和free</h3><ol type="1"><li><p>函数原型：<code>void *malloc(size_t size);</code></p></li><li><p>使用<code>malloc</code>初始化指针变量的常见用法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> *s; <br><span class="hljs-type">int</span> *intptr;<br>s = (<span class="hljs-type">char</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">32</span>); <span class="hljs-comment">/* s指向大小为32个字节（字符）的空间*/</span><br>s = (<span class="hljs-type">char</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">strlen</span>(p)+<span class="hljs-number">1</span>);<span class="hljs-comment">/* s指向能正好存放字符串p的空间*/</span><br>intptr = (<span class="hljs-type">int</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>)*<span class="hljs-number">10</span>);<span class="hljs-comment">/* ptr指向能存放10个整型元素的空间*/</span><br></code></pre></td></tr></table></figure></li><li><p>使用<code>malloc</code>申请到的动态空间在不用时应使用函数<code>free</code>释放，如<code>free(s);</code></p></li><li><p>使用<code>malloc</code>和<code>free</code>函数要用<code>#include &lt;stdio.h&gt;</code></p></li></ol><h3 id="简单文件操作">2.5 简单文件操作</h3><ol type="1"><li><p>打开文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c">FILE *in, *out;<br><span class="hljs-comment">// 为读写文件定义文件指针</span><br>in = fopen(<span class="hljs-string">&quot;input.txt&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>);<br><span class="hljs-comment">// 为输入打开一个给定文件&quot;input.txt&quot;；打开方式&quot;r&quot;为以只读方式打开一个文件</span><br>out = fopen(<span class="hljs-string">&quot;output.txt&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>);<br><span class="hljs-comment">// 为输出打开一个给定文件&quot;output.txt&quot;；打开方式&quot;w&quot;为以只写方式打开一个文件</span><br><br><span class="hljs-comment">// 文件input.txt和output.txt位于与该执行程序.exe文件同一目录下（在vs code中则与工程在同一目录下）</span><br></code></pre></td></tr></table></figure></li><li><p>读写文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c">c = fgetc(in);<br><span class="hljs-comment">// 从文件(input.txt)中读入一个字符</span><br>fputc(c, out);<br><span class="hljs-comment">// 输出一个字符到文件(output.txt)中</span><br>fgets(s, n, in);<br><span class="hljs-comment">// 从文件in中读入一行（最多读入n-1个字符），放入s字符数组中。返回s或NULL</span><br><span class="hljs-comment">// 会在s最后加换行字符</span><br><span class="hljs-built_in">fputs</span>(s, out);<br><span class="hljs-comment">// 把字符串s（不一定含\n）写入文件out中，返回非负数或EOF</span><br><span class="hljs-comment">// 不在输出后加换行字符</span><br><span class="hljs-built_in">fscanf</span>(in, <span class="hljs-string">&quot;%d&quot;</span>, &amp;score);<br><span class="hljs-comment">// 从文件in中读入一个整数</span><br><span class="hljs-built_in">fprintf</span>(out, <span class="hljs-string">&quot;%d\n&quot;</span>, score);<br><span class="hljs-comment">// 输出一个整数到文件out中</span><br></code></pre></td></tr></table></figure></li><li><p>关闭文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">fclose(in);<br><span class="hljs-comment">// 关闭文件input.txt</span><br>fclose(out);<br><span class="hljs-comment">// 关闭文件output.txt</span><br></code></pre></td></tr></table></figure></li><li><p>示例：将一个文件内容拷贝到另一个文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">int</span> c;<br>    FILE *in, *out;<br>    <br>    in = fopen(<span class="hljs-string">&quot;input.txt&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>);<br>    out = fopen(<span class="hljs-string">&quot;output.txt&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>);<br>    <span class="hljs-keyword">while</span>((c = fgetc(in)) != EOF)&#123;<br>        fputc(c, out);<br>    &#125;<br>    <br>    fclose(in);<br>    fclose(out);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="define宏定义">2.6 define宏定义</h3><ol type="1"><li>定义常量，如：<code>#define PI 3.14159</code></li><li>定义宏函数，<code>#define 标识符(参数1, 参数2,...)</code>，如：<code>#define max(A,B) ((A)&gt;(B)?(A):(B))</code><ul><li>宏定义名与参数间不能有空格，如：<code>max(A,B)</code></li><li>参数应该用括号括起来，如：<code>(A)&gt;(B)?(A):(B)</code></li></ul></li></ol><h3 id="typedef类型定义">2.7 typedef类型定义</h3><ul><li><p>语法格式：<code>typedef 原类型名 新类型名</code>，如：<code>typedef int LENGTH;</code>；其变量说明为<code>LENGTH len, maxlen;</code>，这与<code>int len, maxlen;</code>等价</p></li><li><p>常见用法</p><ul><li><p>一些安全关键的软件中需要在程序中明确运行环境的数据类型长度，如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> INT32;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">short</span> INT16<br>INT32 port0,port1;<br></code></pre></td></tr></table></figure></li><li><p>用来定义结构类型，如FILE就是一个用typedef定义的结构类型。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">iobuf</span> &#123;</span><br>    <span class="hljs-type">char</span> *_ptr;<br>    <span class="hljs-type">int</span> _cnt;<br>    <span class="hljs-type">char</span> *_base;<br>    <span class="hljs-type">int</span> _flag;<br>    <span class="hljs-type">int</span> _file;<br>    <span class="hljs-type">int</span> _charbuf;<br>    <span class="hljs-type">int</span> _bufsiz;<br>    <span class="hljs-type">char</span> *_tmpfname;<br>&#125;;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">iobuf</span> <span class="hljs-title">FILE</span>;</span><br></code></pre></td></tr></table></figure></li><li><p>数据结构中用来定义一个链表结点类型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> &#123;</span><br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> *<span class="hljs-title">next</span>;</span><br>&#125; *Nodeptr;<br>Nodeptr <span class="hljs-built_in">list</span>, p;<span class="hljs-comment">//struct node list, p;</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>必须强调，typedef说明均不产生新的数据类型，也不定义存储单元，它只是给已有的类型又增添了新的类型名，没有产生新的语义，即用这种方法所说明的变量与明确指出说明的那些变量有相同的性质。</p></li></ul><h3 id="内存操作函数">2.8 内存操作函数</h3><ol type="1"><li><p><code>memcpy()</code></p><ul><li><p>函数原型：<code>void *memcpy (void *dest, const void *src, size_t num);</code></p></li><li><p>参数说明：</p><ul><li>函数<code>memcpy</code>从<code>src</code>位置开始向后复制<code>num</code>个字节的数据到<code>dest</code>的内存位置。</li><li><code>void *dest</code>代表目标的内存地址，<code>const void *src</code>代表源内存地址。<code>size_t</code>即<code>unsigned int</code>类型。注意：<code>num</code>代表的是要拷贝的<strong>字节数</strong>，而非元素个数。</li><li>该函数的返回值类型也为<code>void *</code>，也即只返回目标地址的数值。</li><li>该函数用于实现<strong>没有重叠部分内存的内存数据拷贝</strong>。如果source和destination有任何的重叠，复制的结果都是未定义的。</li></ul></li><li><p>使用示例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-type">int</span> arr1[] = &#123; <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span> &#125;;<br><span class="hljs-type">int</span> arr2[<span class="hljs-number">10</span>] = &#123; <span class="hljs-number">0</span> &#125;;<br><span class="hljs-built_in">memcpy</span>(arr2, arr1, <span class="hljs-number">20</span>);    <span class="hljs-comment">//拷贝20个字节，即5个int元素</span><br> <br><span class="hljs-type">float</span> arr3[] = &#123; <span class="hljs-number">1.0f</span>,<span class="hljs-number">2.0f</span>,<span class="hljs-number">3.0f</span>,<span class="hljs-number">4.0f</span> &#125;;<br><span class="hljs-type">float</span> arr4[<span class="hljs-number">5</span>] = &#123; <span class="hljs-number">0.0</span> &#125;;<br><span class="hljs-built_in">memcpy</span>(arr3, arr4, <span class="hljs-number">8</span>);    <span class="hljs-comment">//拷贝8个字节，即2个float元素</span><br> <br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//示例来自cplusplus官网</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br> <br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-type">char</span> name[<span class="hljs-number">40</span>];<br>    <span class="hljs-type">int</span> age;<br>&#125; person, person_copy;<br> <br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span> <span class="hljs-params">()</span>&#123;<br><span class="hljs-type">char</span> myname[] = <span class="hljs-string">&quot;Pierre de Fermat&quot;</span>;    <span class="hljs-comment">//定义一个字符串</span><br> <br>    <span class="hljs-comment">/* 用 memcpy 拷贝字符串 */</span><br>    <span class="hljs-comment">//每个char类型占一个字节，因此要拷贝的字节数即strlen()+1，加一是因为要把&#x27;\0&#x27;也拷贝过去。</span><br><span class="hljs-built_in">memcpy</span> ( person.name, myname, <span class="hljs-built_in">strlen</span>(myname)+<span class="hljs-number">1</span> );<br>person.age = <span class="hljs-number">46</span>;<br> <br><span class="hljs-comment">/* 用 memcpy 拷贝结构体 */</span><br><span class="hljs-comment">//sizeof操作符，可以直接得到结构体变量在内存中所占的字节数。</span><br><span class="hljs-built_in">memcpy</span> ( &amp;person_copy, &amp;person, <span class="hljs-keyword">sizeof</span>(person) );<br>  <br>    <span class="hljs-comment">//直接完成了结构体之间的数据拷贝：从person拷贝到person_cpy，不用手动转义，非常方便</span><br>    <span class="hljs-built_in">printf</span> (<span class="hljs-string">&quot;person_copy: %s, %d \n&quot;</span>, person_copy.name, person_copy.age );<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p><code>memmove()</code></p><ul><li><p>函数原型：<code>void *memmove(void *dest, const void *src, size_t num );</code></p></li><li><p>参数说明</p><ul><li>该函数的参数与返回值类型与<code>memcpy()</code>函数相同。该函数同样用作从<code>src</code>位置开始向后复制<code>num</code>个字节数据到<code>dest</code>的内存位置。</li><li><code>memmove()</code>函数与<code>memcpy()</code>函数主要的区别在于<code>memmove()</code><strong>可以进行有内存重叠的数据拷贝</strong>，而<code>memcpy()</code>绝对不能。</li></ul></li><li><p>使用示例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//示例来自cplusplus官网</span><br> <br><span class="hljs-comment">/* memmove example */</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span> <span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">char</span> str[] = <span class="hljs-string">&quot;memmove can be very useful......&quot;</span>;<br>    memmove (str+<span class="hljs-number">20</span>,str+<span class="hljs-number">15</span>,<span class="hljs-number">11</span>);<br>    <span class="hljs-comment">//表示将包括str+15向后11个字节的内容移动到str+20位置</span><br>    <span class="hljs-built_in">puts</span> (str);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p><code>memset()</code></p><ul><li><p>函数原型：<code>void *memset(void *ptr, int value, size_t num );</code></p></li><li><p>参数说明</p><ul><li>第一个参数<code>ptr</code>为指针类型，表示要进行操作的内存的地址。如要对数组<code>arr</code>进行内存内容设置，则该参数的值为<code>ar</code>r。</li><li>第二个参数<code>value</code>为要设定的内存的值。该值的数据类型是<code>int</code>型，但<code>char</code>值也是可以的。</li><li>第三个参数<code>num</code>为要设置值的内存的字节数。注意：是<strong>字节数</strong>，而不是元素的个数。如要改变两个<code>int</code>类型的值，<code>num</code>应为8，而不是2。</li></ul></li><li><p>使用示例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//示例来自cplusplus官网</span><br><br><span class="hljs-comment">/* memset example */</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span> <span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">char</span> str[] = <span class="hljs-string">&quot;almost every programmer should know memset!&quot;</span>;<br>    <span class="hljs-built_in">memset</span> (str,<span class="hljs-string">&#x27;-&#x27;</span>,<span class="hljs-number">6</span>);<br>    <span class="hljs-comment">//表示将从str开始，包括str向后6个字节的内存内容置为&#x27;-&#x27;</span><br>    <span class="hljs-built_in">puts</span> (str);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">//输出：------ every programmer should know memset!</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p><code>memcmp()</code></p><ul><li><p>函数原型：<code>int memcmp(const void *ptr1, const void *ptr2, size_t num );</code></p></li><li><p>参数说明</p><ul><li>比较<code>ptr1</code>和<code>ptr2</code>指针开始的<code>num</code>个字节。</li><li><code>ptr1</code>和<code>ptr2</code>分别是两个代表要比较的内存空间（一般是数组）的指针。</li><li><code>num</code>是要比较的<strong>字节数</strong>。（注意：不是元素个数）。</li><li>返回值为整型，若返回值&gt;0，则ptr1的内存长度大于ptr2；若返回值==0，则二者相等；若返回值&lt;0，则ptr1的内存长度小于ptr2</li></ul></li><li><p>使用示例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//示例来自cplusplus官网</span><br> <br><span class="hljs-comment">/* memcmp example */</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br> <br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span> <span class="hljs-params">()</span>&#123;<br>    <span class="hljs-comment">//创建两个要用作比较的数组</span><br>    <span class="hljs-type">char</span> buffer1[] = <span class="hljs-string">&quot;DWgaOtP12df0&quot;</span>;    <br>    <span class="hljs-type">char</span> buffer2[] = <span class="hljs-string">&quot;DWGAOTP12DF0&quot;</span>;<br><br>    <span class="hljs-comment">//接受比较的结果</span><br>    <span class="hljs-type">int</span> n;<br><br>    <span class="hljs-comment">//要比较的字节数为buffer1的长度</span><br>    <span class="hljs-comment">//两字符串的比较可以用strcmp(buffer1,buffer2)函数实现，原理大致相同。</span><br>    n = <span class="hljs-built_in">memcmp</span> ( buffer1, buffer2, <span class="hljs-keyword">sizeof</span>(buffer1) );<br><br>    <span class="hljs-keyword">if</span> (n&gt;<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">printf</span> (<span class="hljs-string">&quot;&#x27;%s&#x27; is greater than &#x27;%s&#x27;.\n&quot;</span>,buffer1,buffer2);<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(n&lt;<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">printf</span> (<span class="hljs-string">&quot;&#x27;%s&#x27; is less than &#x27;%s&#x27;.\n&quot;</span>,buffer1,buffer2);<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-built_in">printf</span> (<span class="hljs-string">&quot;&#x27;%s&#x27; is the same as &#x27;%s&#x27;.\n&quot;</span>,buffer1,buffer2);<br>&#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ol><h3 id="命令行参数">2.9 命令行参数</h3><ol type="1"><li>在c语言中，主函数main还可以带有参数。形式如下：<code>int main(int argc, char * argv[])</code>或<code>int main(int argc, char **argv)</code>。其中<code>argc</code>为包含命令本身在内的参数个数，<code>argv</code>为指针数组，数组元素为指向各参数（包括命令本身）的指针。</li></ol><p><img src="/img/009ds1/4.png" /></p><ol start="2" type="1"><li>执行程序的方式<ol type="1"><li>法1：打开程序所在目录，把<code>chengxuming.exe</code>改为<code>chengxuming</code>，右键空白区域，在终端打开，输入<code>chengxuming &lt;参数1&gt; &lt;参数2&gt;</code>。</li><li>法2：<code>cwenjianming.c</code>，右键空白区域，在终端打开，输入<code>gcc cwenjianming.c -o chengxuming</code>，就会在相同目录下生成<code>.exe</code>文件，然后输入<code>.\chengxuming.exe &lt;参数1&gt; &lt;参数2&gt;</code></li></ol></li></ol><h3 id="struct结构体">2.10 struct结构体</h3><ul><li><p>说明形式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> 结构类型名&#123;</span><br>    成员类型 成员名;<br>    成员类型 成员名;<br>    ...<br>&#125;<br><br><span class="hljs-comment">// 例：</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">date</span> &#123;</span><br>    <span class="hljs-type">int</span> day;<br>    <span class="hljs-type">int</span> month;<br>    <span class="hljs-type">int</span> year;<br>    <span class="hljs-type">int</span> yearday;<br>    <span class="hljs-type">char</span> mon_name[<span class="hljs-number">4</span>];<br>&#125;;<br><br><span class="hljs-comment">// 结构说明只是定义了一个结构的模版（template）或称为结构的框架，而并未定义结构的对象，也不为它分配存储空间。有了这样的结构模板说明后，一个结构变量可定义为：</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">date</span> <span class="hljs-title">d1</span>, <span class="hljs-title">d2</span>;</span><br><span class="hljs-comment">// 定义时关键字struct和结构名date都不可少，可以把struct date一起看作是某种类型说明符（结构类型）</span><br><br></code></pre></td></tr></table></figure></li><li><p>结构变量的说明方式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 1 无结构名</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>  …<br>&#125; s1, s2;<br><span class="hljs-comment">// 一般适用于说明本地变量。</span><br><br><span class="hljs-comment">// 2 有结构名</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">date</span> &#123;</span><br>  …<br>&#125; ;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">date</span> <span class="hljs-title">s1</span>, <span class="hljs-title">s2</span>;</span><br><span class="hljs-comment">//通常用来说明外部结构变量，或需要在多个函数中用到的相同的结构的变量。</span><br><br><span class="hljs-comment">// 3 使用typedef</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>  …<br>&#125; DATE;<br>DATE s1, s2, *pd, ad[<span class="hljs-number">10</span>];<br><span class="hljs-comment">// 使用typedef定义结构类型名后，结构变量的定义（或说明）就更简洁了。</span><br></code></pre></td></tr></table></figure></li><li><p>结构嵌套：结构成员可以是其他的结构类型，也可以是指向本身结构的指针，但<code>不能是该结构本身，因为它无法确定此结构的边界</code>，如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">keyword</span>&#123;</span><br>    <span class="hljs-type">char</span> *name;<br>    <span class="hljs-type">int</span> count;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">keyword</span> <span class="hljs-title">next</span>;</span><span class="hljs-comment">// 错误！！！！！！</span><br>&#125; *base;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">keyword</span>&#123;</span><br><span class="hljs-type">char</span> *name;<br><span class="hljs-type">int</span> count;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">keyword</span> *<span class="hljs-title">next</span>;</span><span class="hljs-comment">//正确！！！！！！！！！！！！！</span><br>&#125; *base;<br><br></code></pre></td></tr></table></figure></li><li><p>初始化</p><ul><li>结构变量在定义时可以初始化，如：<code>struct date d = &#123;27, 12, 1984, 361, "Dec"&#125;;</code></li><li>结构变量亦可通过整体赋值来初始化，如：<code>struct date d1,d2 = &#123;27, 12, 1984, 361, "Dec"&#125;;d1 = d2;</code></li></ul></li><li><p>结构成员的引用</p><ul><li><p><strong>结构变量名.成员名</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">person</span> <span class="hljs-title">emp</span>;</span><br>emp.birthday.year = <span class="hljs-number">1970</span>;<br>emp.salary = <span class="hljs-number">5000</span>;<br></code></pre></td></tr></table></figure></li><li><p><strong>指向结构变量的指针-&gt;成员名</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">date</span> *<span class="hljs-title">pd</span>, <span class="hljs-title">d</span>;</span><span class="hljs-comment">// pd是指向struct date的指针</span><br>pd = &amp;d;<span class="hljs-comment">// 指向一个已有结构变量</span><br><span class="hljs-comment">//或 pd = (struct date *) malloc(sizeof(struct date));</span><br>pd-&gt;year = <span class="hljs-number">1958</span>;<span class="hljs-comment">// 与 (*pd).year = 1958 等价</span><br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="自引用结构">2.11 自引用结构</h3><h4 id="动态数据的组织与存储方式">2.11.1（动态）数据的组织与存储方式</h4><ul><li>顺序组织，如数组<ul><li>需要连续空间</li><li>数据项的插入或删除操作需要移动大量数据</li></ul></li><li>非顺序（动态）组织，如链表，二叉树等<ul><li>不需要连续空间</li><li>数据项的插入或删除操作非常简单</li></ul></li></ul><h4 id="自引用结构成员">2.11.2 自引用结构成员</h4><p>分为两部分：各种实际数据成员+一个或几个指向自身结构的指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 通常结构</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Type</span> &#123;</span><br>    data_member;<span class="hljs-comment">// 如 int n;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Type</span> *<span class="hljs-title">link</span>;</span><br>&#125;;<br></code></pre></td></tr></table></figure><p><img src="/img/009ds1/5.png" /></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 链表结构</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span>  <span class="hljs-title">word</span> &#123;</span><br>    <span class="hljs-type">char</span> *name;<br>    <span class="hljs-type">int</span> count;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">word</span> *<span class="hljs-title">next</span>;</span><br>&#125; *base;<br></code></pre></td></tr></table></figure><p><img src="/img/009ds1/6.png" /></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 二叉树结构</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tnode</span> &#123;</span><br>    <span class="hljs-type">char</span> *word;<br>    <span class="hljs-type">int</span> count;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tnode</span> *<span class="hljs-title">left</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tnode</span> *<span class="hljs-title">right</span>;</span><br>&#125; *root;<br></code></pre></td></tr></table></figure><p><img src="/img/009ds1/7.png" /></p><h4 id="注意事项">2.11.3 注意事项</h4><ol type="1"><li><p>应用：<strong>动态数组结构，如链表、树等特别适用于数组项数不确定的数据的组织</strong>。</p></li><li><p>使用时应有一个头指针（<code>first</code>,<code>head</code>,<code>root</code>），并使用<code>malloc</code>为每个节点分配空间,如：<code>first = p = (struct node *)malloc(sizeof(struct node));</code></p></li><li><p>使用时，通常使用如下方式将节点链接起来：</p><p><code>p-&gt;next = (struct node *)malloc(sizeof(struct node));</code></p><p><code>p = p-&gt;next;</code></p></li><li><p>使用时要注意(头)节点丢失问题，不要轻易移动<strong>头节点</strong>位置。</p></li></ol><h3 id="链表的生成">2.12 链表的生成</h3><h4 id="链表结构">2.12.1 链表结构</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">link</span> &#123;</span><br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">link</span> *<span class="hljs-title">next</span>;</span><br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="创建链表">2.12.2 创建链表</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">link</span> *<span class="hljs-title">first</span>=</span><span class="hljs-literal">NULL</span>, *p,*q;<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt; <span class="hljs-number">10</span>; i++)&#123;<br>    q = (<span class="hljs-keyword">struct</span> link *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> link));<span class="hljs-comment">// 创建一个新的节点（本节点）</span><br>    q-&gt;n = i; <br>    q-&gt;next = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">if</span>(first == <span class="hljs-literal">NULL</span>)&#123;<span class="hljs-comment">// 第一个节点</span><br>        first = p = q;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        p-&gt;next = q;<span class="hljs-comment">// 使前一个节点指向本节点（当前的最后一个节点）</span><br>        p = p-&gt;next;<span class="hljs-comment">// 指针p继续移动，指向当前的最后一个节点</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="插入和删除节点">2.12.3 插入和删除节点</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 1 在p后插入q</span><br>q-&gt;next = p-&gt;next;<br>p-&gt;next = q;<br><span class="hljs-comment">// 2 删除p的下一节点</span><br>q = p-&gt;next;<br>p-&gt;next = p-&gt;next-&gt;next;<br><span class="hljs-built_in">free</span>(q);<br></code></pre></td></tr></table></figure><p><img src="/img/009ds1/8.png" /></p><p><img src="/img/009ds1/9.png" /></p><h3 id="union联合">2.13 union联合</h3><ul><li><p>定义形式：<code>union 联合名 &#123;分量表&#125; 联合变量名；</code></p></li><li><p>用途：在一个位置存储多个不会同时用到的数据，用于节省内存</p></li><li><p>形象的理解（来自文心一言）：想象一下，你有一个房间，这个房间可以当作书房使用，也可以当作卧室使用，但不能同时是书房和卧室。<code>union</code>就类似于这个房间，你可以在其中存放书（一种数据类型），也可以在其中放床（另一种数据类型），但你不能同时放书和床。</p></li><li><p>示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">union</span> <span class="hljs-title">Data</span> &#123;</span>  <br>    <span class="hljs-type">int</span> i;  <br>    <span class="hljs-type">float</span> f;  <br>    <span class="hljs-type">char</span> str[<span class="hljs-number">20</span>];  <br>&#125;;  <br>  <br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-class"><span class="hljs-keyword">union</span> <span class="hljs-title">Data</span> <span class="hljs-title">data</span>;</span>  <br>  <br>    data.i = <span class="hljs-number">10</span>; <span class="hljs-comment">// 此时，union中存储的是一个整数  </span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, data.i); <span class="hljs-comment">// 输出：10  </span><br>  <br>    data.f = <span class="hljs-number">220.5</span>; <span class="hljs-comment">// 现在，union中存储的是一个浮点数，之前存储的整数被覆盖了  </span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%f\n&quot;</span>, data.f); <span class="hljs-comment">// 输出：220.500000  </span><br>  <br>    <span class="hljs-built_in">strcpy</span>(data.str, <span class="hljs-string">&quot;Hello&quot;</span>); <span class="hljs-comment">// 现在，union中存储的是一个字符串，之前存储的浮点数被覆盖了  </span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, data.str); <span class="hljs-comment">// 输出：Hello  </span><br>  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>注意</p><ul><li><code>union</code>中的所有成员都共享同一块内存空间。也就是说，无论<code>union</code>中有多少个成员，它总是只占用最大的那个成员所需的内存空间。当你给<code>union</code>的一个成员赋值时，其他成员的值就会被覆盖，因为它们都是指向同一块内存的。</li><li><code>union</code>不提供类型安全性，所以使用时要特别小心，确保你知道当前<code>union</code>中存储的是什么类型的数据。</li></ul></li></ul><h3 id="其他">2.14 其他</h3><ul><li><code>#include &lt;stdlib.h&gt;</code>里面有<code>int atoi(char s[]);</code>，可以把字符串转化为相应整数。</li></ul><h2 id="例题">例题</h2><h3 id="例1-简单文件操作宏定义">例1 简单文件操作、宏定义</h3><h4 id="问题提出">1 问题提出</h4><details><summary>问题</summary><ul type="disc"><li>问题描述：从文件中查找包含给定字符串的行。</li><li>输入形式：从标准输入中分两行分别输入被查找的文件及要查找的字符串（中间不含空格）。</li><li>输出形式：在屏幕上输出文件中包含给定字符串的行。</li><li>样例输入：<pre><code class="hljs">在键盘输入如下文件名及字符串:test.txtthe文件 test.txt 内容如下：Now is the timefor all goodmen to come to the aidof their party</code></pre></li><li>样例输出：<pre><code class="hljs">屏幕输出为this is the timemen to come to the aidof their party</code></pre></li></ul></details><details><summary>问题分析</summary><ul type="disc"><li>数据结构设计：分析问题描述，显然需要三个字符数组变量，分别存放文件名、要查找的字符串及从文件中读入的行。<br/>char filename[32], str[81], line[1024];<br/>（一个文件名长度通常不超过32个字符；屏幕上一行通常显示80个字符；而1024是一般文件的最大物理行长度。当然这些取决于具体系统实现。）</li><li>数据输入 <br/>用scanf("%s", )读入文件名和要查找的串<br/>从文件中读入一行用fgets()，不用fscanf()是因为fscanf遇空行停止</li><li>数据处理<br/>从所读入的一行中查找给定的字符串（即从一个字符串中查找另一个字符串）。可用一个单独的函数index实现在一个字符串中查找另一个字符串。</li></ul></details><h4 id="代码实现">2 代码实现</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXLINE  1024</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">index</span><span class="hljs-params">(<span class="hljs-type">char</span> s[ ], <span class="hljs-type">char</span> t[ ])</span>;<span class="hljs-comment">// 找子串</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">( )</span>&#123;<br><span class="hljs-type">char</span> filename[<span class="hljs-number">64</span>], s[<span class="hljs-number">81</span>], line[MAXLINE];<br>FILE *fp;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, filename);<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, s);<br>    <span class="hljs-comment">// 由于打开一个文件的操作可能失败，因此需要判断fopen的返回值，进行错误处理</span><br><span class="hljs-keyword">if</span>((fp = fopen(filename, <span class="hljs-string">&quot;r&quot;</span>)) == <span class="hljs-literal">NULL</span>)&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Can&#x27;t open file %s!\n&quot;</span>, filename);<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br>    <br><span class="hljs-keyword">while</span>(fgets(line, MAXLINE<span class="hljs-number">-1</span>, fp) != <span class="hljs-literal">NULL</span>)<br><span class="hljs-keyword">if</span>(index(line, s) &gt;= <span class="hljs-number">0</span>)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>, line);<br>       <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">index</span><span class="hljs-params">(<span class="hljs-type">char</span> s[ ], <span class="hljs-type">char</span> t[ ])</span>&#123;<br><span class="hljs-type">int</span> i, j, k;<br><span class="hljs-keyword">for</span>(i =<span class="hljs-number">0</span>; s[i] != ‘\<span class="hljs-number">0</span>’; i++)&#123;<br><span class="hljs-keyword">for</span>(j=i,k=<span class="hljs-number">0</span>;t[k]!=‘\<span class="hljs-number">0</span>’&amp;&amp;s[j]==t[k]; j++,k++)<br>;<br>        <span class="hljs-keyword">if</span>(t[k] == ‘\<span class="hljs-number">0</span>’)&#123;<span class="hljs-comment">//找到了</span><br>            <span class="hljs-keyword">return</span> (i);<br>        &#125;<br>&#125;<br><span class="hljs-keyword">return</span> (<span class="hljs-number">-1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="拓展">3 拓展</h4><ol type="1"><li><p>字符串查找函数时间复杂度为O(n*m)，n为源串的长度，m为要查找的串的长度</p><ol type="1"><li><p>KMP算法</p></li><li><p>另一种字符串查找算法（只需一层循环）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">index</span><span class="hljs-params">(<span class="hljs-type">char</span> s[], <span class="hljs-type">char</span> t[])</span><br>&#123;<br>    <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>, j=<span class="hljs-number">0</span>; <span class="hljs-comment">//设置查找的起始位置</span><br>    <span class="hljs-keyword">while</span>(s[i] != ‘\<span class="hljs-number">0</span>’ &amp;&amp; t[j] != ‘\<span class="hljs-number">0</span>’) &#123;<br>        <span class="hljs-keyword">if</span>(s[i] == t[j])&#123;<span class="hljs-comment">//若字符相等，继续查找下一个字符</span><br>            i++; j++;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//若字符不等，则s中退回到上次查找开始的下一个位置</span><br>            i = i-j+<span class="hljs-number">1</span>;<br>            j = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(t[j] == ‘\<span class="hljs-number">0</span>’)&#123;<span class="hljs-comment">//查找到字符串t，返回t在s中的起始位置</span><br>        <span class="hljs-keyword">return</span> i-j;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure></li></ol></li><li><p>区分了大小写：</p><p>使用<code>tolower()</code>函数实现大小写无关的字符串查找（头文件或者宏定义或者单独写一个函数）</p></li><li><p>其他功能的实现</p><ol type="1"><li>如何查找子字符串的最后一次出现？</li><li>如何查找一个字符串在一个文件中的所有出现？（如office软件中的查找功能）</li><li>如何查找给定串并用另一个替换串？（如office软件中的替换功能）</li><li>如何实现模糊查找？（如UNIX命令grep）</li></ol></li></ol><h3 id="例2-二维多维数组">例2 二维、多维数组</h3><h4 id="问题提出-1">1 问题提出</h4><details><summary>问题</summary><ul type="disc"><li><pre>用一个二维方阵（最小为3X3，最大为50X50）表示一片海域。方阵中的元素只由0和1组成。1表示海岸线。计算由海岸线围起来的小岛面积（即：由1围起来的区域中0的个数）。如下图所示8X8方阵表示的小岛面积为9：0 0 0 0 0 0 0 00 0 0 0 1 0 0 00 0 0 1 0 1 0 00 0 1 0 0 0 1 00 1 0 0 0 1 0 00 1 0 1 0 1 0 00 1 1 0 1 0 0 00 0 0 0 0 0 0 0上述方阵表示的海域满足下面两个要求：    1、小岛只有一个。    2、用1表示的海岸线是封闭的，但有可能是凸的，也有可能是凹的。</pre></li><li>输入形式：先从标准输入中输入方阵的阶数，然后从下一行开始输入方阵的元素（只会0或1）。</li><li>输出形式：在标准输出上输出用整数表示的小岛面积。。</li><li>样例输入：<pre>80 0 0 0 0 0 0 00 0 0 0 1 0 0 00 0 0 1 0 1 0 00 0 1 0 0 0 1 00 1 0 0 0 1 0 00 1 0 1 0 1 0 00 1 1 0 1 0 0 00 0 0 0 0 0 0 0</pre></li><li>样例输出：9</li></ul><p></detail></p><h4 id="代码实现-1">2 代码实现</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">int</span> a[<span class="hljs-number">50</span>][<span class="hljs-number">50</span>]=&#123;<span class="hljs-number">0</span>&#125;, i, j, k, c, n, area=<span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 读入</span><br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>;j&lt;n;j++)&#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i][j]);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>;j&lt;n;j++)&#123;<br>            c=<span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">if</span>(a[i][j]==<span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">for</span>(k=i;k&lt;n;k++)&#123;<span class="hljs-comment">//下面有1</span><br>                    <span class="hljs-keyword">if</span>(a[k][j]==<span class="hljs-number">1</span>) &#123;<br>                        c++; <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">for</span>(k=i;k&gt;=<span class="hljs-number">0</span>;k--)&#123;<span class="hljs-comment">//上面有1</span><br>                    <span class="hljs-keyword">if</span>(a[k][j]==<span class="hljs-number">1</span>) &#123;<br>                        c++; <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">for</span>(k=j;k&lt;n;k++)&#123;<span class="hljs-comment">//右面有1</span><br>                    <span class="hljs-keyword">if</span>(a[i][k]==<span class="hljs-number">1</span>) &#123;<br>                        c++; <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">for</span>(k=j;k&gt;=<span class="hljs-number">0</span>;k--)&#123;<span class="hljs-comment">//左面有1</span><br>                    <span class="hljs-keyword">if</span>(a[i][k]==<span class="hljs-number">1</span>)&#123;<br>                        c++; <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(c==<span class="hljs-number">4</span>)&#123;<span class="hljs-comment">//如果上下左右都有1，这个0就被包了起来</span><br>                area++;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,area);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="例3">例3</h3><h4 id="问题">1 问题</h4><p>输出输入行中的最长行。</p><h4 id="代码实现-2">2 代码实现</h4><ul><li>法1：数组方式实现</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXLINE1024</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">str_len</span><span class="hljs-params">(<span class="hljs-type">char</span> s[ ])</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">str_copy</span><span class="hljs-params">(<span class="hljs-type">char</span> s[ ], <span class="hljs-type">char</span> t[ ])</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">( )</span>&#123;<span class="hljs-comment">/* find longest line */</span><br>    <span class="hljs-type">int</span> len;<span class="hljs-comment">// current line length</span><br>    <span class="hljs-type">int</span> max;<span class="hljs-comment">// maximum length seen so far</span><br>    <span class="hljs-type">char</span> line[MAXLINE];<span class="hljs-comment">// current input line</span><br>    <span class="hljs-type">char</span> save[MAXLINE];<span class="hljs-comment">// longest line saved</span><br>    max = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>( gets(line)  != <span class="hljs-literal">NULL</span> )&#123;<br>len = str_len(line);<br>    <span class="hljs-keyword">if</span>( len &gt; max ) &#123;<br>    max = len;<br>    str_copy(save, line);<br>    &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>( max &gt; <span class="hljs-number">0</span>)<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>, save);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">str_len</span><span class="hljs-params">(<span class="hljs-type">char</span> s[ ])</span>&#123;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(s[i] != ‘\<span class="hljs-number">0</span>’)<br>        i++;<br>    <span class="hljs-keyword">return</span> i;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">str_copy</span><span class="hljs-params">(<span class="hljs-type">char</span> s[ ], <span class="hljs-type">char</span> t[ ])</span>&#123;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>((s[i] =t[i] )!= ‘\<span class="hljs-number">0</span>’)<br>        i++;<br> &#125;<br></code></pre></td></tr></table></figure><ul><li>法2：指针方式实现</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXLINE1024</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">str_len</span><span class="hljs-params">(<span class="hljs-type">char</span> s[])</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">( )</span>&#123; <span class="hljs-comment">// find longest line</span><br><span class="hljs-type">int</span> len, max;<br>    <span class="hljs-comment">// current length and maximum length seen so far</span><br><span class="hljs-type">char</span> *curptr, *saveptr,*tmp;<br>    <span class="hljs-comment">//current  line pointer and longest line pointer saved</span><br>    <span class="hljs-type">char</span>  save1[MAXLINE], save2[MAXLINE];<br>    curptr = &amp;save1[<span class="hljs-number">0</span>];<br>    saveptr= &amp;save2[<span class="hljs-number">0</span>];  <br>    max = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>( gets(curptr)  != <span class="hljs-literal">NULL</span> )&#123;<br>        len = str_len(curptr);<br>        <span class="hljs-keyword">if</span>( len &gt; max ) &#123;<br>            max = len;<br>            tmp = curptr;<br>            curptr = saveptr;<br>            saveptr = tmp; <br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>( max &gt; <span class="hljs-number">0</span>)<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>, saveptr);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="例4-命令行参数">例4 命令行参数</h3><h4 id="问题-1">1 问题</h4><p>实现一个命令<code>echo</code>，其将命令后的正文串显示在屏幕上，如：<code>C&gt; echo hello world</code>屏幕输出：<code>hello world</code></p><h4 id="代码实现-3">2 代码实现</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 法1</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">( <span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[ ])</span>&#123;<br>   <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;argc; i++)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s &quot;</span>, argv[i]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 法2</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[ ])</span>&#123;<br>    <span class="hljs-keyword">while</span>(--argc &gt; <span class="hljs-number">0</span>)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s &quot;</span>, *++argv);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="例5-结构体">例5 结构体</h3><h4 id="问题-2">1 问题</h4><p>实现复数运算</p><h4 id="代码实现-4">2 代码实现</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">complex</span>&#123;</span><br>    <span class="hljs-type">float</span>  real;<br>    <span class="hljs-type">float</span>  imag;<br>&#125;;<br><span class="hljs-keyword">struct</span> <span class="hljs-type">complex</span> <span class="hljs-title function_">addComplex</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> <span class="hljs-type">complex</span> c1, <span class="hljs-keyword">struct</span> <span class="hljs-type">complex</span> c2)</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">complex</span> <span class="hljs-title">c1</span>, <span class="hljs-title">c2</span>, <span class="hljs-title">c3</span>;</span><br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%f %f %f %f&quot;</span>, &amp;c1.real, &amp;c1.imag, &amp;c2.real, &amp;c2.imag);<br>    c3 = addComplex(c1, c2);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;(%.2f, %.2f) + (%.2f, %.2f) = (%.2f, %.2f)\n&quot;</span>, c1.real, c1.imag, c2.real, c2.imag, c3.real, c3.imag);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-type">complex</span> <span class="hljs-title function_">addComplex</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> <span class="hljs-type">complex</span> c1, <span class="hljs-keyword">struct</span> <span class="hljs-type">complex</span> c2)</span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">complex</span> <span class="hljs-title">tmp</span>;</span><br>    tmp.real = c1.real + c2.real;<br>    tmp.imag = c1.imag + c2.imag;<br>    <span class="hljs-keyword">return</span> tmp;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="例6-结构体">例6 结构体</h3><h4 id="问题-3">1 问题</h4><p>编写一个程序，统计输入中C语言每个关键字的出现次数。</p><h4 id="算法设计">2 算法设计</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 1 定义一个结构说明泳衣表示关键字与其出现次数</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Key</span> &#123;</span><br>    <span class="hljs-type">char</span> *keyword;<br>    <span class="hljs-type">int</span> count;<br>&#125;;<br><span class="hljs-comment">// 2 关键字表的组织：使用一个有序的结构数组来存放关键字表及关键字出现次数：</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Key</span> <span class="hljs-title">Keytab</span>[ ] =</span> &#123;<br>    <span class="hljs-string">&quot;auto&quot;</span>, <span class="hljs-number">0</span>,<br>    <span class="hljs-string">&quot;break&quot;</span>,<span class="hljs-number">0</span>,<br>    <span class="hljs-string">&quot;case&quot;</span>, <span class="hljs-number">0</span>,<br>    …<br>    <span class="hljs-string">&quot;while&quot;</span>, <span class="hljs-number">0</span><br>&#125;;<br><span class="hljs-comment">// 3 主要算法</span><br>While (仍有新单词读入)<br>    If(在关键字表中查找并找到输入的单词)<br>        相应关键字次数加<span class="hljs-number">1</span>；<br>输出关键字及出现次数；<br><span class="hljs-comment">// 3.1 读入新单词</span><br>        <span class="hljs-comment">// 设函数</span><br>    <span class="hljs-type">char</span> <span class="hljs-title function_">getWord</span><span class="hljs-params">(<span class="hljs-type">char</span> word[],<span class="hljs-type">int</span> lim)</span>；<br>        <span class="hljs-comment">// 从标准输入中读入一个长度不超过lim-1的单词，并返回单词类型。</span><br><span class="hljs-comment">// 为何不用scanf的%s来读?如：while(scanf(‘%s”, word) &gt; 0)…</span><br><span class="hljs-comment">// 3.2 查找输入的单词</span><br>    <span class="hljs-comment">// 设函数</span><br><span class="hljs-keyword">struct</span> Key *<span class="hljs-title function_">binary</span><span class="hljs-params">(<span class="hljs-type">char</span> *word, <span class="hljs-keyword">struct</span> Key tab[ ], <span class="hljs-type">int</span> n)</span><br><span class="hljs-comment">// 在关键字表tab中查找单词word是否存在。如果找到，则返回其出现位置。n为关键字表的长度（关键字个数）。</span><br>    <span class="hljs-comment">// 3.3 输出关键词及出现次数</span><br>        <span class="hljs-comment">// 设函数</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">printKey</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> Key tab[ ], <span class="hljs-type">int</span> n)</span> <br><span class="hljs-comment">// 输出关键字及出现次数。</span><br><span class="hljs-comment">// 4 二分查找</span><br></code></pre></td></tr></table></figure><h4 id="代码实现-5">3 代码实现</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Key</span> &#123;</span><br>    <span class="hljs-type">char</span> *keyword;<br>    <span class="hljs-type">int</span> keycount;<br>&#125; Keytab[ ] = &#123;<br>    <span class="hljs-string">&quot;auto&quot;</span>, <span class="hljs-number">0</span>,<br>    <span class="hljs-string">&quot;break&quot;</span>, <span class="hljs-number">0</span>,<br>    <span class="hljs-string">&quot;case&quot;</span>, <span class="hljs-number">0</span>,<br>    …<br>    <span class="hljs-string">&quot;while&quot;</span>, <span class="hljs-number">0</span><br>&#125;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXWORD 20</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NKEYS (sizeof(Keytab) / sizeof(struct Key))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LETTER ‘a’</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DIGIT ‘0’</span><br><span class="hljs-keyword">struct</span> Key *<span class="hljs-title function_">binary</span><span class="hljs-params">(<span class="hljs-type">char</span> *word, <span class="hljs-keyword">struct</span> Key tab[ ], <span class="hljs-type">int</span> n)</span>;<br><span class="hljs-type">char</span> <span class="hljs-title function_">getword</span><span class="hljs-params">(<span class="hljs-type">char</span> *w, <span class="hljs-type">int</span> lim)</span>;<br><span class="hljs-type">char</span> <span class="hljs-title function_">type</span><span class="hljs-params">( <span class="hljs-type">int</span> c)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">printKey</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> Key tab[ ], <span class="hljs-type">int</span> n)</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">( )</span>&#123;<span class="hljs-comment">// count  C keyword</span><br>    <span class="hljs-type">int</span> t;<br>    <span class="hljs-type">char</span> word[MAXWORD];<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Key</span> *<span class="hljs-title">p</span>;</span><br><br>    <span class="hljs-keyword">while</span>((t = getword(word, MAXWORD)) != EOF)<br>        <span class="hljs-keyword">if</span>(t == LETTER)<span class="hljs-comment">//如果读到词汇返回LETTER</span><br>            <span class="hljs-keyword">if</span>((p = binary(word, Keytab, NKEYS)) != <span class="hljs-literal">NULL</span>)<br>            p-&gt;keycount++;<br>    printKey(keytab, NKEYS);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-keyword">struct</span> Key *<span class="hljs-title function_">binary</span><span class="hljs-params">(<span class="hljs-type">char</span> *word, <span class="hljs-keyword">struct</span> Key tab[ ], <span class="hljs-type">int</span> n)</span>&#123;<br>    <span class="hljs-type">int</span> cond;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Key</span> *<span class="hljs-title">low</span> =</span> &amp;tab[<span class="hljs-number">0</span>];<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Key</span> *<span class="hljs-title">high</span> =</span> &amp;tab[n<span class="hljs-number">-1</span>];<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Key</span> *<span class="hljs-title">mid</span>;</span><br><br>    <span class="hljs-keyword">while</span>(low &lt;= high)&#123;<br>        mid = low + (high – low) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>((cond = <span class="hljs-built_in">strcmp</span>(word, mid-&gt;keyword)) &lt; <span class="hljs-number">0</span>)<br>        high = mid – <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( cond &gt; <span class="hljs-number">0</span>)<br>        low = mid + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> (mid);<br>    &#125;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-literal">NULL</span>);<br>&#125;<br><br><span class="hljs-type">char</span> <span class="hljs-title function_">getword</span><span class="hljs-params">(<span class="hljs-type">char</span> *w, <span class="hljs-type">int</span> lim)</span>&#123;<br>    <span class="hljs-type">int</span> c, t;<br><br>    <span class="hljs-keyword">if</span>(type(c = *w++ = getchar( )) != LETTER)&#123;<br>        *w = ‘\<span class="hljs-number">0</span>’;<br>        <span class="hljs-keyword">return</span> (c);<br>    &#125;<br>    <span class="hljs-keyword">while</span>(--lim &gt; <span class="hljs-number">0</span>) &#123;<br>        t = type(c = *w++ = getchar( ));<br>        <span class="hljs-keyword">if</span>( t != LETTER &amp;&amp; t != DIGIT)&#123;<br>            ungetc(c);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    *(w<span class="hljs-number">-1</span>) = ‘\<span class="hljs-number">0</span>’;<br>    <span class="hljs-keyword">return</span> (LETTER);<br>&#125;<br><span class="hljs-comment">/* 从文件中识别出标识符</span><br><span class="hljs-comment">int getword(char s[], FILE *fp)&#123;</span><br><span class="hljs-comment">    int c,  i = 0;</span><br><span class="hljs-comment">    while(type(c=fgetc(fp))!= LETTER)  </span><br><span class="hljs-comment">        if(c == EOF) return c;  </span><br><span class="hljs-comment">        else continue;</span><br><span class="hljs-comment">    s[i++] = c;</span><br><span class="hljs-comment">    while((c=fgetc(fp))!=EOF)&#123;</span><br><span class="hljs-comment">         if(type(c)!=LETTER&amp;&amp;type(c)!=DIGTH)</span><br><span class="hljs-comment">              break; </span><br><span class="hljs-comment">         s[i++] = c;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">    s[i]=&#x27;\0&#x27;;</span><br><span class="hljs-comment">    return 1;</span><br><span class="hljs-comment">&#125; */</span><br><br><span class="hljs-type">char</span> <span class="hljs-title function_">type</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span>&#123;<span class="hljs-comment">// return type of ASCII character</span><br>    <span class="hljs-keyword">if</span>( c &gt;= ‘a’ &amp;&amp; c &lt;= ‘z’ || c &gt;= ‘A’ &amp;&amp; c &lt;= ‘Z’)<br>    <span class="hljs-keyword">return</span> ( LETTER );<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( c &gt;= ‘<span class="hljs-number">0</span>’ &amp;&amp; c &lt;= ‘<span class="hljs-number">9</span>’)<br>    <span class="hljs-keyword">return</span> ( DIGIT );<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> (c);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">printKey</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> Key tab[ ], <span class="hljs-type">int</span> n)</span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Key</span> *<span class="hljs-title">p</span>;</span><br>        <span class="hljs-keyword">for</span>(p=tab, p &lt; tab+n; p++)<br>            <span class="hljs-keyword">if</span>(p-&gt;keycount &gt; <span class="hljs-number">0</span>)<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%4d%s\n&quot;</span>, p-&gt;keycount, p-&gt;keyword);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="例7-结构体二分查找">例7 结构体、二分查找</h3><h4 id="问题-4">1 问题</h4><ul><li><p>问题描述</p><p>从文件<code>sorelist.txt</code>中读入最多不超过50个学生的学生信息（包括空格隔开的学号、姓名、成绩信息，以学号从低到高排序），分别按姓名和成绩排序输出学生信息到文件<code>sorelist_sort.txt</code>中。</p></li><li><p>输入形式</p><p>从文件scorelist.txt中读入最多不超过50个学生的学生信息：第一行为学生人数；后面每一行为空格隔开的学生学号、姓名、成绩，其中学号和成绩为整数，姓名为字符串，不超过5位英文字符。</p></li><li><p>输出形式</p><p>以姓名顺序（按字典顺序）及成绩顺序（从高到低）将学生信息分别输出到文件<code>scorelist_sort.txt</code>中，中间用一空行分隔。每行输出一位学生的信息，其中学号占3位，姓名（英文）占6位，成绩占5位。</p></li><li><p>输入样例</p><p>文件<code>scorelist.txt</code>中内容为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c4">1 Li  86<br>2 Zhao 90<br>3 Wang 87<br>4 Zhang 56<br></code></pre></td></tr></table></figure></li><li><p>输出样例</p><p>程序运行后，文件<code>scorelist_sort.txt</code>中内容为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">1</span> Li <span class="hljs-number">86</span><br><span class="hljs-number">3</span> Wang <span class="hljs-number">87</span><br><span class="hljs-number">4</span> Zhang <span class="hljs-number">56</span><br><span class="hljs-number">2</span> Zhao <span class="hljs-number">90</span><br><br><span class="hljs-number">2</span> Zhao <span class="hljs-number">90</span><br><span class="hljs-number">3</span> Wang <span class="hljs-number">87</span><br><span class="hljs-number">1</span> Li <span class="hljs-number">86</span><br><span class="hljs-number">4</span> Zhang <span class="hljs-number">56</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="代码实现-6">2 代码实现</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Student</span> &#123;</span><br><span class="hljs-type">int</span> no;<br><span class="hljs-type">char</span> name[<span class="hljs-number">6</span>];<br><span class="hljs-type">int</span> score;<br>&#125;;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">sortbyName</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> Student <span class="hljs-built_in">array</span>[], <span class="hljs-type">int</span> n)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">sortbyScore</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> Student <span class="hljs-built_in">array</span>[], <span class="hljs-type">int</span> n)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">(FILE *fp, <span class="hljs-keyword">struct</span> Student <span class="hljs-built_in">array</span>[], <span class="hljs-type">int</span> n)</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    FILE *in, *out;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Student</span> <span class="hljs-title">info</span>[51];</span><br>    <span class="hljs-type">int</span> i,n;<br>    <span class="hljs-comment">// 输入文件打开失败</span><br>    <span class="hljs-keyword">if</span>((in=fopen(<span class="hljs-string">&quot;scorelist.txt&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>)) == <span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Cann&#x27;t Open file scorelist.txt!\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-comment">// 输出文件打开失败</span><br>    <span class="hljs-keyword">if</span>((out=fopen(<span class="hljs-string">&quot;scorelist_sort.txt&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>)) == <span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Cann&#x27;t Open file scorelist_sort.txt!\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-comment">// 读入</span><br>    <span class="hljs-built_in">fscanf</span>(in,<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>        <span class="hljs-built_in">fscanf</span>(in, <span class="hljs-string">&quot;%d%s%d&quot;</span>, &amp;info[i].no, info[i].name, &amp;info[i].score);<br>    <span class="hljs-comment">// 姓名顺序输出</span><br>    sortbyName(info, n);<br>    print(out, info, n);<br>    <span class="hljs-comment">// 成绩顺序输出</span><br>    sortbyScore(info, n);<br>    print(out,info, n);<br>    <span class="hljs-comment">// 关闭文件</span><br>    fclose(in);<br>    fclose(out);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">sortbyName</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> Student <span class="hljs-built_in">array</span>[], <span class="hljs-type">int</span> n)</span>&#123;<span class="hljs-comment">// 姓名顺序</span><br>    <span class="hljs-type">int</span> i, j;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Student</span> <span class="hljs-title">tmp</span>;</span><br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;n; i++)&#123;<br>        <span class="hljs-keyword">for</span>(j=i; j&lt;n; j++)&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">strcmp</span>(<span class="hljs-built_in">array</span>[i].name,<span class="hljs-built_in">array</span>[j].name)&gt;<span class="hljs-number">0</span>)&#123;<br>                tmp = <span class="hljs-built_in">array</span>[i];<br>                <span class="hljs-built_in">array</span>[i] = <span class="hljs-built_in">array</span>[j];<br>                <span class="hljs-built_in">array</span>[j] = tmp;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">sortbyScore</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> Student <span class="hljs-built_in">array</span>[], <span class="hljs-type">int</span> n)</span>&#123;<span class="hljs-comment">// 成绩顺序</span><br>    <span class="hljs-type">int</span> i, j;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Student</span> <span class="hljs-title">tmp</span>;</span><br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;n; i++)&#123;<br>        <span class="hljs-keyword">for</span>(j=i; j&lt;n; j++)&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">array</span>[i].score &lt; <span class="hljs-built_in">array</span>[j].score)&#123;<br>                tmp = <span class="hljs-built_in">array</span>[i];<br><span class="hljs-built_in">array</span>[i] = <span class="hljs-built_in">array</span>[j];<br>                <span class="hljs-built_in">array</span>[j] = tmp;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">(FILE *fp, <span class="hljs-keyword">struct</span> Student <span class="hljs-built_in">array</span>[], <span class="hljs-type">int</span> n)</span>&#123;<span class="hljs-comment">// 输出</span><br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>        <span class="hljs-built_in">fprintf</span>(fp, <span class="hljs-string">&quot;%3d%6s%5d\n&quot;</span>, <span class="hljs-built_in">array</span>[i].no, <span class="hljs-built_in">array</span>[i].name, <span class="hljs-built_in">array</span>[i].score);<br><span class="hljs-built_in">fprintf</span>(fp, <span class="hljs-string">&quot;\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="例8-链表">例8 链表</h3><h4 id="问题-5">1 问题</h4><ul><li>命令<code>tail</code>用来显示一个文件的最后n行，其格式为：<code>tail [-n] filename</code>。其中：<code>n</code>表示需要显示的行数，省略时n的值为10；<code>filename</code>为给定文件名。如，命令<code>tail –20 example.txt</code>表示显示文件<code>example.txt</code>的最后20行。</li><li>实现该程序，该程序应具有一定的错误处理能力，如能处理非法命令参数和非法文件名。</li></ul><h4 id="问题分析">2 问题分析</h4><ul><li><p>如何得到需要显示的行数和文件名？</p><ul><li>使用命令行参数：<code>int main(int argc, char *argv[])</code></li><li>行数<code>n = atoi(argv[1]+1)</code></li><li>文件名<code>filename = argv[2]</code></li></ul></li><li><p>如何得到最后n行？</p><ul><li><p>方法1：使用n个节点的循环链表。链表中始终存放最近读入的n行。</p><ol type="1"><li><p>首先创建一个空的循环链表；</p></li><li><p>然后再依次读入文件的每一行挂在链表上，最后链表上即为最后n行。</p><p><img src="/img/009ds1/10.png" /></p></li></ol></li><li><p>方法2：使用一个n个元素的指针数组。</p><p>依次读入每一行，然后循环挂到指针数组上。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> *lineptr[N];<span class="hljs-comment">//存入所读入的行</span><br><span class="hljs-type">char</span> line[LEN];<span class="hljs-comment">//当前读入行</span><br><span class="hljs-type">int</span> i;<span class="hljs-comment">//读入的行数</span><br><br>lineptr[i % n] = (<span class="hljs-type">char</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">strlen</span>(line)+<span class="hljs-number">1</span>);<br><span class="hljs-built_in">strcpy</span>(lineptr[i%n], line);<br></code></pre></td></tr></table></figure></li><li><p>方法3：两次扫描文件。</p><ul><li><p>第一遍扫描文件，用于统计文件的总行数N；</p></li><li><p>第二遍扫描文件时，首先跳过前面N-n行，只读取最后n行。</p><p>如何开始第二遍扫描？</p><p><code>fseek(fp, 0, SEEK_SET);</code>将文件读写位置移至文件头或（关闭后）再次打开同一个文件</p></li></ul></li><li><p>方法4：设计函数<code>fbgetc(fp);</code>，从文件尾开始，每次倒读一个字符；<code>fbgets(buf,size,fp);</code>从文件尾开始每次倒读一行</p></li></ul></li></ul><h4 id="代码实现循环链表">3 代码实现（循环链表）</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DEFLINES 10</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXLEN 81</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> &#123;</span><br>    <span class="hljs-type">char</span> *line;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">next</span>;</span><br>&#125;;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[ ])</span> &#123;<br>    <span class="hljs-type">char</span> curline[MAXLEN], *filename;<br>    <span class="hljs-type">int</span> n = DEFLINES, i;<span class="hljs-comment">// 默认十行</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">first</span>, *<span class="hljs-title">ptr</span>;</span><br>    FILE *fp;<br>    <span class="hljs-comment">// 读入行数、文件名</span><br>    <span class="hljs-keyword">if</span>(argc == <span class="hljs-number">3</span> &amp;&amp; argv[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;-&#x27;</span>)&#123;<span class="hljs-comment">// 指定打印行数</span><br>        n = atoi(argv[<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>);<br>        filename = argv[<span class="hljs-number">2</span>];<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(argc == <span class="hljs-number">2</span>)&#123;<br>        filename = argv[<span class="hljs-number">1</span>];<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Usage: tail [-n] filename\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> (<span class="hljs-number">1</span>);<br>    &#125;<br>    <br>    <span class="hljs-comment">// 创建循环链表</span><br>    <span class="hljs-keyword">if</span>((fp = fopen(filename, <span class="hljs-string">&quot;r&quot;</span>)) == <span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; Can&#x27;t open file: %s !\n&quot;</span>, filename);<br>        <span class="hljs-keyword">return</span> (<span class="hljs-number">-1</span>);<br>    &#125;<br>    first = ptr = (<span class="hljs-keyword">struct</span> Node *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span> ( <span class="hljs-keyword">struct</span> Node));<br>    first-&gt;line = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>; i&lt;n; i++)&#123;<br>        ptr-&gt;next = (<span class="hljs-keyword">struct</span> Node *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span> ( <span class="hljs-keyword">struct</span> Node));<br>        ptr = ptr-&gt;next;<br>        ptr-&gt;line = <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    ptr-&gt;next = first;<br>    <span class="hljs-comment">// 将链表的最后一个节点指向头节点，以构成一个循环链表。</span><br>    ptr = first;<br><br>    <span class="hljs-comment">// 读入文件中内容</span><br>    <span class="hljs-keyword">while</span>(fgets(curline, MAXLEN, fp) != <span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-keyword">if</span>(ptr-&gt;line != <span class="hljs-literal">NULL</span>)<span class="hljs-comment">//链表已经满了，需要释放掉不需要的行</span><br>        <span class="hljs-built_in">free</span>(ptr-&gt;line);<br>        ptr-&gt;line = (<span class="hljs-type">char</span> *) <span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">strlen</span>(curline)+<span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">strcpy</span>(ptr-&gt;line, curline);<br>        ptr = ptr-&gt;next;<br>&#125;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;n; i++) &#123;<br>        <span class="hljs-keyword">if</span>(ptr-&gt;line != <span class="hljs-literal">NULL</span>)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>,ptr-&gt;line);<br>        ptr = ptr-&gt;next;<br>    &#125;<br>    fclose(fp);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>学习经验</category>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习经验</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【学习经验】从0开始的python生活</title>
    <link href="/2024/03/08/LE-python/"/>
    <url>/2024/03/08/LE-python/</url>
    
    <content type="html"><![CDATA[<h2id="python环境的安装学习python的第0.5步">python环境的安装（“学习python的第0.5步”）</h2><ol type="1"><li><p>点击https://repo.anaconda.com/miniconda/Miniconda3-latest-Windows-x86_64.exe进行安装，<strong>请务必一定千万要记住你的miniconda3下在了哪里</strong></p></li><li><p>四个全选</p><p><img src="/img/008LEpython/1.png" /></p></li><li><p>或许是测试（？）<em>总之我也不大清楚，但是jhgg这样做总有他的深意吧</em></p><ol type="1"><li><p>按下Win键，输入wt</p><p><img src="/img/008LEpython/2.png" /></p></li><li><p>输入<code>conda info -e</code></p><p><img src="/img/008LEpython/3.png" /></p></li><li><p>输入<code>conda activate base</code></p><p><img src="/img/008LEpython/4.png" /></p></li><li><p>输入<code>python</code></p><p><img src="/img/008LEpython/5.png" /></p></li><li><p>输入<code>print("Hello, world!")</code></p><p><img src="/img/008LEpython/6.png" /></p></li></ol></li></ol><h2 id="pycharm的安装">pycharm的安装</h2><ol type="1"><li><p>https://www.jetbrains.com/pycharm/download/?section=windows下载</p><p><img src="/img/008LEpython/7.png" /></p></li><li><p>next......next......直到......</p><p><img src="/img/008LEpython/8.png" /></p><p>可以勾上“添加‘bin’文件夹到PATH”（<strong>PATH那个选项不要选。如果装过其他版本的python，它也会被添加到path里，其他软件执行python解释器和虚拟环境可能会错误调用。所以先取消勾选，然后再手动一下配置环境变量</strong>），可以考虑勾上“创建桌面快捷方式”，不要勾上另外两个（不要问我为什么，我也不知道，诶嘿）</p></li><li><p>汉化：打开pycharm，左侧有"plugins"，点击打开，在插件商店搜索"chinese"</p><p><img src="/img/008LEpython/9.png" /></p><p>下载后重启pycharm</p></li><li><p>还有一些要做的......</p><ol type="1"><li><p>新建文件（呃还是新建项目来着？总之是打开pycharm后右侧大块区域里靠左边的那个框框点击去）</p></li><li><p>自定义环境</p><p><img src="/img/008LEpython/10.png" /></p></li><li><p>选择现有</p><p><img src="/img/008LEpython/14.png" /></p></li><li><p>类型-&gt;conda</p><p><img src="/img/008LEpython/11.png" /></p></li><li><p>点击这里找找你装conda脚本的位置，一般是：C:\....bat</p><p><img src="/img/008LEpython/12.png" /></p></li><li><p>创建</p><p><img src="/img/008LEpython/13.png" /></p></li></ol></li><li><p>大功告成！</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>学习经验</category>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习经验</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【学习经验】markdown入门</title>
    <link href="/2024/02/14/LE-markdown/"/>
    <url>/2024/02/14/LE-markdown/</url>
    
    <content type="html"><![CDATA[<h2 id="标题">标题</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 大标题</span><br><span class="hljs-section">## 二号标题</span><br><span class="hljs-section">### 三号标题</span><br><span class="hljs-section">#### 四号标题</span><br><span class="hljs-section">##### 五号标题</span><br><span class="hljs-section">###### 六号标题</span><br></code></pre></td></tr></table></figure><h2 id="字体">字体</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-emphasis">*斜体*</span>  <span class="hljs-strong">**加粗**</span>  <span class="hljs-strong">**<span class="hljs-emphasis">*斜体加粗*</span>**</span>  ~~划掉~~  ==高亮==  ^上标^  ~下标~<br></code></pre></td></tr></table></figure><h2 id="列表">列表</h2><ol type="1"><li><p>无序列表</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">+</span> dfji<br><span class="hljs-bullet"> +</span> dfj<br><span class="hljs-bullet">   +</span> dfj<br></code></pre></td></tr></table></figure></li><li><p>有序列表</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> sdf<br><span class="hljs-bullet">2.</span> sdf<br><span class="hljs-bullet">3.</span> sdf<br></code></pre></td></tr></table></figure></li></ol><h2 id="表格">表格</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown">| mon | tue | wed |<br>|-----|-----|:----|<br>|dd|dd|dd|<br>|ss|ss|ss|<br></code></pre></td></tr></table></figure><h2 id="引用">引用</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-quote">&gt; 第一层引用</span><br><span class="hljs-quote">&gt; &gt; 第二层引用</span><br><span class="hljs-quote">&gt; &gt; &gt;第三层引用</span><br><span class="hljs-quote">&gt; &gt; &gt; &gt;第四层引用</span><br></code></pre></td></tr></table></figure><h2 id="分割线">分割线</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">---<br></code></pre></td></tr></table></figure><h2 id="折叠内容">折叠内容</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">details</span>&gt;</span></span><br><span class="hljs-code">    &lt;summary&gt;展示的内容&lt;/summary&gt;</span><br><span class="hljs-code">    折叠的内容</span><br><span class="hljs-code">&lt;/details&gt;</span><br></code></pre></td></tr></table></figure><h2 id="数学公式">数学公式</h2><p>输入<code>$$</code>回车后即可插入数学公式（公式为独立一行且居中）</p><h3 id="基本运算符">基本运算符</h3><ul><li><p>下标：<code>_</code>放在字符下时加上<code>\limits</code></p></li><li><p>上标：<code>^</code></p></li><li><p>根号：<code>\sqrt</code></p></li><li><p>分数：<code>\frac&#123;up&#125;&#123;down&#125;</code></p><p>例如</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">x<span class="hljs-emphasis">_&#123;ij&#125; 、y^&#123;ij&#125; 、\max \limits_</span>&#123;a<span class="language-xml">&lt;x&lt;b&#125; \&#123;f(x)\&#125;、\frac&#123;up&#125;&#123;down&#125;、\sqrt&#123;b&#125;、 \sqrt[a]&#123;b&#125;</span><br></code></pre></td></tr></table></figure></li></ul><p><span class="math display">\[x_{ij} 、y^{ij} 、\max\limits_{a&lt;x&lt;b}\{f(x)\}、\frac{up}{down}、\sqrt{b}、 \sqrt[a]{b}\]</span></p><h3 id="括号">括号</h3><ul><li><table><thead><tr class="header"><th style="text-align: center;">markdown语法</th><th style="text-align: center;">表示字符</th><th style="text-align: center;">markdown语法</th><th style="text-align: center;">表示字符</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">()</td><td style="text-align: center;">()</td><td style="text-align: center;">|</td><td style="text-align: center;">|</td></tr><tr class="even"><td style="text-align: center;">[]</td><td style="text-align: center;">[]</td><td style="text-align: center;">\{\}</td><td style="text-align: center;">{}</td></tr><tr class="odd"><td style="text-align: center;"></td><td style="text-align: center;">⟨</td><td style="text-align: center;"></td><td style="text-align: center;">⟩</td></tr><tr class="even"><td style="text-align: center;"></td><td style="text-align: center;">⌈</td><td style="text-align: center;"></td><td style="text-align: center;">⌉</td></tr><tr class="odd"><td style="text-align: center;"></td><td style="text-align: center;">⌊</td><td style="text-align: center;"></td><td style="text-align: center;">⌋</td></tr><tr class="even"><td style="text-align: center;"></td><td style="text-align: center;">{</td><td style="text-align: center;"></td><td style="text-align: center;">}</td></tr></tbody></table></li><li><p>需要显示大号的括号或分隔符时，用</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown">\left[<br>\frac&#123;(x<span class="hljs-emphasis">_&#123;ij&#125;)_</span>&#123;max&#125;^2&#125;&#123;MSE&#125;<br>\right]<br></code></pre></td></tr></table></figure><p><span class="math display">\[\left[\frac{(x_{ij})_{max}^2}{MSE}\right]\]</span></p></li></ul><h3 id="运算符">运算符</h3><table><thead><tr class="header"><th style="text-align: center;">输入</th><th style="text-align: center;">显示</th><th style="text-align: center;">输入</th><th style="text-align: center;">显示</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"></td><td style="text-align: center;">±</td><td style="text-align: center;"></td><td style="text-align: center;">∓</td></tr><tr class="even"><td style="text-align: center;"></td><td style="text-align: center;">×</td><td style="text-align: center;"></td><td style="text-align: center;">⋅</td></tr><tr class="odd"><td style="text-align: center;"></td><td style="text-align: center;">÷</td><td style="text-align: center;"></td><td style="text-align: center;">≈</td></tr><tr class="even"><td style="text-align: center;"></td><td style="text-align: center;">≠</td><td style="text-align: center;"></td><td style="text-align: center;">≡</td></tr><tr class="odd"><td style="text-align: center;"></td><td style="text-align: center;">≤</td><td style="text-align: center;"></td><td style="text-align: center;">≥</td></tr></tbody></table><h3 id="求和求积">求和求积</h3><table><thead><tr class="header"><th style="text-align: center;">输入</th><th style="text-align: center;">显示</th><th style="text-align: center;">输入</th><th style="text-align: center;">显示</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"></td><td style="text-align: center;">∑</td><td style="text-align: center;"></td><td style="text-align: center;">∏</td></tr></tbody></table><h3 id="集合运算符">集合运算符</h3><table><thead><tr class="header"><th style="text-align: center;">输入</th><th style="text-align: center;">显示</th><th style="text-align: center;">输入</th><th style="text-align: center;">显示</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"></td><td style="text-align: center;">∈</td><td style="text-align: center;"></td><td style="text-align: center;">∉</td></tr><tr class="even"><td style="text-align: center;"></td><td style="text-align: center;">⊂</td><td style="text-align: center;"></td><td style="text-align: center;">⊃</td></tr><tr class="odd"><td style="text-align: center;"></td><td style="text-align: center;">⊆</td><td style="text-align: center;"></td><td style="text-align: center;">⊇</td></tr><tr class="even"><td style="text-align: center;"></td><td style="text-align: center;">⋂</td><td style="text-align: center;"></td><td style="text-align: center;">⋃</td></tr><tr class="odd"><td style="text-align: center;"></td><td style="text-align: center;">∅</td><td style="text-align: center;"></td><td style="text-align: center;">￠</td></tr></tbody></table><h3 id="对数运算符">对数运算符</h3><table><thead><tr class="header"><th style="text-align: center;">输入</th><th style="text-align: center;">显示</th><th style="text-align: center;">输入</th><th style="text-align: center;">显示</th><th style="text-align: center;">输入</th><th style="text-align: center;">显示</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"></td><td style="text-align: center;">log</td><td style="text-align: center;"></td><td style="text-align: center;">lg</td><td style="text-align: center;"></td><td style="text-align: center;">ln</td></tr></tbody></table><h3 id="三角运算符">三角运算符</h3><table><thead><tr class="header"><th style="text-align: center;">输入</th><th style="text-align: center;">显示</th><th style="text-align: center;">输入</th><th style="text-align: center;">显示</th><th style="text-align: center;">输入</th><th style="text-align: center;">显示</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">30^</td><td style="text-align: center;">30°</td><td style="text-align: center;"></td><td style="text-align: center;">⊥</td><td style="text-align: center;">A</td><td style="text-align: center;">∠<em>A</em></td></tr><tr class="even"><td style="text-align: center;"></td><td style="text-align: center;">sin</td><td style="text-align: center;"></td><td style="text-align: center;">cos</td><td style="text-align: center;"></td><td style="text-align: center;">tan</td></tr><tr class="odd"><td style="text-align: center;"></td><td style="text-align: center;">csc</td><td style="text-align: center;"></td><td style="text-align: center;">sec</td><td style="text-align: center;"></td><td style="text-align: center;">cot</td></tr></tbody></table><h3 id="微积分运算符">微积分运算符</h3><table><thead><tr class="header"><th style="text-align: center;">输入</th><th style="text-align: center;">显示</th><th style="text-align: center;">输入</th><th style="text-align: center;">显示</th><th style="text-align: center;">输入</th><th style="text-align: center;">显示</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"></td><td style="text-align: center;">∫</td><td style="text-align: center;"></td><td style="text-align: center;">lim</td><td style="text-align: center;"></td><td style="text-align: center;">∞</td></tr></tbody></table><h3 id="逻辑运算符">逻辑运算符</h3><table><thead><tr class="header"><th style="text-align: center;">输入</th><th style="text-align: center;">显示</th><th style="text-align: center;">输入</th><th style="text-align: center;">显示</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"></td><td style="text-align: center;">∵</td><td style="text-align: center;"></td><td style="text-align: center;">∴</td></tr><tr class="even"><td style="text-align: center;"></td><td style="text-align: center;">∀</td><td style="text-align: center;"></td><td style="text-align: center;">∃</td></tr></tbody></table><h3 id="上下花括号">上下花括号</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">\overbrace&#123;a+b+\dots+n&#125;^&#123;m个&#125;、\underbrace&#123;a+b+\dots+n&#125;<span class="hljs-emphasis">_&#123;m个&#125;</span><br></code></pre></td></tr></table></figure><p><span class="math display">\[\overbrace{a+b+\dots+n}^{m个}、\underbrace{a+b+\dots+n}_{m个}\]</span></p><h3 id="箭头">箭头</h3><table><thead><tr class="header"><th style="text-align: center;">输入</th><th style="text-align: center;">显示</th><th style="text-align: center;">输入</th><th style="text-align: center;">显示</th><th style="text-align: center;">输入</th><th style="text-align: center;">显示</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"></td><td style="text-align: center;">←</td><td style="text-align: center;"></td><td style="text-align: center;">→</td><td style="text-align: center;"></td><td style="text-align: center;">⟵</td></tr><tr class="even"><td style="text-align: center;"></td><td style="text-align: center;">↔︎</td><td style="text-align: center;"></td><td style="text-align: center;">↑</td><td style="text-align: center;"></td><td style="text-align: center;">⇓</td></tr></tbody></table><ul><li>首字母大写为双箭头</li><li>前面加long为长箭头</li></ul><h3 id="希腊字母">希腊字母</h3><ul><li><p>输入 <code>\小写希腊字母英文全称</code> 和<code>\首字母大写希腊字母英文全称</code>来分别输入小写和大写希腊字母。<strong>对于大写希腊字母与现有字母相同的，直接输入大写字母即可。</strong></p><table><thead><tr class="header"><th style="text-align: center;">输入</th><th style="text-align: center;">显示</th><th style="text-align: center;">输入</th><th style="text-align: center;">显示</th><th style="text-align: center;">输入</th><th style="text-align: center;">显示</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"></td><td style="text-align: center;"><em>α</em></td><td style="text-align: center;"></td><td style="text-align: center;"><em>β</em></td><td style="text-align: center;"></td><td style="text-align: center;"><em>γ</em></td></tr><tr class="even"><td style="text-align: center;"></td><td style="text-align: center;"><em>δ</em></td><td style="text-align: center;"></td><td style="text-align: center;"><em>ϵ</em></td><td style="text-align: center;"></td><td style="text-align: center;"><em>η</em></td></tr><tr class="odd"><td style="text-align: center;"></td><td style="text-align: center;"><em>θ</em></td><td style="text-align: center;"></td><td style="text-align: center;"><em>λ</em></td><td style="text-align: center;"></td><td style="text-align: center;"><em>μ</em></td></tr><tr class="even"><td style="text-align: center;"></td><td style="text-align: center;"><em>σ</em></td><td style="text-align: center;"></td><td style="text-align: center;"><em>π</em></td><td style="text-align: center;"></td><td style="text-align: center;"><em>ω</em></td></tr></tbody></table></li></ul><h3 id="字体-1">字体</h3><ul><li><p>若要对公式的某一部分字符进行字体转换，可以用<code>&#123;\字体 &#123;需转换的部分字符&#125;&#125;</code> 命令，其中 <code>\字体</code>部分可以参照下方选择合适的字体。一般情况下，公式默认为意大利体 。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">意大利体\it&#123;sample&#125;、罗马体\rm&#123;sample&#125;、粗体\bf&#123;sample&#125;、等线体\sf&#123;sample&#125;、打字机体\tt&#123;sample&#125;、旧德式字体\frak&#123;sample&#125;、花体\cal&#123;sample&#125;、黑板粗体\Bbb&#123;sample&#125;、数字斜体\mit&#123;sample&#125;、手写体\scr&#123;sample&#125;<br></code></pre></td></tr></table></figure><p><span class="math display">\[意大利体\it{sample}、罗马体\rm{sample}、粗体\bf{sample}、等线体\sf{sample}、打字机体\tt{sample}、旧德式字体\frak{sample}、花体\cal{sample}、黑板粗体\Bbb{sample}、数字斜体\mit{sample}、手写体\scr{sample}\]</span></p></li></ul><h3 id="矩阵">矩阵</h3><p><code>\begin&#123;matrix&#125;...\end&#123;matrix&#125;</code>括起来，使用&amp;分割同行元素，</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs markdown">\begin&#123;matrix&#125;<br>1 &amp; x &amp; x^2\\<br>1 &amp; y &amp; y^2\\<br>1 &amp; z &amp; z^2\\<br>\end&#123;matrix&#125;<br></code></pre></td></tr></table></figure><p><span class="math display">\[\begin{matrix}  1 &amp; x &amp; x^2\\  1 &amp; y &amp; y^2\\  1 &amp; z &amp; z^2\\  \end{matrix}\]</span></p><h3 id="行列式">行列式</h3><p>在矩阵基础上添加<code>\left| ... \right|</code></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs markdown">X=\left|<br>  \begin&#123;matrix&#125;<br><span class="hljs-code">    x_&#123;11&#125; &amp; x_&#123;12&#125; &amp; \cdots &amp; x_&#123;1d&#125;\\</span><br><span class="hljs-code">    x_&#123;21&#125; &amp; x_&#123;22&#125; &amp; \cdots &amp; x_&#123;2d&#125;\\</span><br><span class="hljs-code">    \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\</span><br><span class="hljs-code">    x_&#123;11&#125; &amp; x_&#123;12&#125; &amp; \cdots &amp; x_&#123;1d&#125;\\</span><br><span class="hljs-code">  \end&#123;matrix&#125;</span><br><span class="hljs-code">\right|</span><br></code></pre></td></tr></table></figure><p><span class="math display">\[X=\left|  \begin{matrix}    x_{11} &amp; x_{12} &amp; \cdots &amp; x_{1d}\\    x_{21} &amp; x_{22} &amp; \cdots &amp; x_{2d}\\    \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\    x_{11} &amp; x_{12} &amp; \cdots &amp; x_{1d}\\  \end{matrix}\right|\]</span></p><h3 id="分段函数">分段函数</h3><p><code>\begin&#123;cases&#125; ... \end&#123;cases&#125;</code>包括</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs markdown">f(n)=<br>  \begin&#123;cases&#125;<br><span class="hljs-code">    n/2, &amp; \text&#123;if $n$ is even&#125;\\</span><br><span class="hljs-code">    3n+1,&amp; \text&#123;if $n$ is odd&#125;</span><br><span class="hljs-code">  \end&#123;cases&#125;</span><br></code></pre></td></tr></table></figure><p><span class="math display">\[f(n)=  \begin{cases}    n/2, &amp; \text{if $n$ is even}\\    3n+1,&amp; \text{if $n$ is odd}  \end{cases}\]</span></p><h3 id="方程组">方程组</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs markdown">\left\&#123;<br>  \begin&#123;array&#125;&#123;c&#125;<br><span class="hljs-code">    a_1x+b_1y+c_1z=d_1\\</span><br><span class="hljs-code">    a_2x+b_2y+c_2z=d_2\\</span><br><span class="hljs-code">    a_3x+b_3y+c_3z=d_3</span><br><span class="hljs-code">  \end&#123;array&#125;</span><br><span class="hljs-code">\right.</span><br></code></pre></td></tr></table></figure><p><span class="math display">\[\left\{  \begin{array}{c}    a_1x+b_1y+c_1z=d_1\\    a_2x+b_2y+c_2z=d_2\\    a_3x+b_3y+c_3z=d_3  \end{array}\right.\]</span></p>]]></content>
    
    
    <categories>
      
      <category>学习经验</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习经验</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【学习经验】或许可以用于辅助理解的c语言随想录</title>
    <link href="/2024/02/08/LE-c001/"/>
    <url>/2024/02/08/LE-c001/</url>
    
    <content type="html"><![CDATA[<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span>      </span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">0</span>, b, sum = <span class="hljs-number">100</span>;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);<br>    sum = a + b;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d + %d = %d\n&quot;</span>, a, b, sum);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>（惊）我们发生了一个野生的代码！虽然乱七八糟的英文字母什么的完全看不懂，但是姑且CV下来跑一跑吧！什么？你说你还想知道这个代码为什么会有这样的输出？既然你诚心诚意的发问了，那我就大发慈悲地告诉你吧......呜，好吧，本人学艺不精，暂且还无能力做出一个完整的博客帮助入门c语言，因此————<strong>正经的解释请去参考浙大翁恺的视频，本文只有本人关于c语言的任性比喻，可以用于辅助理解随便看看</strong></p><h2 id="标准库">标准库</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br></code></pre></td></tr></table></figure><p>写下来这一行之后，你就成功地站在了巨人的肩膀之上！可以利用前人的成果十分方便地进行输入、输出、平方、开根号、转换大小写等等了！除了stdio.h外，还有math.h,string.h, ctype.h,stdlib.h等标准库，这些标准库会在之后的学习中接触到，如果你想了解更多，请参考：zh.cppreferenc.com</p><h2 id="主函数">主函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;  <br>&#125;<br></code></pre></td></tr></table></figure><p>编程相当于创造一个又一个函数，对输入的数据进行处理，并进行输出。主函数就是所有函数的老大，是整个程序的入口和出口，相当于游乐园的大门。以后你可能还会写很多其他函数，他们相当于各个区域的小门。而每个函数大括号中的内容就相当于这个区域的游乐设施们。输入的数据（充满活力的游客）会按照规划的游玩顺序（程序）走完全程，最终被输出（玩了一天累死累活的游客）。</p><h3 id="定义变量">定义变量</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> a = <span class="hljs-number">0</span>, b, sum = <span class="hljs-number">100</span>;<br></code></pre></td></tr></table></figure><p>定义了三个变量a，b，sum，相当于函数中的自变量和因变量</p><h3 id="加法运算">加法运算</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">sum = a + b;<br></code></pre></td></tr></table></figure><p>相当于函数中的投射f</p><h3 id="输出">输出</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d + %d = %d\n&quot;</span>, a, b, sum);<br></code></pre></td></tr></table></figure><p>当当，你获得了你想要的输出！！！</p><h3 id="函数返回值">函数返回值</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><p>虽然不知道为什么要返回0不过貌似让他return别的也没关系但是以防万一你还是写return0吧。总之写了这个return 0;是绝对不会出错的。</p><h3 id="注释">注释</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">我用来注释多行语句</span><br><span class="hljs-comment">被注释的内容不会运行，可以用来解释代码</span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">//我用来注释单行语句</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>学习经验</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习经验</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【军训】军训概况及军乐连介绍</title>
    <link href="/2024/01/15/MT-experience/"/>
    <url>/2024/01/15/MT-experience/</url>
    
    <content type="html"><![CDATA[<h1id="军乐嘹亮士气高昂扬我军威壮我北航">军乐嘹亮，士气高昂！扬我军威，壮我北航！</h1><h3 id="时间安排">时间安排</h3><ol type="1"><li><p>总体安排：8.31-9.10共11天。其中8.31上午开营仪式，9.2上午开学典礼，9.3晚上士谔邀请高宁老师讲思政课（习近平的青春岁月），9.4上午体检，9.6早上拉练，9.6晚上合唱比赛，9.7晚上拔河比赛（军乐连不参加），9.8晚上全要素排练，9.9上午新生采集，9.10上午闭营仪式</p></li><li><p>日常作息：晚睡早起</p></li></ol><table><thead><tr class="header"><th style="text-align: left;">时间</th><th style="text-align: left;">内容</th><th>吐槽</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">6:30</td><td style="text-align: left;">起床</td><td>或许是我人生中最后的早起......</td></tr><tr class="even"><td style="text-align: left;">6:40</td><td style="text-align: left;">集合</td><td></td></tr><tr class="odd"><td style="text-align: left;">6:40-7:20</td><td style="text-align: left;">早训</td><td>军乐连早训强度低，后期还为了更好地进行行管训练取消了早训</td></tr><tr class="even"><td style="text-align: left;">7:20-8:20</td><td style="text-align: left;">早饭</td><td>实际上早饭时间绝对没有一个小时，因为7:20结束早训之后你要从训练场地走回食堂，食堂要排队，而且你也要提前从食堂出发去集合场地。</td></tr><tr class="odd"><td style="text-align: left;">8:20-11:30</td><td style="text-align: left;">上午训练</td><td>三个小时强度不小，如果晒太阳就更累了</td></tr><tr class="even"><td style="text-align: left;">11:30-12:30</td><td style="text-align: left;">午饭</td><td>同理，不是说11:30吃上饭，而是说11:30结束训练，从训练地点出发去食堂。不过你吃到几点倒是无所谓。</td></tr><tr class="odd"><td style="text-align: left;">12:30-14:30</td><td style="text-align: left;">午休</td><td>事实上，午休不一定能休息，因为你需要复习训练内容/打扫宿舍/选课/写入党申请书</td></tr><tr class="even"><td style="text-align: left;">14:30-17:45</td><td style="text-align: left;">下午训练</td><td>下午更热！顺带一提我印象里军乐连一般都是14:00集合</td></tr><tr class="odd"><td style="text-align: left;">17:45-18:30</td><td style="text-align: left;">晚餐</td><td>其实早饭晚饭基本上都是刚刚好够你吃完一顿饭的时间，并没有四十多分钟，更别想着回趟宿舍之类的了。</td></tr><tr class="even"><td style="text-align: left;">19:00-21:30</td><td style="text-align: left;">晚训</td><td>强度低，一方面天黑了不晒了，另一方面不是每天晚上都是训练，也会有一些文娱活动，比如欣赏DCI/合唱比赛/拔河比赛</td></tr><tr class="odd"><td style="text-align: left;">21:30-22:30</td><td style="text-align: left;">自由活动</td><td>洗澡人很多，需要排队。</td></tr><tr class="even"><td style="text-align: left;">22:30</td><td style="text-align: left;">熄灯</td><td>其实并没有人查寝，所以也没有人十点半就熄灯。</td></tr></tbody></table><ol start="3" type="1"><li>日常训练之外的事情：思政课、选课、拉练、合唱比赛、拔河比赛（军乐连不参加）、写入党申请书、值班（24小时中的任意一小时，也就是说你有可能在凌晨三点值班，也有可能在中午十二点值班）</li></ol><h3 id="关于纪律">关于纪律</h3><ol type="1"><li>任何时间<strong>不能一人行动</strong>，必须两人成行三人成列四人成方</li><li>出宿舍不能穿便装<strong>不能带手机</strong>（导致通知的传达和获取十分不便）<del>（不过你穿便装偷偷出去取个快递也没人知道你是大一的）</del></li><li>军训时期不能发军训相关内容的朋友圈</li><li>在食堂和宿舍外的任何地方都需要军容端正，扣子不能有没扣好的，口袋拉练不能有没拉上的，名牌不能有歪掉的，领子不能立起来，帽子不能戴歪。因此你经常会在食堂门口见到一堆从头摸到脚检查自己有没有军容不整的小绿人......</li></ol><h3 id="关于军乐连旗队的误解">关于军乐连/旗队的误解</h3><ol type="1"><li><p>军乐连不用晒太阳？</p><p>nope。事实上，虽然旗队外的军乐连有几天可以在室内训练吹走和行进步伐，但是他们也会有一半的日子需要在操场上晒大太阳，完全没有树荫。而旗队属于一开始就在外面训练，教官会努力找阴凉地，但也不一定所有人都不被晒（不过会定时轮换），但是旗队在操场上晒大太阳练习行进步伐的时间会比乐队和打击乐少一点点。</p></li><li><p>军乐连很轻松？</p><p>nope！！！完全错误的认知啊朋友！其他连是只有肉体上的痛苦，军乐连是肉体和精神同时痛苦啊！一个暑假没动脑子没记东西了，突然让我十天之内记住一套行进步伐和旗队动作或乐谱，这真的很痛苦。其实你看我的军训日记也能看出来，那几天很累，你的脚会磨出水泡，你的手和胳膊会酸痛，你的脑子会被行进步伐和旗队动作或乐谱充满。</p></li><li><p>旗队只用拿着旗子跑过去站着不动？</p><p>朋友，完全错误的认知啊！！！当初年少无知的我就是以着这样的认知选择报名了旗队，有幸被旗队教官挑中后在之后的推文看到了他无比华丽的抛旗动作，然后认识到了自己对旗队浅薄的认知。</p></li><li><p>旗队生活带给了我什么？</p><p>结交了不同书院不同专业的朋友、增加了行管相关知识、加入了行进管乐团学会了一些抛旗动作、军训生活的美好记忆。<strong><em>欢迎各位加入军乐连，加入北京航空航天大学行进管乐团，我们一定不会让你失望的。</em></strong></p></li></ol><h3 id="如果你想了解行进管乐团......">如果你想了解行进管乐团......</h3><figure><img src="/img/005MTexperi/001marchingband.jpg"alt="北航行进管乐团团标" /><figcaption aria-hidden="true">北航行进管乐团团标</figcaption></figure><ol type="1"><li>北航的行进管乐团表演：【【台湾行进管乐公开赛】北航行进管乐团夺冠方案《西游记》】https://www.bilibili.com/video/BV1Kx411m7af/?share_source=copy_web&amp;vd_source=fc9422f088d6dd276399cc472e4f7182</li><li>专业的行进管乐团表演：【DCI 2017冠军蓝魔Blue Devils展演 行进管乐】https://www.bilibili.com/video/BV18s411g7vP/?share_source=copy_web&amp;vd_source=fc9422f088d6dd276399cc472e4f7182</li><li>旗队：【北航行进管乐 旗队宣传片】https://www.bilibili.com/video/BV1cW411k7Yr/?share_source=copy_web&amp;vd_source=fc9422f088d6dd276399cc472e4f7182</li><li>打击乐：【DCI蓝魔Blue Devils 2012行进打击乐队热身练习】https://www.bilibili.com/video/BV1ix411B7z1/?share_source=copy_web&amp;vd_source=fc9422f088d6dd276399cc472e4f7182</li><li>铜管：【Blue Devils蓝魔Space Chords铜管热身练习】https://www.bilibili.com/video/BV1hx411q7FQ/?share_source=copy_web&amp;vd_source=fc9422f088d6dd276399cc472e4f7182</li></ol>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
      <category>军训</category>
      
    </categories>
    
    
    <tags>
      
      <tag>军训</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【学习经验】从学长学姐继承下来的板子们</title>
    <link href="/2024/01/14/LE-banzi/"/>
    <url>/2024/01/14/LE-banzi/</url>
    
    <content type="html"><![CDATA[<h3 id="二分查找二分法">二分查找/二分法</h3><ol type="1"><li><p>查找a中是否存在key</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">int</span> a[], <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> key)</span>&#123;<br>    <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = n - <span class="hljs-number">1</span>, mid;<br>    <span class="hljs-keyword">while</span> (l &lt;= r)&#123;<br>        mid = l + (r - l) / <span class="hljs-number">2</span>;      <span class="hljs-comment">//左右边界中间点的值</span><br>        <span class="hljs-keyword">if</span> (a[mid] &lt; key) l = mid + <span class="hljs-number">1</span>;   <br>        <span class="hljs-comment">//如果当前的mid比目标小，则左边界右移到mid右边</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a[mid] &gt; key) r = mid - <span class="hljs-number">1</span>;     <br>        <span class="hljs-comment">//如果当前的mid比目标大，则右边界左移到mid左边</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> mid;                        <br>        <span class="hljs-comment">//如果当前的mid等于目标，返回mid</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;              <span class="hljs-comment">//没找到key</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>查a中第一个大于等于 key 的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">find_first</span><span class="hljs-params">(<span class="hljs-type">int</span> a[], <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> key)</span>&#123;<br>    <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = n - <span class="hljs-number">1</span>, mid;<br>    <span class="hljs-keyword">while</span> (l &lt;= r)&#123;<br>    mid = l + (r - l) / <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span> (a[mid] &lt; key) l = mid + <span class="hljs-number">1</span>; <br>        <span class="hljs-comment">//如果当前的mid&lt;目标，则左边界右移到mid右边</span><br>    <span class="hljs-keyword">else</span> r = mid - <span class="hljs-number">1</span>;                       <br>        <span class="hljs-comment">//如果当前的mid&gt;=目标，则右边界左移到mid左边</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> (l &lt; <span class="hljs-number">0</span> || l &gt;= n) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;     <span class="hljs-comment">//key&lt;a[0] || key&gt;a[n-1]</span><br>    <span class="hljs-keyword">return</span> a[l] == key ? l : <span class="hljs-number">-1</span>;        <span class="hljs-comment">//如果key不存在，返回-1</span><br> &#125;<br></code></pre></td></tr></table></figure></li><li><p>查a中第一个大于key的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">find_last</span><span class="hljs-params">(<span class="hljs-type">int</span> a[], <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> key)</span>&#123;<br>    <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = n - <span class="hljs-number">1</span>, mid;<br>    <span class="hljs-keyword">while</span> (l &lt;= r)&#123;<br>        mid = l + (r - l) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (a[mid] &lt;= key) l = mid + <span class="hljs-number">1</span>;         <br>        <span class="hljs-comment">//如果当前的mid&lt;=目标，则左边界右移到mid右边</span><br>        <span class="hljs-keyword">else</span> r = mid - <span class="hljs-number">1</span>;                       <br>        <span class="hljs-comment">//如果当前的mid&gt;目标，则右边界左移到mid左边</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> (l &lt; <span class="hljs-number">0</span> || l &gt;= n) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;       <span class="hljs-comment">//key&lt;a[0] || key&gt;a[n-1]</span><br>    <span class="hljs-keyword">return</span> a[l] == key ? l : <span class="hljs-number">-1</span>;          <span class="hljs-comment">//如果key不存在，返回-1</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>二分法求单调（递增）函数func(x)的解</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">double</span> <span class="hljs-title function_">solve</span><span class="hljs-params">(<span class="hljs-type">double</span> left, <span class="hljs-type">double</span> right, <span class="hljs-type">double</span> y)</span>&#123;<br>    <span class="hljs-type">double</span> mid;<br>    <span class="hljs-keyword">while</span> (right - left &gt; eps)&#123;<br>        mid = (right + left) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (func(mid) &gt; y)        <span class="hljs-comment">// 递减则 func(mid) &lt; y</span><br>            right = mid;<br>        <span class="hljs-keyword">else</span> left = mid;<br>    &#125;<br>    <span class="hljs-keyword">return</span> mid;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="排序">排序</h3><ol type="1"><li><p>冒泡排序-升序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">bubble_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> a[], <span class="hljs-type">int</span> n)</span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n - i - <span class="hljs-number">1</span>; j++)&#123;<br>            <span class="hljs-keyword">if</span> (a[j] &gt; a[j + <span class="hljs-number">1</span>]) &#123;<br>                <span class="hljs-type">int</span> temp = a[j];<br>                a[j] = a[j + <span class="hljs-number">1</span>];<br>                a[j + <span class="hljs-number">1</span>] = temp;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>选择排序-升序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">select_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> a[], <span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++) &#123;<br>        <span class="hljs-type">int</span> min_idx = i;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt; n; j++) &#123;<br>            <span class="hljs-keyword">if</span> (a[j] &lt; a[min_idx]) &#123;<br>                min_idx = j;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (min_idx != i) &#123;<br>            <span class="hljs-type">int</span> temp = a[i];<br>            a[i] = a[min_idx];<br>            a[min_idx] = temp;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>qsort快排</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c">qsort(a, n, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">double</span>), cmp);   <br><span class="hljs-comment">//a 需要排序的数组名称    n 需要排序的个数    sizeof(double) 一个元素的大小</span><br><span class="hljs-comment">//升序排序，最基础的写法</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">cmp</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span>*p1, <span class="hljs-type">const</span> <span class="hljs-type">void</span>*p2)</span>&#123;<br>    <span class="hljs-type">double</span> *d1=(<span class="hljs-type">double</span> *)p1;    <span class="hljs-comment">//转换为目标类型</span><br>    <span class="hljs-type">double</span> *d2=(<span class="hljs-type">double</span> *)p2;    <span class="hljs-comment">//转换为目标类型</span><br>    <span class="hljs-keyword">if</span>((*d1 - *d2) &lt; -eps) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;       <span class="hljs-comment">//返回负数=p1在p2前面</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>((*d1 - *d2) &gt; eps) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    <span class="hljs-comment">//返回正数=p1在p2后面</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 结构体的指针数组的cmp</span><br> <span class="hljs-type">int</span> <span class="hljs-title function_">cmp</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *p1, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *p2)</span>&#123;<br>     <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tnode</span> **<span class="hljs-title">d1</span> =</span> (<span class="hljs-keyword">struct</span> tnode **)p1;<br>     <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tnode</span> **<span class="hljs-title">d2</span> =</span> (<span class="hljs-keyword">struct</span> tnode **)p2;<br>     <span class="hljs-keyword">if</span>((*d1)-&gt;weight &lt; (*d2)-&gt;weight)&#123;<br>         <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>     &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>((*d1)-&gt;weight &gt; (*d2)-&gt;weight)&#123;<br>         <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>     &#125;<span class="hljs-keyword">else</span>&#123;<br>         <span class="hljs-keyword">if</span>((*d1)-&gt;c &lt; (*d2)-&gt;c)&#123;<br>             <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>         &#125;<span class="hljs-keyword">else</span>&#123;<br>             <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>         &#125;<br>     &#125;<br> &#125;<br></code></pre></td></tr></table></figure></li><li><p>归并排序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">msort</span><span class="hljs-params">(<span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span>&#123;    <span class="hljs-comment">//归并排序</span><br>    <span class="hljs-keyword">if</span>(left == right)&#123;      <span class="hljs-comment">// 只剩一个元素，已经有序，无需排序</span><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> mid = (left+right)/<span class="hljs-number">2</span>;<br>   <br>    <span class="hljs-comment">// 排序左侧</span><br>    msort(left, mid);<br>    <span class="hljs-comment">// 排序右侧</span><br>    msort(mid+<span class="hljs-number">1</span>, right);<br>   <br>    <span class="hljs-comment">// 合并</span><br>    <span class="hljs-type">int</span> left_i = left, right_i = mid+<span class="hljs-number">1</span>, i=left;<br>    <span class="hljs-keyword">while</span>(left_i&lt;=mid &amp;&amp; right_i&lt;=right)&#123;<br>        <span class="hljs-keyword">if</span>(a[right_i] &lt; a[left_i])&#123;<br>            temp[i++] = a[right_i];<br>            right_i++;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a[right_i] &gt; a[left_i])&#123;<br>            temp[i++] = a[left_i];<br>            left_i++;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            temp[i++] = a[right_i];<br>            temp[i++] = a[left_i];<br>            left_i++;<br>            right_i++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(left_i&lt;=mid)&#123;<br>        temp[i++] = a[left_i++];<br>    &#125;<br>    <span class="hljs-keyword">while</span>(right_i&lt;=right)&#123;<br>        temp[i++] = a[right_i++];<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=left; j&lt;=right; j++)&#123;<br>        <span class="hljs-comment">// printf(&quot;%d &quot;, temp[j]);</span><br>        a[j] = temp[j];<br>    &#125;<br>    <span class="hljs-comment">// puts(&quot;&quot;);</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="高精度">高精度</h3><ol type="1"><li><p>高精度加法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX 1000005</span><br><span class="hljs-type">char</span> s1[MAX], s2[MAX];<br><span class="hljs-type">int</span> a1[MAX], a2[MAX];<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> len, len1, len2, i, j;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, s1);        <span class="hljs-comment">//s1读入第一个数字</span><br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, s2);        <span class="hljs-comment">//s2读入第二个数字</span><br>    len1 = <span class="hljs-built_in">strlen</span>(s1);<br>    len2 = <span class="hljs-built_in">strlen</span>(s2);<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; len1; i++)<br>        <span class="hljs-comment">//字符串倒序导入数组，方便从低位开始运算</span><br>        a1[i] = s1[len1 - <span class="hljs-number">1</span> - i] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; len2; i++)<br>        <span class="hljs-comment">//字符串中的是字符，要转换成数字</span><br>        a2[i] = s2[len2 - <span class="hljs-number">1</span> - i] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>    len = (len1 &gt; len2) ? len1 : len2;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>        a1[i + <span class="hljs-number">1</span>] += (j = (a1[i] + a2[i]) / <span class="hljs-number">10</span>);<span class="hljs-comment">//进位</span><br>        a1[i] = (a1[i] + a2[i]) % <span class="hljs-number">10</span>;<span class="hljs-comment">//保留</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> (j) len++;<span class="hljs-comment">//最后一位是否进位</span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; len; i++)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, a1[len - <span class="hljs-number">1</span> - i]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>高精度减法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX 1000005</span><br><span class="hljs-type">char</span> s1[MAX], s2[MAX];<br><span class="hljs-type">int</span> a[MAX], b[MAX];<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> len, i;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s %s&quot;</span>, s1, s2);<br>    <span class="hljs-type">int</span> l1 = <span class="hljs-built_in">strlen</span>(s1);<br>    <span class="hljs-type">int</span> l2 = <span class="hljs-built_in">strlen</span>(s2);<br>    <span class="hljs-type">int</span> flag = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">if</span> (l1 &lt; l2 || (<span class="hljs-built_in">strcmp</span>(s1, s2) &lt; <span class="hljs-number">0</span> &amp;&amp; l1 == l2)) &#123;  <span class="hljs-comment">//s2代表的数更大</span><br>        len = l2;<br>        flag = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (i = l2 - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)<br>            a[l2 - i - <span class="hljs-number">1</span>] = s2[i] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>        <span class="hljs-keyword">for</span> (i = l1 - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)<br>            b[l1 - i - <span class="hljs-number">1</span>] = s1[i] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        len = l1;<br>        <span class="hljs-keyword">for</span> (i = l1 - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)<br>            a[l1 - i - <span class="hljs-number">1</span>] = s1[i] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>        <span class="hljs-keyword">for</span> (i = l2 - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)<br>            b[l2 - i - <span class="hljs-number">1</span>] = s2[i] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>        a[i] -= b[i];<br>        <span class="hljs-keyword">if</span> (a[i] &lt; <span class="hljs-number">0</span>) &#123;<br>            a[i + <span class="hljs-number">1</span>] -= <span class="hljs-number">1</span>;<br>            a[i] += <span class="hljs-number">10</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (a[len - <span class="hljs-number">1</span>] == <span class="hljs-number">0</span> &amp;&amp; len &gt; <span class="hljs-number">1</span>) len--;<br>    <span class="hljs-keyword">if</span> (flag == <span class="hljs-number">1</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;-&quot;</span>);<br>    <span class="hljs-keyword">for</span> (i = len - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, a[i]);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>高精度乘法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX 1000005</span><br><span class="hljs-type">char</span> s1[MAX], s2[MAX];<br><span class="hljs-type">int</span> a1[MAX], a2[MAX], ans[MAX];<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> i, j, len1, len2;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s%s&quot;</span>, s1, s2);<br>    len1 = <span class="hljs-built_in">strlen</span>(s1);<br>    len2 = <span class="hljs-built_in">strlen</span>(s2);<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; len1; i++) &#123;<br>        a1[i] = s1[len1 - <span class="hljs-number">1</span> - i] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; len2; i++) &#123;<br>        a2[i] = s2[len2 - <span class="hljs-number">1</span> - i] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; len1; i++) &#123;<br>        <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; len2; j++) &#123;<br>            ans[i + j] += a1[i] * a2[j];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; i &lt; len1 + len2; i++) &#123;<br>        ans[i] += j;<br>        j = ans[i] / <span class="hljs-number">10</span>;<br>        ans[i] %= <span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (; ans[i] == <span class="hljs-number">0</span>; i--)&#123;<br>        <span class="hljs-keyword">if</span>(i&lt;<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;0&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;       <span class="hljs-comment">//跳过前面的0</span><br>    <span class="hljs-keyword">for</span> (; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, ans[i]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="最大公约数">最大公约数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">gcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>    <span class="hljs-keyword">while</span> (b != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-type">int</span> tmp = a;<br>        a = b;<br>        b = tmp % b;<br>    &#125;<br>    <span class="hljs-keyword">return</span> a;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="输出全排列">输出全排列</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> <span class="hljs-built_in">stack</span>[<span class="hljs-number">10</span>];<br><span class="hljs-type">void</span> <span class="hljs-title function_">print_stack</span><span class="hljs-params">()</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> len)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">find_in_stack</span><span class="hljs-params">(<span class="hljs-type">int</span> key, <span class="hljs-type">int</span> len)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    dfs(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> len)</span> &#123;<br>    <span class="hljs-keyword">if</span> (len == n) &#123;<br>        print_stack();<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        <span class="hljs-keyword">if</span> (!find_in_stack(i, len)) &#123;<br>            <span class="hljs-built_in">stack</span>[len] = i;<br>            dfs(len + <span class="hljs-number">1</span>);<br>        &#125;<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">print_stack</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, <span class="hljs-built_in">stack</span>[i]);<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">find_in_stack</span><span class="hljs-params">(<span class="hljs-type">int</span> key, <span class="hljs-type">int</span> len)</span> &#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++)<br>        <span class="hljs-keyword">if</span> (key == <span class="hljs-built_in">stack</span>[i])<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="计算组合数">计算组合数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title function_">comb</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> n, <span class="hljs-type">long</span> <span class="hljs-type">long</span> m)</span> &#123;    <span class="hljs-comment">//n &gt;= m</span><br>    <span class="hljs-keyword">if</span> (m == n || m == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> comb(n - <span class="hljs-number">1</span>, m) + comb(n - <span class="hljs-number">1</span>, m - <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="快速幂取模-a的b次方p">快速幂取模-a的b次方%p</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title function_">fast_pow</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> a, <span class="hljs-type">long</span> <span class="hljs-type">long</span> b, <span class="hljs-type">long</span> <span class="hljs-type">long</span> p)</span> &#123;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> ans = <span class="hljs-number">1</span>;<br>    a = a % p;<br>    <span class="hljs-keyword">while</span> (b) &#123;<br>        <span class="hljs-keyword">if</span> (b &amp; <span class="hljs-number">1</span>)          <span class="hljs-comment">//b二进制的最后一位是1时</span><br>            ans = (ans * a) % p;<br>        b &gt;&gt;= <span class="hljs-number">1</span>;    <span class="hljs-comment">// b按位右移</span><br>        a = a * a % p;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>假设我们拿到了<em>a</em>，并且b=11。想求a<sup>11</sup>，但是又不想乘11次，有点慢。以电脑视角稍稍观察一下b=(11)<sub>10</sub>，二进制下是b=(1011)<sub>2</sub>。制作一个base。现在base =a，表示的是，a<sup>1</sup> = a。待会base会变的。制作一个ans，初值11，准备用来做答案。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">while</span>(b &gt; <span class="hljs-number">0</span>)<br>&#123;<br></code></pre></td></tr></table></figure></li><li><p>循环一。看，b（二进制）的最后一位是11吗？是的。这代表a<sup>11</sup>=a<sup>8</sup>×a<sup>2</sup>×a<sup>1</sup>中的“×a<sup>1</sup> ”存在。所以 ans*=base。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span>(b &amp; <span class="hljs-number">1</span>)<br>    ans *= base;<br><br><span class="hljs-comment">/*关于 b &amp; 1：</span><br><span class="hljs-comment">“&amp;”美名曰“按位与”。</span><br><span class="hljs-comment">x &amp; y 是二进制 x 和 y 的每一位分别进行“与运算”的结果。</span><br><span class="hljs-comment">与运算，即两者都为 1 时才会返回 1，否则返回 0。</span><br><span class="hljs-comment">那么 b &amp; 1</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">          二进制</span><br><span class="hljs-comment">b     =    1011</span><br><span class="hljs-comment">1     =    0001</span><br><span class="hljs-comment">b&amp;1   =    0001</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">因为 1（二进制）的前面几位全部都是 0，</span><br><span class="hljs-comment">所以只有 b 二进制最后一位是 1 时，b &amp; 1 才会返回 1。</span><br><span class="hljs-comment">挺巧妙的，并且很快。)*/</span><br></code></pre></td></tr></table></figure><p>然后base努力上升，他通过自乘一次，使自己变成a<sup>2</sup>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">base *= base;<br></code></pre></td></tr></table></figure><p>同时</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">b &gt;&gt;= <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>它把（二进制的）自己每一位都往右移动了。原来的最后第二位，变成了最后第一位。b=(101)<sub>2</sub>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">&#125;<br></code></pre></td></tr></table></figure></li><li><p>循环二，再看看b，最后一位还是11。这说明有“×<em>a</em><sup>2</sup>”，ans∗=base。base继续努力，通过base∗=base让自己变成了a<sup>4</sup>。然后b也右移一位。b=(10)<sub>2</sub>。</p></li><li><p>循环三，可是b的最后一位不再是1了，说明不存在“×a<sup>4</sup>”。base自我升华，达到了a<sup>8</sup>。且b&gt;&gt;=1。这一步中，答案没有增加，可是毕竟b&gt;0，还有希望。</p></li><li><p>循环四，b的最后一位是1，这说明“×a<sup>8</sup>”的存在。ans∗=base。由于b再右移一位就是0了，循环结束。</p><p>总的来说，如果b在二进制上的某一位是1，我们就把答案乘上对应的a<sup>2^n</sup>。</p></li></ul><p><strong>一些相关笔记补充</strong></p><ol type="1"><li><p>直接求幂可以用循环解决，但是会出现溢出的问题</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title function_">normal</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> base,<span class="hljs-type">long</span> <span class="hljs-type">long</span> power)</span>&#123;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> result=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=power;i++)&#123;<br>        result*=base;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>取模运算的法则：</p><p>(a+b)%p=(a%p+b%p)%p(a<em>b)%p=(a%p</em>b%p)%p，利用这一法则可以在循环乘积每一步前先取模来防止溢出</p></li><li><p>快速幂算法：每一步将指数分成两半，相应底数做平方运算，最后求出的结果实际是指数为奇数时的底数相乘</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">while</span>(power&gt;<span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-keyword">if</span>(power&amp;<span class="hljs-number">1</span>==<span class="hljs-number">1</span>)&#123;<br>        result=result *base;<br>    &#125;<br>    power&gt;&gt;=<span class="hljs-number">1</span>;<br>    base=base*base;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="汉诺塔">汉诺塔</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">move</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">char</span> from, <span class="hljs-type">char</span> to)</span> &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Move %d from %c to %c!\n&quot;</span>, n, from, to);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">hanoi</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">char</span> from, <span class="hljs-type">char</span> via, <span class="hljs-type">char</span> to)</span> &#123;<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>)&#123;        <span class="hljs-comment">//只剩一个盘子，递归结束</span><br>        move(n, from, to);<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        hanoi(n - <span class="hljs-number">1</span>, from, to, via);        <span class="hljs-comment">//先把n-1个盘子拿走</span><br>        move(n, from, to);                  <span class="hljs-comment">//再移动最底下的</span><br>        hanoi(n - <span class="hljs-number">1</span>, via, from, to);        <span class="hljs-comment">//再把n-1个搬到目标棍子上</span><br>    &#125;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    <span class="hljs-type">char</span> a = <span class="hljs-string">&#x27;A&#x27;</span>, b = <span class="hljs-string">&#x27;B&#x27;</span>, c = <span class="hljs-string">&#x27;C&#x27;</span>;<br>    hanoi(n, a, b, c);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="判断质数">判断质数</h3><ol type="1"><li><p>法一：直接判断</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">is_prime</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span>&#123;<br>    <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i * i &lt;= x; i++)&#123;<br>        <span class="hljs-keyword">if</span> (x % i == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>生成质数表再查找</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//利用已有的质数表primes，判断n是否为质数</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">isPrime</span><span class="hljs-params">(<span class="hljs-type">int</span> primes[], <span class="hljs-type">int</span> n)</span>&#123;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; primes[i]*primes[i] &lt;= n; i++)&#123;<br>        <span class="hljs-keyword">if</span>(n % primes[i]== <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-comment">//构造≤Q的质数表（Q&gt;=5）</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">init_primes</span><span class="hljs-params">(<span class="hljs-type">int</span> primes[], <span class="hljs-type">int</span> Q)</span>&#123;<br>    <span class="hljs-type">int</span> count=<span class="hljs-number">3</span>, num, step;<br>    primes[<span class="hljs-number">0</span>] = <span class="hljs-number">2</span>; primes[<span class="hljs-number">1</span>] = <span class="hljs-number">3</span>; primes[<span class="hljs-number">2</span>] = <span class="hljs-number">5</span>;<span class="hljs-comment">//头3个质数</span><br>    num = <span class="hljs-number">7</span>; step = <span class="hljs-number">2</span>;<span class="hljs-comment">//初始为2</span><br>    <span class="hljs-keyword">while</span>(count &lt; Q)&#123;<br>        step = <span class="hljs-number">6</span>-step;<span class="hljs-comment">// 构造4-2-4-2-...序列，减少遍历</span><br>        <span class="hljs-keyword">if</span>(isPrime(primes, num))<br>            primes[count++] = num;<br>        num += step;<span class="hljs-comment">// 下一个可能的质数</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="判断闰年">判断闰年</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span>((y%<span class="hljs-number">4</span>==<span class="hljs-number">0</span> &amp;&amp; y%<span class="hljs-number">100</span>!=<span class="hljs-number">0</span>) || y%<span class="hljs-number">400</span>==<span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;闰喵29\n&quot;</span>);<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;不闰喵28\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="计算逆序数">计算逆序数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 利用归并排序计算一串数字a中的逆序数 </span><br><span class="hljs-type">int</span> a[<span class="hljs-number">500010</span>], temp[<span class="hljs-number">500010</span>];<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> nixu;<br><span class="hljs-type">void</span> <span class="hljs-title function_">msort</span><span class="hljs-params">(<span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;n; i++)&#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;a[i]);<br>    &#125;<br>    msort(<span class="hljs-number">0</span>, n<span class="hljs-number">-1</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld&quot;</span>, nixu);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">msort</span><span class="hljs-params">(<span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span>&#123;<br>    <span class="hljs-keyword">if</span>(left == right)&#123;      <span class="hljs-comment">// 只剩一个元素，已经有序，无需排序</span><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> mid = (left+right)/<span class="hljs-number">2</span>;<br><br>    <span class="hljs-comment">// 排序左侧</span><br>    msort(left, mid);<br>    <span class="hljs-comment">// 排序右侧</span><br>    msort(mid+<span class="hljs-number">1</span>, right);<br><br>    <span class="hljs-comment">// 合并</span><br>    <span class="hljs-type">int</span> left_i = left, right_i = mid+<span class="hljs-number">1</span>, i=left;<br>    <span class="hljs-keyword">while</span>(left_i&lt;=mid &amp;&amp; right_i&lt;=right)&#123;<br>        <span class="hljs-keyword">if</span>(a[right_i] &lt; a[left_i])&#123;<br>            nixu += (mid-left_i+<span class="hljs-number">1</span>);<br>            temp[i++] = a[right_i++];<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            temp[i++] = a[left_i++];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(left_i&lt;=mid)&#123;<br>        temp[i++] = a[left_i++];<br>    &#125;<br>    <span class="hljs-keyword">while</span>(right_i&lt;=right)&#123;<br>        temp[i++] = a[right_i++];<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=left; j&lt;=right; j++)&#123;<br>        a[j] = temp[j];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="斐波那契数列">斐波那契数列</h3><ol type="1"><li><p>斐波那契数列</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">fb</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span>&#123;<br>    <span class="hljs-keyword">if</span>(n&lt;=<span class="hljs-number">3</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> fb(n<span class="hljs-number">-3</span>)+fb(n<span class="hljs-number">-1</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>广义斐波那契数列</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title function_">gfb</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> n,<span class="hljs-type">long</span> <span class="hljs-type">long</span> p,<span class="hljs-type">long</span> <span class="hljs-type">long</span> q,<span class="hljs-type">long</span> <span class="hljs-type">long</span> a,<span class="hljs-type">long</span> <span class="hljs-type">long</span> b,<span class="hljs-type">long</span> <span class="hljs-type">long</span> c )</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> n,t,p,q,a,b,c;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld%lld%lld%lld%lld&quot;</span>,&amp;n,&amp;p,&amp;q,&amp;a,&amp;b,&amp;c);<br>    t=gfb(n,p,q,a,b,c);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,t);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title function_">gfb</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> n,<span class="hljs-type">long</span> <span class="hljs-type">long</span> p,<span class="hljs-type">long</span> <span class="hljs-type">long</span> q,<span class="hljs-type">long</span> <span class="hljs-type">long</span> a,<span class="hljs-type">long</span> <span class="hljs-type">long</span> b,<span class="hljs-type">long</span> <span class="hljs-type">long</span> c )</span>&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-number">1</span>==n) <span class="hljs-keyword">return</span> p;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-number">2</span>==n) <span class="hljs-keyword">return</span> q;<br>    <span class="hljs-keyword">if</span>(n&gt;=<span class="hljs-number">3</span>) <span class="hljs-keyword">return</span> (a*gfb(n<span class="hljs-number">-1</span>,p,q,a,b,c)+b*gfb(n<span class="hljs-number">-2</span>,p,q,a,b,c)+c);<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="大数乘法取模-abmod">大数乘法取模-(a*b)%mod</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title function_">quickMulMod</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> a, <span class="hljs-type">long</span> <span class="hljs-type">long</span> b, <span class="hljs-type">long</span> <span class="hljs-type">long</span> mod)</span>&#123;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (b)&#123;<br>        <span class="hljs-keyword">if</span> (b &amp; <span class="hljs-number">1ll</span>)&#123;<br>            ans = (ans + a) % mod;<br>        &#125;<br>        a = (a + a) % mod;<br>        b &gt;&gt;= <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="计算三角形周长面积">计算三角形周长面积</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;math.h&gt;</span></span><br><span class="hljs-type">double</span> <span class="hljs-title function_">S</span><span class="hljs-params">(<span class="hljs-type">double</span> a,<span class="hljs-type">double</span> b,<span class="hljs-type">double</span> c)</span>;<br><span class="hljs-type">double</span> <span class="hljs-title function_">C</span><span class="hljs-params">(<span class="hljs-type">double</span> a,<span class="hljs-type">double</span> b,<span class="hljs-type">double</span> c)</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">int</span> t;<br>    <span class="hljs-type">double</span> x1,y1,x2,y2,x3,y3;<br>    <span class="hljs-type">double</span> a,b,c;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;t);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;t;i++)&#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lf%lf%lf%lf%lf%lf&quot;</span>,&amp;x1,&amp;y1,&amp;x2,&amp;y2,&amp;x3,&amp;y3);<br>        a=<span class="hljs-built_in">sqrt</span>((x2-x3)*(x2-x3)+(y2-y3)*(y2-y3));<br>        b=<span class="hljs-built_in">sqrt</span>((x1-x3)*(x1-x3)+(y1-y3)*(y1-y3));<br>        c=<span class="hljs-built_in">sqrt</span>((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.3f %.3f\n&quot;</span>,C(a,b,c),S(a,b,c));<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">double</span> <span class="hljs-title function_">C</span><span class="hljs-params">(<span class="hljs-type">double</span> a,<span class="hljs-type">double</span> b,<span class="hljs-type">double</span> c)</span>&#123;<br>    <span class="hljs-keyword">return</span> a+b+c;<br>&#125;<br><span class="hljs-comment">//海伦公式</span><br><span class="hljs-type">double</span> <span class="hljs-title function_">S</span><span class="hljs-params">(<span class="hljs-type">double</span> a,<span class="hljs-type">double</span> b,<span class="hljs-type">double</span> c)</span>&#123;<br>    <span class="hljs-type">double</span> co,si;<br>    co=(a*a+b*b-c*c)/(<span class="hljs-number">2</span>*a*b);<br>    si=<span class="hljs-built_in">sqrt</span>(<span class="hljs-number">1</span>-co*co);<br>    <span class="hljs-keyword">return</span> a*b*si/<span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="进制转化">进制转化</h3><ol type="1"><li><p>十进制转二进制小数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">double</span> xiao,x;<br>    <span class="hljs-type">int</span> zheng,a[<span class="hljs-number">50</span>],b[<span class="hljs-number">11</span>],i=<span class="hljs-number">0</span>,cnt=<span class="hljs-number">0</span>,len=<span class="hljs-number">0</span>,tmp;<br>    <span class="hljs-built_in">memset</span>(a,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(a));<br>    <span class="hljs-built_in">memset</span>(b,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(b));<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lf&quot;</span>,&amp;x);<br>    tmp=zheng=(<span class="hljs-type">int</span>)x;   <span class="hljs-comment">//整数部分</span><br>    <span class="hljs-keyword">if</span>(!zheng)&#123;          <span class="hljs-comment">//整数是0</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;0&quot;</span>);<br>    &#125;<span class="hljs-keyword">else</span>&#123;              <span class="hljs-comment">//整数不是0</span><br>        <span class="hljs-keyword">while</span>(zheng)&#123;<br>            a[len++]=zheng%<span class="hljs-number">2</span>;<br>            zheng /= <span class="hljs-number">2</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(i=len<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;  <span class="hljs-comment">//输出整数部分</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,a[i]);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;.&quot;</span>);       <span class="hljs-comment">//输出小数点</span><br>    xiao=x-tmp;       <span class="hljs-comment">//小数部分</span><br>    <span class="hljs-keyword">while</span>(xiao)&#123;<br>        tmp=(<span class="hljs-type">int</span>)(xiao*<span class="hljs-number">2</span>);<br>        b[cnt++]=tmp;<br>        xiao=<span class="hljs-number">2</span>*xiao-tmp;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++)&#123;     <span class="hljs-comment">//输出小数部分</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,b[i]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>二进制转十进制</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">bin2Dec</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[])</span>&#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    * 将2进制转为10进制</span><br><span class="hljs-comment">    * 设1个int的32位bit由低到高存在arr[0]...arr[31]</span><br><span class="hljs-comment">    * 函数命名是binary to decimal的缩写</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">32</span>; i++)&#123;<br>        ret += arr[i] * (<span class="hljs-number">1</span> &lt;&lt; i); <br>        <span class="hljs-comment">//相当于ret += arr[i] * (int)pow(2, i);</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> ret;    <span class="hljs-comment">//ret是得到的十进制数</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>任意进制转换为2-36进制的long long</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ctype.h&gt;</span></span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Convert string to long long int</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * @param s source string</span><br><span class="hljs-comment"> * @param base 2 &lt;= base &lt;= 36</span><br><span class="hljs-comment"> * @return long long int value</span><br><span class="hljs-comment"> */</span><br>ll <span class="hljs-title function_">str2ll</span><span class="hljs-params">(<span class="hljs-type">char</span> s[], <span class="hljs-type">int</span> base)</span> &#123;<br>    ll sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> x, i;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; s[i]; i++) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isdigit</span>(s[i])) x = s[i] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">islower</span>(s[i])) x = s[i] - <span class="hljs-string">&#x27;a&#x27;</span> + <span class="hljs-number">10</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isupper</span>(s[i])) x = s[i] - <span class="hljs-string">&#x27;A&#x27;</span> + <span class="hljs-number">10</span>;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Unexpected Character!&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (x &gt;= base) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Unexpected Character!&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br>        sum *= base;<br>        sum += x;<br>    &#125;<br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">char</span> s[<span class="hljs-number">32</span>];<br>    <span class="hljs-type">int</span> x;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s%d&quot;</span>, s, &amp;x);      <span class="hljs-comment">//s需要转换的字符串    //x进制</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld&quot;</span>, str2ll(s, x));<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="首个出现三次的字母">首个出现三次的字母</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-type">int</span> w1[<span class="hljs-number">27</span>]=&#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-type">int</span> w2[<span class="hljs-number">27</span>]=&#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;<br>    <span class="hljs-type">char</span> str[<span class="hljs-number">105</span>]=&#123;&#125;;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,str);<br>    <span class="hljs-type">int</span> len=<span class="hljs-built_in">strlen</span>(str);<br>    <span class="hljs-type">int</span> flag=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;len;i++)&#123;<br>        <span class="hljs-keyword">if</span>(w1[str[i]-<span class="hljs-string">&#x27;a&#x27;</span>]==<span class="hljs-number">0</span>)&#123;<br>            w1[str[i]-<span class="hljs-string">&#x27;a&#x27;</span>]=i+<span class="hljs-number">1</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;        <span class="hljs-comment">//出现过一次</span><br>            <span class="hljs-keyword">if</span>(w2[str[i]-<span class="hljs-string">&#x27;a&#x27;</span>]==<span class="hljs-number">0</span>) w2[str[i]-<span class="hljs-string">&#x27;a&#x27;</span>]=i+<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c %d %d %d&quot;</span>,str[i],w1[str[i]-<span class="hljs-string">&#x27;a&#x27;</span>],w2[str[i]-<span class="hljs-string">&#x27;a&#x27;</span>],i+<span class="hljs-number">1</span>); <span class="hljs-comment">//哪个字符 第一出现 第二次出现 第三次出现</span><br>                flag=<span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(flag) <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="子串逆置">子串逆置</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;math.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ctype.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ull unsigned long long</span><br><span class="hljs-type">char</span> s[<span class="hljs-number">205</span>];<br><span class="hljs-type">char</span> t[<span class="hljs-number">205</span>];<br><span class="hljs-type">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">char</span> a,<span class="hljs-type">char</span> b)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s %s&quot;</span>,s,t);<br>    <span class="hljs-type">int</span> ls=<span class="hljs-built_in">strlen</span>(s),lt=<span class="hljs-built_in">strlen</span>(t);<br>    <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>,j=<span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> head,tail;<br>    <span class="hljs-type">char</span> tmp;<br>    <span class="hljs-type">int</span> flag=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;=(ls-lt);i++)&#123;<br>        j=<span class="hljs-number">0</span>;<br>        flag=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(s[i]==t[j])&#123;<br>            <span class="hljs-keyword">for</span>(j=<span class="hljs-number">1</span>;j&lt;lt;j++)&#123;<br>                <span class="hljs-keyword">if</span>(s[i+j]!=t[j])&#123;<br>                    flag=<span class="hljs-number">0</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(flag&amp;&amp;j==lt)&#123;<br>            <span class="hljs-keyword">for</span>(head=i,tail=i+lt<span class="hljs-number">-1</span>;head&lt;tail;head++,tail--)&#123;<br>                tmp=s[head];<br>                s[head]=s[tail];<br>                s[tail]=tmp;<br>            &#125;<br>            i+=lt<span class="hljs-number">-1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;ls;i++)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>,s[i]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="字符串归零by-onlyar">字符串归零（by <ahref="onlyar.site">onlyar</a>）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ull<br><span class="hljs-type">void</span> <span class="hljs-title function_">fill_zero_to_string</span><span class="hljs-params">(<span class="hljs-type">char</span> *address)</span>&#123;<br>    ull zero =<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i*<span class="hljs-keyword">sizeof</span>(zero)&lt; MAX_KEEPWORD_LEN; i++)&#123;<br>        *((ull *) address + i) = zero;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3id="字符串查找或许你想写个strstr吗">字符串查找（或许你想写个strstr吗）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MN 50005</span><br><span class="hljs-type">char</span> hastack[MN];<br><span class="hljs-type">char</span> needle[MN];<br><span class="hljs-type">int</span> <span class="hljs-title function_">strStr</span><span class="hljs-params">(<span class="hljs-type">char</span> a[],<span class="hljs-type">char</span> b[])</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    gets(hastack);<br>    gets(needle);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,strStr(hastack,needle));<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">strStr</span><span class="hljs-params">(<span class="hljs-type">char</span> a[],<span class="hljs-type">char</span> b[])</span>&#123;<br>    <span class="hljs-keyword">if</span>(b==<span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-type">int</span> flag=<span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> la=<span class="hljs-built_in">strlen</span>(a),lb=<span class="hljs-built_in">strlen</span>(b),i=<span class="hljs-number">0</span>,j=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;=(la-lb);i++)&#123;<br>            flag=<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>;j&lt;lb;j++)&#123;<br>                <span class="hljs-keyword">if</span>(a[i+j]!=b[j])&#123;<br>                    flag=<span class="hljs-number">0</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(flag) <span class="hljs-keyword">return</span> i+<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(!flag) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3id="多关键字排序-所以说这位不知名的学长你为什么要三目运算符套三目运算符啊害怕">多关键字排序-所以说这位不知名的学长你为什么要三目运算符套三目运算符啊（害怕）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;math.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ctype.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ull unsigned long long</span><br><span class="hljs-type">int</span> n, k;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span>&#123;</span><br>    <span class="hljs-type">int</span> id;<br>    <span class="hljs-type">int</span> w[<span class="hljs-number">11</span>];<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> <span class="hljs-title">arr</span>[1010];</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">cmp</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *a, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *b)</span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> <span class="hljs-title">c</span> =</span> *(<span class="hljs-keyword">struct</span> node *)a;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> <span class="hljs-title">d</span> =</span> *(<span class="hljs-keyword">struct</span> node *)b;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; k; ++i)<br>        <span class="hljs-keyword">if</span>(c.w[i] == d.w[i]) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> i % <span class="hljs-number">2</span> ? (d.w[i] &gt; c.w[i] ? <span class="hljs-number">1</span> : <span class="hljs-number">-1</span>) : (c.w[i] &gt; d.w[i] ? <span class="hljs-number">1</span> : <span class="hljs-number">-1</span>);<br>    <span class="hljs-keyword">return</span> c.id - d.id;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;k);<br>    <span class="hljs-type">int</span> i, j;<br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; n; ++i)&#123;<br>        arr[i].id = i + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(j = <span class="hljs-number">0</span>; j &lt; k; ++j)<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;arr[i].w[j]);<br>    &#125;<br>    qsort(arr, n, <span class="hljs-keyword">sizeof</span>(arr[<span class="hljs-number">0</span>]), cmp);<br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; n; ++i)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, arr[i].id);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3id="你绝对不会用到的-二的幂次方-才不是因为看不懂不敢用呢">你绝对不会用到的-二的幂次方-才不是因为看不懂不敢用呢</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;math.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ctype.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ull unsigned long long</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">re</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    ll n;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,&amp;n);<br>    re(n);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">re</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span>&#123;<br>    <span class="hljs-type">int</span> flag=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span>(n==<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;0&quot;</span>);<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(n==<span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;2(0)&quot;</span>);<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">31</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>            <span class="hljs-keyword">if</span>(n&amp;(<span class="hljs-number">1</span>&lt;&lt;i))&#123;<br>                <span class="hljs-built_in">printf</span>(flag++?<span class="hljs-string">&quot;+2(&quot;</span>:<span class="hljs-string">&quot;2(&quot;</span>);<br>                re(i);<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;)&quot;</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3id="我觉得不会再考一遍吧-双阶乘-但还是存一下吧">我觉得不会再考一遍吧-双阶乘-但还是存一下吧</h3><ol type="1"><li>版本1</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> a[<span class="hljs-number">2500000</span>];<span class="hljs-comment">//定义数组同时将数组全部初始化</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>   <span class="hljs-type">long</span> <span class="hljs-type">long</span> n,t,k=<span class="hljs-number">0</span>;<br>   <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>, &amp;t);<br>   <span class="hljs-type">int</span> i,m,s,c,temp;<span class="hljs-comment">//i用来乘阶乘；m为数组位数; s为位数; c是进位</span><br>   <span class="hljs-keyword">while</span>(k&lt;t)&#123;<br>       <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>, &amp;n);<br>       <span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span>)&#123;<br>           <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;1\n&quot;</span>);<br>       &#125;<span class="hljs-keyword">else</span>&#123;<br>           <span class="hljs-keyword">if</span>(n%<span class="hljs-number">2</span> == <span class="hljs-number">0</span>&amp;&amp;n!=<span class="hljs-number">0</span>)&#123;       <span class="hljs-comment">//偶数情况</span><br>               a[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br>               s=<span class="hljs-number">1</span>;<br>               <span class="hljs-comment">//利用数组来存储结果</span><br>               <span class="hljs-keyword">for</span>(i=<span class="hljs-number">2</span>;i&lt;=n;i+=<span class="hljs-number">2</span>)&#123;<br>                   <span class="hljs-keyword">for</span>(m=<span class="hljs-number">0</span>,c=<span class="hljs-number">0</span>;m&lt;s;m++)&#123;<br>                       temp=a[m]*i+c;<br>                       a[m]=temp%<span class="hljs-number">10</span>;<br>                       c=temp/<span class="hljs-number">10</span>;     <span class="hljs-comment">//进位</span><br>                   &#125;<br>                   <span class="hljs-keyword">while</span>(c!= <span class="hljs-number">0</span>)&#123;<br>                       ++s;<br>                       a[s<span class="hljs-number">-1</span>]=c%<span class="hljs-number">10</span>;<br>                       c=c/<span class="hljs-number">10</span>;<br>                   &#125;<br>               &#125;<br>               <span class="hljs-comment">//倒序输出结果</span><br>               <span class="hljs-keyword">for</span>(i=s<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>                   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,a[i]);<br>               &#125;<br>               <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>           &#125;<span class="hljs-keyword">else</span>&#123;     <span class="hljs-comment">//奇数情况</span><br>               a[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br>               s=<span class="hljs-number">1</span>;<br>               <span class="hljs-comment">//利用数组来存储结果</span><br>               <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=n;i+=<span class="hljs-number">2</span>)&#123;<br>                   <span class="hljs-keyword">for</span>(m=<span class="hljs-number">0</span>,c=<span class="hljs-number">0</span>;m&lt;s;m++)&#123;<br>                       temp=a[m]*i+c;<br>                       a[m]=temp%<span class="hljs-number">10</span>;<br>                       c=temp/<span class="hljs-number">10</span>;<br>                   &#125;<br>                   <span class="hljs-keyword">while</span>(c!=<span class="hljs-number">0</span>)&#123;<br>                       ++s;<br>                       a[s<span class="hljs-number">-1</span>]=c%<span class="hljs-number">10</span>;<br>                       c=c/<span class="hljs-number">10</span>;<br>                   &#125;<br>               &#125;<br>               <span class="hljs-comment">//倒序输出结果</span><br>               <span class="hljs-keyword">for</span>(i=s<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>                   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,a[i]);<br>               &#125;<br>               <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>           &#125;<br>       &#125;<br>       k++;<br>   &#125;<br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2" type="1"><li>版本2</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>   <span class="hljs-type">int</span> a[<span class="hljs-number">10001</span>];<br>   <span class="hljs-type">int</span> b,sum;<br>   <span class="hljs-type">int</span> x=<span class="hljs-number">0</span>;<br>   <span class="hljs-type">int</span> y,z=<span class="hljs-number">0</span>;<br>   <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>,k=<span class="hljs-number">1</span>;<br>   <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;y);<br>   <span class="hljs-keyword">for</span>(k=<span class="hljs-number">1</span>;k&lt;=y;k++)&#123;<br>       z=<span class="hljs-number">0</span>;<br>       i=<span class="hljs-number">0</span>;<br>       <span class="hljs-keyword">while</span>(i&lt;=<span class="hljs-number">10000</span>)&#123;<br>           a[i]=<span class="hljs-number">0</span>;<br>           i++;<br>       &#125;<br>       a[<span class="hljs-number">10000</span>]=<span class="hljs-number">1</span>;<br>       <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;b);<br>       <span class="hljs-keyword">for</span>(;b&gt;=<span class="hljs-number">2</span>;b-=<span class="hljs-number">2</span>)&#123;<br>           <span class="hljs-keyword">for</span>(i=<span class="hljs-number">10000</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>               a[i]*=b;<br>           &#125;<br>           <span class="hljs-keyword">for</span>(i=<span class="hljs-number">10000</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>               <span class="hljs-keyword">if</span>(a[i]&gt;=<span class="hljs-number">10000</span>)&#123;<br>                   a[i<span class="hljs-number">-1</span>]+=(a[i]/<span class="hljs-number">10000</span>);<br>                   a[i]%=<span class="hljs-number">10000</span>;<br>               &#125;<br>           &#125;<br>       &#125;<br>       <span class="hljs-keyword">while</span>(a[z]==<span class="hljs-number">0</span>)&#123;<br>           z++;<br>       &#125;<br>       <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,a[z]);<br>       <span class="hljs-keyword">for</span>(i=z+<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">10000</span>;i++)&#123;<br>           <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%04d&quot;</span>,a[i]);<br>       &#125;<br>       <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>   &#125;<br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="只能伸长不能缩短的变长数组">只能伸长不能缩短的变长数组</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">* 定义结构体 struct Vector，其指针重命名为 VecPtr</span><br><span class="hljs-comment">* length   : 数组已使用的长度</span><br><span class="hljs-comment">* capacity : 数组的容量</span><br><span class="hljs-comment">* array    ：用于存放数据的区域</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Vector</span> &#123;</span><br>    <span class="hljs-type">int</span> length;<br>    <span class="hljs-type">int</span> capacity;<br>    <span class="hljs-type">int</span> *<span class="hljs-built_in">array</span>;<br>&#125; *VecPtr;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">* 创建一个空的变长数组，初始容量为 5，返回变长数组的指针</span><br><span class="hljs-comment">*/</span><br>VecPtr <span class="hljs-title function_">create_vector</span><span class="hljs-params">()</span> &#123;<br>    VecPtr vec = (VecPtr) <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> Vector));<br>    vec-&gt;<span class="hljs-built_in">array</span> = (<span class="hljs-type">int</span> *) <span class="hljs-built_in">malloc</span>(<span class="hljs-number">5</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br>    vec-&gt;capacity = <span class="hljs-number">5</span>;<br>    vec-&gt;length = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> vec;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">* 这个函数可以在数组的尾部插入元素，当数组满了自动扩大一倍</span><br><span class="hljs-comment">* vec  : 变长数组的指针</span><br><span class="hljs-comment">* item : 要插入的元素</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">push_back</span><span class="hljs-params">(VecPtr vec, <span class="hljs-type">int</span> item)</span> &#123;<br>    vec-&gt;<span class="hljs-built_in">array</span>[vec-&gt;length] = item;<br>    vec-&gt;length++;<br>    <span class="hljs-keyword">if</span> (vec-&gt;length == vec-&gt;capacity)   <span class="hljs-comment">// 满了</span><br>        vec-&gt;<span class="hljs-built_in">array</span> = (<span class="hljs-type">int</span> *) <span class="hljs-built_in">realloc</span>(vec-&gt;<span class="hljs-built_in">array</span>, <span class="hljs-number">2</span> * vec-&gt;capacity * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));      <span class="hljs-comment">// 翻倍</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>学习经验</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习经验</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【军训】军训日记</title>
    <link href="/2024/01/13/MT-Diary/"/>
    <url>/2024/01/13/MT-Diary/</url>
    
    <content type="html"><![CDATA[<blockquote><p>军训期间写的日记，几乎都是在结束了一天的训练之后累得不行躺在床上像尸体一样写完的，写的时候大脑已经完全不受理智控制了，有很多很多很多<strong>情绪化</strong>的内容，放出来只是为了记录一下,顺便分享一下军乐连的生活。军训很累，但很快乐。</p><p>最后，欢迎加入旗队，欢迎加入军乐连，欢迎加入行进管乐团。 # 8.31</p></blockquote><p>预计七点讲座，到了之后因为有人乱动让站着等设备调试，八点半左右结束讲座。因为连内有三人被抓胸牌，总共四人犯错共扣八分，所以被抓住批评（回来后得知二营四连也是四人被抓，但没被训）。正坐+军训站姿一共一个小时，被训的时候完全没人说话，死一般的沉默。副指导背着手走来走去，盯每个人的姿势和仪容仪表。过程中有一个人晕倒，一个人报告头晕申请坐下。九点二十五巡完走出艺术楼，在外面又小训了一下，最终成功十点抵达宿舍————然而我们十点半就要熄灯。虽然今天没人查寝，但因为军乐连所有人都罚了抄纪律单，加上完全没有力气站着了，所以只是简单洗漱，抄完清单后就上床了。</p><h1 id="section">9.1</h1><p>今天开始训练旗队的套路，一共学了31个八拍，根本记不住，不过队内有个有经验的同学，已经学到可以教人的程度了。中午的休息时间还挺多的，但晚上基本上就没有休息时间了，大概18:19左右我们抵达食堂，然后大概18:26左右拿到了饭，但是18:50就要集合，于是我们就在20分钟以内解决了晚饭，不过实际上是10分钟左右就解决了一碗滚烫的兰州拉面。本来还想买一杯绿豆冰沙喝一喝，结果因为没有时间就放弃了。</p><p>19:00开始训练。旗队的小教官十分友善地问我们，你们现在头脑还清楚吗？然后我们都说不清楚，于是旗队的小教官就让我们稍微练了一下步伐，就是左右脚的脚后跟分别抬起，大概练了几个八拍，又配着音乐走了一次，然后就让我们休息了。休息了一会儿，小教官的同学？朋友？又或者有可能是之前旗队的人来了，然后那个男生就拿起了旗子甩了几下，我们就开始鼓掌，然后又起哄，“教官来一个！教官来一个！”。于是教官也被我们哄骗着来了一个，然后两个人就抛了一个又一个，最后还被我们哄骗着来了一个一抛一接。</p><p>随后，我们就进了礼堂去看枪械的组合和拆解的讲座，负责讲座的同学来自某个社团。两位同学大概讲了讲枪械的拆装，但是因为时间有限，只有两排左右的人进行练习。很不幸，我不是其中之一。没练到的有个同学一直举着手说“让我来试一试”，结果我们那位<del>长得像尹正的</del>中长发的教官就走过来说你不要举手，我在这里呢www。之后我们又看了DCI08年冠军的表演视频，还有北航学生大概在一七年的时候在台湾的一个国际比赛的夺冠作品，感觉跟杂技表演似的。不过与昨天不同的是，我们坐的时候终于不用保持坐三分之一椅子的姿势了，我可以靠在椅背上，还是蛮舒服的，我旁边那个人都要舒服得睡着了。</p><p>​今天我们连一共有两个人被揪牌，但是都进行了一下求情，所以没有扣分，再加上我们军宣组做的视频好像得到了一个奖，还有一个寝室被评为了标杆寝室之类的东西，然后我们负责纪律的中长头发的<del>长得像尹正的</del>指导员就特别开心。他还跟我说，如果我们之后有一天不迟到，且没有人被揪牌，就会有一个小教官在第二天进行表演，如果我们到军训结束一直都没有被扣分，那他就会表演一段舞蹈，然后我们的特别温柔的女指导员就会表演一段琴。</p><p>今天我们大概在9:30左右放了，然后在10:00左右我打完水上了楼回到了宿舍打开门发现漆黑无比，我的室友居然还没有回来，我十分惊讶，赶紧拿了东西去洗了澡，洗澡的地方也几乎不用排队，大概10分钟左右迅速解决完毕回来发现她们也回来了。过了一会儿看到导员来查寝，说今天只是稍微提醒一下，之后再开始扣分。然后又发现第一批入党申请书要在明天14:00之前交过去，但明天还有开学典礼和训练，可能没有时间写。于是一个寝室四个人有三个都在熬夜写入党申请书。不过除了我之外，其实其他三个人都要等凌晨1:00的值班。于是我就从10:40左右一直写到了凌晨1:00，然后写了大概一半多一点，剩下就明天努力写吧......</p><h1 id="section-1">9.2</h1><p>开学典礼给可怜的军训人一点喘息的机会，虽然起的依旧很早，吃饭时间也很紧张，但是至少我们坐在摄像机拍不到的地方，可以快乐的睡大觉<del>（本人成功在校长讲话的时候睡了过去，困得要死）</del>。军训结束后回宿舍换下院服然后穿军装再走到训练场地，路上教官：“你们走的已经比很多连都齐了，但是你们不要一副刚睡醒的样子，有点精气神好不好。”<del>我：确实刚睡醒。</del></p><p>上午下午复习昨天教的东西，怎么说，能做，但不完全能做，上午训练时间很短，不过因为训练的内容是前天上午学的，所以做的还算熟练，训练时间也看起来很快就过去了。中午回寝室之后一直在看训练的视频，拿着晾衣杆比划了很久。但是下午训练的时候依旧脑子一片空白，明明都是一天前学的东西，为什么昨天就做不好呢（泣）。晚上下了雨，愉快的在宿舍里呆着，但是因为训练效果实在是太差了所以一直拿着晾衣杆比划。室友：你跟魔怔了似的。</p><h1 id="section-2">9.3</h1><p>第二次早训，结果教官因为有事所以去学院路了；；于是不得不和男生一起训，不过很显然男生那边这次训的轻了点儿<del>，感觉教官喊话声音都变小了</del>，上午练完了最后一点动作，还好最后部分动作是重复的，但是，但是！最后七拍也太快了！！！虽然教官看我们是在做不下去，把动作稍微改了改，但动作还是好满啊！！！手都晃不过来了————</p><p>中午一起去加训了一下，结果完全没有时间打扫寝室，感谢舍友理解（非常感谢；；）咣咣咣走回寝室又冲回了食堂，遇到教官在水吧消费。走到训练场地的时候还在国实那边听到了《十年》<del>，一边晒着大太阳去加训一边听歌，有种自己是苦情剧女主的感觉，然后没忍住笑了出来</del>。中午训练的时候看到一堆研究生在那边体检，于是一边练习一边被蚊子咬（咬了我脚踝四个包……不过训练的时候基本上也不会在意，所以问题不大）一边被研究生们观察。接着下午又去篮球馆训练了，看起来场地挺大，但实际上却完全不够走队形，一个下午没有休息把全套队形排完了，结果现在啥都不记得，忘的一干二净。而且因为没有标点，所以走的可以说是乱七八糟，但是，但是！一想到全套动作我们只练了两天半，队形也只练了半天，之前也只练了一天的基本功，突然觉得我们这练得还挺好的，很难想象这么多东西是短短四天搞出来的。</p><p>晚上士谔有个大班的课，于是没有去晚训，因为吃完晚饭才知道要有讲座，所以走过去的路上看到军乐连的同学直接让他们帮忙请了假。个人觉得讲座讲的挺不错，讲的真的很有意思<em>（后编：高宁老师的思政课是极好的；；）</em>。讲座之后军乐连三个女生直接自己走了回来，没等二营四连点名整队，走在路上因为收获了一定的自由所以极其开心，几乎是边走边跳了，还看到六营其他连有人在才艺表演，怎么不带军乐连玩啊；；不过二营四连女生走的真的很快，感觉都要追上我们了，于是快到宿舍楼下的时候三个人就开始狂奔准备抢先回去洗澡。</p><p>另：练旗练得右手小拇指关节酸痛，但别的手指貌似都没问题，痛苦啊；；不过练的时候就感受不到了……</p><h1 id="section-3">9.4</h1><p>上午体检。五点四十起床，六点十分空腹没喝水集合。士谔之前没发采血管和体检单，昨天晚上又开会没拿到东西，于是东西只能今天由男生那边带过来。然而我们在文体馆门口集合许久后才看到“尹正”教官和另一个教官拿着东西下来了。采完血之后已经是七点四十几了，另一个开着的项目是胸透，而其他项目要八点才开，于是就和其他人一起去吃早饭了。东区食堂真的好简陋啊，天花板（又或是空调）还在向下滴水……失物招领柜里面还看到了一个钱包，里面还有身份证……<em>（后编：谁能想到本人的身份证在两个月之后也出现在了这里呢）</em><img src="/img/004MTDiary/002tijian.jpg" alt="体检排队ing" />吃完饭后回去继续体检，测了视力（带着眼镜测，水的一批，指一个能说对就算过）、内科（队伍看着很长实际上不用排很久的队）、血压（上楼之后听到有个研究生和朋友说新开了血压的队伍，于是就跟着冲过去了，然后本来要等近一个小时的队伍，结果几分钟就到我了）、辨色力（喜欢这个）、胸透（令人畏惧的等候时间，大概排了一个半小时的队，期间把朋友圈刷了，把走队形看了好几遍并写成了文字版，还想了两遍怎么转旗）</p><blockquote><h3 id="文字版队形">文字版队形</h3><p><strong>第一套（12个8拍）</strong> 1-2 向前 3-4 向前左前 5-9向右➕并排 10 原地 11-12 八字 <strong>第二套（12个8拍）</strong> 1 原地2小于号 3 一列 4 原地 5 两列 6 向右 7-10 原地 11向右 12原地<strong>第三套打击乐（10个8拍➕9 10 11 12➕2个八拍）</strong> 1-2 原地3-4 八字 5-6 两行 7 原地 8-9 两列？ 10 一列？ 11-12 原地<strong>第四套（1➕12个8拍与第一套相同）</strong> 1（间奏） 回头 1-2向后 3-4 原地 5 回头向外走 6-8 原地 9向前 10-12原地<strong>第五套（4➕1个8拍 1个7拍）</strong> 1-4 原地 5 向左 6 原地</p></blockquote><p>之后吃午饭、回宿舍、洗衣服，然后继续拿着个晾衣杆模拟旗舞。 ​下午到了馆里之后圳哥让我们坐下休息一会，然后跟我们说“我给你们带了点吃的”，然后从包里拿出了两盒果冻，我们：“耶！！！”谢谢圳哥圳哥真好<del>，不愧是有女朋友还天天朋友圈秀恩爱的人</del>。走了一会儿队形之后因为有人来打靶射击所以只能开始练动作，开着空调的篮球馆里硬是搞了一身汗。不过最后一次完整的练习本人从头到尾完整地做完了，耶✌️</p><p>晚上送合唱团的同学到了教三，然后又跑到文体馆，结果发现其他同学都没到，于是两个人和一堆教官坐在大厅里，还在圳哥面前傻乎乎地跑到自动贩卖机看时间，一回来发现背后就有个表……人到齐之后上楼速通了一遍动作就又咣咣咣地跑到教三去开会，累的要死，一身汗还让脱外套穿短袖吹空调，果不其然感冒了。开完会回到文体馆，然后又开了个军乐连的晚会，“尹正”教官说他看了我们的军训日记，然后说情绪有问题可以和朋友、家人、导员说，军训期间也可以和他们教官说。他还说如果脚磨出了水泡实在很疼可以在来和回的路上穿受训鞋，但在操场走队列的时候可以穿自己的鞋。不过他说鞋子要让声部教官帮忙拿，所以一定要很痛才这么做<del>，不然估计圳哥要背三十多双鞋</del>。昨天军乐连有俩被揪牌，一个是旗队的，旗队的同学唱了稻香，还让同学们一起跟唱，中间有段rap都不会，结果有个教官帮忙一起唱了，教官真好谢谢教官。可怜的圳哥也连带着被罚了10个蹲起或俯卧撑，他早上还说自己弯下腰用了20秒，现在还选俯卧撑，我不理解。心疼圳哥圳哥真惨。</p><h1 id="section-4">9.5</h1><p>早训 上午动作下午队列晚上想练队列但因为操场有人占领所以只能动作困得要死</p><h1 id="section-5">9.6</h1><p>四点十分起床，拉练拉了六公里，说实话个人觉得“毒气弹”那边的味道还挺好闻的<del>，像是在烧烤一样……好想去烧烤啊</del><img src="/img/004MTDiary/005marching.jpg" alt="六营！" /></p><p>上午训练因为拿着旗就没拿厚的队形册子，结果不知道教官说的第几页对着哪一个八拍，于是旗队被骂惨了，还说我们态度不端正，说它可以让我们军训不及格，可以让我们重修军训，明年再训的时候把我们再搞到军乐连，然后再让我们不及格……然后圳哥也在那边跟着骂我们，明明他上午训练都晚来一会多睡了会觉，结果还脾气那么大，kuso。一个上午一直当乐队和鼓手的陪练，在那边晒着大太阳还啥都不练，毫无进展，甚至越走越模糊，真的很生气。</p><p>中午估计圳哥是和女朋友吃饭去了，于是下午整个人脾气好了很多，还鼓励我们说已经很棒了，不要太紧张……因为晚上有合唱比赛，所以早一点让我们去吃饭然后提前集合了。晚上合唱比赛前体验了一下一般军训的喊号拉歌，真的是我们完全没有的生活啊。旗队只有旗子和草地。六营真的厉害，合唱比赛拿了第一名，这就是军乐连所在的营————我们小教官还上去吹了伴奏，极好的，什么叫乐团首席啊（后仰）</p><p>合唱比赛之后问有没有人想要加训，旗队有人举手要加训，结果任指导员说我们圳哥身体扛不住实在要不行了，就没让加训，好惨啊圳哥。<img src="/img/004MTDiary/004hechangjiaoguan.png"alt="小教官表演ing" /></p><h1 id="section-6">9.7</h1><p>没有早训，六点三十五起床，舒服，但不完全舒服，吃了个小面包喝了碗紫米粥，舒服。</p><p>上午训练先是旗队自己训，还是挺开心的，后来就给乐队和鼓手做陪练，生不如死，休息的时候就坐在那里看旁边其他连队的人耍枪和匕首还有打军体拳。</p><p>下午在篮球场训练，好痛苦，走的时候总要躲着篮球架子和电线杆子。最后一次训练还做错了两个动作。中间看到尹正教官穿着自己的衣服走了过来说了些什么</p><p>晚上军乐连没去看拔河比赛，而是七点集合然后去咏曼剧场看DCI视频，看的时候困得我要睡着了。我们还看了教官表演时候的第一视角，还通过他的b站账号顺藤摸瓜找到了圳哥和他女朋友的账号，然后狠狠吃了一把狗粮。之后尹正教官来和我们谈心了。他说他一开始很担心表演不能顺利进行。时间紧，任务重，队内伤病员不断增加，每次问小教官情况时得到的答案都是“嗯……应该能搞完吧”，每次教官训练完也都处于崩溃边缘。他说我们这几天训练强度真的很大，处于一种令他害怕的状态（看来我累的要死不是因为我不行）。然后他又和我们说中午的时候一个教官去琴房休息，说不让人打扰他，下午排练完之后他在群里发了一条语音“军乐连！向着琴房！进攻！”虽然不懂什么意思，但大概是很高兴的意思，于是尹正教官说他忽然有了自信，他发现之前自己的训练经验在我们身上不管用了。</p><p>最后还收到了第二批慰问物资，有一个超大的梨，两个苹果，两个香蕉，幸福，终于有水果吃了。</p><h1 id="section-7">9.8</h1><p>走了几遍完整的过场，结果雨越下越大，最后走完一遍就回排练厅里待着了，排练厅里面圳哥巨严肃地让九个人九个人地练动作，练完之后就让我们坐在那里休息，空气安静得让我几乎要睡着，好在我看了一下表，发现快到11:35了，就和圳哥说了一下然后提前撤退去执勤了。</p><p>下午因为有雨，所以先缠了旗，把蓝旗面换成了红旗面。新技能get！刚到场地，圳哥就一脸臭脸地让旗队站好不要动，我怀疑他和他女朋友闹矛盾了。训练时旁边各种走方阵踢正步军体拳匕首操耍枪的人看着，训练的时候还一不小心差点打到旁边的军体拳。最后从入场走了一遍走到了退场。</p><p>退场的时候我们都以为指挥一抬手我们就放旗，结果圳哥跟我们说敲两下鼓再放旗，还说我们不认真听讲，让提前放旗的坐十个蹲起，可恶，明明他没说过怎么放，他只说过拿旗怎么拿。</p><p>晚上下着小雨，本打算带到场地后看上级安排要不要进行全要素演练，结果雨太大了，到了场地后把因为没有雨伞而被困在排练厅的匕首操同学们给救回去了。回去路上雨越来越大，鞋子裤子几乎都湿透了。</p><h1 id="section-8">9.9</h1><p>上午下雨，9:30集合，去做新生采集，人好多，大概11点才搞完，搞完之后回排练厅练了一遍动作就放了。下午两点半集合，因为依旧在下雨没有场地训练，所以到了之后就让联欢会有节目的人先去排练，其他人摸鱼，然后三点半开始联欢。还说有军乐连的往届学长学姐给我们带来了慰问物资，结果并没有收到，泣。但是节目都好精彩；；喜欢</p><p>晚上集合后就去全要素排练，淋着雨等所有人走完方阵，又等完了军体拳，然后我们才上场</p><blockquote><p><em>（以下内容摘自朋友圈）</em></p><p>明天见</p><p>你见过淋着小雨20摄氏度的时候穿着短袖排练耍旗的人吗，我见过，而且耍完旗之后发现还神奇地流汗了。（穿短袖是因为长袖外套活动不开，纯属自愿）。听到掌声的时候真的很感动也很恍惚，在此之前我从未想过我会把管弦乐排练厅当作家，会和行进管乐团产生这么深的羁绊，也从未想过面对观众时我内心的激动会比紧张更多。从最开始练动作时对自己能否完成任务感到怀疑而崩溃，到动作练的差不多稍有自信却又因让人挠头的走图而变回崩溃状态，再到最后能够还算熟练地走完动作。加训也好，晾衣杆模拟也罢，这些付出的努力终究会变成果实。在此之前，我从来没有过连续十天把休息外的时间全部投入到一件事情上————即使高考的时候我也有不同的科目可以轮换着复习，换换脑子。</p><p>顺带一提，drum solo真的好帅；；每次一到那里我就会亢奋不已；；</p><p>可能明天的汇报演出会有吹叉劈的，会有摔旗的，会有节奏忽快忽慢，但我的评价是：<strong>比肩蓝魔！</strong></p></blockquote><p>下场后回去放乐器穿衣服穿雨衣回来重新站队，结果指挥的人嫌我们站的不好让退出去重新站，我不理解，一堆教官同学在那边淋雨，他就这样对待我们，我不理解。结果炸毛教官骂得比我们声音还大，第一次觉得他骂得好（</p><h1 id="section-9">9.10</h1><p>军训生活结束了。</p><p>六点起床洗漱换衣服吃早饭，集合后带到排练厅，练了三遍动作就准备带去后场了，练动作之后圳哥还跟我们说“你们别紧张啊，昨天晚上条件那么差，下着雨，旗杆还滑，又看不清点位，都能走成，今天上午条件这么好一定也可以走成的”。后场的时间好漫长，升国旗看不到旗，仪仗连踢正步也必须蹲下才能看到，后来实在站不住就坐着看了。好在很快就到我们了，军体拳进去的时候我们跟着一起去在后面备场，入场的时候教官还在旁边为我们加油助威。<del>看到打军体拳的同学转过来的时候真的没忍住笑出来了，这队伍怎么这么不齐啊！你们就打个拳而已，为什么有人去到两列中间了。</del></p><p>军体拳之后就到行进管乐了，入场时、drumsolo后以及离场时的鼓掌让我兴奋不已，刚走进去的时候多少有点紧张，但是音乐一响起来，拍子一数起来，我就知道，这一切都是我熟悉的东西，于是一点一点顺理成章的把流程顺了下来，仿佛它早被刻入我的dna里了，于是像梦一般，动作定格在最后一个动作，然后放旗，离场。一次成功的演出，不一定完美，但是它是一场成功的演出，接下来一群人赶回排练厅换好衣服又跑回操场坐在那里听领导讲话，说实话挺难绷的，昨天下了一天雨操场全是湿的，做下去整个裤子全都湿透了。<img src="/img/004MTDiary/006yelling.jpg"alt="军乐嘹亮，士气高昂！扬我军威，壮我北航！" /> &gt;<em>（以下内容摘自朋友圈）</em> &gt; &gt;展示结束从操场向外走的那一刻，突然才发现军训已经结束了，快乐是当然的，终于结束了十天半的痛苦生活，终于能单独行动，能骑车，能穿自己的衣服，外出的时候也不用检查扣子扣没扣全。每天衣服湿透好几次也好，手指手腕脚底板疼的要死也罢，这十天半当然是痛苦的，但结交到的其他班的朋友、变成家的管弦排练厅、自由旋转的旗帜，是我在其他地方永远不会拥有的经历。&gt;最开始写日记只是为了骂教官让所有人因为四个揪牌的在那罚站罚坐一小时。后来日记里就什么都有了，合排时的紧张、给乐队当陪练时的无聊难熬、被夸奖时的快乐。我很感谢当初选择军乐连旗队的我，能够再次度过十天目的单一的日子，我很喜欢这种埋头苦干的感觉，什么都不用想，每天看着旗子转，想着要做什么动作，要向哪边走。最终让我们相信自己，也让教官相信我们可以走完方案。&gt;很遗憾因为士谔的启航仪式没能去参加最后的联欢会，分别总是突然的不正式的，再见</p><p>闭营仪式结束之后我们又去启航仪式，百无聊赖地启航，看着群里传来的军乐连联欢的视频，无比的羡慕，好在最后赶到吃了块蛋糕并且领到了刊物、相框和照片，我会好好珍藏的。</p><p>之后又去大钟广场拍士谔的照片，太阳晃得睁不开眼睛。拍完后火速回宿舍来找爸妈领取探监物资；；搞到了一堆葡萄西瓜梨零食月饼和衣服，然后穿着自己的衣服舒舒服服地去和梦拓团建了，然后又去开小班会，险些迟到，之后回到宿舍稍微收拾一下又去搞淑芬的摸底考试，笑死，考的基本上是高考内容，但忘得一干二净。</p><p>顺带一提今天为了避免葡萄烂掉，分给别的三个宿舍四串葡萄，然后我们宿舍内又努力消灭了剩下的葡萄，幸福</p>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
      <category>军训</category>
      
    </categories>
    
    
    <tags>
      
      <tag>军训</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【学习经验】大一上丨程设丨数分丨高代丨大英丨习概丨道法</title>
    <link href="/2024/01/13/LE-FirstSemester/"/>
    <url>/2024/01/13/LE-FirstSemester/</url>
    
    <content type="html"><![CDATA[<h1 id="c语言程序设计2学分">c语言程序设计（2学分）</h1><ol type="1"><li>高三暑假：b站搜索浙大翁恺提前预习<ol type="1"><li>【浙江大学翁恺教你C语言程序设计！C语言基础入门！】https://www.bilibili.com/video/BV1dr4y1n7vA/?share_source=copy_web&amp;vd_source=fc9422f088d6dd276399cc472e4f7182</li><li>提前预习是为了在第一节课能够听懂老师讲什么，并且在一定程度上领先于其他同学，获得自信。并不代表开学后可以摸鱼，因为事实上我暑假看了并记住的内容老师用一节课就讲完了......</li></ol></li><li>开学后<ol type="1"><li>预习：找学长学姐要ppt/提前1-2天老师会发ppt。强烈建议在课前把ppt上的内容都过一遍，代码都跑一遍。</li><li>课上：别摸鱼。</li><li>课后：<ol type="1"><li>练习赛（当天）：下课后45分钟就考试，晚饭的安排？大多数人只能做出3-4道题，所以没做出来题不用太慌张。</li><li>练习赛（周末）：做一两道就给满平时分（至少我们这届是这样的），但是建议能多做就多做。我最开始做9道（一共10道），大概用半天的时间，后来做7道，但是大概需要一天时间。</li></ol></li></ol></li><li>关于考试<ol type="1"><li>串讲：狠狠的听！</li><li>考试的时候本地的内容都可以看（比如之前写的代码、存的板子、存的ppt、pdf、word文档），所以考试前一定要<strong>存板子存ppt存学长学姐们的串讲资料</strong></li><li>别紧张！你已经考了很多次试了</li><li><strong>提前把杀毒软件卸载了</strong>（别考着考着杀毒软件蹦出来不让你跑程序）</li></ol></li></ol><h1 id="工科数学分析一6学分">工科数学分析（一）（6学分）</h1><ol type="1"><li>高三暑假：本人买了书，只看了封皮底面和侧边，内容一眼没看，建议预习个程设就够了，剩下的时间好好享受这个盛大的夏日吧。</li><li>开学后<ol type="1"><li>预习：看一遍书<del>为了减轻课上摸鱼的罪恶感</del></li><li>课上：大多数人三节连堂（45+5+45+5+45），一直保持清醒是很难的，可以适当地小摸一下，小摸怡情，大摸伤身</li><li>课后：作业有两种<ol type="1"><li>智慧树：判定完成的标准是每个小节都80%完成率以上，阶段测试完成（忘记有没有分数要求了。<strong>难度稍低</strong>，<strong>建议课后及时完成</strong>，不要堆到考试前突击（小技巧：完成阶段测试也可以提升前面每个小节的完成度，如果实在没时间，可以先做阶段测试，然后再单独做前面没刷上完成度的小节）</li><li>书上习题：周末把一周的作业统一上交到平台上。<strong>难度较高</strong>，有的证明题不会做不用担心，看一看答案，把答案看懂就行了。</li><li>辅助理解：【【官方双语】微积分的本质 - 01 -】https://www.bilibili.com/video/BV1cx411m78R/?share_source=copy_web&amp;vd_source=fc9422f088d6dd276399cc472e4f7182</li></ol></li></ol></li><li>关于考试<ol type="1"><li>串讲：能听现场就听现场（无法保证录播的质量），课上做完笔记，课后及时总结</li><li><strong>多做往年题</strong>，能做多少做多少，找到题目的套路之后就能应对考试了（但是也不完全，可能会在今年突然有创新题......<del>听天由命吧朋友</del>）</li></ol></li></ol><h1 id="工科高等代数6学分">工科高等代数（6学分）</h1><ol type="1"><li>高三暑假：把红皮高代（北京航空航天出版社）买了，据说比那个绿皮高代好用</li><li>解析几何（期中前）<ol type="1"><li>预习：没必要</li><li>课上：高中知识+稍稍延伸，简单，视你高中数学学习情况而定，可以小摸甚至大摸</li><li>期中考试：背背公式，看看笔记就够了，不用做往年题</li></ol></li><li>线性代数（期中后）<ol type="1"><li>预习：可以看看书，但我没预习过（xd）</li><li>课上：如果老师讲的课你觉得听不懂，建议自学，自己一个人啃书也好，去b站上网课也好，学习是你的目的，听课不是。我上课基本上是掏出书，开始硬啃，可能半个小时就能把一节课的书看一遍，但是看一遍没法搞懂，看完书后去做课后题（需要注意的是，绿皮书没有课后题的答案），做完课后题再看一遍书。你也可以直接b站听网课。推荐有：<ol type="1"><li>【麻省理工学院 - MIT - 线性代数（我愿称之为线性代数教程天花板）】https://www.bilibili.com/video/BV16Z4y1U7oU/?share_source=copy_web&amp;vd_source=fc9422f088d6dd276399cc472e4f7182</li><li>【北大丘维声教授清华高等代数课程1080P高清修复版(全151集)】https://www.bilibili.com/video/BV1jR4y1M78W/?share_source=copy_web&amp;vd_source=fc9422f088d6dd276399cc472e4f7182</li><li>辅助理解用：【【官方双语/合集】线性代数的本质 - 系列合集】https://www.bilibili.com/video/BV1ys411472E/?share_source=copy_web&amp;vd_source=fc9422f088d6dd276399cc472e4f7182</li></ol></li><li>课后：作业是绿皮书书后题，没答案，我的建议是要写，但不需要特别认真的写，毕竟你要是写错了也不知道，建议找点别的课后习题来做。</li><li>期末考试：做往年题！听串讲！</li></ol></li></ol><h1 id="大学英语2学分">大学英语（2学分）</h1><ol type="1"><li>开学前有分班考试，学长建议去b班，a、b班期末考试题目一样，但是平时成绩b班给的比a班松一点，而且b班事少；但是个人感觉还是要看老师，a、b班都有事多事少的老师，还得看运气。</li><li><del>早八英语课不是人上的，我除了做听力和做pre的时候基本上都在睡觉</del></li><li>关于成绩![/img/002HowToScore]<ol type="1"><li>abcefg感觉基本上都能拿满，最后扣分项目只有听力小测和期末成绩</li><li>听力小测：不同人听力能力会有很大的区别（毕竟有的省市英语高考听口占了50分，有的省市完全不考听力），建议如果高考没有考听力的话，多做做四级题目练练耳朵。个人觉得小测难度与四级听力差不多，但是难度高于北京高考听口。不过个人经验表明如果北京高考听口你能拿50分，你航的听力测试差不多也能应付过去（大概每次考试满分10分能拿个9分10分的）。</li><li>你航英语期末考试只有选择题，分为听力、阅读、词汇。听力和小测难度差不多；阅读比北京高考简单，虽然篇目很长，但是题目简单；词汇很难，<del>约等于涂彩票</del>。但是感觉老师会捞捞，下图是一个b班的成绩。![/img/002ScoreForB/jpg]</li></ol></li></ol><h1 id="习概3学分">习概（3学分）</h1><ol type="1"><li>开卷考试。期末考试前看一下书的目录就行，考试的时候能够找到对应的地方然后迅速开抄就可以。</li></ol><h1 id="道法3学分">道法（3学分）</h1><ol type="1"><li>闭卷考试。填空题（20分）给了范围，选择题（20分）大题（60分）没给范围</li><li>填空题给了大概6面A4纸的范围（一个单元一面纸），我的总复习时间是13h29min，大概复习办法是烤漆复习数分/高代累了的时候，在中间穿插背诵，转换头脑。在所有科目都考完之后集中背诵。</li><li>没给范围的内容就别准备了，毕竟道法书还挺厚的，你看一遍也记不住什么东西。考试靠运气就好。</li><li>大题尽量多写就行，考完试祈祷老师捞捞就好。</li></ol><h1 id="总结">总结</h1><ol type="1"><li>重点：程设数分高代。由于程设只上半学期，数分和高代上一学期......<ol type="1"><li>程设期末考试前（大概11月末）：程设+数分</li><li>程设期末考试后：数分+高代</li></ol></li><li>程设学习时长与学分并不匹配</li><li>数分高代考试策略：听串讲+做往年题</li><li>思政课考试策略：<del>临时抱佛脚</del></li></ol>]]></content>
    
    
    <categories>
      
      <category>学习经验</category>
      
      <category>学期总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习经验</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
