

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/icon02.jpg">
  <link rel="icon" href="/img/icon02.jpg">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  
    <meta name="description" content="说在前面 算法应该是大二上我学的最轻松的一门课了，我有一个完美的开始和一个完美的结束——尽管中间一度每周打算签完到就不做了，非常感谢狗头学长的板子(C++算法板子积累 - Only(AR) 的编程日记)，也特别感谢各位助教对我的帮助。下面的板子转pdf打印出来大概有90多页，虽然大部分都用不上，但是！有总比没有好嘛—— Tips 图论 + 重边：最短路记得判断，只存最短的边 + 负环？">
<meta property="og:type" content="article">
<meta property="og:title" content="【学习经验】算法板子">
<meta property="og:url" content="http://example.com/2025/01/10/LE-suanfabanzi/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="说在前面 算法应该是大二上我学的最轻松的一门课了，我有一个完美的开始和一个完美的结束——尽管中间一度每周打算签完到就不做了，非常感谢狗头学长的板子(C++算法板子积累 - Only(AR) 的编程日记)，也特别感谢各位助教对我的帮助。下面的板子转pdf打印出来大概有90多页，虽然大部分都用不上，但是！有总比没有好嘛—— Tips 图论 + 重边：最短路记得判断，只存最短的边 + 负环？">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/img/LE-suanfabanzi/002.png">
<meta property="article:published_time" content="2025-01-10T03:23:19.000Z">
<meta property="article:modified_time" content="2025-01-10T03:28:38.830Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="学习经验">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://example.com/img/LE-suanfabanzi/002.png">
  
  
  
  <title>【学习经验】算法板子 - Hexo</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.7","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"left","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.2.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Rainel</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>Home</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>Archives</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>Categories</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>Tags</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>About</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/" target="_self">
                <i class="iconfont icon-link-fill"></i>
                <span>Links</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/bg/p2.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="【学习经验】算法板子"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-01-10 11:23" pubdate>
          January 10, 2025 am
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          33k words
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          274 mins
        
      </span>
    

    
    
      
        <span id="leancloud-page-views-container" class="post-meta" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="leancloud-page-views"></span> views
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="padding-left: 2rem; margin-right: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>Table of Contents</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">【学习经验】算法板子</h1>
            
            
              <div class="markdown-body">
                
                <h5 id="说在前面">说在前面</h5>
<p>算法应该是大二上我学的最轻松的一门课了，我有一个完美的开始和一个完美的结束——尽管中间一度每周打算签完到就不做了，非常感谢狗头学长的板子(<a
target="_blank" rel="noopener" href="https://onlyar.site/2022/01/24/Cpp-template/">C++算法板子积累 -
Only(AR)
的编程日记</a>)，也特别感谢各位助教对我的帮助。下面的板子转pdf打印出来大概有90多页，虽然大部分都用不上，但是！有总比没有好嘛——</p>
<h5 id="tips">Tips</h5>
<p><strong>图论</strong> + 重边：最短路记得判断，只存最短的边 +
负环？负边权？ +
有重边的情况下判断负环：有负数就存负数，负数越小越好；否则存正数，正数越大越好
+ 最短路径 + 单源最短路径：一个点到其他任意点的最短路径 +
Bellman-Ford算法：时间<span
class="math inline">\(O(VE)\)</span>；可<strong>负权重</strong>；可<strong>回路</strong>；可以<strong>检测负环</strong>，但不能在存在负环的图中计算单源最短路径。
+ 有向无环图中的单源最短路径问题：时间<span
class="math inline">\(O(V+E)\)</span>；可<strong>负权重</strong>；不可回路
+ Dijkstra算法：时间<span
class="math inline">\(O((V+E)*logV)\)</span>；不可负权重；可<strong>回路</strong>
+ 所有结点对的最短路径问题：所有点到所有点的最短路径 +
floyd算法：时间<span class="math inline">\(O(n^3)\)</span>空间<span
class="math inline">\(O(n^2)\)</span>；可<strong>负权重</strong>；可<strong>回路</strong>；不能检测负环，不能有负环
+ 特别地，可以用<strong>BFS</strong>求无权图最短路径 +
最大流：在一个流网络中，找到从源点到汇点的最大流量。流网络是一个有向图，每条边有一个容量限制，表示通过该边的最大流量。
+ Edmonds-Karp算法：时间 <span
class="math inline">\(O(VE^{2})\)</span>；适合<strong>稀疏</strong>图 +
Dinic算法：时间 <span
class="math inline">\(O(V^{2}E)\)</span>；适合<strong>稠密</strong>图 +
最大二分匹配：在二分图中找到最大的匹配数。二分图是一种特殊的图，其节点可以分为两个互不相交的集合，使得每条边都连接这两个不同集合中的节点。
+ Dinic最小割/最大流算法：时间 <span
class="math inline">\(O(V^2E)\)</span> + 匈牙利算法：时间 <span
class="math inline">\(O(VE)\)</span> +
最小生成树：在连通加权图中，找到一棵包含所有节点的树，使得树中所有边的权重之和最小。目的是找到连接所有顶点的最小总权重的边集。不关心顶点之间的具体路径长度，只关心整体结构的权重最小。
+ Prim：时间 朴素版 <span
class="math inline">\(O(V^2)\)</span>，堆优化版 <span
class="math inline">\(O(ElogV)\)</span> + Kruskal：时间 <span
class="math inline">\(O(ElogE)\)</span> + 有向无环图 <span
class="math inline">\(G(V,E)\)</span>，<span
class="math inline">\(G\)</span>
是半连通的当且仅当有一条路径，这条路径上有图 <span
class="math inline">\(G\)</span>
中所有点：所以判断一个图是不是半连通的只需要判断拓扑序列的相邻节点是否有边</p>
<p><strong>做题思想/技巧</strong> <img
src="/img/LE-suanfabanzi/001.png" srcset="/img/loading.gif" lazyload /></p>
<p><strong>注意事项</strong> + 在对接近 0 的负数四舍五入时应输出
<code>0.00</code> 而非
<code>-0.00</code>：<code>fabs(a) &lt; 0.005</code> 时输出
<code>0.00</code> + <strong>快速读写</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//快读</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> ll <span class="hljs-title">read</span><span class="hljs-params">()</span></span>&#123;<br>   ll s=<span class="hljs-number">0</span>,w=<span class="hljs-number">1</span>;<br>   <span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<br>   <span class="hljs-keyword">while</span>(ch&lt;<span class="hljs-string">&#x27;0&#x27;</span>||ch&gt;<span class="hljs-string">&#x27;9&#x27;</span>)&#123;<span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;-&#x27;</span>)w=<span class="hljs-number">-1</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<br>   <span class="hljs-keyword">while</span>(ch&gt;=<span class="hljs-string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="hljs-string">&#x27;9&#x27;</span>) s=s*<span class="hljs-number">10</span>+ch-<span class="hljs-string">&#x27;0&#x27;</span>,ch=<span class="hljs-built_in">getchar</span>();<br>   <span class="hljs-keyword">return</span> s*w;<br>&#125;<br><span class="hljs-comment">//快写</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">out</span><span class="hljs-params">(ll a)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(a&gt;=<span class="hljs-number">10</span>)<span class="hljs-built_in">out</span>(a/<span class="hljs-number">10</span>);<br>    <span class="hljs-built_in">putchar</span>(a%<span class="hljs-number">10</span>+<span class="hljs-string">&#x27;0&#x27;</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    ll n;<br>    n=<span class="hljs-built_in">read</span>();<br>    <span class="hljs-built_in">out</span>(n);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure> + 数组大小
如无向图双倍空间，FFT四倍空间 空间计算 <code>sizeof</code>
，如下方法计算 数组所占空间（KB）：
<code>cout &lt;&lt; sizeof a/1024</code> + corner case <span
class="math inline">\(n  = 0,1\)</span> <span class="math inline">\(a_i
= 0, 1e9, -1e9\)</span> 几何中斜率为0 + 初始化 +
多测清空，<strong>不要滥用 <code>memset</code></strong>
<code>memset(a, 0, sizeof(int)*(n+1));</code> 正确
<code>memset(a, 0, sizeof a);</code> 超时 以及 <code>memset</code>
初始化最大值 应为 <code>memset(a, 0x3f, sizeof(int) * (n+1));</code> +
<strong>long long</strong> + cin和cout关闭同步流（但关闭后不能用scanf
printf等c语言的输入输出） <code>ios::sync_with_stdio(false)</code> +
cin, cout时用 '' 代替 endl + <strong>数组</strong>是否够大 +
<strong>浮点数误差</strong>：如<strong>几何</strong>求面积能否直接用整数计算
+ <strong>不要用gets!!!!!!!!!!!!!!!!!!</strong> + <strong>int max:
2147483647, which is 2^31 - 1</strong> <strong>int min: -2147483648,
which is -2^31</strong> <strong>long long max: 9223372036854775807,
which is 2^63 - 1</strong> <strong>long long min: -9223372036854775808,
which is -2^63</strong> + 一些最大值最小值 用 <code>climits</code>
头文件 <code>INT_MAX</code> <code>INT_MIN</code> <code>LLONG_MAX</code>
<code>LLONG_MIN</code> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;climits&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 打印整型的最大值和最小值</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;int 的最大值是：&quot;</span> &lt;&lt; INT_MAX &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;int 的最小值是：&quot;</span> &lt;&lt; INT_MIN &lt;&lt; std::endl;<br>    <span class="hljs-comment">// 打印长整型的最大值和最小值</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;long long 的最大值是：&quot;</span> &lt;&lt; LLONG_MAX &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;long long 的最小值是：&quot;</span> &lt;&lt; LLONG_MIN &lt;&lt; std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p>
<h5 id="cppstart">cppStart</h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stack&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;set&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;climits&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="标准库">标准库</h5>
<ul>
<li><p>能<strong>按索引访问</strong>元素的容器：<code>vector</code></p></li>
<li><p>能<strong>遍历</strong>的容器：<code>vector</code>,
<code>set</code>, <code>multiset</code></p></li>
<li><p><code>vector</code>（向量）:
动态数组；当需要<strong>随机访问</strong>元素且频繁在末尾添加或删除元素时。</p></li>
<li><p><code>queue</code>（队列）:
FIFO的数据结构；当需要按照添加顺序处理元素时，如广度优先搜索（BFS）。</p></li>
<li><p><code>priority_queue</code>（优先队列）:
<strong>自动排序</strong>；当需要处理具有优先级的任务时，如最小生成树算法（Prim’s）或处理事件驱动的系统。</p></li>
<li><p><code>stack</code>（栈）:
LIFO；当需要后进先出的处理顺序时，如深度优先搜索（DFS）、递归算法的辅助数据结构。</p></li>
<li><p><code>set</code>（集合）:
<strong>自动排序</strong>，<strong>不包含重复元素</strong>；当需要存储唯一元素并经常进行查找操作时，如去重、集合运算。</p></li>
<li><p><code>multiset</code>（多重集合）: 与 <code>set</code>
类似，但允许存储<strong>重复的元素</strong>；当需要存储元素并保持<strong>有序</strong>，但元素可以重复时。</p></li>
</ul>
<h6 id="algorithm">algorithm</h6>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp">__gcd(a, b) <span class="hljs-comment">// 求两个数的最大公因数  </span><br>__builtin_popcount(a) <span class="hljs-comment">// 求 int 的二进制里多少个 1  </span><br>  <br><span class="hljs-built_in">is_sorted</span>(a, a + n) <span class="hljs-comment">// 是否升序  </span><br><span class="hljs-built_in">is_sorted_until</span>(a, a + n) <span class="hljs-comment">// 到哪里是升序  </span><br><span class="hljs-built_in">sort</span>(a, a + n) <span class="hljs-comment">// 不稳定排序(默认升序)  </span><br><span class="hljs-built_in">sort</span>(a, a + n, <span class="hljs-built_in">greater</span>&lt;<span class="hljs-type">int</span>&gt;()) <span class="hljs-comment">// 降序排序  </span><br><span class="hljs-built_in">stable_sort</span>(a, a + n) <span class="hljs-comment">// 稳定排序  </span><br><span class="hljs-built_in">nth_element</span>(a, a + k, a + n) <span class="hljs-comment">// 将第 k 大元素放到 a[k]  </span><br><span class="hljs-built_in">unique</span>(begin, end) <span class="hljs-comment">// 对有序数组去重，返回末尾地址(去除的是相邻的重复元素,所以使用前需先排序)</span><br>  <br><span class="hljs-built_in">max</span>(a, b) <span class="hljs-comment">// 返回较大值  </span><br><span class="hljs-built_in">min</span>(a, b) <span class="hljs-comment">// 返回较小值  </span><br><span class="hljs-built_in">max_element</span>(a, a + n) <span class="hljs-comment">// 返回最大值位置  </span><br><span class="hljs-built_in">min_element</span>(a, a + n) <span class="hljs-comment">// 返回最小值位置  </span><br>  <br><span class="hljs-type">int</span> pos1 = <span class="hljs-built_in">lower_bound</span>(a, a + n, key)-a; <span class="hljs-comment">// 返回第一个大于等于 key 的元素的下标 </span><br><span class="hljs-type">int</span> pos2 = <span class="hljs-built_in">upper_bound</span>(a, a + n, key)-a; <span class="hljs-comment">// 返回第一个大于 key 的元素的下标</span><br><span class="hljs-built_in">binary_search</span>(a, a + n, key) <span class="hljs-comment">// 二分查找是否存在  </span><br>  <br><span class="hljs-built_in">is_heap</span>(a, a + n) <span class="hljs-comment">// 判断是否为大顶堆 vector&lt;int&gt;a; is_heap(a.begin(), a.end())</span><br><span class="hljs-built_in">is_heap_until</span>(a, a + n) <span class="hljs-comment">// 到哪里是大顶堆  </span><br><span class="hljs-built_in">make_heap</span>(a, a + n) <span class="hljs-comment">// 区间建堆 vector&lt;int&gt;a; make_heap(a.begin(), a.end())</span><br><span class="hljs-built_in">push_heap</span>(a, a + n) <span class="hljs-comment">// 末尾元素入堆并调整，与push_back配合（push_back将元素添加到数组的末尾，然后用push_heap来调整堆）</span><br><span class="hljs-built_in">pop_heap</span>(a, a + n) <span class="hljs-comment">// 堆顶移到末尾并调整，与pop_back配合（pop_heap将堆顶元素移动到数组的末尾，然后用pop_back从数组中移除该元素）</span><br><span class="hljs-built_in">sort_heap</span>(a, a + n) <span class="hljs-comment">// 升序堆排序  </span><br>  <br><span class="hljs-built_in">is_permutation</span>() <span class="hljs-comment">// 两个序列是否互为另一个的排序，即检查它们是否包含相同数量的相同元素，尽管元素的顺序可能不同</span><br><span class="hljs-built_in">next_permutation</span>() <span class="hljs-comment">// 重排为字典序的下一个更大的排列。如果这样的排列存在，返回true；否则，重排为第一个排列（即升序排列），返回false</span><br><span class="hljs-built_in">prev_permutation</span>() <span class="hljs-comment">// 重排为字典序的上一个更小的排列。如果这样的排列存在，返回true；否则，重排为最后一个排列（即降序排列），返回false</span><br>  <br><span class="hljs-built_in">fill</span>(a, a + n, val) <span class="hljs-comment">// 批量赋值  </span><br><span class="hljs-built_in">reverse</span>(a, a + n) <span class="hljs-comment">// 数组翻转</span><br><br><span class="hljs-keyword">auto</span> it = <span class="hljs-built_in">find</span>(shuzu, shuzu+n, <span class="hljs-number">1</span>)<br><span class="hljs-keyword">auto</span> it = <span class="hljs-built_in">find</span>(v1.<span class="hljs-built_in">begin</span>(), v1.<span class="hljs-built_in">end</span>(), <span class="hljs-number">1</span>) <span class="hljs-comment">// 查找v1中有没有1，find函数返回一个迭代器，如果v1中有1则迭代器it指向找到的第一个目标元素，否则指向v1.end()</span><br><span class="hljs-comment">// vector set multiset 普通数组都能用find，queue priority_queue stack不能用</span><br></code></pre></td></tr></table></figure>
<p>如 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> a[<span class="hljs-number">10</span>] = &#123;<span class="hljs-number">5</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;  <br><span class="hljs-type">int</span> b[<span class="hljs-number">10</span>] = &#123;<span class="hljs-number">5</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">1</span>&#125;;  <br>cout &lt;&lt; <span class="hljs-built_in">is_permutation</span>(a, &amp;a[<span class="hljs-number">5</span>], b);<br><span class="hljs-built_in">is_permutation</span> (c1.<span class="hljs-built_in">begin</span>()+<span class="hljs-number">1</span>, c1.<span class="hljs-built_in">end</span>(), c2.<span class="hljs-built_in">begin</span>());<br></code></pre></td></tr></table></figure></p>
<h6 id="vector">vector</h6>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector &lt;<span class="hljs-type">int</span>&gt; v1 <span class="hljs-comment">// 空</span><br>vector &lt;<span class="hljs-type">int</span>&gt; <span class="hljs-built_in">v2</span>(<span class="hljs-number">5</span>,<span class="hljs-number">0</span>); <span class="hljs-comment">// 5个0</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">v3</span><span class="hljs-params">(v2.begin(), v2.end())</span></span>;  <span class="hljs-comment">// 和v2相同</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">v4</span><span class="hljs-params">(v2)</span></span>;   <span class="hljs-comment">// 和v2相同</span><br>v.<span class="hljs-built_in">at</span>(k)   <span class="hljs-comment">// 访问 v[k]  </span><br>v.<span class="hljs-built_in">front</span>() <span class="hljs-comment">// 首元素  </span><br>v.<span class="hljs-built_in">back</span>()  <span class="hljs-comment">// 末元素  </span><br>v.<span class="hljs-built_in">begin</span>() <span class="hljs-comment">// 首地址(迭代器)  用于和v.end()一起放到find()里面去找v中是否存在某个值</span><br>v.<span class="hljs-built_in">end</span>()   <span class="hljs-comment">// 末地址(迭代器)  如auto it = find(v1.begin(),v1.end(),1)</span><br>v.<span class="hljs-built_in">empty</span>()      <span class="hljs-comment">// 是否空  返回true/false</span><br>v.<span class="hljs-built_in">size</span>()       <span class="hljs-comment">// 大小  </span><br>v.<span class="hljs-built_in">max_size</span>()   <span class="hljs-comment">// 最大空间  </span><br>v.<span class="hljs-built_in">clear</span>()      <span class="hljs-comment">// 清除  </span><br>v.<span class="hljs-built_in">insert</span>(pos, item)   <span class="hljs-comment">// 在 pos(迭代器) 位置插入 item  </span><br>v.<span class="hljs-built_in">eraze</span>(pos)   <span class="hljs-comment">// 擦除 pos(迭代器) 位置的元素  </span><br>v.<span class="hljs-built_in">push_back</span>(item)     <span class="hljs-comment">// 末尾插入  </span><br>v.<span class="hljs-built_in">pop_back</span>()   <span class="hljs-comment">// 末尾删除</span><br><br>v.<span class="hljs-built_in">reserve</span>(n);  <span class="hljs-comment">// 请求向量容量至少足以包含 _n_ 个元素。</span><br><br><span class="hljs-comment">// v.size()的返回值是unsigned，所以...</span><br>vector&lt;<span class="hljs-type">int</span>&gt; v;<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">3</span>);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=v.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i++) &#123;<span class="hljs-comment">//错误</span><br>	cout&lt;&lt;v[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=(<span class="hljs-type">int</span>)v.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i++) &#123;<span class="hljs-comment">//(正确)</span><br>	cout&lt;&lt;v[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h6 id="queue">queue</h6>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*----- queue -----*/</span>  <br>queue&lt;<span class="hljs-type">int</span>&gt; q;<br>q.<span class="hljs-built_in">push</span>(item) <span class="hljs-comment">// item 入队  </span><br>q.<span class="hljs-built_in">front</span>() <span class="hljs-comment">// 访问队头  </span><br>q.<span class="hljs-built_in">pop</span>() <span class="hljs-comment">// 出队  </span><br>q.<span class="hljs-built_in">back</span>() <span class="hljs-comment">// 访问队尾  </span><br>q.<span class="hljs-built_in">empty</span>() <span class="hljs-comment">// 是否空  </span><br>q.<span class="hljs-built_in">size</span>() <span class="hljs-comment">// 大小  </span><br>q.<span class="hljs-built_in">emplace</span>(item) <span class="hljs-comment">// item 替换队尾  </span><br><span class="hljs-comment">/*----- priority_queue -----*/</span>  <br>priority_queue&lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;, greater&lt;<span class="hljs-type">int</span>&gt;&gt; pq  <br>pq.<span class="hljs-built_in">top</span>() <span class="hljs-comment">// 访问队首  </span><br>pq.<span class="hljs-built_in">empty</span>() <span class="hljs-comment">// 优先队列是否空  </span><br>pq.<span class="hljs-built_in">size</span>() <span class="hljs-comment">// 大小  </span><br>pq.<span class="hljs-built_in">push</span>(item) <span class="hljs-comment">// 插入 item  </span><br>pq.<span class="hljs-built_in">pop</span>() <span class="hljs-comment">// 出队</span><br></code></pre></td></tr></table></figure>
<h6 id="优先队列的声明">优先队列的声明</h6>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">priority_queue &lt;<span class="hljs-type">int</span>&gt; i;  <span class="hljs-comment">//【排序】14 12 10 8 6</span><br>priority_queue &lt;<span class="hljs-type">double</span>&gt; d;  <br>priority_queue &lt;<span class="hljs-type">int</span>,vector&lt;<span class="hljs-type">int</span>&gt;,less&lt;<span class="hljs-type">int</span>&gt; &gt;q;<span class="hljs-comment">//【排序】14 12 10 8 6</span><br>priority_queue &lt;<span class="hljs-type">int</span>,vector&lt;<span class="hljs-type">int</span>&gt;,greater&lt;<span class="hljs-type">int</span>&gt; &gt; q;<span class="hljs-comment">//【排序】6 8 10 12 14</span><br><span class="hljs-comment">// 不需要#include&lt;vector&gt;头文件，注意后面两个“&gt;”不要写在一起，“&gt;&gt;”是右移运算符  </span><br></code></pre></td></tr></table></figure>
<h6 id="结构体的优先队列">结构体的优先队列</h6>
<p>重写cmp <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;<br>    <span class="hljs-type">int</span> fir,sec;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>,&amp;fir,&amp;sec);&#125;<br>&#125;input;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">cmp1</span>&#123;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span> <span class="hljs-params">()</span> <span class="hljs-params">(<span class="hljs-type">const</span> node &amp;x,<span class="hljs-type">const</span> node &amp;y)</span> <span class="hljs-type">const</span></span>&#123;<br>        <span class="hljs-keyword">return</span> x.fir&lt;y.fir;<br>    &#125;<br>&#125;;<span class="hljs-comment">//当一个node x的fir值小于另一个node y的fir值时，x在y后面</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">cmp3</span>&#123;  <br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span> <span class="hljs-params">()</span> <span class="hljs-params">(<span class="hljs-type">const</span> node &amp;x,<span class="hljs-type">const</span> node &amp;y)</span> <span class="hljs-type">const</span></span>&#123;  <br>        <span class="hljs-keyword">return</span> x.fir+x.sec&lt;y.fir+y.sec;  <br>    &#125;  <br>&#125;;<span class="hljs-comment">//当一个node x的fri值和sec值的和小于另一个node y的fir值和sec值的和时，x在y后面</span><br>priority_queue&lt;node,vector&lt;node&gt;,cmp1&gt; q1;  <br>priority_queue&lt;node,vector&lt;node&gt;,cmp3&gt; q3;  <br><span class="hljs-keyword">while</span>(!q1.<span class="hljs-built_in">empty</span>()) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;(%d,%d) &quot;</span>,q1.<span class="hljs-built_in">top</span>().fir,q1.<span class="hljs-built_in">top</span>().sec),q1.<span class="hljs-built_in">pop</span>(); <br><span class="hljs-keyword">while</span>(!q3.<span class="hljs-built_in">empty</span>()) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;(%d,%d) &quot;</span>,q3.<span class="hljs-built_in">top</span>().fir,q3.<span class="hljs-built_in">top</span>().sec),q3.<span class="hljs-built_in">pop</span>();<br><br>【输入】<br><span class="hljs-number">1</span> <span class="hljs-number">2</span>  <br><span class="hljs-number">2</span> <span class="hljs-number">1</span>  <br><span class="hljs-number">6</span> <span class="hljs-number">9</span>  <br><span class="hljs-number">9</span> <span class="hljs-number">6</span>  <br><span class="hljs-number">-100</span> <span class="hljs-number">100</span>  <br><span class="hljs-number">-500</span> <span class="hljs-number">20</span>  <br><span class="hljs-number">4000</span> <span class="hljs-number">-3000</span><br>【输出】<br>cmp1: (<span class="hljs-number">4000</span>,<span class="hljs-number">-3000</span>) (<span class="hljs-number">9</span>,<span class="hljs-number">6</span>) (<span class="hljs-number">6</span>,<span class="hljs-number">9</span>) (<span class="hljs-number">2</span>,<span class="hljs-number">1</span>) (<span class="hljs-number">1</span>,<span class="hljs-number">2</span>) (<span class="hljs-number">-100</span>,<span class="hljs-number">100</span>) (<span class="hljs-number">-500</span>,<span class="hljs-number">20</span>)  <br>cmp3: (<span class="hljs-number">4000</span>,<span class="hljs-number">-3000</span>) (<span class="hljs-number">6</span>,<span class="hljs-number">9</span>) (<span class="hljs-number">9</span>,<span class="hljs-number">6</span>) (<span class="hljs-number">1</span>,<span class="hljs-number">2</span>) (<span class="hljs-number">2</span>,<span class="hljs-number">1</span>) (<span class="hljs-number">-100</span>,<span class="hljs-number">100</span>) (<span class="hljs-number">-500</span>,<span class="hljs-number">20</span>)<br></code></pre></td></tr></table></figure></p>
<h6 id="stack">stack</h6>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp">stack&lt;<span class="hljs-type">int</span>&gt; s;<br>s.<span class="hljs-built_in">push</span>(item) <span class="hljs-comment">// item 入栈  </span><br>s.<span class="hljs-built_in">top</span>() <span class="hljs-comment">// 访问栈顶  </span><br>s.<span class="hljs-built_in">pop</span>() <span class="hljs-comment">// 出栈</span><br>s.<span class="hljs-built_in">empty</span>() <span class="hljs-comment">// 栈是否空  </span><br>s.<span class="hljs-built_in">size</span>() <span class="hljs-comment">// 大小  </span><br>s.<span class="hljs-built_in">emplace</span>(item) <span class="hljs-comment">// item 替换栈顶  </span><br></code></pre></td></tr></table></figure>
<h6 id="set">set</h6>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*----- set 不允许容器中有重复元素 -----*/</span>  <br>s.<span class="hljs-built_in">size</span>() <span class="hljs-comment">// 大小  </span><br>s.<span class="hljs-built_in">empty</span>() <span class="hljs-comment">// 是否空  </span><br>s.<span class="hljs-built_in">clear</span>() <span class="hljs-comment">// 清除  </span><br>s.<span class="hljs-built_in">insert</span>(key) <span class="hljs-comment">// 插入  </span><br>s.<span class="hljs-built_in">erase</span>(pos/key) <span class="hljs-comment">// 删除  </span><br>s.<span class="hljs-built_in">erase</span>(<span class="hljs-number">3</span>); <span class="hljs-comment">// 删除键值为3的元素 &#123;1,2,3,4,5&#125;-&gt;&#123;1,2,4,5&#125;</span><br><span class="hljs-keyword">auto</span> it = s.<span class="hljs-built_in">find</span>(<span class="hljs-number">4</span>);<br><span class="hljs-keyword">if</span> (it != s.<span class="hljs-built_in">end</span>())&#123; <br>	s.<span class="hljs-built_in">erase</span>(it); <span class="hljs-comment">// 删除迭代器it指向的元素 &#123;1,2,3,4,5&#125;-&gt;&#123;1,2,3,5&#125;</span><br>&#125;<br>s.<span class="hljs-built_in">count</span>(key) <span class="hljs-comment">// 是否存在  </span><br>s.<span class="hljs-built_in">find</span>(key) <span class="hljs-comment">// 查找，成功返回位置，失败返回 s.end()  </span><br><span class="hljs-comment">/*----- multiset 允许容器中有重复元素 -----*/</span>  <br>ms.<span class="hljs-built_in">size</span>() <span class="hljs-comment">// 大小  </span><br>ms.<span class="hljs-built_in">empty</span>() <span class="hljs-comment">// 是否空  </span><br>ms.<span class="hljs-built_in">clear</span>() <span class="hljs-comment">// 清除  </span><br>ms.<span class="hljs-built_in">insert</span>(key) <span class="hljs-comment">// 插入  </span><br>ms.<span class="hljs-built_in">erase</span>(pos/key) <span class="hljs-comment">// 删除  </span><br>ms.<span class="hljs-built_in">count</span>(key) <span class="hljs-comment">// 计数  </span><br>ms.<span class="hljs-built_in">find</span>(key) <span class="hljs-comment">// 查找，成功返回位置，失败返回 s.end()</span><br><br><span class="hljs-comment">//插⼊</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>	s.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">gint</span>());<br><br><span class="hljs-comment">// set容器排序：利用仿函数改变排序规则</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCompare</span>&#123;<br>	<span class="hljs-keyword">public</span>:<br>	<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> v1, <span class="hljs-type">int</span> v2)</span> </span>&#123;<br>		<span class="hljs-keyword">return</span> v1 &gt; v2;<br>	&#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>	<span class="hljs-comment">//默认从小到大 10 20 30 40 50</span><br>	set&lt;<span class="hljs-type">int</span>&gt; s1 = &#123;<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>, <span class="hljs-number">50</span>&#125;;<br>	<span class="hljs-comment">//指定排序规则 50 40 30 20 10</span><br>	set&lt;<span class="hljs-type">int</span>, MyCompare&gt; s2 = &#123;<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>, <span class="hljs-number">50</span>&#125;;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// set的遍历</span><br><span class="hljs-comment">// 法1</span><br><span class="hljs-keyword">for</span> (set&lt;<span class="hljs-type">int</span>&gt;::iterator it = s1.<span class="hljs-built_in">begin</span>(); it != s1.<span class="hljs-built_in">end</span>(); ++it) &#123;  <br>    cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;  <br>&#125;<br><span class="hljs-comment">// 法2</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = mySet.<span class="hljs-built_in">begin</span>(); it != mySet.<span class="hljs-built_in">end</span>(); ++it) &#123;  <br>    cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;  <br>&#125;<br><span class="hljs-comment">// 法3</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> it : mySet) &#123;  <br>    cout &lt;&lt; it &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;  <br>&#125;<br></code></pre></td></tr></table></figure>
<h6 id="pair">pair</h6>
<p>可以用来代替一些便捷的自定义struct。且pair自带小于号，可直接用于排序，第一关键字为第一维升序，第二关键字为第二维升序
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; p1;<br>pair&lt;<span class="hljs-type">int</span>,string&gt; p2;<br>pair&lt;<span class="hljs-type">double</span>,<span class="hljs-type">int</span>&gt; p3;<br></code></pre></td></tr></table></figure></p>
<h6 id="map">map</h6>
<p>构建⼀个映射关系复杂度为 <span class="math inline">\(O(logn)\)</span>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">map&lt;T1,T2&gt; mp;<br>map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; mp1;<br>map&lt;string,<span class="hljs-type">int</span>&gt; mp2;<br>map&lt;<span class="hljs-type">int</span>,set&lt;<span class="hljs-type">int</span>&gt; mp3;<br>map&lt;<span class="hljs-type">int</span>,vector&lt;<span class="hljs-type">int</span>&gt;&gt; mp4;<br></code></pre></td></tr></table></figure></p>
<h5 id="存图">存图</h5>
<h6 id="邻接矩阵">邻接矩阵</h6>
<ul>
<li>存储<strong>稠密图</strong></li>
<li>实现时需要注意<strong>重边与自环</strong>。对于最短路问题，可以在重复的边中选择边权最小的一条保留。</li>
<li>Floyd 算法适合邻接矩阵 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> d[N][N]; <span class="hljs-comment">// N 个结点的邻接矩阵</span><br></code></pre></td></tr></table></figure> ###### 邻接表</li>
<li>存储<strong>稠密图</strong></li>
<li>对于每个结点，使用一个 vector 保存与之相连的边。
<strong>vector实现无权邻接表</strong></li>
<li>假设图中总共至多有 N 个结点，每条边不含边权。可以这样实现邻接表：
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;<span class="hljs-type">int</span>&gt; g[N]; <span class="hljs-comment">// N 个结点的邻接表</span><br>g[u].<span class="hljs-built_in">emplace_back</span>(v); <span class="hljs-comment">// 添加一条边 u → v</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; g[u].<span class="hljs-built_in">size</span>(); i++) &#123;<br>	<span class="hljs-type">int</span> v = g[u][i]; <span class="hljs-comment">// 遍历 u 的出边 u → v</span><br>	<span class="hljs-comment">// · · ·</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
<li>实际上，可以使用语法糖简化遍历出边的实现，但是并不建议滥用 auto。
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> v : g[u]) &#123;<br>	<span class="hljs-comment">// 遍历 u 的出边 u → v</span><br>	<span class="hljs-comment">// · · ·</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<p><strong>vector实现有权邻接表</strong> +
对于具有<strong>边权</strong>或是<strong>其他信息</strong>的边，可以定义结构体以保存边的信息。
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span> &#123;<br>	<span class="hljs-type">int</span> to; <span class="hljs-comment">// 边指向的点</span><br>	<span class="hljs-type">int</span> weight; <span class="hljs-comment">// 边权</span><br>&#125;<br>vector&lt;Edge&gt; g[N];  <span class="hljs-comment">// N 个结点的邻接表</span><br>g[u].<span class="hljs-built_in">emplace_back</span>(&#123;v, w&#125;);  <span class="hljs-comment">// 添加边权为 w 的一条边 u → v</span><br></code></pre></td></tr></table></figure></p>
<p><strong>pair实现有权邻接表</strong> + 两个元素的有序对
<code>⟨x, y⟩</code> 可以使用 STL 的 pair 保存。 +
<code>pair ⟨x, y⟩</code> 之间的大小关系定义为：<span
class="math inline">\(⟨x1, y1⟩ &lt; ⟨x2, y2⟩ ⇐⇒ x1 &lt; x2 ∨ (x1 = x2 ∧
y1 &lt; y2)\)</span> + 第一个元素类型 T1，第二个元素类型 T2 的
pair：<code>pair&lt;T1, T2&gt; p;</code> + 创建一个
pair：<code>p = make_pair(x, y);</code> + 取 pair
的第一个元素：<code>p.first</code> + 取 pair
的第二个元素：<code>p.second</code> + 可以用 pair
实现邻接表。第一个元素保存<strong>边指向的点</strong>，第二个元素保存<strong>边权</strong>：
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; g[N];<br>g[u].<span class="hljs-built_in">emplace_back</span>(<span class="hljs-built_in">make_pair</span>(v, w));<br><span class="hljs-comment">// 添加边权为 w 的一条边 u → v</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> e : g[u]) &#123;<br>	<span class="hljs-type">int</span> v = e.first, w = e.second;<br>	<span class="hljs-comment">// 遍历 u 的出边 u → v，边权为 w</span><br>&#125;<br></code></pre></td></tr></table></figure></p>
<h5 id="char和string">char*和string</h5>
<h6 id="char-to-string">char* to string</h6>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">char</span>* name;<br>string softwareName = name;<br></code></pre></td></tr></table></figure>
<h6 id="string-to-char">string to char*</h6>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">char</span>* <span class="hljs-title">strToChar</span><span class="hljs-params">(string strSend)</span></span>&#123;<br>    <span class="hljs-type">char</span>* ConvertData;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> len2 = strSend.<span class="hljs-built_in">length</span>();<br>    ConvertData = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[len2 + <span class="hljs-number">1</span>];<br>    <span class="hljs-built_in">strcpy</span>(ConvertData, strSend.<span class="hljs-built_in">c_str</span>());<br>    <span class="hljs-keyword">return</span> ConvertData;<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="插入排序">插入排序</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">insertSort</span><span class="hljs-params">(keytype k[ ],<span class="hljs-type">int</span> n)</span>&#123;  <br>	keytype temp;  <br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;n; i++)&#123;  <br>		temp = k[i];  <br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i<span class="hljs-number">-1</span>; j&gt;=<span class="hljs-number">0</span> &amp;&amp; temp&lt;k[j]; j--)   <br>			k[j+<span class="hljs-number">1</span>] = k[j];  <br>		k[j+<span class="hljs-number">1</span>] = temp;  <br>	&#125;  <br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="归并排序-on-log-n">归并排序 <span class="math inline">\(O(n log
n)\)</span></h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ctype.h&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;math.h&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX 1000  </span><br>  <br><span class="hljs-type">int</span> temp[MAX], ans[MAX] = &#123;<span class="hljs-number">50</span>, <span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">70</span>, <span class="hljs-number">40</span>, <span class="hljs-number">80</span>, <span class="hljs-number">60</span>&#125;;  <br>  <br><span class="hljs-type">void</span> <span class="hljs-title function_">Mergesort</span><span class="hljs-params">(<span class="hljs-type">int</span> startId, <span class="hljs-type">int</span> endId)</span>;  <br><span class="hljs-type">void</span> <span class="hljs-title function_">Merge</span><span class="hljs-params">(<span class="hljs-type">int</span> startId, <span class="hljs-type">int</span> midId, <span class="hljs-type">int</span> endId)</span>;  <br>  <br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;  <br>	Mergesort(<span class="hljs-number">0</span>, <span class="hljs-number">7</span>);  <br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">8</span>; i++)  <br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, ans[i]);  <br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>	&#125;  <br><br><span class="hljs-type">void</span> <span class="hljs-title function_">Mergesort</span><span class="hljs-params">(<span class="hljs-type">int</span> startId, <span class="hljs-type">int</span> endId)</span>&#123;  <br>	<span class="hljs-type">int</span> midId = startId + (endId - startId)/<span class="hljs-number">2</span>;  <br>	<span class="hljs-keyword">if</span>(startId &lt; endId)&#123;  <br>		Mergesort(startId, midId);  <br>		Mergesort(midId+<span class="hljs-number">1</span>, endId);  <br>		Merge(startId, midId, endId);  <br>	&#125;  <br>&#125;  <br>  <br><span class="hljs-type">void</span> <span class="hljs-title function_">Merge</span><span class="hljs-params">(<span class="hljs-type">int</span> startId, <span class="hljs-type">int</span> midId, <span class="hljs-type">int</span> endId)</span>&#123;  <br>	<span class="hljs-type">int</span> i=startId, j=midId+<span class="hljs-number">1</span>, k=startId;  <br>	<span class="hljs-keyword">while</span>(i &lt;= midId &amp;&amp; j&lt;=endId)&#123;  <br>		<span class="hljs-keyword">if</span>(ans[i] &lt; ans[j])&#123;  <br>			temp[k] = ans[i];  <br>			k++; i++;  <br>		&#125;<span class="hljs-keyword">else</span>&#123;  <br>			temp[k] = ans[j];  <br>			k++; j++;  <br>		&#125;  <br>	&#125;  <br>	<span class="hljs-keyword">while</span>(i &lt;= midId)&#123;  <br>		temp[k] = ans[i];  <br>		k++; i++;  <br>	&#125;  <br>	<span class="hljs-keyword">while</span>(j &lt;= endId)&#123;  <br>		temp[k] = ans[j];  <br>		k++; j++;  <br>	&#125;  <br>	<span class="hljs-keyword">for</span>(i=startId; i&lt;=endId; i++)&#123;  <br>		ans[i] = temp[i];  <br>	&#125;  <br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="逆序对计数">逆序对计数</h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span>  </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;  <br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;  <br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX (200000+5)  </span><br><span class="hljs-type">int</span> temp[MAX], a[MAX];  <br><span class="hljs-function">ll <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-type">int</span> a[], <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span></span>;  <br>  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;  <br>    <span class="hljs-type">int</span> n;  <br>    cin &gt;&gt; n;  <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)  <br>        cin &gt;&gt; a[i];  <br>    cout &lt;&lt; <span class="hljs-built_in">solve</span>(a, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>);  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;  <br><span class="hljs-function">ll <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-type">int</span> a[], <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> </span>&#123;  <br>    <span class="hljs-keyword">if</span> (left == right)  <br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>    <span class="hljs-keyword">else</span> &#123;  <span class="hljs-comment">// 分治  </span><br>        <span class="hljs-type">int</span> mid = (right - left) / <span class="hljs-number">2</span> + left; <span class="hljs-comment">// 分  </span><br>        ll s1 = <span class="hljs-built_in">solve</span>(a, left, mid);         <span class="hljs-comment">// 治：左边排序  </span><br>        ll s2 = <span class="hljs-built_in">solve</span>(a, mid + <span class="hljs-number">1</span>, right);    <span class="hljs-comment">// 治：右边排序  </span><br>        ll s3 = <span class="hljs-number">0</span>;  <br>        <span class="hljs-type">int</span> i = left, j = mid + <span class="hljs-number">1</span>, k = <span class="hljs-number">0</span>;  <br>        <span class="hljs-keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= right) &#123;     <span class="hljs-comment">// 合：整体排序  </span><br>            <span class="hljs-keyword">if</span> (a[i] &lt;= a[j]) &#123;     <span class="hljs-comment">// 如果 a[i] &lt;= a[j] 就放a[i]进去  </span><br>                temp[left + k] = a[i];  <br>                k++;  <br>                i++;  <br>            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-comment">// 如果 a[i] &gt; a[j] 就放a[j]进去  </span><br>                temp[left + k] = a[j];  <br>                s3 += (mid - i + <span class="hljs-number">1</span>);    <span class="hljs-comment">// 如果a[j]&lt;a[i]，说明a[j]&lt;a[i]~a[mid]，共有mid-i+1个逆序对  </span><br>                k++;  <br>                j++;  <br>            &#125;  <br>        &#125;  <br>        <span class="hljs-keyword">if</span> (i &lt;= mid)  <br>            <span class="hljs-keyword">while</span> (i &lt;= mid) &#123;  <br>                temp[k + left] = a[i];  <br>                k++;  <br>                i++;  <br>            &#125;  <br>        <span class="hljs-keyword">else</span>  <br>            <span class="hljs-keyword">while</span> (j &lt;= right) &#123;  <br>                temp[k + left] = a[j];  <br>                k++;  <br>                j++;  <br>            &#125;  <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> l = left; l &lt;= right; l++)  <br>            a[l] = temp[l];  <br>        <span class="hljs-keyword">return</span> s1 + s2 + s3;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="多数问题">多数问题</h5>
<p>n个数组成一个数组，寻找是否有一个数的数量≥n/2 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span>  </span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">2000000</span>;    <span class="hljs-comment">//定义数组的最大长度  </span><br><span class="hljs-type">int</span> a[N];  <br><span class="hljs-type">int</span> <span class="hljs-title function_">majorityDC</span><span class="hljs-params">(<span class="hljs-type">int</span> a[], <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end, <span class="hljs-type">int</span> *result)</span> &#123;<br>	<span class="hljs-comment">// 分治法求解多数问题，*result是数量过半的数的值，数组下标区间为[start, end]  </span><br>    <span class="hljs-keyword">if</span> (start == end) &#123;  <br>        *result = a[end];  <br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;  <br>    &#125;<span class="hljs-keyword">else</span>&#123;  <br>        <span class="hljs-type">int</span> m1, m2;  <br>        majorityDC(a, start, (start + end) / <span class="hljs-number">2</span>, &amp;m1);    <br>        <span class="hljs-comment">//m1为前半区间[start, (start + end) / 2]的多数  </span><br>        majorityDC(a, (start + end) / <span class="hljs-number">2</span> + <span class="hljs-number">1</span>, end, &amp;m2);   <br>        <span class="hljs-comment">//m2为后半区间[(start + end) / 2 + 1, end]的多数  </span><br>        <span class="hljs-type">int</span> count1 = <span class="hljs-number">0</span>, count2 = <span class="hljs-number">0</span>;  <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = start; i &lt;= end; i++) &#123;  <br>            <span class="hljs-keyword">if</span> (a[i] == m1) &#123;   <span class="hljs-comment">//count1记录m1在数组a[]中出现的次数  </span><br>                count1++;  <br>            &#125;  <br>            <span class="hljs-keyword">if</span> (a[i] == m2) &#123;   <span class="hljs-comment">//count2记录m2在数组a[]中出现的次数  </span><br>                count2++;  <br>            &#125;  <br>        &#125;  <br>        <span class="hljs-keyword">if</span>(count1 &gt; ((end - start + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>)) &#123;  <br>            <span class="hljs-comment">//m1在数组a[]中出现的次数大于数组长度的一半，则m1为多数  </span><br>            *result = m1;  <br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;  <br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(count2 &gt; ((end - start + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>)) &#123;  <br>            <span class="hljs-comment">//m2在数组a[]中出现的次数大于数组长度的一半，则m2为多数  </span><br>            *result = m2;  <br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;  <br>        &#125;<span class="hljs-keyword">else</span>&#123;  <br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <span class="hljs-comment">//m1, m2均不是多数，则数组a[]的多数不存在  </span><br>        &#125;  <br>    &#125;  <br>&#125;  <br>  <br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-type">int</span> n, resultDC;  <br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);  <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;n; i++)&#123;  <br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, &amp;a[i]);  <br>    &#125;  <br>    <span class="hljs-keyword">if</span>(majorityDC(a, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>, &amp;resultDC))&#123;  <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, resultDC);  <br>    &#125;<span class="hljs-keyword">else</span>&#123;  <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Can not find the majority!&quot;</span>);  <br>    &#125;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></td></tr></table></figure></p>
<h5 id="维护堆的性质">维护堆的性质</h5>
<ol type="1">
<li>堆的定义：
<ol type="1">
<li>是一棵完全二叉树</li>
<li>每个节点的值都大于或等于其子节点的值，为最大堆；反之为最小堆。</li>
</ol></li>
<li>堆的存储：一般用数组来表示堆，下标为i的结点的父结点下标为<span
class="math inline">\(\frac{i-1}2\)</span>；其左右子结点分别为 <span
class="math inline">\(2i + 1\)</span>、<span class="math inline">\(2i +
2\)</span>（若数组编号从0开始）。下标为i的结点的父结点下标为<span
class="math inline">\(\frac{i-1}2\)</span>；其左右子结点分别为<span
class="math inline">\(2i\)</span>、<span class="math inline">\(2i +
1\)</span>（若数组编号从1开始） 时间复杂度<span
class="math inline">\(O(lgn)\)</span>或对于树高h的节点来说，时间复杂度<span
class="math inline">\(O(h)\)</span> ###### c递归维护 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 维护最大堆的性质  </span><br><span class="hljs-comment">// arr:一个最大堆的数组  </span><br><span class="hljs-comment">// i:需要调整的堆中的元素  </span><br><span class="hljs-type">void</span> <span class="hljs-title function_">max_heapify</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> n)</span>&#123;  <br>    <span class="hljs-comment">// 从a[i] a[l] a[r]选择最大的  </span><br>    <span class="hljs-type">int</span> l = <span class="hljs-number">2</span>*i+<span class="hljs-number">1</span>, r = <span class="hljs-number">2</span>*i+<span class="hljs-number">2</span>;  <br>    <span class="hljs-type">int</span> largest = i;  <br>    <span class="hljs-keyword">if</span>(l &lt;= n &amp;&amp; arr[l]&gt;arr[largest])&#123;  <br>        largest = l;  <br>    &#125;  <br>    <span class="hljs-keyword">if</span>(r &lt;= n &amp;&amp; arr[r]&gt;arr[largest])&#123;  <br>        largest = r;  <br>    &#125;  <br>    <span class="hljs-comment">// 如果a[i]最大，程序结束  </span><br>    <span class="hljs-keyword">if</span>(largest != i)&#123;  <br>        swap(&amp;arr[i], &amp;arr[largest]);  <br>        max_heapify(arr, largest);  <br>    &#125;  <br>&#125;  <br>  <br><span class="hljs-type">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>* a, <span class="hljs-type">int</span>* b)</span> &#123;  <br>    <span class="hljs-type">int</span> temp = *b;  <br>    *b = *a;  <br>    *a = temp;  <br>&#125;<br></code></pre></td></tr></table></figure>
###### c非递归维护 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 维护最大堆的性质  </span><br><span class="hljs-comment">// arr:一个最大堆的数组  </span><br><span class="hljs-comment">// i:需要调整的堆中的元素  </span><br><span class="hljs-type">void</span> <span class="hljs-title function_">max_heapify</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> &#123;  <br>	<span class="hljs-comment">//建立父节点指标和子节点指标  </span><br>	<span class="hljs-type">int</span> dad = start;  <br>	<span class="hljs-type">int</span> son = dad * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;  <br>	<span class="hljs-keyword">while</span> (son &lt;= end) &#123; <span class="hljs-comment">//若子节点指标在范围内才做比较  </span><br>		<span class="hljs-keyword">if</span> (son + <span class="hljs-number">1</span> &lt;= end &amp;&amp; arr[son] &lt; arr[son + <span class="hljs-number">1</span>]) <span class="hljs-comment">//先比较两个子节点大小，选择最大的  </span><br>		son++;  <br>		<span class="hljs-keyword">if</span> (arr[dad] &gt; arr[son]) <span class="hljs-comment">//如果父节点大于子节点代表调整完毕，直接跳出函数  </span><br>			<span class="hljs-keyword">return</span>;  <br>		<span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">//否则交换父子内容再继续子节点和孙节点比较  </span><br>			swap(&amp;arr[dad], &amp;arr[son]);  <br>			dad = son;  <br>			son = dad * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;  <br>		&#125;  <br>	&#125;  <br>&#125;  <br>  <br><span class="hljs-type">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>* a, <span class="hljs-type">int</span>* b)</span> &#123;  <br>	<span class="hljs-type">int</span> temp = *b;  <br>	*b = *a;  <br>	*a = temp;  <br>&#125;<br></code></pre></td></tr></table></figure> ##### 建堆 时间复杂度<span
class="math inline">\(O(n)\)</span> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">build_max_heap</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[ ],<span class="hljs-type">int</span> n)</span>&#123;  <br>	<span class="hljs-type">int</span> i;  <br>	<span class="hljs-keyword">for</span>(i=n/<span class="hljs-number">2</span><span class="hljs-number">-1</span>; i&gt;=<span class="hljs-number">0</span>; i--) <span class="hljs-comment">// 建初始堆积  </span><br>		max_heapify(arr, i, n);  <br>&#125;<br></code></pre></td></tr></table></figure> ##### 堆排序算法
时间复杂度<span class="math inline">\(O(nlgn)\)</span> ######
c非递归维护最大堆 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 堆排序  </span><br><span class="hljs-type">void</span> <span class="hljs-title function_">heapsort</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> n)</span>&#123;  <br>    build_max_heap(arr, n);     <span class="hljs-comment">// 先建堆  </span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i--) &#123;  <br>        swap(&amp;arr[<span class="hljs-number">0</span>], &amp;arr[i]);     <span class="hljs-comment">// 将第一个元素(剩下的max)和已排好元素前一位做交换  </span><br>        max_heapify(arr, <span class="hljs-number">0</span>, i - <span class="hljs-number">1</span>); <span class="hljs-comment">// 重新调整  </span><br>    &#125;  <br>&#125;  <br>  <br><span class="hljs-comment">// 建堆  </span><br><span class="hljs-type">void</span> <span class="hljs-title function_">build_max_heap</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[ ],<span class="hljs-type">int</span> n)</span>&#123;  <br>    <span class="hljs-type">int</span> i;  <br>    <span class="hljs-keyword">for</span>(i=n/<span class="hljs-number">2</span><span class="hljs-number">-1</span>; i&gt;=<span class="hljs-number">0</span>; i--) <span class="hljs-comment">// 建初始堆积  </span><br>        max_heapify(arr, i, n);  <br>&#125;  <br>  <br><span class="hljs-comment">// 维护最大堆的性质  </span><br><span class="hljs-comment">// arr:一个最大堆的数组  </span><br><span class="hljs-comment">// i:需要调整的堆中的元素  </span><br><span class="hljs-type">void</span> <span class="hljs-title function_">max_heapify</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> n)</span>&#123;  <br>    <span class="hljs-comment">// 从a[i] a[l] a[r]选择最大的  </span><br>    <span class="hljs-type">int</span> l = <span class="hljs-number">2</span>*i+<span class="hljs-number">1</span>, r = <span class="hljs-number">2</span>*i+<span class="hljs-number">2</span>;  <br>    <span class="hljs-type">int</span> largest = i;  <br>    <span class="hljs-keyword">if</span>(l &lt;= n &amp;&amp; arr[l]&gt;arr[i])&#123;  <br>        largest = l;  <br>    &#125;  <br>    <span class="hljs-keyword">if</span>(r &lt;= n &amp;&amp; arr[r]&gt;arr[largest])&#123;  <br>        largest = r;  <br>    &#125;  <br>    <span class="hljs-comment">// 如果a[i]最大，程序结束  </span><br>    <span class="hljs-keyword">if</span>(largest != i)&#123;  <br>        swap(&amp;arr[i], &amp;arr[largest]);  <br>        max_heapify(arr, largest, n);  <br>    &#125;  <br>&#125;  <br>  <br><span class="hljs-type">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>* a, <span class="hljs-type">int</span>* b)</span> &#123;  <br>    <span class="hljs-type">int</span> temp = *b;  <br>    *b = *a;  <br>    *a = temp;  <br>&#125;<br></code></pre></td></tr></table></figure> ###### c+cpp递归维护最大堆
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span>  </span><br><span class="hljs-type">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>* a, <span class="hljs-type">int</span>* b)</span> &#123;  <br>	<span class="hljs-type">int</span> temp = *b;  <br>	*b = *a;  <br>	*a = temp;  <br>&#125;  <br>  <br><span class="hljs-comment">// 维护最大堆的性质  </span><br><span class="hljs-comment">// arr:一个最大堆的数组  </span><br><span class="hljs-comment">// i:需要调整的堆中的元素  </span><br><span class="hljs-type">void</span> <span class="hljs-title function_">max_heapify</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> &#123;  <br>	<span class="hljs-comment">//建立父节点指标和子节点指标  </span><br>	<span class="hljs-type">int</span> dad = start;  <br>	<span class="hljs-type">int</span> son = dad * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;  <br>	<span class="hljs-keyword">while</span> (son &lt;= end) &#123; <span class="hljs-comment">//若子节点指标在范围内才做比较  </span><br>		<span class="hljs-keyword">if</span> (son + <span class="hljs-number">1</span> &lt;= end &amp;&amp; arr[son] &lt; arr[son + <span class="hljs-number">1</span>]) <span class="hljs-comment">//先比较两个子节点大小，选择最大的  </span><br>		son++;  <br>		<span class="hljs-keyword">if</span> (arr[dad] &gt; arr[son]) <span class="hljs-comment">//如果父节点大于子节点代表调整完毕，直接跳出函数  </span><br>			<span class="hljs-keyword">return</span>;  <br>		<span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">//否则交换父子内容再继续子节点和孙节点比较  </span><br>			swap(&amp;arr[dad], &amp;arr[son]);  <br>			dad = son;  <br>			son = dad * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;  <br>		&#125;  <br>	&#125;  <br>&#125;  <br><span class="hljs-comment">// 堆排序算法  </span><br><span class="hljs-type">void</span> <span class="hljs-title function_">heap_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> len)</span> &#123;  <br>	<span class="hljs-type">int</span> i;  <br>	<span class="hljs-comment">//建堆，初始化，i从最后一个父节点开始调整  </span><br>	<span class="hljs-keyword">for</span> (i = len / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)  <br>		max_heapify(arr, i, len - <span class="hljs-number">1</span>);  <br>	<span class="hljs-comment">//先将第一个元素和已排好元素前一位做交换，再从新调整，直到排序完毕  </span><br>	<span class="hljs-keyword">for</span> (i = len - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i--) &#123;  <br>		swap(&amp;arr[<span class="hljs-number">0</span>], &amp;arr[i]);  <br>		max_heapify(arr, <span class="hljs-number">0</span>, i - <span class="hljs-number">1</span>);  <br>	&#125;  <br>&#125;  <br></code></pre></td></tr></table></figure> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span>  </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 维护最大堆的性质  </span><br><span class="hljs-comment">// arr:一个最大堆的数组  </span><br><span class="hljs-comment">// i:需要调整的堆中的元素  </span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">max_heapify</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> </span>&#123;  <br>	<span class="hljs-comment">//建立父节点指标和子节点指标  </span><br>	<span class="hljs-type">int</span> dad = start;  <br>	<span class="hljs-type">int</span> son = dad * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;  <br>	<span class="hljs-keyword">while</span> (son &lt;= end) &#123; <span class="hljs-comment">//若子节点指标在范围内才做比较  </span><br>		<span class="hljs-keyword">if</span> (son + <span class="hljs-number">1</span> &lt;= end &amp;&amp; arr[son] &lt; arr[son + <span class="hljs-number">1</span>]) <span class="hljs-comment">//先比较两个子节点大小，选择最大的  </span><br>		son++;  <br>		<span class="hljs-keyword">if</span> (arr[dad] &gt; arr[son]) <span class="hljs-comment">//如果父节点大于子节点代表调整完毕，直接跳出函数  </span><br>			<span class="hljs-keyword">return</span>;  <br>		<span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">//否则交换父子内容再继续子节点和孙节点比较  </span><br>			<span class="hljs-built_in">swap</span>(arr[dad], arr[son]);  <br>			dad = son;  <br>			son = dad * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;  <br>		&#125;  <br>	&#125;  <br>&#125;  <br><br><span class="hljs-comment">// 堆排序算法  </span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">heap_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> len)</span> </span>&#123;  <br>	<span class="hljs-comment">//初始化，i从最后一个父节点开始调整  </span><br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = len / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)  <br>	<span class="hljs-built_in">max_heapify</span>(arr, i, len - <span class="hljs-number">1</span>);  <br>	<span class="hljs-comment">//先将第一个元素和已经排好的元素前一位做交换，再从新调整(刚调整的元素之前的元素)，直到排序完毕  </span><br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = len - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i--) &#123;  <br>		<span class="hljs-built_in">swap</span>(arr[<span class="hljs-number">0</span>], arr[i]);  <br>		<span class="hljs-built_in">max_heapify</span>(arr, <span class="hljs-number">0</span>, i - <span class="hljs-number">1</span>);  <br>	&#125;  <br>&#125;  <br></code></pre></td></tr></table></figure> ###### 用cpp的algorithm建堆和堆排序
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span>  </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;  <br>    vector&lt;<span class="hljs-type">int</span>&gt; a = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>&#125;;  <br>    <span class="hljs-built_in">make_heap</span>(a.<span class="hljs-built_in">begin</span>(), a.<span class="hljs-built_in">end</span>());   <span class="hljs-comment">// 造堆</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i : a)&#123;  <br>        cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;  <br>    &#125;  <br>    cout &lt;&lt; endl;  <br>    <span class="hljs-built_in">sort_heap</span>(a.<span class="hljs-built_in">begin</span>(), a.<span class="hljs-built_in">end</span>());   <span class="hljs-comment">// 堆排序</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i : a)&#123;  <br>        cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;  <br>    &#125;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
<h5 id="c优先队列">c优先队列</h5>
<h6 id="读最大元素-o1">读最大元素 O(1)</h6>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">heap_maximum</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[])</span>&#123;  <br>	<span class="hljs-keyword">return</span> arr[<span class="hljs-number">0</span>];<br>&#125;<br></code></pre></td></tr></table></figure>
<h6 id="移走最大元素-olgn">移走最大元素 O(lgn)</h6>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">heap_extract_max</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> n)</span>&#123;  <br>	<span class="hljs-keyword">if</span>(n &lt; <span class="hljs-number">1</span>)&#123;  <br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;HEAP UNDERFLOW&quot;</span>);  <br>		<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>	&#125;  <br>	<span class="hljs-type">int</span> max = arr[<span class="hljs-number">0</span>];  <br>	arr[<span class="hljs-number">0</span>] = arr[n<span class="hljs-number">-1</span>];  <br>	n--;  <br>	max_heapify(arr, <span class="hljs-number">0</span>, n);  <br>	<span class="hljs-keyword">return</span> max;  <br>&#125;<br></code></pre></td></tr></table></figure>
<h6 id="增加某结点的值-olgn">增加某结点的值 O(lgn)</h6>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">heap_increase_key</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> key)</span>&#123;  <span class="hljs-comment">// 修改结点arr[i]的值为key</span><br>	<span class="hljs-keyword">if</span>(key &lt; arr[i])&#123;  <br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;NEW KEY IS SMALLER THAN CURRENT KEY&quot;</span>);  <br>	&#125;  <br>	arr[i] = key;  <br>	<span class="hljs-keyword">while</span>(i&gt;<span class="hljs-number">0</span> &amp;&amp; arr[(i<span class="hljs-number">-1</span>)/<span class="hljs-number">2</span>]&lt;arr[i])&#123;  <br>		swap(&amp;a[i], &amp;arr[(i<span class="hljs-number">-1</span>)/<span class="hljs-number">2</span>]);  <br>		i = (i<span class="hljs-number">-1</span>)/<span class="hljs-number">2</span>;  <br>	&#125;  <br>&#125;<br></code></pre></td></tr></table></figure>
<h6 id="插入一个新节点-olgn">插入一个新节点 O(lgn)</h6>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">max_heap_insert</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> key, <span class="hljs-type">int</span> n)</span>&#123;  <br>	n++;  <br>	a[n<span class="hljs-number">-1</span>] = key<span class="hljs-number">-1</span>;  <br>	heap_increase_key(arr, n<span class="hljs-number">-1</span>, key);  <br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="快速排序">快速排序</h5>
<p>最好情况/平均情况：<span class="math inline">\(O(nlgn)\)</span>
###### 法1 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// way1  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> keytype int  </span><br>  <br>using namespace <span class="hljs-built_in">std</span>;  <br><span class="hljs-type">void</span> <span class="hljs-title function_">quickSort</span><span class="hljs-params">(keytype k[],<span class="hljs-type">int</span> n)</span>;  <br><span class="hljs-type">void</span> <span class="hljs-title function_">quick</span><span class="hljs-params">(keytype k[ ],<span class="hljs-type">int</span> left,<span class="hljs-type">int</span> right)</span>;  <br><span class="hljs-type">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span> *x, <span class="hljs-type">int</span> *y)</span>;  <br>  <br><span class="hljs-type">void</span> <span class="hljs-title function_">quickSort</span><span class="hljs-params">(keytype k[],<span class="hljs-type">int</span> n)</span>&#123;  <br>    quick(k, <span class="hljs-number">0</span>, n<span class="hljs-number">-1</span>);  <br>&#125;  <br><span class="hljs-type">void</span> <span class="hljs-title function_">quick</span><span class="hljs-params">(keytype k[ ],<span class="hljs-type">int</span> left,<span class="hljs-type">int</span> right)</span>&#123;  <br>    <span class="hljs-type">int</span> i, j;  <br>    keytype pivot;  <br>    <span class="hljs-keyword">if</span>(left &lt; right)&#123;  <br>        i = left;  <br>        j = right+<span class="hljs-number">1</span>;  <br>        pivot = k[left];  <br>        <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;  <br>            <span class="hljs-keyword">while</span>(k[++i]&lt;pivot &amp;&amp; i!=right) &#123; &#125;  <br>            <span class="hljs-keyword">while</span>(k[--j]&gt;pivot &amp;&amp; j!=left) &#123; &#125;  <br>            <span class="hljs-keyword">if</span>(i &lt; j)  <br>                swap(&amp;k[i], &amp;k[j]);  <span class="hljs-comment">/*交换K[i]与K[j]的内容*/</span>  <br>            <span class="hljs-keyword">else</span>  <br>                <span class="hljs-keyword">break</span>;  <br>        &#125;  <br>        swap(&amp;k[left], &amp;k[j]);      <span class="hljs-comment">/*交换K[s]与K[j]的内容*/</span>  <br>        quick(k, left, j<span class="hljs-number">-1</span>);       <span class="hljs-comment">/* 对前一部分排序 */</span><br>        quick(k, j+<span class="hljs-number">1</span>, right);       <span class="hljs-comment">/* 对后一部分排序 */</span><br>    &#125;  <br>&#125;  <br><span class="hljs-type">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(keytype *x, keytype *y)</span>&#123;  <br>    keytype temp;  <br>    temp = *x;<span class="hljs-comment">//取内容交换    </span><br>	*x = *y;  <br>    *y = temp;  <br>&#125;  <br>  <br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-type">int</span> a[<span class="hljs-number">100</span>] = &#123;<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">123</span>,<span class="hljs-number">1524</span>,<span class="hljs-number">4235</span>,<span class="hljs-number">345</span>,<span class="hljs-number">34</span>,<span class="hljs-number">67</span>,<span class="hljs-number">324</span>&#125;;  <br>    quickSort(a, <span class="hljs-number">12</span>);  <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">12</span>; i++)&#123;  <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, a[i]);  <br>    &#125;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></td></tr></table></figure> ###### 法2 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// way2 BY K&amp;R  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> keytype int  </span><br>  <br>using namespace <span class="hljs-built_in">std</span>;  <br><span class="hljs-type">void</span> <span class="hljs-title function_">quickSort</span><span class="hljs-params">(keytype k[],<span class="hljs-type">int</span> n)</span>;  <br><span class="hljs-type">void</span> <span class="hljs-title function_">qsort</span><span class="hljs-params">(keytype v[ ],<span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span>;  <br><span class="hljs-type">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(keytype v[ ],<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span>;  <br>  <br><span class="hljs-type">void</span> <span class="hljs-title function_">quickSort</span><span class="hljs-params">(keytype k[],<span class="hljs-type">int</span> n)</span>&#123;  <br>    qsort(k, <span class="hljs-number">0</span>, n<span class="hljs-number">-1</span>);  <br>&#125;  <br><span class="hljs-type">void</span> <span class="hljs-title function_">qsort</span><span class="hljs-params">(keytype v[ ],<span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span>&#123;  <br>    <span class="hljs-type">int</span> i, last;  <br>    <span class="hljs-keyword">if</span>(left &gt;= right)  <br>        <span class="hljs-keyword">return</span>;  <br>    swap(v, left, (left+right)/<span class="hljs-number">2</span>);<span class="hljs-comment">// 将中间与left交换，将中间作为基准  </span><br>    last = left;    <span class="hljs-comment">// last: 最后一个比left小的元素  </span><br>    <span class="hljs-keyword">for</span>(i=left+<span class="hljs-number">1</span>; i&lt;=right; i++)  <br>        <span class="hljs-keyword">if</span>(v[i] &lt; v[left])  <span class="hljs-comment">// 如果当前元素小于基准元素  </span><br>            swap(v, ++last, i); <span class="hljs-comment">// last右移，获得新的last  </span><br>    swap(v, left, last);    <span class="hljs-comment">// 把基准元素left放到正确位置  </span><br>    qsort(v, left, last);  <br>    qsort(v, last+<span class="hljs-number">1</span>, right);  <br>&#125;  <br><span class="hljs-type">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(keytype v[ ],<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span>&#123;  <br>    keytype tmp;  <br>    tmp = v[i];  <br>    v[i] = v[j];  <br>    v[j] = tmp;  <br>&#125;  <br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-type">int</span> a[<span class="hljs-number">100</span>] = &#123;<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">123</span>,<span class="hljs-number">1524</span>,<span class="hljs-number">4235</span>,<span class="hljs-number">345</span>,<span class="hljs-number">34</span>,<span class="hljs-number">67</span>,<span class="hljs-number">324</span>&#125;;  <br>    quickSort(a, <span class="hljs-number">12</span>);  <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">12</span>; i++)&#123;  <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, a[i]);  <br>    &#125;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></td></tr></table></figure></p>
<h5 id="快速排序的随机化版本">快速排序的随机化版本</h5>
<p>最坏情况：<span class="math inline">\(O(n^2)\)</span>
期望运行时间：<span class="math inline">\(O(nlgn)\)</span>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;random&gt;</span>  </span><br>  <br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">randomized_partition</span><span class="hljs-params">(<span class="hljs-type">int</span> a[], <span class="hljs-type">int</span> p, <span class="hljs-type">int</span> r)</span></span>;  <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">randomized_quiksort</span><span class="hljs-params">(<span class="hljs-type">int</span> a[], <span class="hljs-type">int</span> p, <span class="hljs-type">int</span> r)</span></span>;  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(<span class="hljs-type">int</span> a[], <span class="hljs-type">int</span> p, <span class="hljs-type">int</span> r)</span></span>;  <br>  <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">randomized_quiksort</span><span class="hljs-params">(<span class="hljs-type">int</span> a[], <span class="hljs-type">int</span> p, <span class="hljs-type">int</span> r)</span></span>&#123;  <br>    <span class="hljs-keyword">if</span>(p &lt; r)&#123;  <br>        <span class="hljs-type">int</span> q = <span class="hljs-built_in">randomized_partition</span>(a, p, r); <span class="hljs-comment">// 随机选择一个元素作为基准，并进行划分  </span><br>        <span class="hljs-built_in">randomized_quiksort</span>(a, p, q<span class="hljs-number">-1</span>);  <br>        <span class="hljs-built_in">randomized_quiksort</span>(a, q+<span class="hljs-number">1</span>, r);  <br>    &#125;  <br>&#125;  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">randomized_partition</span><span class="hljs-params">(<span class="hljs-type">int</span> a[], <span class="hljs-type">int</span> p, <span class="hljs-type">int</span> r)</span></span>&#123;  <br>    <span class="hljs-type">int</span> i = <span class="hljs-built_in">rand</span>()%(r-p)+p; <span class="hljs-comment">// 在[p, r]范围内随机选择一个索引作为基准  </span><br>    <span class="hljs-built_in">swap</span>(a[r], a[i]);  <br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">partition</span>(a, p, r); <span class="hljs-comment">// 调用partition函数进行划分  </span><br>&#125;  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(<span class="hljs-type">int</span> a[], <span class="hljs-type">int</span> p, <span class="hljs-type">int</span> r)</span></span>&#123;  <br>    <span class="hljs-type">int</span> x = a[r];  <br>    <span class="hljs-type">int</span> i = p<span class="hljs-number">-1</span>; <span class="hljs-comment">// i指向小于基准的最后一个元素  </span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=p; j&lt;=r<span class="hljs-number">-1</span>; j++)&#123;  <br>        <span class="hljs-keyword">if</span>(a[j] &lt;= x)&#123;  <br>            i++; <span class="hljs-comment">// i右移  </span><br>            <span class="hljs-built_in">swap</span>(a[i], a[j]); <span class="hljs-comment">// 交换元素，将小于基准的元素移到左边  </span><br>        &#125;  <br>    &#125;  <br>    <span class="hljs-built_in">swap</span>(a[i+<span class="hljs-number">1</span>], a[r]); <span class="hljs-comment">// 将基准元素交换到正确的位置  </span><br>    <span class="hljs-keyword">return</span> i+<span class="hljs-number">1</span>; <span class="hljs-comment">// 返回基准元素的最终位置  </span><br>&#125;  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;  <br>    <span class="hljs-type">int</span> a[<span class="hljs-number">100</span>] = &#123;<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">123</span>,<span class="hljs-number">1524</span>,<span class="hljs-number">4235</span>,<span class="hljs-number">345</span>,<span class="hljs-number">34</span>,<span class="hljs-number">67</span>,<span class="hljs-number">324</span>&#125;;  <br>    <span class="hljs-built_in">randomized_quiksort</span>(a, <span class="hljs-number">0</span>, <span class="hljs-number">12</span>);  <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">12</span>; i++)&#123;  <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, a[i]);  <br>    &#125;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></td></tr></table></figure> ##### 最大子列和 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX 1000005  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long  </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;  <br><span class="hljs-type">int</span> a[MAX];  <br><span class="hljs-comment">// 输入：数组array 数组长度n     返回：array的子列中最大的和</span><br><span class="hljs-function">ll <span class="hljs-title">maxSubArray</span><span class="hljs-params">(<span class="hljs-type">int</span> *array, <span class="hljs-type">int</span> n)</span> </span>&#123;  <br>    ll Max = <span class="hljs-number">-0x3f3f3f3f3f3f3f3f</span>;  <br>    ll sum = <span class="hljs-number">0</span>;  <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;  <br>        <span class="hljs-keyword">if</span> (sum &lt; <span class="hljs-number">0</span>)  <span class="hljs-comment">// 如果sum已经&lt;0了，留下sum只会让之后的和更小，所以去掉sum</span><br>            sum = array[i];  <br>        <span class="hljs-keyword">else</span>  <br>            sum += array[i];  <br>        Max = <span class="hljs-built_in">max</span>(sum, Max);  <br>    &#125;  <br>    <span class="hljs-keyword">return</span> Max;  <br>&#125;  <br>  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;  <br>    <span class="hljs-type">int</span> n;  <br>    cin &gt;&gt; n;  <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)  <br>        cin &gt;&gt; a[i];  <br>    cout &lt;&lt; <span class="hljs-built_in">maxSubArray</span>(a, n);  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></td></tr></table></figure> ##### 钢条切割
给定一段长度为 <span class="math inline">\(n\)</span>
英寸的钢条和一个价格表 <span
class="math inline">\(p_i(i=1,2,...,n)\)</span>
，求切割钢条方案，使得销售收益 <span class="math inline">\(r_n\)</span>
最大。 ###### 带备忘的自顶向下法(top-down with memoization) +
复杂度：<span class="math inline">\(O(n^2)\)</span>
将钢条分为两部分，左边长度为 <span class="math inline">\(i\)</span>
，右边长度为 <span class="math inline">\(n-i\)</span>
，只对右边继续进行切割（递归求解），对左边不再进行切割。
这样，不做任何切割的方案就可以描述为：第一段的长度为 <span
class="math inline">\(n\)</span> ，收益为 <span
class="math inline">\(p_n\)</span> ，剩余部分长度为 <span
class="math inline">\(0\)</span> ，对应的收益为 <span
class="math inline">\(r_n=0\)</span> 。于是我们可以得到公式：<span
class="math inline">\(r_n = max_{1\ge i \ge n}(p_i + r_{n-i})\)</span>。
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span>  </span><br>using namespace <span class="hljs-built_in">std</span>;  <br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX 100  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MIN_VALUE -1  </span><br><span class="hljs-type">int</span> <span class="hljs-title function_">max</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span>&#123;  <br>    <span class="hljs-keyword">if</span>(a &gt; b)&#123;  <br>        <span class="hljs-keyword">return</span> a;  <br>    &#125;<span class="hljs-keyword">else</span>&#123;  <br>        <span class="hljs-keyword">return</span> b;  <br>    &#125;  <br>&#125;  <br>  <br><span class="hljs-comment">// p为价格表，n为正在切割的钢管长度，r为最大收益  </span><br><span class="hljs-type">int</span> <span class="hljs-title function_">MEMOIZED_CUT_ROD_AUX</span><span class="hljs-params">(<span class="hljs-type">int</span>* p, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span>* r)</span>&#123;  <br>    <span class="hljs-type">int</span> q;  <br>    <span class="hljs-keyword">if</span>(r[n] &gt;= <span class="hljs-number">0</span>)&#123;  <span class="hljs-comment">// 切过这个长度，已经记住了  </span><br>        <span class="hljs-keyword">return</span> r[n];  <br>    &#125;  <br>    <span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span>)&#123;     <span class="hljs-comment">// 切一段长度为0的  </span><br>        q = <span class="hljs-number">0</span>;  <br>    &#125;<span class="hljs-keyword">else</span>&#123;  <br>        q = MIN_VALUE;  <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)&#123;    <span class="hljs-comment">// 左边长度i，右边长度n-i  </span><br>            q = max(q, p[i]+MEMOIZED_CUT_ROD_AUX(p, n-i, r));  <br>        &#125;  <br>    &#125;  <br>    r[n] = q;  <br>    <span class="hljs-keyword">return</span> q;  <br>&#125;  <br><br><span class="hljs-comment">// 函数入口 p为价格表 n为正在切割的钢管长度     返回能得到的最大value</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">MEMOIZED_CUT_ROD</span><span class="hljs-params">(<span class="hljs-type">int</span>* p, <span class="hljs-type">int</span> n)</span>&#123;  <br>    <span class="hljs-type">int</span> r[MAX];  <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;=n; i++)&#123;  <br>        r[i] = MIN_VALUE;<span class="hljs-comment">// 初始化  </span><br>    &#125;  <br>    <span class="hljs-keyword">return</span> MEMOIZED_CUT_ROD_AUX(p, n, r);  <br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-type">int</span> p[<span class="hljs-number">15</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">17</span>,<span class="hljs-number">17</span>, <span class="hljs-number">20</span>, <span class="hljs-number">24</span>, <span class="hljs-number">30</span>&#125;;  <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, MEMOIZED_CUT_ROD(p, <span class="hljs-number">14</span>));  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></td></tr></table></figure> ###### 给出最大收益及最优切割方案 下面的
EXTENDED_BOTTOM_UP_CUT_ROD 对长度为 <span
class="math inline">\(i\)</span> 的钢条不仅计算最大收益值 <span
class="math inline">\(r_j\)</span>
，还保存最优解对应的第一段钢条的切割长度 <span
class="math inline">\(S\)</span> 。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span>  </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;  <br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX 100  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MIN_VALUE (-1)  </span><br><span class="hljs-type">int</span> s[MAX], r[MAX];  <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">EXTENDED_BOTTOM_UP_CUT_ROD</span><span class="hljs-params">(<span class="hljs-type">int</span> *p, <span class="hljs-type">int</span> n)</span></span>&#123;  <br>    r[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;  <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>; j&lt;=n; j++)&#123;  <br>        <span class="hljs-type">int</span> q = MIN_VALUE;  <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=j; i++)&#123;  <br>            <span class="hljs-keyword">if</span>(q &lt; p[i]+r[j-i])&#123;    <span class="hljs-comment">// 更好的切割  </span><br>                q = p[i]+r[j-i];    <span class="hljs-comment">// 更新价格  </span><br>                s[j] = i;           <span class="hljs-comment">// 更新切割方式  </span><br>            &#125;  <br>        &#125;  <br>        r[j] = q;  <br>    &#125;  <br>&#125;  <br><span class="hljs-comment">// p:价格表 n:要切的钢条长度  </span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PRINT_CUT_ROD_SOLUTION</span><span class="hljs-params">(<span class="hljs-type">int</span> *p,<span class="hljs-type">int</span> n)</span></span>&#123;  <br>    <span class="hljs-built_in">EXTENDED_BOTTOM_UP_CUT_ROD</span>(p, n);  <br>    <span class="hljs-comment">// 计算切割下来的每段钢条的长度s[1..n]和最大value r[1..n]  </span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, r[n]);  <br>    <span class="hljs-keyword">while</span>(n &gt; <span class="hljs-number">0</span>)&#123;  <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, s[n]);  <br>        n -= s[n];  <br>    &#125;  <br>&#125;  <br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;  <br>    <span class="hljs-type">int</span> p[<span class="hljs-number">15</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">17</span>,<span class="hljs-number">17</span>, <span class="hljs-number">20</span>, <span class="hljs-number">24</span>, <span class="hljs-number">30</span>&#125;;  <br>    <span class="hljs-built_in">PRINT_CUT_ROD_SOLUTION</span>(p, <span class="hljs-number">14</span>);  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></td></tr></table></figure> ##### 矩阵链乘法 +
<strong>矩阵链乘法问题</strong>：给定n个矩阵的链<span
class="math inline">\(&lt;A_1,A_2,...,A_n&gt;\)</span>，矩阵<span
class="math inline">\(A_i\)</span>是规模为 <span
class="math inline">\(p_{i-1}\times p_{i}(1\le i\le
n)\)</span>，求完全括号化方案，使得计算乘积 <span
class="math inline">\(A_1A_2...A_n\)</span> 所需标量乘法次数最少。 +
<strong>完全括号化</strong>：它是单一矩阵，或者是两个完全括号化的矩阵乘积链的积，且已外加括号。
例如，如果矩阵链为<span
class="math inline">\(&lt;A_1,A_2,A_3,A_4&gt;\)</span>，则共有5种完全括号化的矩阵乘积链：<span
class="math inline">\((A_1\ (A_{2}\ (A_{3}\ A_{4}))),\ (A_{1}\ ((A_{2}\
A_3)A_{4})),\ ((A_{1}\ A_2)(A_{3}\ A_{4})),\)</span><span
class="math inline">\(\ ((A_{1}(A_{2}\ A_{3}))A_{4}),\ (((A_{1}\
A_2)A_{3}\ )A_{4}\ )\)</span> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span>  </span><br>using namespace <span class="hljs-built_in">std</span>;  <br><span class="hljs-comment">/*  </span><br><span class="hljs-comment"> * p: 表示矩阵的规模，矩阵 A_i 的规模用 p_i-1 * p_i 表示</span><br><span class="hljs-comment"> * s: s[i,j]表示A_i A_i+1 ... A_j最优括号化方案的分割点位置k  </span><br><span class="hljs-comment"> * m: m[i,j]表示A_i A_i+1 ... A_j所需标量乘法次数的最小值  </span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX 100  </span><br><span class="hljs-type">long</span> <span class="hljs-type">long</span> p[MAX],m[MAX][MAX],s[MAX][MAX];  <br><span class="hljs-type">void</span> <span class="hljs-title function_">MATRIX_CHAIN_ORDER</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span>&#123;  <br>    <span class="hljs-comment">// 初始化  </span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)&#123;  <br>        m[i][i] = <span class="hljs-number">0</span>;  <br>    &#125;  <br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> l=<span class="hljs-number">2</span>; l&lt;=n; l++)&#123;    <span class="hljs-comment">// l is the chain length  </span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n-l+<span class="hljs-number">1</span>; i++)&#123;    <span class="hljs-comment">// 矩阵链的起始位置  </span><br>            <span class="hljs-type">int</span> j = i+l<span class="hljs-number">-1</span>;              <span class="hljs-comment">// 矩阵链的结束位置  </span><br>            m[i][j] = <span class="hljs-number">9223372036854775807</span>;  <span class="hljs-comment">// long long 最大值  </span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=i; k&lt;=j<span class="hljs-number">-1</span>; k++)&#123;  <span class="hljs-comment">// A_i...A_j 的最优括号化方案的分割点为k</span><br>                <span class="hljs-type">long</span> <span class="hljs-type">long</span> q = m[i][k]+m[k+<span class="hljs-number">1</span>][j] + p[i<span class="hljs-number">-1</span>]*p[k]*p[j];  <br>                <span class="hljs-keyword">if</span>(q &lt; m[i][j])&#123;  <br>                    m[i][j] = q;  <br>                    s[i][j] = k;  <br>                &#125;  <br>            &#125;  <br>        &#125;  <br>    &#125;  <br>&#125;  <br><span class="hljs-type">void</span> <span class="hljs-title function_">PRINT_OPTIMAL_PARENS</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> i, <span class="hljs-type">long</span> <span class="hljs-type">long</span> j)</span>&#123;  <br>    <span class="hljs-keyword">if</span>(i == j)&#123;  <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;A&quot;</span>);  <br>    &#125;<span class="hljs-keyword">else</span>&#123;  <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;(&quot;</span>);  <br>        PRINT_OPTIMAL_PARENS(i, s[i][j]);  <br>        PRINT_OPTIMAL_PARENS(s[i][j]+<span class="hljs-number">1</span>, j);  <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;)&quot;</span>);  <br>    &#125;  <br>&#125;  <br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-type">int</span> n;  <br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);  <span class="hljs-comment">// n个矩阵</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;=n; i++)&#123;  <br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>, &amp;p[i]);  <br>    &#125;  <br>    MATRIX_CHAIN_ORDER(n);  <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, m[<span class="hljs-number">1</span>][n]);   <span class="hljs-comment">// A_1..A_n所需标量乘法次数的最小值  </span><br>    PRINT_OPTIMAL_PARENS(<span class="hljs-number">1</span>,n);   <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></td></tr></table></figure></p>
<h5 id="最长公共子序列">最长公共子序列</h5>
<ul>
<li><strong>子序列</strong>：给定一个序列 <span class="math inline">\(X
= &lt;x_1, x_2, ..., x_m&gt;\)</span>，另一个序列 <span
class="math inline">\(Z = &lt;z_1,z_2,...,z_k&gt;\)</span>
满足如下条件时成为 <span class="math inline">\(X\)</span>
的子序列（subsequence），即存在一个严格递增的 <span
class="math inline">\(X\)</span> 的下表序列 <span
class="math inline">\(&lt;i_1,i_2,...,i_k&gt;\)</span>，对所有 <span
class="math inline">\(j=1,2,...,k\)</span>，满足 <span
class="math inline">\(x_{i_1} = z_j\)</span> 。 例如，<span
class="math inline">\(Z=&lt;B,C,D,B&gt;\)</span> 是 <span
class="math inline">\(X=&lt;A,B,C,B,D,A,B&gt;\)</span>
的子序列，对应的下标序列为 <span
class="math inline">\(&lt;2,3,5,7&gt;\)</span> 。</li>
<li><strong>公共子序列</strong>：给定两个序列 <span
class="math inline">\(X\)</span> 和 <span
class="math inline">\(Y\)</span> ，如果 Z 既是 X 的子序列，也是 Y
的子序列，我们称它是 X 和 Y 的公共子序列（common subsequence）。</li>
<li><strong>最长公共子序列问题</strong>（longest-common-subsequence
problem）：给定两个序列 <span class="math inline">\(X =
&lt;x_1,x_2,...,x_m&gt;\)</span> 和 <span
class="math inline">\(Y=&lt;y_1,y_2,..,y_n&gt;\)</span>，求 <span
class="math inline">\(X\)</span> 和 <span
class="math inline">\(Y\)</span> 长度最长的公共子序列。 复杂度：<span
class="math inline">\(O(n^2)\)</span> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX 100  </span><br>  <br><span class="hljs-type">int</span> c[MAX][MAX];  <br>  <br><span class="hljs-comment">// 接受字符串x和y，寻找x和y的最长公共子序列  </span><br><span class="hljs-type">void</span> <span class="hljs-title function_">LCS_LENGTH</span><span class="hljs-params">(<span class="hljs-type">char</span> *x, <span class="hljs-type">char</span> *y)</span>&#123;  <br>    <span class="hljs-comment">// 初始化  </span><br>    <span class="hljs-type">int</span> xLen = <span class="hljs-built_in">strlen</span>(x), yLen = <span class="hljs-built_in">strlen</span>(y);  <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;xLen; i++)&#123;  <br>        <span class="hljs-keyword">if</span>(y[<span class="hljs-number">0</span>] == x[i] || c[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>] == <span class="hljs-number">1</span>)&#123;  <br>            c[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;  <br>        &#125;  <br>    &#125;  <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;yLen; i++)&#123;  <br>        <span class="hljs-keyword">if</span>(x[<span class="hljs-number">0</span>] == y[i] || c[<span class="hljs-number">0</span>][i<span class="hljs-number">-1</span>] == <span class="hljs-number">1</span>)&#123;  <br>            c[<span class="hljs-number">0</span>][i] = <span class="hljs-number">1</span>;  <br>        &#125;  <br>    &#125;  <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;xLen; i++)&#123;  <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>; j&lt;yLen; j++)&#123;  <br>            <span class="hljs-keyword">if</span>(x[i] == y[j])&#123;  <br>                c[i][j] = c[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] + <span class="hljs-number">1</span>;  <br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(c[i<span class="hljs-number">-1</span>][j] &gt;= c[i][j<span class="hljs-number">-1</span>])&#123;   <span class="hljs-comment">// xi!=yj时f(x)=max(c[i-1,j],c[i,j-1])</span><br>                c[i][j] = c[i<span class="hljs-number">-1</span>][j];  <br>            &#125;<span class="hljs-keyword">else</span>&#123;  <br>                c[i][j] = c[i][j<span class="hljs-number">-1</span>];  <br>            &#125;  <br>        &#125;  <br>    &#125;  <br>&#125;  <br><span class="hljs-comment">// 最长公共子序列 输入字符串x,y 字符串长度-1是i,j</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">PRINT_LCS</span><span class="hljs-params">(<span class="hljs-type">char</span> *x, <span class="hljs-type">char</span> *y, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span>&#123;  <br>    <span class="hljs-keyword">if</span>(i == <span class="hljs-number">-1</span> || j == <span class="hljs-number">-1</span>)&#123;  <br>        <span class="hljs-keyword">return</span>;  <br>    &#125;  <br>    <span class="hljs-keyword">if</span>(x[i] == y[j])&#123;  <br>        PRINT_LCS(x, y, i<span class="hljs-number">-1</span>, j<span class="hljs-number">-1</span>);  <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c &quot;</span>, x[i]);  <br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(c[i<span class="hljs-number">-1</span>][j] &gt;= c[i][j<span class="hljs-number">-1</span>])&#123;  <br>        PRINT_LCS(x, y, i<span class="hljs-number">-1</span>, j);  <br>    &#125;<span class="hljs-keyword">else</span>&#123;  <br>        PRINT_LCS(x, y, i, j<span class="hljs-number">-1</span>);  <br>    &#125;  <br>&#125;  <br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-type">char</span> x[MAX] = <span class="hljs-string">&quot;ABCBDAB&quot;</span>, y[MAX] = <span class="hljs-string">&quot;BDCABA&quot;</span>;  <br>    LCS_LENGTH(x,y);  <br>    PRINT_LCS(x, y, <span class="hljs-built_in">strlen</span>(x)<span class="hljs-number">-1</span>, <span class="hljs-built_in">strlen</span>(y)<span class="hljs-number">-1</span>);  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h5 id="最长公共子串">最长公共子串</h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 最长公共子串 输入字符串s1和s2 返回最长公共子串的长度max  </span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">PRINT_LCS2</span><span class="hljs-params">(<span class="hljs-type">char</span> *s1, <span class="hljs-type">char</span> *s2)</span></span>&#123;  <br>    <span class="hljs-type">int</span> max = <span class="hljs-number">0</span>, start = <span class="hljs-number">0</span>, len1 = <span class="hljs-built_in">strlen</span>(s1), len2 = <span class="hljs-built_in">strlen</span>(s2);  <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=len1; i++)&#123;  <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>; j&lt;=len2; j++)&#123;  <br>            <span class="hljs-keyword">if</span>(s1[i<span class="hljs-number">-1</span>] == s2[j<span class="hljs-number">-1</span>])  <br>                dp[i][j] = dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] + <span class="hljs-number">1</span>;  <br>            <span class="hljs-keyword">if</span>(dp[i][j] &gt; max)&#123;  <br>                max = dp[i][j]; <span class="hljs-comment">// 最长公共子串的长度  </span><br>                start = i - max; <span class="hljs-comment">// 该子串的起始点位  </span><br>            &#125;  <br>        &#125;  <br>    &#125;  <br>    <span class="hljs-keyword">return</span> max;<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="最优二叉搜索树">最优二叉搜索树</h5>
<ul>
<li><strong>最优二叉搜索树问题</strong>：给定一个 <span
class="math inline">\(n\)</span> 个不同关键字的已排序的序列 <span
class="math inline">\(K=&lt;k_1,k_2,…,k_n&gt;(
k_1&lt;k_2&lt;…&lt;k_n)\)</span>
，我们希望用这些关键字构造一棵二叉搜索树。对每个关键字 <span
class="math inline">\(k\)</span>，都有一个概率<span
class="math inline">\(p_i\)</span>，表示其搜索频率。有些要搜索的值可能不在
<span class="math inline">\(K\)</span> 中，因此我们还有 <span
class="math inline">\(n+1个\)</span> <strong>伪关键字</strong> <span
class="math inline">\(d_0,d_1,d_2,...,d+n\)</span> 表示不在 <span
class="math inline">\(K\)</span> 中的值。<span
class="math inline">\(d_0\)</span> 表示所有小于 <span
class="math inline">\(k_1\)</span> 的值，<span
class="math inline">\(d_n\)</span> 表示所有大于 <span
class="math inline">\(k_n\)</span> 的值，对 <span
class="math inline">\(i=1，2，…，n-1\)</span>，伪关键字 <span
class="math inline">\(d_i\)</span> 表示所有在 <span
class="math inline">\(k_i\)</span> 和 <span
class="math inline">\(k_{i+1}\)</span> 之间的值。对每个伪关键字 <span
class="math inline">\(d_i\)</span>，也都有一个概率 <span
class="math inline">\(q_i\)</span> 表示对应的搜索频率。每个关键字 <span
class="math inline">\(k_i\)</span> 是一个内部结点，而每个伪关键字 <span
class="math inline">\(d_i\)</span>
是一个叶结点。每次搜索要么成功（找到某个关键字 <span
class="math inline">\(k_i\)</span>）要么失败（找到某个为关键字 <span
class="math inline">\(d_i\)</span> ），因此有如下公式：<span
class="math inline">\(\sum\limits^{n}_{i=1}p_{i}+\sum\limits^{n}_{i=0}q_{i}
= 1\)</span></li>
<li><strong>最优二叉搜索树</strong>：对于一个给定的概率集合，我们希望构造一棵期望搜索代价最小的二叉搜索树，我们称之为<strong>最优二叉搜索树</strong>
复杂度：<span class="math inline">\(\Theta(n^{3})\)</span></li>
<li>穷举法获得最优二叉搜索树的时间复杂度为 <span
class="math inline">\(\Omega (\frac{4^{n}}{n^{\frac{3}{2}}})\)</span>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span>  </span><br>  <br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX (1000+10)  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXE 1000000000  </span><br><span class="hljs-type">double</span> p[MAX], q[MAX], w[MAX][MAX], e[MAX][MAX];  <br><span class="hljs-comment">// p,q为概率，表示其搜索频率</span><br><span class="hljs-comment">// e[i,j]为在包含关键字k_i,..,k_j的最优二叉搜索树中进行一次搜索的期望代价</span><br><span class="hljs-comment">// w[i,j]为在关键字k_i,..,k_j的期望之和</span><br><span class="hljs-type">int</span> root[MAX][MAX], n = <span class="hljs-number">5</span>;  <br>  <br><span class="hljs-type">void</span> <span class="hljs-title function_">optimalBST</span><span class="hljs-params">(<span class="hljs-type">double</span> *p,<span class="hljs-type">double</span> *q,<span class="hljs-type">int</span> n)</span>;  <br><span class="hljs-type">void</span> <span class="hljs-title function_">printRoot</span><span class="hljs-params">()</span>;  <br><span class="hljs-type">void</span> <span class="hljs-title function_">printOptimalBST</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j,<span class="hljs-type">int</span> r)</span>;  <br>  <br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);  <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)&#123;  <br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lf&quot;</span>, &amp;p[i]);  <br>    &#125;  <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;=n; i++)&#123;  <br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lf&quot;</span>, &amp;q[i]);  <br>    &#125;  <br>    optimalBST(p,q,n);  <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lf\n&quot;</span>, e[<span class="hljs-number">1</span>][n]);   <span class="hljs-comment">// 最小的cost  </span><br>    printRoot();    <span class="hljs-comment">// 输出所有的根  </span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;最优二叉树结构：best structure\n&quot;</span>);  <br>    printOptimalBST(<span class="hljs-number">1</span>,n,<span class="hljs-number">-1</span>);    <span class="hljs-comment">// 深度优先遍历输出最优二叉树的结构  </span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;  <br><span class="hljs-comment">//接受概率列表p和q及规模n作为输入，返回cost表e和根表root。  </span><br><span class="hljs-type">void</span> <span class="hljs-title function_">optimalBST</span><span class="hljs-params">(<span class="hljs-type">double</span> *p,<span class="hljs-type">double</span> *q,<span class="hljs-type">int</span> n)</span>&#123;  <br>    <span class="hljs-comment">// 初始化只包括虚拟键的子树  </span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n + <span class="hljs-number">1</span>;++i)&#123;  <br>        w[i][i - <span class="hljs-number">1</span>] = q[i - <span class="hljs-number">1</span>];  <br>        e[i][i - <span class="hljs-number">1</span>] = q[i - <span class="hljs-number">1</span>];  <br>    &#125;  <br>  <br>    <span class="hljs-comment">// 由上到下，由左到右逐步计算  </span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> len = <span class="hljs-number">1</span>;len &lt;= n;++len)&#123;  <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n - len + <span class="hljs-number">1</span>;++i)&#123;  <br>            <span class="hljs-type">int</span> j = i + len - <span class="hljs-number">1</span>;  <br>            e[i][j] = MAXE;  <br>            w[i][j] = w[i][j - <span class="hljs-number">1</span>] + p[j] + q[j];  <span class="hljs-comment">// i到j的期望之和</span><br>            <span class="hljs-comment">// 求取最小代价的子树的根  </span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = i;k &lt;= j;++k)&#123;  <span class="hljs-comment">// 遍历所有可能的根</span><br>	            <span class="hljs-comment">// e[i,j] = p_k+(e[i,k-1]+w[i,k-1]) + (e[k+1,j]+w[k+1,j])</span><br>                <span class="hljs-comment">//        = e[i,k-1]+e[k+1,j] + w[i,j]</span><br>                <span class="hljs-type">double</span> temp = e[i][k - <span class="hljs-number">1</span>] + e[k + <span class="hljs-number">1</span>][j] + w[i][j];<br>                <span class="hljs-keyword">if</span> (temp &lt; e[i][j])&#123;  <br>                    e[i][j] = temp;  <br>                    root[i][j] = k;  <br>                &#125;  <br>            &#125;  <br>        &#125;  <br>    &#125;  <br>&#125;  <br>  <br><span class="hljs-comment">// 输出最优二叉查找树所有子树的根  </span><br><span class="hljs-type">void</span> <span class="hljs-title function_">printRoot</span><span class="hljs-params">()</span>&#123;  <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;各子树的根 roots\n&quot;</span>);  <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;++i)&#123;  <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j &lt;= n;++j)&#123;  <br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, root[i][j]);  <br>        &#125;  <br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);  <br>    &#125;  <br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);  <br>&#125;  <br>  <br><span class="hljs-comment">// 打印最优二叉查找树的结构  </span><br><span class="hljs-comment">// 打印出[i,j]的子树，它是根r的左子树和右子树  </span><br><span class="hljs-type">void</span> <span class="hljs-title function_">printOptimalBST</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j,<span class="hljs-type">int</span> r)</span>&#123;  <br>    <span class="hljs-type">int</span> rootChild = root[i][j];  <br>    <span class="hljs-keyword">if</span> (rootChild == root[<span class="hljs-number">1</span>][n])&#123;  <br>        <span class="hljs-comment">// 输出整棵树的根  </span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;k%d is root\n&quot;</span>, rootChild);  <br>        printOptimalBST(i,rootChild - <span class="hljs-number">1</span>,rootChild);  <br>        printOptimalBST(rootChild + <span class="hljs-number">1</span>,j,rootChild);  <br>        <span class="hljs-keyword">return</span>;  <br>    &#125;  <br>    <span class="hljs-keyword">if</span> (j &lt; i - <span class="hljs-number">1</span>)&#123;  <br>        <span class="hljs-keyword">return</span>;  <br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (j == i - <span class="hljs-number">1</span>)&#123;      <span class="hljs-comment">// 遇到虚拟键  </span><br>        <span class="hljs-keyword">if</span> (j &lt; r)&#123;  <br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;d%d is k%d&#x27;s left son\n&quot;</span>, j, r);  <br>        &#125;<span class="hljs-keyword">else</span> &#123;  <br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;d%d is k%d&#x27;s right son\n&quot;</span>, j, r);  <br>        &#125;  <br>        <span class="hljs-keyword">return</span>;  <br>    &#125;<span class="hljs-keyword">else</span>&#123;      <span class="hljs-comment">// 遇到内部结点  </span><br>        <span class="hljs-keyword">if</span> (rootChild &lt; r)&#123;  <br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;k%d is k%d&#x27;s left son\n&quot;</span>, rootChild, r);  <br>        &#125;<span class="hljs-keyword">else</span>&#123;  <br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;k%d is k%d&#x27;s right son\n&quot;</span>, rootChild, r);  <br>        &#125;  <br>    &#125;  <br>    printOptimalBST(i,rootChild - <span class="hljs-number">1</span>,rootChild);  <br>    printOptimalBST(rootChild + <span class="hljs-number">1</span>,j,rootChild);  <br>&#125;<br></code></pre></td></tr></table></figure> ##### 最小编辑距离 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX 2005  </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;  <br><span class="hljs-type">int</span> ans;  <br><span class="hljs-type">int</span> dp[<span class="hljs-number">2</span>][MAX];  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">min3</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c)</span> </span>&#123;  <br>    <span class="hljs-type">int</span> m = a;  <br>    <span class="hljs-keyword">if</span> (b &lt; m)  <br>        m = b;  <br>    <span class="hljs-keyword">if</span> (c &lt; m)  <br>        <span class="hljs-keyword">return</span> c;  <br>    <span class="hljs-keyword">return</span> m;  <br>&#125;  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minDistance</span><span class="hljs-params">(string word1, string word2)</span> </span>&#123;  <br>    <span class="hljs-type">int</span> l1 = word1.<span class="hljs-built_in">length</span>();  <br>    <span class="hljs-type">int</span> l2 = word2.<span class="hljs-built_in">length</span>();  <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= l2; j++)  <br>        dp[<span class="hljs-number">0</span>][j] = j;   <span class="hljs-comment">// 初始化dp[0]为从空字符串到word2的编辑距离  </span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= l1; i++) &#123;  <br>        <span class="hljs-comment">// dp[0][j]: word1前i-1个字符转化成word2的前j个字符的编辑距离  </span><br>        <span class="hljs-comment">// dp[1][j]: word1前i个字符转化成word2的前j个字符的编辑距离  </span><br>        dp[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = i;  <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= l2; j++)  <br>            <span class="hljs-keyword">if</span> (word1[i - <span class="hljs-number">1</span>] == word2[j - <span class="hljs-number">1</span>])  <br>                dp[<span class="hljs-number">1</span>][j] = dp[<span class="hljs-number">0</span>][j - <span class="hljs-number">1</span>];  <span class="hljs-comment">// 如果相同，和i-1到j-1的编辑距离一样  </span><br>            <span class="hljs-keyword">else</span> &#123;  <br>                dp[<span class="hljs-number">1</span>][j] = <span class="hljs-built_in">min3</span>(dp[<span class="hljs-number">0</span>][j - <span class="hljs-number">1</span>], dp[<span class="hljs-number">0</span>][j], dp[<span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]) + <span class="hljs-number">1</span>;  <br>                <span class="hljs-comment">// dp[0][j-1] 和i-1转成j-1一样，相当于word1换个字  </span><br>                <span class="hljs-comment">// dp[0][j] 和i-1转成j一样，相当于word1加个字  </span><br>                <span class="hljs-comment">// dp[1][j-1] 和i转成j-1一样，相当于word1删个字  </span><br>            &#125;  <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= l2; j++)  <br>            dp[<span class="hljs-number">0</span>][j] = dp[<span class="hljs-number">1</span>][j];  <br>    &#125;  <br>    <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][l2];  <br>&#125;  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;  <br>    string a;  <br>    string b;  <br>    cin &gt;&gt; a &gt;&gt; b;  <br>    cout &lt;&lt; <span class="hljs-built_in">minDistance</span>(a, b);  <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n%d\n&quot;</span>,ans);  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></td></tr></table></figure> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 进行了什么编辑操作</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX 2005  </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;  <br>  <br><span class="hljs-type">int</span> replace_count = <span class="hljs-number">0</span>;  <br><span class="hljs-type">int</span> delete_count = <span class="hljs-number">0</span>;  <br><span class="hljs-type">int</span> insert_count = <span class="hljs-number">0</span>;  <br><span class="hljs-type">int</span> dp[MAX][MAX] = &#123;&#125;;  <br>  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">min3</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c)</span> </span>&#123;  <br>    <span class="hljs-type">int</span> m = a;  <br>    <span class="hljs-keyword">if</span> (b &lt; m)  <br>        m = b;  <br>    <span class="hljs-keyword">if</span> (c &lt; m)  <br>        <span class="hljs-keyword">return</span> c;  <br>    <span class="hljs-keyword">return</span> m;  <br>&#125;  <br>  <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printOperations</span><span class="hljs-params">(string word1, string word2, <span class="hljs-type">int</span> dp[MAX][MAX])</span> </span>&#123;  <br>    <span class="hljs-type">int</span> i = word1.<span class="hljs-built_in">length</span>();  <br>    <span class="hljs-type">int</span> j = word2.<span class="hljs-built_in">length</span>();  <br>    <span class="hljs-keyword">while</span> (i &gt; <span class="hljs-number">0</span> || j &gt; <span class="hljs-number">0</span>) &#123;  <br>        <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; j &gt; <span class="hljs-number">0</span> &amp;&amp; word1[i - <span class="hljs-number">1</span>] == word2[j - <span class="hljs-number">1</span>]) &#123;  <br>            i--;  <br>            j--;  <br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (j &gt; <span class="hljs-number">0</span> &amp;&amp; (i == <span class="hljs-number">0</span> || dp[i][j] == dp[i][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>)) &#123;  <br>            insert_count++;  <br>            j--;  <br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; (j == <span class="hljs-number">0</span> || dp[i][j] == dp[i - <span class="hljs-number">1</span>][j] + <span class="hljs-number">1</span>)) &#123;  <br>            delete_count++;  <br>            i--;  <br>        &#125; <span class="hljs-keyword">else</span> &#123;  <br>            replace_count++;  <br>            i--;  <br>            j--;  <br>        &#125;  <br>    &#125;  <br>&#125;  <br>  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minDistance</span><span class="hljs-params">(string word1, string word2)</span> </span>&#123;  <br>    <span class="hljs-type">int</span> l1 = word1.<span class="hljs-built_in">length</span>();  <br>    <span class="hljs-type">int</span> l2 = word2.<span class="hljs-built_in">length</span>();  <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= l2; j++)  <br>        dp[<span class="hljs-number">0</span>][j] = j;  <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= l1; i++) &#123;  <br>        dp[i][<span class="hljs-number">0</span>] = i;  <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= l2; j++) &#123;  <br>            <span class="hljs-keyword">if</span> (word1[i - <span class="hljs-number">1</span>] == word2[j - <span class="hljs-number">1</span>])  <br>                dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];  <br>            <span class="hljs-keyword">else</span>  <br>                dp[i][j] = <span class="hljs-built_in">min3</span>(dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>], dp[i - <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>]) + <span class="hljs-number">1</span>;  <br>        &#125;  <br>    &#125;  <br>    <span class="hljs-built_in">printOperations</span>(word1, word2, dp);  <br>    <span class="hljs-keyword">return</span> dp[l1][l2];  <br>&#125;  <br>  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;  <br>    string a;  <br>    string b;  <br>    cin &gt;&gt; a &gt;&gt; b;  <br>    <span class="hljs-type">int</span> distance = <span class="hljs-built_in">minDistance</span>(a, b);  <br>    cout &lt;&lt; distance &lt;&lt; endl;  <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Replace: %d\n&quot;</span>, replace_count);  <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Delete: %d\n&quot;</span>, delete_count);  <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Insert: %d\n&quot;</span>, insert_count);  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h5
id="最长单调子序列lislongest-increasing-subsequence">最长单调子序列/LIS（Longest
Increasing Subsequence）</h5>
<p><span class="math inline">\(O(n^2)\)</span> 做法 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">LIS</span><span class="hljs-params">()</span></span>&#123; <span class="hljs-comment">// a为目标数组 ans为最终得到的最长单调子序列的长度  </span><br>    <span class="hljs-type">int</span> ans=<span class="hljs-number">1</span>;  <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)&#123;<span class="hljs-comment">//枚举子序列的终点  </span><br>        dp[i]=<span class="hljs-number">1</span>;<span class="hljs-comment">// 初始化为1，长度最短为自身  </span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>; j&lt;i; j++)&#123;<span class="hljs-comment">//从头向终点检查每一个元素  </span><br>            <span class="hljs-keyword">if</span>(a[i]&gt;a[j])&#123;  <br>                dp[i]=<span class="hljs-built_in">max</span>(dp[i],dp[j]+<span class="hljs-number">1</span>);  <span class="hljs-comment">// 状态转移  </span><br>            &#125;  <br>        &#125;<br>        ans=<span class="hljs-built_in">max</span>(ans,dp[i]);  <span class="hljs-comment">// 比较每一个dp[i],最大值为答案  </span><br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;  <br>    <span class="hljs-keyword">while</span>(cin&gt;&gt;n)&#123;  <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)&#123; <span class="hljs-comment">// 下标从1开始  </span><br>            cin&gt;&gt;a[i];  <br>        &#125;  <br>        <span class="hljs-type">int</span> ans=<span class="hljs-built_in">LIS</span>();  <br>        cout&lt;&lt;ans&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;  <br>    &#125;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></td></tr></table></figure></p>
<p><span class="math inline">\(O(nlgn)\)</span> 做法 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 严格单调递增子列的长度  </span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lsrsa</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt; &amp;a)</span> </span>&#123;  <br>    vector&lt;<span class="hljs-type">int</span>&gt; sa;  <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x: a) &#123;  <br>        <span class="hljs-keyword">if</span> (sa.<span class="hljs-built_in">empty</span>() || x &gt; sa.<span class="hljs-built_in">back</span>())  <span class="hljs-comment">// 如果sa为空或x&gt;sa的最后一个元素  </span><br>            sa.<span class="hljs-built_in">push_back</span>(x);  <br>        <span class="hljs-keyword">else</span>  <br>            <span class="hljs-comment">// 如果x&lt;=sa的最后一个元素，二分查找找到sa中第一个&gt;=x的数，并用x替换它。  </span><br>            <span class="hljs-comment">// 实际上是在尝试找到更小的元素替代sa中的元素，这样后续可能可以添加更多的元素到sa中，从而形成一个更长的子序列。  </span><br>            *<span class="hljs-built_in">lower_bound</span>(sa.<span class="hljs-built_in">begin</span>(), sa.<span class="hljs-built_in">end</span>(), x) = x;  <br>    &#125;  <br>    <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>) sa.<span class="hljs-built_in">size</span>();  <br>&#125;  <br><span class="hljs-comment">// 单调不减子列的长度  </span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lrsa</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt; &amp;a)</span> </span>&#123;  <br>    vector&lt;<span class="hljs-type">int</span>&gt; sa;  <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x: a) &#123;  <br>        <span class="hljs-keyword">if</span> (sa.<span class="hljs-built_in">empty</span>() || x &gt;= sa.<span class="hljs-built_in">back</span>())  <span class="hljs-comment">// 如果sa为空或x&gt;=sa的最后一个元素  </span><br>            sa.<span class="hljs-built_in">push_back</span>(x);  <br>        <span class="hljs-keyword">else</span> <span class="hljs-comment">// 如果x&lt;sa的最后一个元素，二分查找找到sa中第一个&gt;x的数，并用x替换它。  </span><br>            *<span class="hljs-built_in">upper_bound</span>(sa.<span class="hljs-built_in">begin</span>(), sa.<span class="hljs-built_in">end</span>(), x) = x;  <br>    &#125;  <br>    <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>) sa.<span class="hljs-built_in">size</span>();  <br>&#125;<br></code></pre></td></tr></table></figure></p>
<h5 id="活动选择问题">活动选择问题</h5>
<p>假定有一个 <span class="math inline">\(n\)</span> 个活动的集合 <span
class="math inline">\(S=\{a_{1}, a_{2},
...,a_{n}\}\)</span>，这些活动使用同一个资源，而这个资源在某个时刻只能供一个活动使用，每个活动
<span class="math inline">\(a_{i}\)</span> 都有一个开始时间 <span
class="math inline">\(s_{i}\)</span> 和一个结束时间 <span
class="math inline">\(f_{i}\)</span> ，其中 <span
class="math inline">\(0\le s_{i}&lt;f_{i}&lt;∞\)</span>
，如果被选中，任务 <span class="math inline">\(a_i\)</span>
发生在半开时间区间 <span class="math inline">\([s_i,f_i)\)</span>
期间。如果两个活动时间不重叠，则称他们是<strong>兼容的</strong>。在<strong>活动选择问题</strong>中，我们希望选出一个<strong>最大兼容活动集</strong>。假定活动已按结束时间的单调递增顺序排序。
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX 100  </span><br>using namespace <span class="hljs-built_in">std</span>;  <br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">thing</span>&#123;</span>  <br>    <span class="hljs-type">int</span> startTime, endTime;  <br>&#125;;  <br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">thing</span> <span class="hljs-title">things</span>[<span class="hljs-title">MAX</span>], <span class="hljs-title">ans</span>[<span class="hljs-title">MAX</span>];</span> <span class="hljs-comment">// ans 参加的活动们  </span><br><span class="hljs-type">int</span> n;  <br><span class="hljs-type">void</span> <span class="hljs-title function_">Greedy_Activity_Selector</span><span class="hljs-params">()</span>&#123;  <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;0 &quot;</span>);  <br>    ans[<span class="hljs-number">0</span>] = things[<span class="hljs-number">0</span>];  <br>    <span class="hljs-type">int</span> lastId=<span class="hljs-number">0</span>, ansNum = <span class="hljs-number">1</span>;   <span class="hljs-comment">// 当前的最后一个活动的截止时间 当前已经参加的活动数量  </span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>; i&lt;=n; i++)&#123;  <br>        <span class="hljs-keyword">if</span>(things[i].startTime &gt;= things[lastId].endTime)&#123;  <br>            ans[ansNum] = things[i];  <br>            ansNum++;  <br>            lastId = i;  <br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, i);  <br>        &#125;  <br>    &#125;  <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n%d&quot;</span>, ansNum);  <br>&#125;  <br><span class="hljs-type">int</span> <span class="hljs-title function_">cmp</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *a, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *b)</span>&#123;  <br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">thing</span> *<span class="hljs-title">pa</span> =</span> (<span class="hljs-keyword">struct</span> thing *)a;  <br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">thing</span> *<span class="hljs-title">pb</span> =</span> (<span class="hljs-keyword">struct</span> thing *)b;  <br>    <span class="hljs-keyword">if</span>(pa-&gt;endTime &lt; pb-&gt;endTime)&#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;  <br>    &#125;<span class="hljs-keyword">else</span>&#123;  <br>        <span class="hljs-keyword">if</span>(pa-&gt;startTime &lt; pb-&gt;startTime)&#123;  <br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;  <br>        &#125;<span class="hljs-keyword">else</span>&#123;  <br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;  <br>        &#125;  <br>    &#125;  <br>&#125;  <br>  <br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);  <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;n; i++)&#123;  <br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;things[i].startTime);  <br>    &#125;  <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;n; i++)&#123;  <br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;things[i].endTime);  <br>    &#125;  <br>    qsort(things, n, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> thing), cmp);  <span class="hljs-comment">// 按活动结束时间升序排序  </span><br>    Greedy_Activity_Selector();  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></td></tr></table></figure></p>
<h5 id="背包">0-1背包</h5>
<p>一个正在抢劫商店的小偷发现了 <span class="math inline">\(n\)</span>
个商品，第 <span class="math inline">\(i\)</span> 个商品价值 <span
class="math inline">\(v_i\)</span> 美元，重 <span
class="math inline">\(w_i\)</span> 磅，<span
class="math inline">\(v_{i}\)</span> 和 <span
class="math inline">\(w_i\)</span>
都是整数。这个小偷希望拿走价值尽量高的商品，但他的背包最多能容纳 <span
class="math inline">\(W\)</span> 磅重的商品，<span
class="math inline">\(W\)</span> 是一个整数。他应该拿哪些商品呢? ######
二维dp <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span>  </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;  <br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>;  <br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MaxW = <span class="hljs-number">10000</span>;  <br><span class="hljs-type">int</span> n, W, v[N], w[N], f[N][MaxW];  <br>  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;  <br>    cin &gt;&gt; n &gt;&gt; W;  <span class="hljs-comment">// n物品数量 W最大重量  </span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i)  <br>        cin &gt;&gt; v[i] &gt;&gt; w[i];    <span class="hljs-comment">// v价值 w重量  </span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)&#123;   <span class="hljs-comment">// 遍历所有物品  </span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= W; ++j)&#123;   <span class="hljs-comment">// 重量从0到最大重量  </span><br>            f[i][j] = f[i - <span class="hljs-number">1</span>][j]; <span class="hljs-comment">// 不选择当前物品时的价值，直接继承上一个状态的价值  </span><br>            <span class="hljs-comment">// 如果当前背包容量可以放下当前物品，则尝试放入，更新最大价值  </span><br>            <span class="hljs-keyword">if</span> (j &gt;= w[i]) f[i][j] = <span class="hljs-built_in">max</span>(f[i][j], f[i - <span class="hljs-number">1</span>][j - w[i]] + v[i]);  <br>        &#125;  <br>    &#125;  <br>    cout &lt;&lt; f[n][W] &lt;&lt; endl;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></td></tr></table></figure> ###### 一维dp <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span>  </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;  <br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>;  <br><span class="hljs-type">int</span> n, W, v[N], w[N], f[N];  <br>  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;  <br>    cin &gt;&gt; n &gt;&gt; W;  <span class="hljs-comment">// n物品数量 W最大重量    </span><br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i)  <br>	        cin &gt;&gt; v[i] &gt;&gt; w[i];  <span class="hljs-comment">// v价值 w重量    </span><br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i)&#123; <span class="hljs-comment">// 遍历所有物品  </span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = W; j &gt;= w[i]; j--)&#123; <span class="hljs-comment">// 逆序遍历背包容量  </span><br>            <span class="hljs-comment">// 更新f[j]，即考虑放入当前物品i时的最大价值  </span><br>            f[j] = <span class="hljs-built_in">max</span>(f[j], f[j - w[i]] + v[i]);  <br>        &#125;  <br>    &#125;  <br>    cout &lt;&lt; f[W] &lt;&lt; endl;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></td></tr></table></figure> ######
01背包变种，一维dp 同样的 <span class="math inline">\(w, v,
W\)</span>，但背包容量 <span class="math inline">\(W\)</span>
极大，无法开数组 <span
class="math inline">\(f[0..W]\)</span>，求背包能装下的最大价值
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span>  </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;  <br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 510  </span><br><span class="hljs-type">long</span> <span class="hljs-type">long</span> n, W, v[N], w[N], f[N*N], sumV;  <br>  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;  <br>    <span class="hljs-built_in">memset</span>(f, <span class="hljs-number">0x3f</span>, <span class="hljs-built_in">sizeof</span>(f));  <br>    f[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;  <br>    cin &gt;&gt; n &gt;&gt; W;  <span class="hljs-comment">// n个物品 W最大重量  </span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;  <br>        cin &gt;&gt; w[i] &gt;&gt; v[i];    <span class="hljs-comment">// w重量 v价值    </span><br>		sumV += v[i];   <span class="hljs-comment">// 最大价值    </span><br>	&#125;  <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i)&#123; <span class="hljs-comment">// 遍历所有物品    </span><br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=sumV; j&gt;=v[i]; j--)&#123;  <span class="hljs-comment">// 从最大价值开始，只有在j&gt;=v[i]的情况下才有可能装当前的物品，否则f保持不变    </span><br>			f[j] = <span class="hljs-built_in">min</span>(f[j], f[j-v[i]]+w[i]);   <span class="hljs-comment">// f[j]表示包内物品价值为j时的最小重量    </span><br>		&#125;  <br>    &#125;  <br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> ans = <span class="hljs-number">0</span>;  <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;=sumV; j++)&#123; <span class="hljs-comment">// 从价值为0到最大价值    </span><br>		<span class="hljs-keyword">if</span>(f[j] &lt;= W)&#123;  <span class="hljs-comment">// 如果包内重量小于W    </span><br>			ans = j;    <span class="hljs-comment">// 更新ans    </span><br>		&#125;  <br>    &#125;  <br>    cout &lt;&lt; ans &lt;&lt; endl;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></td></tr></table></figure></p>
<h5 id="完全背包">完全背包</h5>
<p>一个正在抢劫商店的小偷发现了 <span class="math inline">\(n\)</span>
种商品，第 <span class="math inline">\(i\)</span> 种商品价值 <span
class="math inline">\(v_i\)</span> 美元，重 <span
class="math inline">\(w_i\)</span> 磅，<span
class="math inline">\(v_{i}\)</span> 和 <span
class="math inline">\(w_i\)</span>
都是整数，<strong>每种商品都有无限个</strong>。这个小偷希望拿走价值尽量高的商品，但他的背包最多能容纳
<span class="math inline">\(W\)</span> 磅重的商品，<span
class="math inline">\(W\)</span> 是一个整数。他应该拿哪些商品呢?
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span>  </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;  <br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>;  <br><span class="hljs-type">int</span> n, W, v[N], w[N], f[N];  <br>  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;  <br>    cin &gt;&gt; n &gt;&gt; W;      <span class="hljs-comment">// 物品种类n 最大容量W  </span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i)  <br>        cin &gt;&gt; v[i] &gt;&gt; w[i];    <span class="hljs-comment">// 价值v 体积w  </span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i)&#123; <span class="hljs-comment">// 遍历所有物品  </span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = v[i]; j &lt;= W; j--)&#123; <span class="hljs-comment">// 顺序遍历背包容量  </span><br>            <span class="hljs-comment">// 更新f[j]，即考虑放入当前物品i时的最大价值  </span><br>            f[j] = <span class="hljs-built_in">max</span>(f[j], f[j - v[i]] + w[i]);  <br>        &#125;  <br>    &#125;  <br>    cout &lt;&lt; f[W] &lt;&lt; endl;  <br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></td></tr></table></figure> ##### 分组背包
物品被分成若干组，<strong>每组中的物品只能选择一个</strong>。也就是说，从每组物品中，你只能选择一个或者不选，但不能选择多个
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span>  </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;  <br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;  <br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX = <span class="hljs-number">1005</span>;  <br><span class="hljs-keyword">struct</span> &#123;  <br>    <span class="hljs-type">int</span> cnt;  <br>    ll ID[MAX];  <br>&#125; group[MAX]; <span class="hljs-comment">//用一个结构体来存储每一组的物品编号  </span><br>ll dp[MAX];     <span class="hljs-comment">// 最大价值  </span><br>ll val[MAX];    <span class="hljs-comment">// 每个物品的价值  </span><br>ll weight[MAX]; <span class="hljs-comment">// 每个物品的重量  </span><br>  <br><span class="hljs-function">ll <span class="hljs-title">group_bag</span><span class="hljs-params">(<span class="hljs-type">int</span> cap, <span class="hljs-type">int</span> max_group)</span></span>;  <br>  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;  <br>    <span class="hljs-type">int</span> n, W;  <br>    cin &gt;&gt; W &gt;&gt; n;  <span class="hljs-comment">//  n表示物品数量，W表示背包容量  </span><br>    <span class="hljs-type">int</span> a, b, k, max_group = <span class="hljs-number">0</span>;  <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;  <br>        cin &gt;&gt; a &gt;&gt; b &gt;&gt; k; <span class="hljs-comment">// a重量  b价值  k物品所在的组号  </span><br>        weight[i] = a;  <br>        val[i] = b;  <br>        group[k].ID[group[k].cnt++] = i;  <br>        max_group = <span class="hljs-built_in">max</span>(max_group, k);  <br>    &#125;  <br>    cout &lt;&lt; <span class="hljs-built_in">group_bag</span>(W, max_group);  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;  <br>  <br><span class="hljs-function">ll <span class="hljs-title">group_bag</span><span class="hljs-params">(<span class="hljs-type">int</span> W, <span class="hljs-type">int</span> max_group)</span> </span>&#123;  <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= max_group; i++) <span class="hljs-comment">// 第一层循环，遍历所有组  </span><br>        <span class="hljs-keyword">for</span> (ll j = W; j &gt;= <span class="hljs-number">0</span>; j--) <span class="hljs-comment">// 第二层循环，从背包容量W到0倒序遍历  </span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; group[i].cnt; k++) <span class="hljs-comment">// 第三层循环，遍历当前组内的所有物品  </span><br>                <span class="hljs-keyword">if</span> (j &gt;= weight[group[i].ID[k]]) <span class="hljs-comment">// 如果当前物品可以放入背包  </span><br>                    <span class="hljs-comment">// 更新dp数组，选择放入或不放入当前物品，取最大值  </span><br>                    dp[j] = <span class="hljs-built_in">max</span>(dp[j],dp[j - weight[group[i].ID[k]]] + val[group[i].ID[k]]);  <br>    <span class="hljs-keyword">return</span> dp[W];  <br>&#125;<br></code></pre></td></tr></table></figure> ##### 多重背包 一个正在抢劫商店的小偷发现了 <span
class="math inline">\(n\)</span> 种商品，第 <span
class="math inline">\(i\)</span> 种商品价值 <span
class="math inline">\(v_i\)</span> 美元，重 <span
class="math inline">\(w_i\)</span> 磅，<span
class="math inline">\(v_{i}\)</span> 和 <span
class="math inline">\(w_i\)</span> 都是整数，<strong>每种商品有 <span
class="math inline">\(M_{i}\)</span>
个</strong>。这个小偷希望拿走价值尽量高的商品，但他的背包最多能容纳
<span class="math inline">\(W\)</span> 磅重的商品，<span
class="math inline">\(W\)</span> 是一个整数。他应该拿哪些商品呢?
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//二进制优化  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span>  </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;  <br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAXN=<span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;  <br><span class="hljs-type">int</span> n,W;  <br><span class="hljs-type">int</span> v[MAXN],w[MAXN];  <br><span class="hljs-type">int</span> f[MAXN];  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;  <br>    cin &gt;&gt; n &gt;&gt; W;  <span class="hljs-comment">// 物品个数n和最大重量W    </span><br>	<span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;    <span class="hljs-comment">// 记录二进制合成后的物体数</span><br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>,a,b,s; i&lt;=n; i++)   &#123;  <br>        cin&gt;&gt; a &gt;&gt; b &gt;&gt; s;   <span class="hljs-comment">// 单个价值a 单个重量b 数量s</span><br>		<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>;  <br>        <span class="hljs-keyword">while</span>(k &lt;= s)&#123; <span class="hljs-comment">// 将每个物品都按照二进制合成    </span><br>			v[++cnt] = k*a;  <br>            w[cnt] = k*b;  <br>            s -= k;  <br>            k *= <span class="hljs-number">2</span>;  <br>        &#125;  <br>        <span class="hljs-keyword">if</span>(s)&#123;  <br>            v[++cnt] = s*a;  <br>            w[cnt] = s*b;  <br>        &#125;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=cnt; i++) <span class="hljs-comment">// 01背包     </span><br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=W; j&gt;=v[i]; j--)  <br>            f[j] = <span class="hljs-built_in">max</span>(f[j], f[j-v[i]]+w[i]);  <br>    cout &lt;&lt; f[W];  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></td></tr></table></figure></p>
<h5 id="分数背包部分背包">分数背包（部分背包）</h5>
<p>一个正在抢劫商店的小偷发现了 <span class="math inline">\(n\)</span>
个商品，第 <span class="math inline">\(i\)</span> 个商品价值 <span
class="math inline">\(v_i\)</span> 美元，重 <span
class="math inline">\(w_i\)</span> 磅，<span
class="math inline">\(v_{i}\)</span> 和 <span
class="math inline">\(w_i\)</span>
都是整数，对每个商品，小偷<strong>可以拿走其一部分</strong>，而不是只能做出二元(0-1)选择。。这个小偷希望拿走价值尽量高的商品，但他的背包最多能容纳
<span class="math inline">\(W\)</span> 磅重的商品，<span
class="math inline">\(W\)</span> 是一个整数。他应该拿哪些商品呢?
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span>  </span><br>  <br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">coin</span>&#123;</span>  <br>    <span class="hljs-type">double</span> w;<span class="hljs-comment">// 重量  </span><br>    <span class="hljs-type">double</span> v;<span class="hljs-comment">// value  </span><br>    <span class="hljs-type">double</span> rou;  <br>&#125;;  <br>  <br><span class="hljs-type">int</span> <span class="hljs-title function_">cmp</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *a, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *b)</span>&#123;  <br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">coin</span> *<span class="hljs-title">pa</span> =</span> (<span class="hljs-keyword">struct</span> coin *)a;  <br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">coin</span> *<span class="hljs-title">pb</span> =</span> (<span class="hljs-keyword">struct</span> coin *)b;  <br>    <span class="hljs-keyword">if</span>(pa-&gt;rou &gt; pb-&gt;rou)&#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;  <br>    &#125;<span class="hljs-keyword">else</span>&#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;  <br>    &#125;  <br>&#125;  <br>  <br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-type">int</span> n;      <span class="hljs-comment">// 物品个数n  </span><br>    <span class="hljs-type">double</span> W;   <span class="hljs-comment">// 最大容量W  </span><br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%lf&quot;</span>, &amp;n, &amp;W);  <br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">coin</span> <span class="hljs-title">gold</span>[110]=</span>&#123;&#125;;  <br>  <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;n; i++)&#123;  <br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lf%lf&quot;</span>, &amp;gold[i].w, &amp;gold[i].v);  <br>        gold[i].rou = gold[i].v / gold[i].w;  <br>    &#125;  <br>    qsort(gold, n, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> coin), cmp);  <br>  <br>    <span class="hljs-type">double</span> ans=<span class="hljs-number">0</span>;  <br>    <span class="hljs-type">int</span> now=<span class="hljs-number">0</span>;  <br>    <span class="hljs-keyword">while</span>(W &gt;= <span class="hljs-number">0</span>)&#123;  <br>        <span class="hljs-keyword">if</span>(now == n)&#123;   <span class="hljs-comment">// 遍历完所有物品  </span><br>            <span class="hljs-keyword">break</span>;  <br>        &#125;  <br>        <span class="hljs-keyword">if</span>(gold[now].w &lt; W)&#123;    <span class="hljs-comment">// 放得下整个物品now  </span><br>            W -= gold[now].w;  <br>            ans += gold[now].v;  <br>        &#125;<span class="hljs-keyword">else</span>&#123;      <span class="hljs-comment">// 只能放部分  </span><br>            ans += gold[now].v * (W/gold[now].w);  <br>            W = <span class="hljs-number">0</span>;  <br>            <span class="hljs-keyword">break</span>;  <br>        &#125;  <br>        now++;  <br>    &#125;  <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.2lf&quot;</span>, ans);  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></td></tr></table></figure></p>
<h5 id="赫夫曼编码">赫夫曼编码</h5>
<p>考虑一种<strong>二进制字符编码</strong>，其中每个字符用一个唯一的二进制串表示，称为<strong>码字</strong>。如果使用<strong>定长编码</strong>，需要用3位来表示6个字符:a=000，b=001，…，f=101。这种方法需要300000个二进制位来编码文件。是否有更好的编码方案呢?
时间复杂度 <span class="math inline">\(O(nlgn)\)</span>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX 100  </span><br><span class="hljs-comment">// 结构体</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> &#123;</span>  <br>    <span class="hljs-type">char</span> data;  <br>    <span class="hljs-type">int</span> frequency;  <br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>* <span class="hljs-title">left</span>;</span>  <br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>* <span class="hljs-title">right</span>;</span>  <br>&#125; Node;  <br>  <br><span class="hljs-comment">// 创建新节点的函数 return结构体指针类型 data结构体的字符 frequency字符的出现频率</span><br>Node* <span class="hljs-title function_">createNode</span><span class="hljs-params">(<span class="hljs-type">char</span> data, <span class="hljs-type">int</span> frequency)</span> &#123;  <br>    Node* node = (Node*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Node));  <br>    node-&gt;data = data;  <br>    node-&gt;frequency = frequency;  <br>    node-&gt;left = <span class="hljs-literal">NULL</span>;  <br>    node-&gt;right = <span class="hljs-literal">NULL</span>;  <br>    <span class="hljs-keyword">return</span> node;  <br>&#125;  <br>  <br><span class="hljs-comment">// Huffman构建函数</span><br>Node* <span class="hljs-title function_">buildHuffmanTree</span><span class="hljs-params">(<span class="hljs-type">char</span>* inputText)</span> &#123;  <br>    <span class="hljs-type">int</span> charCount[<span class="hljs-number">256</span>] = &#123;&#125;;  <br>    <span class="hljs-type">int</span> length = <span class="hljs-built_in">strlen</span>(inputText);  <br>    <span class="hljs-type">int</span> i;  <br>  <br>    <span class="hljs-comment">// 统计ascii码为inputText[i]的字符的出现次数    </span><br>	<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; length; i++) &#123;  <br>        charCount[(<span class="hljs-type">int</span>)inputText[i]]++;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">// 创建叶子结点    </span><br>	Node* nodes[<span class="hljs-number">256</span>];  <br>    <span class="hljs-type">int</span> nodeCount = <span class="hljs-number">0</span>;  <br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">256</span>; i++) &#123;  <br>        <span class="hljs-keyword">if</span> (charCount[i] &gt; <span class="hljs-number">0</span>) &#123;  <br>            nodes[nodeCount] = createNode((<span class="hljs-type">char</span>)i, charCount[i]);  <br>            nodeCount++;  <br>        &#125;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">// 依次合并叶子结点    </span><br>	<span class="hljs-keyword">while</span> (nodeCount &gt; <span class="hljs-number">1</span>) &#123;  <br>        <span class="hljs-type">int</span> minFrequency1 = length + <span class="hljs-number">1</span>;     <span class="hljs-comment">// 当前频率最小的    </span><br>		<span class="hljs-type">int</span> minFrequency2 = length + <span class="hljs-number">1</span>;     <span class="hljs-comment">// 当前频率次小的    </span><br>		<span class="hljs-type">int</span> index1 = <span class="hljs-number">-1</span>;  <br>        <span class="hljs-type">int</span> index2 = <span class="hljs-number">-1</span>;  <br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; nodeCount; i++) &#123;   <span class="hljs-comment">// 获得minFrequency1和minFrequency2以及index1 index2    </span><br>			<span class="hljs-keyword">if</span> (nodes[i]-&gt;frequency &lt; minFrequency1) &#123;  <br>                minFrequency2 = minFrequency1;  <br>                index2 = index1;  <br>                minFrequency1 = nodes[i]-&gt;frequency;  <br>                index1 = i;  <br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nodes[i]-&gt;frequency &lt; minFrequency2) &#123;  <br>                minFrequency2 = nodes[i]-&gt;frequency;  <br>                index2 = i;  <br>            &#125;  <br>        &#125;  <br>  <br>        <span class="hljs-comment">// 把最小的和次小的构建为一个树    </span><br>		Node* parent = createNode(<span class="hljs-string">&#x27;\0&#x27;</span>, nodes[index1]-&gt;frequency + nodes[index2]-&gt;frequency);  <br>        parent-&gt;left = nodes[index1];  <br>        parent-&gt;right = nodes[index2];  <br>  <br>        <span class="hljs-comment">// parent放进去，原孩子删掉，最后一个往前移，node数量--    </span><br>		nodes[index2] = parent;  <br>        nodes[index1] = nodes[nodeCount - <span class="hljs-number">1</span>];  <br>        nodeCount--;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">return</span> nodes[<span class="hljs-number">0</span>];  <br>&#125;  <br>  <br><span class="hljs-comment">// 编写huffman编码表及打印  </span><br><span class="hljs-type">void</span> <span class="hljs-title function_">printHuffmanCodes</span><span class="hljs-params">(Node* root, <span class="hljs-type">int</span> code[], <span class="hljs-type">int</span> top, <span class="hljs-type">int</span> codeTable[][<span class="hljs-number">256</span>], <span class="hljs-type">int</span> codeLengths[])</span> &#123;  <br>    <span class="hljs-comment">// root根结点 code当前字符的huffman函数 top当前字符的树的深度/huffman编码长度   </span><br>	<span class="hljs-comment">// codeTable所有字符的huffman编码 codeLengths 所有字符的huffman编码长度  </span><br>    <span class="hljs-keyword">if</span> (root-&gt;left) &#123;   <span class="hljs-comment">// 有左子结点    </span><br>		code[top] = <span class="hljs-number">0</span>;  <br>        printHuffmanCodes(root-&gt;left, code, top + <span class="hljs-number">1</span>, codeTable, codeLengths);  <br>    &#125;  <br>    <span class="hljs-keyword">if</span> (root-&gt;right) &#123;  <span class="hljs-comment">// 有右子节点    </span><br>		code[top] = <span class="hljs-number">1</span>;  <br>        printHuffmanCodes(root-&gt;right, code, top + <span class="hljs-number">1</span>, codeTable, codeLengths);  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">if</span> (root-&gt;left == <span class="hljs-literal">NULL</span> &amp;&amp; root-&gt;right == <span class="hljs-literal">NULL</span>) &#123;    <span class="hljs-comment">// 是叶子节点    </span><br>		codeLengths[(<span class="hljs-type">int</span>)root-&gt;data] = top;     <span class="hljs-comment">// 字符root-&gt;data的编码长度为top    </span><br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c:&quot;</span>,root-&gt;data);       <span class="hljs-comment">// 输出字符root-&gt;data    </span><br>		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; top; i++) &#123;         <span class="hljs-comment">// 输出字符root-&gt;data的编码    </span><br>			codeTable[(<span class="hljs-type">int</span>)root-&gt;data][i] = code[i];  <br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,code[i]);  <br>        &#125;  <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);  <br>    &#125;  <br>&#125;  <br>  <br><span class="hljs-comment">// 编码函数  </span><br><span class="hljs-type">void</span> <span class="hljs-title function_">encodeText</span><span class="hljs-params">(Node* root, <span class="hljs-type">char</span>* inputText, <span class="hljs-type">char</span> encodedText[], <span class="hljs-type">int</span> codeTable[][<span class="hljs-number">256</span>], <span class="hljs-type">int</span> codeLengths[])</span>&#123;  <br>    <span class="hljs-comment">// 翻译inputText为huffman编码encodedText  </span><br>    <span class="hljs-type">int</span> length = <span class="hljs-built_in">strlen</span>(inputText);  <br>    <span class="hljs-type">int</span> i, j;  <br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; length; i++) &#123;  <br>        <span class="hljs-type">char</span> character = inputText[i];      <span class="hljs-comment">// 当前处理的字符    </span><br>		<span class="hljs-type">int</span> length = codeLengths[(<span class="hljs-type">int</span>)character];   <span class="hljs-comment">// 字符转化成huffman编码后的长度    </span><br>		<span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; length; j++) &#123;  <br>            encodedText[<span class="hljs-built_in">strlen</span>(encodedText)] = codeTable[(<span class="hljs-type">int</span>)character][j] + <span class="hljs-string">&#x27;0&#x27;</span>;  <br>        &#125;  <br>    &#125;  <br>&#125;  <br>  <br><span class="hljs-comment">// 解码函数  </span><br><span class="hljs-type">void</span> <span class="hljs-title function_">decodeText</span><span class="hljs-params">(Node* root, <span class="hljs-type">char</span>* encodedText, <span class="hljs-type">char</span>* decodedText)</span> &#123;  <br>    <span class="hljs-comment">// 翻译huffman编码encodedText为decodedText  </span><br>    <span class="hljs-type">int</span> length = <span class="hljs-built_in">strlen</span>(encodedText);  <br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;  <br>  <br>    <span class="hljs-keyword">while</span> (i &lt; length) &#123;  <br>        Node* current = root;  <br>        <span class="hljs-keyword">while</span> (current-&gt;left != <span class="hljs-literal">NULL</span> || current-&gt;right != <span class="hljs-literal">NULL</span>) &#123;  <br>            <span class="hljs-keyword">if</span> (encodedText[i] == <span class="hljs-string">&#x27;0&#x27;</span>) &#123;  <br>                current = current-&gt;left;  <br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (encodedText[i] == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;  <br>                current = current-&gt;right;  <br>            &#125;  <br>            i++;  <br>        &#125;  <br>        decodedText[<span class="hljs-built_in">strlen</span>(decodedText)] = current-&gt;data;  <br>    &#125;  <br>    decodedText[<span class="hljs-built_in">strlen</span>(decodedText)] = <span class="hljs-string">&#x27;\0&#x27;</span>;  <br>&#125;  <br>  <br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-type">char</span> inputText[MAX] = <span class="hljs-string">&quot;&quot;</span>;  <br>    gets(inputText);  <br>    Node* root = buildHuffmanTree(inputText);   <span class="hljs-comment">// 建树  </span><br>    <span class="hljs-type">int</span> code[<span class="hljs-number">256</span>];  <span class="hljs-comment">// 当前字符的huffman编码  </span><br>    <span class="hljs-type">int</span> top = <span class="hljs-number">0</span>;  <br>  <br>    <span class="hljs-type">int</span> codeTable[<span class="hljs-number">256</span>][<span class="hljs-number">256</span>] = &#123;<span class="hljs-number">0</span>&#125;;  <span class="hljs-comment">// 所有字符的huffman编码  </span><br>    <span class="hljs-type">int</span> codeLengths[<span class="hljs-number">256</span>] = &#123;<span class="hljs-number">0</span>&#125;;     <span class="hljs-comment">// 所有字符的编码长度  </span><br>  <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Huffman Codes:\n&quot;</span>);  <br>    printHuffmanCodes(root, code, top, codeTable, codeLengths);  <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);  <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;InputText:\n%s\n\n&quot;</span>,inputText);  <br>  <br>    <span class="hljs-comment">// 字符转huffman    </span><br>	<span class="hljs-type">char</span> encodedText[<span class="hljs-number">1000</span>] = <span class="hljs-string">&quot;&quot;</span>;  <br>    encodeText(root, inputText, encodedText, codeTable, codeLengths);  <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Encoded Text: \n%s\n\n&quot;</span>, encodedText);  <br>  <br>    <span class="hljs-comment">// huffman转字符    </span><br>	<span class="hljs-type">char</span> decodedText[<span class="hljs-number">1000</span>] = <span class="hljs-string">&quot;&quot;</span>;  <br>    decodeText(root, encodedText, decodedText);  <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Decoded Text: \n%s\n\n&quot;</span>, decodedText);  <br>  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></td></tr></table></figure></p>
<h5 id="链式前向星">链式前向星</h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span>&#123;  <br>    <span class="hljs-type">int</span> to, w, next; <span class="hljs-comment">//终点，权值，前驱  </span><br>&#125; e[E_MAX];  <br><span class="hljs-type">int</span> cnt_E = <span class="hljs-number">0</span>;  <br><span class="hljs-type">int</span> head[V_MAX]; <span class="hljs-comment">//需要先初始化为-1    </span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">intList</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>&#123;  <br>	<span class="hljs-built_in">memset</span>(head, <span class="hljs-number">-1</span>, <span class="hljs-built_in">sizeof</span>(head));  <br>&#125;  <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addEdge</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> w)</span></span>&#123;  <br>	e[cnt_E].to = y; <span class="hljs-comment">//保存终点    </span><br>	e[cnt_E].next = head[x]; <span class="hljs-comment">//添加链接    </span><br>	head[x] = cnt_E++; <span class="hljs-comment">//更新表头</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="bfs广度优先搜索">BFS广度优先搜索</h5>
<h6 id="邻接矩阵-1">邻接矩阵</h6>
<p>时间复杂度 <span class="math inline">\(O(n^2)\)</span>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MaxV (10000+10)  </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;  <br><span class="hljs-type">int</span> G[MaxV][MaxV];  <span class="hljs-comment">// 邻接矩阵  </span><br><span class="hljs-type">bool</span> visited[MaxV];    <br><span class="hljs-type">int</span> last[MaxV], d[MaxV];  <span class="hljs-comment">// last[i]点i的前驱结点 d[i]点i的深度  </span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">BFS</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> n)</span></span>;    <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printPath</span><span class="hljs-params">(<span class="hljs-type">int</span> s, <span class="hljs-type">int</span> v)</span></span>;    <br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <br>	<span class="hljs-type">int</span> n, m;    <br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);  <span class="hljs-comment">// n顶点数 m边数  </span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;m; i++)&#123;    <br>		<span class="hljs-type">int</span> u, v;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;u, &amp;v);    <br>        G[u][v] = <span class="hljs-number">1</span>;    <br>    &#125;<br>	<span class="hljs-built_in">BFS</span>(<span class="hljs-number">1</span>, n);    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>; i&lt;=n; i++)&#123; <span class="hljs-comment">// 如果是非连通图，该循环保证每个极大连通子图中的顶点都能被遍历到</span><br>		<span class="hljs-keyword">if</span>(!visited[i])<br>			<span class="hljs-built_in">BFS</span>(i,n);<br>	    &#125;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);    <br>    <span class="hljs-built_in">printPath</span>(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>);  <span class="hljs-comment">// 打印从点1到点4的路径  </span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, d[<span class="hljs-number">4</span>]);  <span class="hljs-comment">// 打印点4的高度  </span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <br>&#125;    <br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">BFS</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> n)</span></span>&#123;  <span class="hljs-comment">// i起始顶点 n顶点总数  </span><br>    queue&lt;<span class="hljs-type">int</span>&gt; Q;   <span class="hljs-comment">// 待访问的顶点  </span><br>    Q.<span class="hljs-built_in">push</span>(i);  <span class="hljs-comment">// 当前节点    </span><br>	visited[i] = <span class="hljs-literal">true</span>;  <span class="hljs-comment">// 当前节点被visited过了</span><br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;v%d-&gt;&quot;</span>, i);<br>    <br>    <span class="hljs-keyword">while</span>(!Q.<span class="hljs-built_in">empty</span>())&#123;   <br>		<span class="hljs-type">int</span> k = Q.<span class="hljs-built_in">front</span>();<br>        Q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>; j&lt;=n; j++)&#123;<br>			<span class="hljs-keyword">if</span>(G[k][j] == <span class="hljs-number">1</span> &amp;&amp; !visited[j])&#123;<br>				Q.<span class="hljs-built_in">push</span>(j);  <span class="hljs-comment">// 当前节点</span><br>				visited[j] = <span class="hljs-literal">true</span>;  <span class="hljs-comment">// 当前节点被visited过了</span><br>				<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;v%d-&gt;&quot;</span>, j);<br>                d[j] = d[k]+<span class="hljs-number">1</span>;<br>                last[j] = k;<br>            &#125;<br>		&#125;<br>	&#125;  <br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printPath</span><span class="hljs-params">(<span class="hljs-type">int</span> s, <span class="hljs-type">int</span> v)</span></span>&#123;  <span class="hljs-comment">// s起始顶点 v终点  </span><br>    <span class="hljs-keyword">if</span>(v == s)&#123;    <br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, s);<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(last[v] == <span class="hljs-number">0</span>)&#123;    <br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;No path from %d to %d exists&quot;</span>, s, v);<br>    &#125;<span class="hljs-keyword">else</span>&#123;    <br>		<span class="hljs-built_in">printPath</span>(s, last[v]);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, v);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p>
<h6 id="邻接表">邻接表</h6>
<p>时间复杂度 <span class="math inline">\(O(n+e)\)</span>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MaxV (10000+10)  </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;  <br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span>&#123;       <span class="hljs-comment">// 定义边结点类型  </span><br>    <span class="hljs-type">int</span> adjvex;  <span class="hljs-comment">//指向的点  </span><br>    <span class="hljs-type">int</span> weight;  <span class="hljs-comment">//边的权重  </span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span> *next;  <span class="hljs-comment">//相邻的边  </span><br>&#125;ELink;  <br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">ver</span>&#123;       <span class="hljs-comment">// 定义顶点结点类型  </span><br>    <span class="hljs-type">int</span> vertex;  <span class="hljs-comment">//顶点id  </span><br>    ELink* link;  <span class="hljs-comment">//从此顶点出发的边  </span><br>&#125;VLink;  <br>  <br>VLink G[MaxV];  <br><span class="hljs-type">bool</span> visited[MaxV];  <br><span class="hljs-type">int</span> last[MaxV], d[MaxV];  <span class="hljs-comment">// last[i]点i的前驱结点 d[i]点i的深度  </span><br>  <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">BFS</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> n)</span></span>;  <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printPath</span><span class="hljs-params">(<span class="hljs-type">int</span> s, <span class="hljs-type">int</span> v)</span></span>;  <br>  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;  <br>    <span class="hljs-type">int</span> n, m;  <br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);  <span class="hljs-comment">// n顶点数 m边数  </span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;m; i++)&#123;  <br>        <span class="hljs-type">int</span> u, v;  <br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;u, &amp;v);  <span class="hljs-comment">// u到v有边，有向的  </span><br>        ELink* e = (ELink*) <span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span> (ELink));  <br>        e-&gt;adjvex = v, e-&gt;weight = <span class="hljs-number">0</span>, e-&gt;next = <span class="hljs-literal">nullptr</span>;  <br>        <span class="hljs-keyword">if</span>(G[u].link == <span class="hljs-literal">nullptr</span>)&#123;  <br>            G[u].link = e;  <br>        &#125;<span class="hljs-keyword">else</span>&#123;  <br>            e-&gt;next = G[u].link;  <br>            G[u].link = e;  <br>        &#125;  <br>    &#125;  <br>    <span class="hljs-built_in">BFS</span>(<span class="hljs-number">1</span>, n);  <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++)&#123;   <span class="hljs-comment">// 如果是非连通图，该循环保证每个极大连通子图中的顶点都能被遍历到</span><br>		<span class="hljs-keyword">if</span>(!visited[i])  <br>            <span class="hljs-built_in">BFS</span>(i,n);  <br>    &#125;  <br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);  <br>    <span class="hljs-built_in">printPath</span>(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>);  <span class="hljs-comment">// 打印从点1到点4的路径  </span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);  <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, d[<span class="hljs-number">4</span>]);  <span class="hljs-comment">// 打印点4的高度  </span><br>  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;  <br>  <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">BFS</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> n)</span></span>&#123;  <br>    queue&lt;<span class="hljs-type">int</span>&gt; Q;   <span class="hljs-comment">// 待访问的顶点  </span><br>    ELink* p;  <br>  <br>    Q.<span class="hljs-built_in">push</span>(i);  <span class="hljs-comment">// 当前节点  </span><br>    visited[i] = <span class="hljs-literal">true</span>;  <span class="hljs-comment">// 当前节点被visited过了  </span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;v%d-&gt;&quot;</span>, i);  <br>  <br>    <span class="hljs-keyword">while</span>(!Q.<span class="hljs-built_in">empty</span>())&#123;  <br>        <span class="hljs-type">int</span> k = Q.<span class="hljs-built_in">front</span>();  <br>        Q.<span class="hljs-built_in">pop</span>();  <br>        p = G[k].link;  <br>  <br>        <span class="hljs-keyword">while</span>(p != <span class="hljs-literal">nullptr</span>)&#123;    <span class="hljs-comment">// 如果队列头结点非空  </span><br>            <span class="hljs-type">int</span> j = p-&gt;adjvex;  <span class="hljs-comment">// 头结点序号  </span><br>            <span class="hljs-keyword">if</span>(!visited[j])&#123;    <span class="hljs-comment">// 没visited过当前节点  </span><br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;v%d-&gt;&quot;</span>, j);  <br>                visited[j] = <span class="hljs-literal">true</span>;  <br>                Q.<span class="hljs-built_in">push</span>(j);  <br>                d[j] = d[k]+<span class="hljs-number">1</span>;  <br>                last[j] = k;  <br>            &#125;  <br>            p = p-&gt;next;    <span class="hljs-comment">// 下个节点  </span><br>        &#125;  <br>    &#125;  <br>&#125;  <br>  <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printPath</span><span class="hljs-params">(<span class="hljs-type">int</span> s, <span class="hljs-type">int</span> v)</span></span>&#123;  <br>    <span class="hljs-keyword">if</span>(v == s)&#123;  <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, s);  <br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(last[v] == <span class="hljs-number">0</span>)&#123;  <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;No path from %d to %d exists&quot;</span>, s, v);  <br>    &#125;<span class="hljs-keyword">else</span>&#123;  <br>        <span class="hljs-built_in">printPath</span>(s, last[v]);  <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, v);  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure></p>
<h5 id="dfs深度优先搜索">DFS深度优先搜索</h5>
<h6 id="邻接矩阵-2">邻接矩阵</h6>
<p>时间复杂度 <span class="math inline">\(O(n^2)\)</span> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MaxV (10000+10)  </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;  <br><span class="hljs-type">int</span> G[MaxV][MaxV];        <span class="hljs-comment">// 邻接矩阵  </span><br><span class="hljs-type">bool</span> visited[MaxV];  <br><span class="hljs-type">int</span> last[MaxV], d[MaxV];  <span class="hljs-comment">// last[i]点i的前驱结点 d[i]点i的深度  </span><br>  <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DFS</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> n)</span></span>;  <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printPath</span><span class="hljs-params">(<span class="hljs-type">int</span> s, <span class="hljs-type">int</span> v)</span></span>;  <br>  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;  <br>    <span class="hljs-type">int</span> n, m;  <span class="hljs-comment">// n顶点数 m边数  </span><br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);  <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;m; i++)&#123;  <br>        <span class="hljs-type">int</span> u, v;  <br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;u, &amp;v);  <br>        G[u][v] = <span class="hljs-number">1</span>;  <br>    &#125;  <br>    <span class="hljs-built_in">DFS</span>(<span class="hljs-number">1</span>, n);  <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++)&#123;   <span class="hljs-comment">// 如果是非连通图，该循环保证每个极大连通子图中的顶点都能被遍历到</span><br>	    <span class="hljs-keyword">if</span>(!visited[i])  <br>            <span class="hljs-built_in">DFS</span>(i,n);  <br>    &#125;  <br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);  <br>    <span class="hljs-built_in">printPath</span>(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>);  <span class="hljs-comment">// 打印从点1到点4的路径</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);  <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, d[<span class="hljs-number">4</span>]);  <span class="hljs-comment">// 打印点4的高度</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;  <br>  <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DFS</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> n)</span></span>&#123; <span class="hljs-comment">// i当前结点 n总结点数量  </span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;v%d-&gt;&quot;</span>, i);  <br>    visited[i] = <span class="hljs-literal">true</span>;  <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>; j&lt;=n; j++)&#123;  <br>        <span class="hljs-keyword">if</span>(G[i][j] == <span class="hljs-number">1</span> &amp;&amp; !visited[j])&#123;  <br>            last[j] = i;    <span class="hljs-comment">// 前驱  </span><br>            d[j] = d[i]+<span class="hljs-number">1</span>;  <span class="hljs-comment">// 深度  </span><br>            <span class="hljs-built_in">DFS</span>(j, n);  <br>        &#125;  <br>    &#125;  <br>&#125;  <br>  <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printPath</span><span class="hljs-params">(<span class="hljs-type">int</span> s, <span class="hljs-type">int</span> v)</span></span>&#123;   <span class="hljs-comment">// s起点 v终点  </span><br>    <span class="hljs-keyword">if</span>(v == s)&#123;  <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, s);  <br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(last[v] == <span class="hljs-number">0</span>)&#123;  <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;No path from %d to %d exists&quot;</span>, s, v);  <br>    &#125;<span class="hljs-keyword">else</span>&#123;  <br>        <span class="hljs-built_in">printPath</span>(s, last[v]);  <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, v);  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure>
###### 邻接表 时间复杂度 <span class="math inline">\(O(n+e)\)</span>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MaxV (10000+10)  </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;  <br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span>&#123;       <span class="hljs-comment">// 定义边结点类型  </span><br>    <span class="hljs-type">int</span> adjvex;  <span class="hljs-comment">//指向的点  </span><br>    <span class="hljs-type">int</span> weight;  <span class="hljs-comment">//边的权重  </span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span> *next;  <span class="hljs-comment">//相邻的边  </span><br>&#125;ELink;  <br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">ver</span>&#123;       <span class="hljs-comment">// 定义顶点结点类型  </span><br>    <span class="hljs-type">int</span> vertex;  <span class="hljs-comment">//顶点id  </span><br>    ELink* link;  <span class="hljs-comment">//从此顶点出发的边  </span><br>&#125;VLink;  <br>  <br>VLink G[MaxV];  <br><span class="hljs-type">bool</span> visited[MaxV];  <br><span class="hljs-type">int</span> last[MaxV], d[MaxV];  <br>  <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DFS</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> n)</span></span>;  <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printPath</span><span class="hljs-params">(<span class="hljs-type">int</span> s, <span class="hljs-type">int</span> v)</span></span>;  <br>  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;  <br>    <span class="hljs-type">int</span> n, m;  <br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);  <span class="hljs-comment">// n顶点数 m边数  </span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;m; i++)&#123;  <br>        <span class="hljs-type">int</span> u, v;  <span class="hljs-comment">// u到v有边，有向的  </span><br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;u, &amp;v);  <br>        ELink* e = (ELink*) <span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span> (ELink));  <br>        e-&gt;adjvex = v, e-&gt;weight = <span class="hljs-number">0</span>, e-&gt;next = <span class="hljs-literal">nullptr</span>;  <br>        <span class="hljs-keyword">if</span>(G[u].link == <span class="hljs-literal">nullptr</span>)&#123;  <br>            G[u].link = e;  <br>        &#125;<span class="hljs-keyword">else</span>&#123;  <br>            e-&gt;next = G[u].link;  <br>            G[u].link = e;  <br>        &#125;  <br>    &#125;  <br>    <span class="hljs-built_in">DFS</span>(<span class="hljs-number">1</span>, n);  <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++)&#123;   <span class="hljs-comment">// 如果是非连通图，该循环保证每个极大连通子图中的顶点都能被遍历到</span><br>		<span class="hljs-keyword">if</span>(!visited[i])  <br>            <span class="hljs-built_in">DFS</span>(i,n);  <br>    &#125;  <br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);  <br>    <span class="hljs-built_in">printPath</span>(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>);  <span class="hljs-comment">// 打印从点1到点4的路径</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);  <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, d[<span class="hljs-number">4</span>]);  <span class="hljs-comment">// 打印点4的高度</span><br>  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;  <br>  <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DFS</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> n)</span></span>&#123; <span class="hljs-comment">// i当前结点 n总结点数量  </span><br>    ELink* p;  <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;v%d-&gt;&quot;</span>, i);  <br>    visited[i] = <span class="hljs-literal">true</span>;  <br>    p = G[i].link;  <br>    <span class="hljs-keyword">while</span>(p != <span class="hljs-literal">NULL</span>)&#123;  <br>        <span class="hljs-type">int</span> j = p-&gt;adjvex;  <br>        <span class="hljs-keyword">if</span>(!visited[j])&#123;  <br>            last[j] = i;    <span class="hljs-comment">// 前驱  </span><br>            d[j] = d[i]+<span class="hljs-number">1</span>;  <span class="hljs-comment">// 深度  </span><br>            <span class="hljs-built_in">DFS</span>(j, n);  <br>        &#125;  <br>        p = p-&gt;next;  <br>    &#125;  <br>&#125;  <br>  <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printPath</span><span class="hljs-params">(<span class="hljs-type">int</span> s, <span class="hljs-type">int</span> v)</span></span>&#123;   <span class="hljs-comment">// s起点 v终点  </span><br>    <span class="hljs-keyword">if</span>(v == s)&#123;  <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, s);  <br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(last[v] == <span class="hljs-number">0</span>)&#123;  <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;No path from %d to %d exists&quot;</span>, s, v);  <br>    &#125;<span class="hljs-keyword">else</span>&#123;  <br>        <span class="hljs-built_in">printPath</span>(s, last[v]);  <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, v);  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure></p>
<h5 id="拓扑排序">拓扑排序</h5>
<p>拓扑排序：对于<strong>有向无环图</strong> <span
class="math inline">\(G\)</span> 来说，如果图G包含边 <span
class="math inline">\((u,v)\)</span>，则结点 <span
class="math inline">\(u\)</span> 在拓扑排序中处于结点 <span
class="math inline">\(v\)</span> 的前面。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span>  </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;  <br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_VERTICES 10010 <span class="hljs-comment">// 定义图的最大顶点数  </span></span><br>unordered_map&lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;&gt;graph; <span class="hljs-comment">// 定义图的结构  </span><br>  <br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span> &#123;         <span class="hljs-comment">//链式前向星，存边的起点、终点、和前驱  </span><br>    <span class="hljs-type">int</span> from, to, next;  <br>&#125; e[MAX_VERTICES];  <br><span class="hljs-type">int</span> cnt;          <span class="hljs-comment">//存储的边数  </span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;  <br>    <span class="hljs-type">int</span> t;  <br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;t);  <br>    <span class="hljs-keyword">while</span>(t--)&#123;  <br>        <span class="hljs-type">int</span> head[MAX_VERTICES] = &#123;&#125;;  <span class="hljs-comment">//下标是起点的表头，存第一个边的编号，初始化为 -1</span><br>		<span class="hljs-type">int</span> id[MAX_VERTICES]=&#123;&#125;;  <span class="hljs-comment">//每个点的入度  </span><br>        <span class="hljs-built_in">memset</span>(head, <span class="hljs-number">-1</span>, <span class="hljs-built_in">sizeof</span>(head));  <br>        graph.<span class="hljs-built_in">clear</span>();  <br>  <br>        <span class="hljs-type">int</span> n, m;  <br>        cnt = <span class="hljs-number">1</span>;  <br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);  <br>  <br>        <span class="hljs-comment">// 读入  </span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;  <br>            <span class="hljs-type">int</span> from, to;  <br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;from, &amp;to);  <br>            e[cnt].from = from;  <span class="hljs-comment">//起点  </span><br>            e[cnt].to = to;      <span class="hljs-comment">//终点  </span><br>            e[cnt].next = head[from];  <span class="hljs-comment">//添加  </span><br>            id[to]++;  <br>            head[from] = cnt++;  <span class="hljs-comment">//更新表头  </span><br>            graph[from].<span class="hljs-built_in">push_back</span>(to);  <br>        &#125;  <br>        <br>        <span class="hljs-comment">// 拓扑排序  </span><br>        priority_queue&lt;<span class="hljs-type">int</span>&gt; q; <span class="hljs-comment">// 对于拓扑排序不唯一的情况,先输出序号大的点,再输出序号小的点,即输出字典序最大的拓扑排序</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++) &#123;  <br>            <span class="hljs-keyword">if</span> (id[i] == <span class="hljs-number">0</span>)  <br>                q.<span class="hljs-built_in">push</span>(i);  <span class="hljs-comment">//把入度为0的点入队  </span><br>        &#125;  <br>        vector&lt;<span class="hljs-type">int</span>&gt; ans;  <span class="hljs-comment">//数组保存结果  </span><br>        <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;  <br>            <span class="hljs-type">int</span> x = q.<span class="hljs-built_in">top</span>();  <span class="hljs-comment">//出队  </span><br>            q.<span class="hljs-built_in">pop</span>();  <br>            ans.<span class="hljs-built_in">push_back</span>(x);  <br>            <span class="hljs-type">int</span> edge = head[x];  <br>            <span class="hljs-keyword">while</span> (edge != <span class="hljs-number">-1</span>) &#123;  <br>                id[e[edge].to]--;  <span class="hljs-comment">//删除边  </span><br>                <span class="hljs-keyword">if</span> (id[e[edge].to] == <span class="hljs-number">0</span>) <span class="hljs-comment">//把入度为0的点入队  </span><br>                    q.<span class="hljs-built_in">push</span>(e[edge].to);  <br>                edge = e[edge].next;  <br>            &#125;  <br>        &#125;  <br>  <br>        <span class="hljs-comment">// 输出形成的拓扑序列  </span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> an : ans)&#123;  <br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, an);  <br>        &#125;  <br>  <br>    &#125;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></td></tr></table></figure></p>
<h5 id="单源最短路径">单源最短路径</h5>
<h6 id="bellman-ford算法">1 Bellman-Ford算法</h6>
<ul>
<li><strong>权重可以为负</strong>，可以<strong>有回路</strong>。时间复杂度<span
class="math inline">\(O(VE)\)</span> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span>  </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;  <br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX 0x3f3f3f3f  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 1010  </span><br>  <br><span class="hljs-type">int</span> nodenum, edgenum, original; <span class="hljs-comment">//点，边，起点  </span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span>&#123; <span class="hljs-comment">//边  </span><br>    <span class="hljs-type">int</span> u, v;   <span class="hljs-comment">// 起点 终点  </span><br>    <span class="hljs-type">int</span> cost;   <span class="hljs-comment">// 权重  </span><br>&#125;Edge;  <br>  <br>Edge edge[N];  <br><span class="hljs-type">int</span> dis[N], pre[N]; <span class="hljs-comment">// dis源点到每个顶点的最短距离，pre最短路径的前驱节点  </span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Bellman_Ford</span><span class="hljs-params">()</span></span>;  <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print_path</span><span class="hljs-params">(<span class="hljs-type">int</span> root)</span></span>;  <br>  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;  <br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;nodenum, &amp;edgenum, &amp;original);  <br>    pre[original] = original; <span class="hljs-comment">// 初始化源点的前驱为自己  </span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= edgenum; ++i)&#123;  <br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;edge[i].u, &amp;edge[i].v, &amp;edge[i].cost);  <br>    &#125;  <br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">Bellman_Ford</span>())  <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= nodenum; ++i)&#123; <span class="hljs-comment">//每个点最短路  </span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, dis[i]); <span class="hljs-comment">// 输出源点到该顶点的最短距离  </span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Path:&quot;</span>);  <br>            <span class="hljs-built_in">print_path</span>(i); <span class="hljs-comment">// 打印路径  </span><br>        &#125;  <br>    <span class="hljs-keyword">else</span> <span class="hljs-comment">// 如果存在负权回路，输出提示信息  </span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;have negative circle\n&quot;</span>);  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;  <br>  <br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Bellman_Ford</span><span class="hljs-params">()</span></span>&#123;  <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= nodenum; ++i) <span class="hljs-comment">//初始化  </span><br>        dis[i] = (i == original ? <span class="hljs-number">0</span> : MAX);  <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= nodenum - <span class="hljs-number">1</span>; ++i) <span class="hljs-comment">// n-1遍</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= edgenum; ++j)  <br>            <span class="hljs-keyword">if</span>(dis[edge[j].v] &gt; dis[edge[j].u] + edge[j].cost)&#123; <span class="hljs-comment">//松弛  </span><br>                dis[edge[j].v] = dis[edge[j].u] + edge[j].cost;  <br>                pre[edge[j].v] = edge[j].u; <span class="hljs-comment">// 更新前驱节点  </span><br>            &#125;  <br>    <span class="hljs-type">bool</span> flag = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 标记是否存在负权回路 false为有  </span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= edgenum; ++i)  <br>        <span class="hljs-keyword">if</span>(dis[edge[i].v] &gt; dis[edge[i].u] + edge[i].cost)&#123;  <br>            <span class="hljs-comment">// 如果还能松弛，则存在负权回路  </span><br>            flag = <span class="hljs-literal">false</span>;  <br>            <span class="hljs-keyword">break</span>;  <br>        &#125;  <br>    <span class="hljs-keyword">return</span> flag;  <br>&#125;  <br>  <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print_path</span><span class="hljs-params">(<span class="hljs-type">int</span> root)</span></span>&#123; <span class="hljs-comment">// 打印最短路的路径（反向）  </span><br>    <span class="hljs-keyword">while</span>(root != pre[root])&#123; <span class="hljs-comment">// 前驱  </span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d--&gt;&quot;</span>, root);  <br>        root = pre[root];  <br>    &#125;  <br>    <span class="hljs-keyword">if</span>(root == pre[root])  <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, root);  <br>&#125;<br></code></pre></td></tr></table></figure> ###### 2
有向无环图中的单源最短路径问题
<strong>权重可以为负</strong>，<strong>不能有回路</strong>。时间复杂度<span
class="math inline">\(O(V+E)\)</span> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span>  </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;  <br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_VERTICES 10010  <span class="hljs-comment">// 定义图的最大结点数  </span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_EDGE 10010       <span class="hljs-comment">// 定义图的最大边数  </span></span><br>  <br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span>&#123;       <span class="hljs-comment">// 定义边结点类型  </span><br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> adjvex;  <span class="hljs-comment">//指向的点  </span><br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> weight;  <span class="hljs-comment">//边的权重  </span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span> *next; <span class="hljs-comment">//相邻的边  </span><br>&#125;ELink;  <br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">ver</span>&#123;       <span class="hljs-comment">// 定义顶点结点类型  </span><br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> vertex, id, d, last;  <br>    <span class="hljs-comment">// 编号 入度 到源点的距离 最短路径中的前驱结点  </span><br>    ELink* link; <span class="hljs-comment">// 与顶点相连的第一个边结点的指针  </span><br>&#125;VLink;  <br>  <br><span class="hljs-comment">// 定义图的结构  </span><br>VLink G[MAX_VERTICES];  <br>  <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InitializeSingleSource</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> n, <span class="hljs-type">long</span> <span class="hljs-type">long</span> s)</span></span>;  <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Relax</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span>  u, <span class="hljs-type">long</span> <span class="hljs-type">long</span> v, ELink* edge)</span></span>;  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;  <br>    <span class="hljs-type">int</span> t;  <br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;t);  <br>    <span class="hljs-keyword">while</span>(t--)&#123;  <br>        <span class="hljs-type">int</span> n, m, s;  <br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;s); <span class="hljs-comment">// 顶点数 边数 源点  </span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;m; i++)&#123;  <br>            <span class="hljs-type">long</span> <span class="hljs-type">long</span> u, v, w;  <br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld%lld&quot;</span>, &amp;u, &amp;v, &amp;w);  <br>            ELink* e = (ELink*) <span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span> (ELink));  <br>            e-&gt;adjvex = v, e-&gt;weight = w, e-&gt;next = <span class="hljs-literal">nullptr</span>;  <br>            <span class="hljs-keyword">if</span>(G[u].link == <span class="hljs-literal">nullptr</span>)&#123;  <br>                G[u].link = e;  <br>            &#125;<span class="hljs-keyword">else</span>&#123;  <br>                e-&gt;next = G[u].link;  <br>                G[u].link = e;  <br>            &#125;  <br>            G[v].id++;  <br>        &#125;  <br>  <br>        <span class="hljs-comment">// 拓扑排序  </span><br>        queue&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span> &gt; q;  <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;  <br>            <span class="hljs-keyword">if</span> (G[i].id == <span class="hljs-number">0</span>)  <br>                q.<span class="hljs-built_in">push</span>(i);  <span class="hljs-comment">//把入度为0的点入队  </span><br>        &#125;  <br>        vector&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span> &gt; ans; <span class="hljs-comment">// 拓扑排序结果  </span><br>        <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;  <br>            <span class="hljs-type">long</span> <span class="hljs-type">long</span> x = q.<span class="hljs-built_in">front</span>();  <br>            q.<span class="hljs-built_in">pop</span>();  <br>            ans.<span class="hljs-built_in">push_back</span>(x);  <br>            ELink* edge = G[x].link;  <br>            <span class="hljs-keyword">while</span> (edge != <span class="hljs-literal">nullptr</span>) &#123;  <br>                G[edge-&gt;adjvex].id--;  <br>                <span class="hljs-keyword">if</span> (G[edge-&gt;adjvex].id == <span class="hljs-number">0</span>) <span class="hljs-comment">//把入度为0的点入队  </span><br>                    q.<span class="hljs-built_in">push</span>(edge-&gt;adjvex);  <br>                edge = edge-&gt;next;  <br>            &#125;  <br>        &#125;  <br>  <br>        <span class="hljs-built_in">InitializeSingleSource</span>(n, s); <span class="hljs-comment">// 初始化  </span><br>        <span class="hljs-comment">// 松弛结点  </span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">long</span> <span class="hljs-type">long</span> an: ans)&#123;  <br>            VLink now = G[an];  <br>            ELink* temp = now.link;  <br>            <span class="hljs-keyword">while</span> (temp != <span class="hljs-literal">nullptr</span>) &#123;  <br>                <span class="hljs-built_in">Relax</span>(an, temp-&gt;adjvex, temp);  <br>                temp = temp-&gt;next;  <br>            &#125;  <br>        &#125;  <br>        <span class="hljs-comment">// 输出结果  </span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">long</span> <span class="hljs-type">long</span> an: ans)&#123;  <br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld:%lld &quot;</span>, an, G[an].d);  <br>            <span class="hljs-comment">// 输出每个顶点到源点的最短距离  </span><br>        &#125;  <br>    &#125;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;  <br>  <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InitializeSingleSource</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> n, <span class="hljs-type">long</span> <span class="hljs-type">long</span>  s)</span></span>&#123;  <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)&#123;  <br>        G[i].d = LONG_LONG_MAX;  <br>    &#125;  <br>    G[s].d = <span class="hljs-number">0</span>;  <br>&#125;  <br>  <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Relax</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span>  u, <span class="hljs-type">long</span> <span class="hljs-type">long</span> v, ELink* edge)</span></span>&#123;  <br>    <span class="hljs-keyword">if</span>(G[v].d &gt; G[u].d+edge-&gt;weight)&#123;  <br>        G[v].d = G[u].d+edge-&gt;weight;   <span class="hljs-comment">// 更新距离  </span><br>        G[v].last = u;  <span class="hljs-comment">// 更新前驱  </span><br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure> ###### 3
Dijkstra算法</li>
<li><strong>非负</strong>权重的图，可以有<strong>回路</strong>。时间复杂度<span
class="math inline">\(O((V+E)*logV)\)</span> <strong>标准版</strong>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;queue&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MaxV 2005  </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;  <br>  <br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span> &#123;  <br>    <span class="hljs-type">int</span> to;  <br>    <span class="hljs-type">int</span> weight;  <br>    <span class="hljs-comment">// 构造函数，初始化目标顶点和权重  </span><br>    <span class="hljs-built_in">Edge</span>(<span class="hljs-type">int</span> t, <span class="hljs-type">int</span> w) :<span class="hljs-built_in">to</span>(t), <span class="hljs-built_in">weight</span>(w) &#123;&#125;  <br>&#125;;  <br>  <br><span class="hljs-comment">//graph用邻接表表示的图 src源节点  </span><br>vector&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">dijkstra</span>(<span class="hljs-type">const</span> vector&lt;vector&lt;Edge&gt;&gt;&amp; graph, <span class="hljs-type">int</span> src) &#123;  <br>    <span class="hljs-comment">//储存各个顶点到src顶点的距离  </span><br>    vector&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">dis</span>(MaxV, INT_MAX);  <br>    <span class="hljs-comment">//记录访问过的顶点  </span><br>    vector&lt;<span class="hljs-type">bool</span>&gt;<span class="hljs-built_in">vis</span>(MaxV, <span class="hljs-literal">false</span>);  <br>    <span class="hljs-comment">//用优先级队列来处理距离最短的顶点，pair&lt;int,int&gt;的第一个int存储距离，第二个int存储顶点;  </span><br>    <span class="hljs-comment">//底层用vector来存储这个队列；greater表示从小到大排  </span><br>	priority_queue&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;,vector&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; &gt;,greater&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; &gt; &gt;pq;  <br>  <br>    <span class="hljs-comment">//src顶点到自己的距离为0  </span><br>    dis[src] = <span class="hljs-number">0</span>;  <br>    pq.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">0</span>,src&#125;);  <br>  <br>    <span class="hljs-keyword">while</span> (!pq.<span class="hljs-built_in">empty</span>()) &#123;  <br>        <span class="hljs-comment">//v表示当前距离最短的顶点  </span><br>        <span class="hljs-type">int</span> v = pq.<span class="hljs-built_in">top</span>().second; pq.<span class="hljs-built_in">pop</span>();  <br>        <span class="hljs-comment">//若是访问过当前顶点则跳过  </span><br>        <span class="hljs-keyword">if</span> (vis[v]) <span class="hljs-keyword">continue</span>;  <br>        vis[v] = <span class="hljs-literal">true</span>;  <br>        <span class="hljs-comment">//访问邻接顶点  </span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp;edge: graph[v]) &#123;  <br>            <span class="hljs-type">int</span> t = edge.to;  <br>            <span class="hljs-type">int</span> w = edge.weight;  <br>            <span class="hljs-keyword">if</span> (!vis[t] &amp;&amp; w+dis[v]&lt;dis[t]) &#123;  <br>                dis[t] = w + dis[v];  <br>                pq.<span class="hljs-built_in">push</span>(&#123; dis[t],t &#125;);  <br>            &#125;  <br>        &#125;  <br>    &#125;  <br>    <span class="hljs-keyword">return</span> dis;  <br>&#125;  <br>  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;  <br>    <span class="hljs-type">int</span> n, m, source;  <span class="hljs-comment">// 顶点数 边数 源点 </span><br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;source);<br>    vector&lt;vector&lt;Edge&gt;&gt;<span class="hljs-built_in">graph</span>(MaxV);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;m; i++)&#123;<br>        <span class="hljs-type">int</span> u, v, w;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;u, &amp;v, &amp;w);<br>        graph[u].<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">Edge</span>(v,w)); <span class="hljs-comment">// 有向图 u到v权重为w</span><br>    &#125;  <br>    vector&lt;<span class="hljs-type">int</span>&gt;shortest_path = <span class="hljs-built_in">dijkstra</span>(graph, source); <span class="hljs-comment">// 起点source</span><br>    cout &lt;&lt; shortest_path[<span class="hljs-number">3</span>]; <span class="hljs-comment">// 顶点source到顶点3的最短路径长度  </span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h5 id="所有结点对的最短路径问题">所有结点对的最短路径问题</h5>
<h6 id="floyd算法">floyd算法</h6>
<p>空间复杂度 <span class="math inline">\(O(V^2)\)</span>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;limits.h&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> V 310  <span class="hljs-comment">// 图中节点的数量  </span></span><br><span class="hljs-type">long</span> <span class="hljs-type">long</span> dist[V][V], graph[V][V], Path[V][V];  <br><span class="hljs-comment">// dist两点间的最短距离 graph图的邻接矩阵 Path最短路径的中转点  </span><br>  <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">floydWarshall</span><span class="hljs-params">()</span></span>;  <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PrintPath</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> u, <span class="hljs-type">long</span> <span class="hljs-type">long</span> v)</span></span>;  <br>  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;  <br>    <span class="hljs-type">int</span> n, m;   <span class="hljs-comment">// 顶点数 边数  </span><br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);  <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;m; i++)&#123;  <br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> u, v, w;  <span class="hljs-comment">// 起点、终点和权重  </span><br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld%lld&quot;</span>, &amp;u, &amp;v, &amp;w);  <br>        <span class="hljs-keyword">if</span>((graph[u][v]!=<span class="hljs-number">0</span> &amp;&amp; w&lt;graph[u][v]) || graph[u][v] == <span class="hljs-number">0</span>)&#123;  <br>            <span class="hljs-comment">// 考虑到可能有重复边  </span><br>            graph[u][v] = w;  <br>        &#125;  <br>    &#125;  <br>    <span class="hljs-built_in">floydWarshall</span>();  <br>  <br>    <span class="hljs-type">int</span> q;  <span class="hljs-comment">// q次询问  </span><br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;q);  <br>    <span class="hljs-keyword">while</span>(q--)&#123;  <br>        <span class="hljs-type">int</span> u, v;  <br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;u, &amp;v);  <span class="hljs-comment">// 询问的起点和终点  </span><br>        <span class="hljs-keyword">if</span>(u == v)&#123;     <span class="hljs-comment">// u和v是同一个点，距离为0  </span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d-&gt;%d: 0\n&quot;</span>, u, v);  <br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(dist[u][v] == LONG_LONG_MAX)&#123;  <span class="hljs-comment">// u不可达v，输出-1  </span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d-&gt;%d: -1\n&quot;</span>, u, v);  <br>        &#125;<span class="hljs-keyword">else</span>&#123;  <span class="hljs-comment">// u可达v  </span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d-&gt;%d: %lld\n&quot;</span>, u, v, dist[u][v]);  <span class="hljs-comment">// 最短距离  </span><br>            <span class="hljs-built_in">PrintPath</span>(u, v);  <span class="hljs-comment">// 打印最短路径  </span><br>        &#125;  <br>    &#125;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;  <br>  <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">floydWarshall</span><span class="hljs-params">()</span> </span>&#123;  <br>    <span class="hljs-comment">// 初始化最短路径矩阵  </span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; V; i++)  <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; V; j++)&#123;  <br>            <span class="hljs-keyword">if</span>(graph[i][j] != <span class="hljs-number">0</span>)&#123;  <br>                dist[i][j] = graph[i][j];  <br>            &#125;<span class="hljs-keyword">else</span>&#123;  <br>                dist[i][j] = LONG_LONG_MAX;  <br>            &#125;  <br>            <span class="hljs-keyword">if</span>(dist[i][j] &lt; LONG_LONG_MAX &amp;&amp; i != j)&#123;  <br>                Path[i][j] = j; <span class="hljs-comment">// 初始化路径为直接连接  </span><br>            &#125;<span class="hljs-keyword">else</span>&#123;  <br>                Path[i][j] = <span class="hljs-number">-1</span>;  <br>            &#125;  <br>        &#125;  <br>  <br>    <span class="hljs-comment">// 更新最短路径矩阵  </span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; V; k++) &#123;  <span class="hljs-comment">// 遍历所有节点作为中转点  </span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; V; i++) &#123;  <span class="hljs-comment">// 遍历所有起点  </span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; V; j++) &#123;  <span class="hljs-comment">// 遍历所有终点  </span><br>                <span class="hljs-keyword">if</span> (dist[i][k] != LONG_LONG_MAX &amp;&amp; dist[k][j] != LONG_LONG_MAX &amp;&amp; dist[i][k] + dist[k][j] &lt; dist[i][j]) &#123;  <br>                    <span class="hljs-comment">// 如果通过k点可以使i到j的距离更短，松弛  </span><br>                    dist[i][j] = dist[i][k] + dist[k][j];  <br>                    Path[i][j] = k;  <span class="hljs-comment">// 更新路径的中转点为k  </span><br>                &#125;  <br>            &#125;  <br>        &#125;  <br>    &#125;  <br>&#125;  <br><br><span class="hljs-comment">// 打印最短路径  </span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PrintPath</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> u, <span class="hljs-type">long</span> <span class="hljs-type">long</span> v)</span></span>&#123;  <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld &quot;</span>, u);  <span class="hljs-comment">// 打印起点  </span><br>    <span class="hljs-keyword">while</span>(Path[u][v] != v)&#123;  <span class="hljs-comment">// 当中转点不是终点时  </span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld &quot;</span>, Path[u][v]);  <span class="hljs-comment">// 打印中转点  </span><br>        u = Path[u][v];  <span class="hljs-comment">// 更新起点为中转点  </span><br>    &#125;  <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, v);  <span class="hljs-comment">// 打印终点  </span><br>&#125;<br></code></pre></td></tr></table></figure></p>
<h6 id="有向图的传递闭包">有向图的传递闭包</h6>
<ul>
<li><strong>传递闭包</strong>：<span
class="math inline">\(G*=(V,E*)\)</span> ，其中 <span
class="math inline">\(E*=\{(i,j)|如果图G中包含一条从结点i到结点j的路径\}\)</span></li>
<li>用于解决问题：给定有向图，判断对于所有结点对i和j，图G是否包含一条从结点i到结点j的路径
时间复杂度：<span class="math inline">\(O(n^3)\)</span>
<strong>法1：floyd算法每条边权重赋1</strong> <strong>法2</strong>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> V 310  <span class="hljs-comment">// 图中节点的数量  </span></span><br><span class="hljs-type">long</span> <span class="hljs-type">long</span> dist[V][V];  <span class="hljs-comment">// dist[i][j] i到j的可达性  </span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">floydWarshall</span><span class="hljs-params">()</span></span>;  <br>  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;  <br>    <span class="hljs-type">int</span> n, m;  <br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);  <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;m; i++)&#123;  <br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> u, v, w;  <br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld%lld&quot;</span>, &amp;u, &amp;v, &amp;w);  <br>        dist[u][v] = <span class="hljs-number">1</span>;  <br>    &#125;  <br>    <span class="hljs-built_in">floydWarshall</span>();  <br>  <br>    <span class="hljs-type">int</span> q;  <span class="hljs-comment">// q次询问  </span><br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;q);  <br>    <span class="hljs-keyword">while</span>(q--)&#123;  <br>        <span class="hljs-type">int</span> u, v;  <br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;u, &amp;v);  <br>        <span class="hljs-keyword">if</span>(dist[u][v])&#123;     <span class="hljs-comment">// u可达v，输出1  </span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d-&gt;%d: 1\n&quot;</span>, u, v);  <br>        &#125;<span class="hljs-keyword">else</span>&#123;  <span class="hljs-comment">// u不可达v，输出0  </span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d-&gt;%d: 0\n&quot;</span>, u, v);  <br>        &#125;  <br>    &#125;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;  <br>  <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">floydWarshall</span><span class="hljs-params">()</span> </span>&#123;  <br>    <span class="hljs-comment">// 初始化最短路径矩阵  </span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; V; i++)  <br>        dist[i][i] = <span class="hljs-number">1</span>;  <br>  <br>    <span class="hljs-comment">// 更新最短路径矩阵  </span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; V; k++) &#123;  <span class="hljs-comment">// 遍历所有节点作为中转点  </span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; V; i++) &#123;  <span class="hljs-comment">// 遍历所有起点  </span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; V; j++) &#123;  <span class="hljs-comment">// 遍历所有终点  </span><br>                dist[i][j] = dist[i][j] | (dist[i][k] &amp; dist[k][j]);  <br>            &#125;  <br>        &#125;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h6 id="经过固定点的最短路径">经过固定点的最短路径</h6>
<p><img src="/img/LE-suanfabanzi/002.png" srcset="/img/loading.gif" lazyload /> ##### 最大流 ######
Edmonds-Karp算法 时间复杂度 <span
class="math inline">\(O(VE^{2})\)</span>，其中 <span
class="math inline">\(V\)</span> 为点的总数，<span
class="math inline">\(E\)</span> 为边的总数 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span>  </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;  <br>  <br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">210</span>;<span class="hljs-comment">// 最大节点数量  </span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> INF=<span class="hljs-number">0x7FFFFFFF</span>;  <br><span class="hljs-type">int</span> n,m; <span class="hljs-comment">// n为节点数，m为汇点编号  </span><br><span class="hljs-type">int</span> map0[N][N]; <span class="hljs-comment">// 残留图，表示每条有向边的容量  </span><br><span class="hljs-type">int</span> pi[N];  <span class="hljs-comment">//BFS的前驱图  </span><br><span class="hljs-type">int</span> flow_in[N]; <span class="hljs-comment">//流入i的最大流量是flow_in[i]  </span><br><span class="hljs-type">int</span> start,end0; <span class="hljs-comment">// 源点和汇点  </span><br>queue&lt;<span class="hljs-type">int</span>&gt; q;  <br>  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span></span>;  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Edmonds_Karp</span><span class="hljs-params">()</span></span>;  <br>  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;  <br>    <span class="hljs-type">int</span> i,u,v,cost;  <br>    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m)!=EOF)&#123; <span class="hljs-comment">// 读取节点数和汇点编号  </span><br>        <span class="hljs-built_in">memset</span>(map0,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(map0));  <br>        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;  <br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;u,&amp;v,&amp;cost);  <br>            map0[u][v]+=cost; <span class="hljs-comment">// 更新残留图的容量  </span><br>        &#125;  <br>        start=<span class="hljs-number">1</span>,end0=m;  <span class="hljs-comment">// 1是源点，m是汇点  </span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,<span class="hljs-built_in">Edmonds_Karp</span>());  <br>    &#125;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;  <br>  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span></span>&#123;  <br>    <span class="hljs-type">int</span> i,t;  <br>    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>()) q.<span class="hljs-built_in">pop</span>();  <br>    <span class="hljs-built_in">memset</span>(pi,<span class="hljs-number">-1</span>,<span class="hljs-built_in">sizeof</span>(pi));  <br>    pi[start]=<span class="hljs-number">0</span>; <span class="hljs-comment">// 源点的前驱为自己  </span><br>    flow_in[start]=INF;  <br>  <br>    q.<span class="hljs-built_in">push</span>(start);  <br>    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;  <br>        t=q.<span class="hljs-built_in">front</span>();  <br>        q.<span class="hljs-built_in">pop</span>();  <br>  <br>        <span class="hljs-keyword">if</span>(t==end0) <span class="hljs-keyword">break</span>;  <span class="hljs-comment">// 已经走到汇点，循环结束  </span><br>        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;  <br>            <span class="hljs-keyword">if</span>(pi[i]==<span class="hljs-number">-1</span> &amp;&amp; map0[t][i])&#123; <span class="hljs-comment">// 节点i未被访问且t到i有边  </span><br>                flow_in[i] = <span class="hljs-built_in">min</span>(flow_in[t], map0[t][i]); <span class="hljs-comment">// 更新流入i的最大流量  </span><br>                q.<span class="hljs-built_in">push</span>(i);  <br>                pi[i]=t;    <span class="hljs-comment">// i的前驱结点为t  </span><br>            &#125;  <br>        &#125;  <br>    &#125;  <br>    <span class="hljs-keyword">if</span>(pi[end0]==<span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// 如果汇点未被访问，说明没有增广路径  </span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> flow_in[m]; <span class="hljs-comment">// 返回增广路径的流量  </span><br>&#125;  <br>  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Edmonds_Karp</span><span class="hljs-params">()</span></span>&#123;  <br>    <span class="hljs-type">int</span> max_flow_in=<span class="hljs-number">0</span>; <span class="hljs-comment">// 流f的流值|f|  </span><br>    <span class="hljs-type">int</span> cf_p;     <span class="hljs-comment">// 增广路径的残留容量Cf(p)  </span><br>  <br>    <span class="hljs-keyword">while</span>((cf_p=<span class="hljs-built_in">bfs</span>())!=<span class="hljs-number">-1</span>)&#123;    <span class="hljs-comment">// 当还有增广路径时  </span><br>        <span class="hljs-comment">//1. 流值|f|增加本次增广路径的残留容量cf_p  </span><br>        max_flow_in+=cf_p;  <br>  <br>        <span class="hljs-comment">//2. 更新残留图  </span><br>        <span class="hljs-type">int</span> now=end0;  <br>        <span class="hljs-keyword">while</span>(now!=start)&#123;  <br>            <span class="hljs-type">int</span> pre=pi[now]; <span class="hljs-comment">// 获取前驱节点  </span><br>            map0[pre][now]-=cf_p;  <span class="hljs-comment">//更新正向边的实际容量  </span><br>            map0[now][pre]+=cf_p;  <span class="hljs-comment">//添加反向边  </span><br>            now=pre; <span class="hljs-comment">// 移动到前驱节点  </span><br>        &#125;  <br>    &#125;  <br>    <span class="hljs-keyword">return</span> max_flow_in; <span class="hljs-comment">// 返回最大流  </span><br>&#125;<br></code></pre></td></tr></table></figure> ######
Dinic算法 时间复杂度 <span
class="math inline">\(O(V^{2}E)\)</span>，其中 <span
class="math inline">\(V\)</span> 为点的总数，<span
class="math inline">\(E\)</span> 为边的总数 + 第一行一个正整数
T（1≤T≤10），表示数据组数。 + 对于每组数据，第一行四个正整数
n,m,s,t（1≤n≤100，1≤m≤5×10^3，1≤s,t≤n），n个点，m条边，计算从s到t的最大流。
+ 接下来 m 行，每行三个正整数
ui,vi,wi（1≤ui,vi≤n，0≤wi&lt;2^31），表示第 i 条有向边 ui→vi
的最大容量为 wi。 + 图中有可能存在<strong>重边和自环</strong>。
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span>  </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;  <br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;  <br><span class="hljs-type">const</span> <span class="hljs-type">int</span> V_MAX = <span class="hljs-number">205</span>; <span class="hljs-comment">// 最大顶点数  </span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> E_MAX = <span class="hljs-number">5005</span>; <span class="hljs-comment">// 最大边数  </span><br><span class="hljs-type">const</span> ll LL_INF = <span class="hljs-number">0x3f3f3f3f3f3f3f3f</span>;  <br>ll max_stream = <span class="hljs-number">0</span>; <span class="hljs-comment">// 最大流  </span><br><span class="hljs-type">int</span> cnt_E = <span class="hljs-number">0</span>;  <br><span class="hljs-type">int</span> n, m, s, t;  <br>  <br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span> &#123;  <br>    <span class="hljs-type">int</span> to; <span class="hljs-comment">// 边的目标顶点  </span><br>    <span class="hljs-type">int</span> nxt; <span class="hljs-comment">// 下一条边的索引  </span><br>    ll val; <span class="hljs-comment">// 边的容量  </span><br>&#125; e[E_MAX * <span class="hljs-number">2</span>]; <span class="hljs-comment">// 边数组，每条边对应一条正向边和一条反向边  </span><br><span class="hljs-type">int</span> head[V_MAX]; <span class="hljs-comment">// 邻接表的头指针数组  </span><br><span class="hljs-type">int</span> depth[V_MAX]; <span class="hljs-comment">// 每个顶点的层次  </span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addEdge</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> w)</span></span>;  <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span>;  <br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span></span>;  <br><span class="hljs-function">ll <span class="hljs-title">Dinic</span><span class="hljs-params">()</span></span>;  <br>  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;  <br>    <span class="hljs-type">int</span> T;  <br>    cin &gt;&gt; T;  <br>    <span class="hljs-keyword">while</span>(T--)&#123;  <br>        cin &gt;&gt; n &gt;&gt; m &gt;&gt; s &gt;&gt; t; <span class="hljs-comment">// 顶点数 边数 源点 汇点  </span><br>        cnt_E = <span class="hljs-number">0</span>, max_stream = <span class="hljs-number">0</span>; <span class="hljs-comment">// 初始化边计数器和最大流  </span><br>        <span class="hljs-built_in">fill</span>(head + <span class="hljs-number">1</span>, head + <span class="hljs-number">1</span> + n, <span class="hljs-number">-1</span>);  <br>        <span class="hljs-built_in">read</span>();  <br>        cout &lt;&lt; <span class="hljs-built_in">Dinic</span>() &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;  <br>    &#125;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;  <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addEdge</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> w)</span> </span>&#123;  <br>    e[cnt_E].to = y;  <br>    e[cnt_E].val = w;  <br>    e[cnt_E].nxt = head[x];  <br>    head[x] = cnt_E++;  <br>&#125;  <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;  <br>    <span class="hljs-type">int</span> u, v, w;  <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;  <br>        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;  <br>        <span class="hljs-built_in">addEdge</span>(u, v, w); <span class="hljs-comment">// 添加正向边  </span><br>        <span class="hljs-built_in">addEdge</span>(v, u, <span class="hljs-number">0</span>); <span class="hljs-comment">// 添加反向边，容量为0  </span><br>    &#125;  <br>&#125;  <br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span> </span>&#123;   <span class="hljs-comment">// bfs用于获得层次（分层图）  </span><br>    <span class="hljs-built_in">memset</span>(depth, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(depth));  <br>    depth[s] = <span class="hljs-number">1</span>; <span class="hljs-comment">// 源点的层次为1  </span><br>    queue&lt;<span class="hljs-type">int</span>&gt; q;  <br>    q.<span class="hljs-built_in">push</span>(s); <span class="hljs-comment">// 将源点加入队列  </span><br>    <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;  <br>        <span class="hljs-type">int</span> u = q.<span class="hljs-built_in">front</span>();  <br>        q.<span class="hljs-built_in">pop</span>();  <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = head[u]; i &gt; <span class="hljs-number">-1</span>; i = e[i].nxt) &#123;  <br>            <span class="hljs-type">int</span> v = e[i].to;  <br>            <span class="hljs-keyword">if</span> (e[i].val &amp;&amp; !depth[v]) &#123; <span class="hljs-comment">// 边有剩余容量且目标顶点未访问  </span><br>                depth[v] = depth[u] + <span class="hljs-number">1</span>; <span class="hljs-comment">// 更新目标顶点的层次  </span><br>                q.<span class="hljs-built_in">push</span>(v); <span class="hljs-comment">// 将目标顶点加入队列  </span><br>            &#125;  <br>        &#125;  <br>    &#125;  <br>    <span class="hljs-keyword">if</span> (depth[t] != <span class="hljs-number">0</span>) <span class="hljs-comment">// 如果汇点可达  </span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 返回true表示存在增广路径  </span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <br>&#125;  <br>  <br><span class="hljs-function">ll <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> pos, ll in)</span> </span>&#123; <span class="hljs-comment">// DFS用于寻找增广路径并计算流量  </span><br>    <span class="hljs-keyword">if</span> (pos == t) <span class="hljs-comment">// 如果当前顶点是汇点，则返回当前流量  </span><br>        <span class="hljs-keyword">return</span> in;  <br>    ll out = <span class="hljs-number">0</span>; <span class="hljs-comment">// 初始化当前顶点的流出量为0  </span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> u = head[pos]; u &gt; <span class="hljs-number">-1</span> &amp;&amp; in; u = e[u].nxt) &#123;  <br>        <span class="hljs-type">int</span> v = e[u].to;  <br>        <span class="hljs-comment">// 如果边有剩余容量且目标顶点的层次恰好是当前顶点层次加1  </span><br>        <span class="hljs-keyword">if</span> (e[u].val &amp;&amp; depth[v] == depth[pos] + <span class="hljs-number">1</span>) &#123;  <br>            <span class="hljs-comment">// 递归调用dfs寻找增广路径，并计算可以流过当前边的流量  </span><br>            ll res = <span class="hljs-built_in">dfs</span>(v, <span class="hljs-built_in">min</span>(e[u].val, in));  <br>            e[u].val -= res; <span class="hljs-comment">// 更新正向边的容量  </span><br>            e[u ^ <span class="hljs-number">1</span>].val += res; <span class="hljs-comment">// 更新反向边的容量  </span><br>            in -= res; <span class="hljs-comment">// 减少当前流量  </span><br>            out += res; <span class="hljs-comment">// 增加流出量  </span><br>        &#125;  <br>    &#125;  <br>    <span class="hljs-keyword">if</span> (out == <span class="hljs-number">0</span>)  <br>        <span class="hljs-comment">// 如果当前顶点没有流出量，则将其层次设为0，表示在后续的BFS中不会再访问  </span><br>        depth[pos] = <span class="hljs-number">0</span>;  <br>    <span class="hljs-keyword">return</span> out;  <br>&#125;  <br><span class="hljs-function">ll <span class="hljs-title">Dinic</span><span class="hljs-params">()</span> </span>&#123;  <br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">bfs</span>())   <span class="hljs-comment">// 存在增广路径  </span><br>        max_stream += <span class="hljs-built_in">dfs</span>(s, LL_INF);  <br>    <span class="hljs-keyword">return</span> max_stream;  <br>&#125;<br></code></pre></td></tr></table></figure></p>
<h5 id="最大二分匹配">最大二分匹配</h5>
<h6 id="dinic最小割最大流算法">Dinic最小割/最大流算法</h6>
<p>时间复杂度 <span class="math inline">\(O(VE)\)</span> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 最大流等于最小割  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;queue&gt;</span>  </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;  <br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e3</span>+<span class="hljs-number">10</span>, M = <span class="hljs-number">5e5</span>+<span class="hljs-number">1e4</span>+<span class="hljs-number">10</span>, INT = <span class="hljs-number">0x3f3f3f3f</span>;  <br><span class="hljs-comment">// 最大节点数(至少n+m+2) 最大边数(至少最大边数+n+m，因为有源点汇点的边) 无穷大常量  </span><br><span class="hljs-type">int</span> e[M], ne[M], f[M], h[N], idx;  <br><span class="hljs-comment">// e边的终点 ne下一条边的索引 f边的容量 h每个节点边的起始索引 idx边的索引  </span><br><span class="hljs-type">int</span> cur[N], d[N]; <span class="hljs-comment">// cur当前弧优化 d节点层次  </span><br><span class="hljs-comment">// 弧优化通过记录每次DFS搜索的断点，使得下一次DFS可以直接从上次搜索的断点继续，从而跳过那些已经饱和的边</span><br><span class="hljs-type">int</span> n, m, eNum, S, T; <span class="hljs-comment">// n: 节点数, m: 边数, S: 源点, T: 汇点  </span><br>  <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c)</span></span>;  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dinic</span><span class="hljs-params">()</span></span>;  <br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span></span>;  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> lim)</span></span>;  <br>  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;  <br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;eNum);  <br>    S = <span class="hljs-number">0</span>, T = n + m + <span class="hljs-number">1</span>; <span class="hljs-comment">// 设置源点和汇点  </span><br>    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> h);  <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) <span class="hljs-built_in">add</span>(S, i, <span class="hljs-number">1</span>); <span class="hljs-comment">// 添加源点到左侧点的边  </span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n + <span class="hljs-number">1</span>; i &lt;= n+m; i++) <span class="hljs-built_in">add</span>(i, T, <span class="hljs-number">1</span>); <span class="hljs-comment">// 添加右侧点到汇点的边  </span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= eNum; i++)&#123;  <br>        <span class="hljs-type">int</span> a, b;  <br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);  <br>        <span class="hljs-built_in">add</span>(a, b+n, <span class="hljs-number">1</span>); <span class="hljs-comment">// 起点 终点 容量为1  </span><br>    &#125;  <br>    cout &lt;&lt; <span class="hljs-built_in">dinic</span>() &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; <span class="hljs-comment">// 输出二分图最大匹配的边数  </span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;idx;i+=<span class="hljs-number">2</span>)  <span class="hljs-comment">// 输出二分图匹配的点对  </span><br>    &#123;  <br>        <span class="hljs-keyword">if</span>(e[i]&gt;n &amp;&amp; e[i]&lt;=n+m &amp;&amp; !f[i]) <span class="hljs-comment">// 是右侧的边且剩余容量为0(这条边在最大流中已经被完全使用)  </span><br>        &#123;  <br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d\n&quot;</span>,e[i^<span class="hljs-number">1</span>],e[i]-n); <span class="hljs-comment">// 左侧的点 右侧的点  </span><br>        &#125;  <br>    &#125;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;  <br>  <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c)</span></span>&#123; <span class="hljs-comment">// a: 起点, b: 终点, c: 容量  </span><br>    e[idx] = b, f[idx] = c, ne[idx] = h[a], h[a] = idx++; <span class="hljs-comment">// 添加正向边  </span><br>    e[idx] = a, f[idx] = <span class="hljs-number">0</span>, ne[idx] = h[b], h[b] = idx++; <span class="hljs-comment">// 添加反向边，容量为0  </span><br>&#125;  <br>  <br><span class="hljs-comment">// Dinic算法主函数  </span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dinic</span><span class="hljs-params">()</span></span>&#123;  <br>    <span class="hljs-type">int</span> r = <span class="hljs-number">0</span>, flow; <span class="hljs-comment">// 初始化最大流为0  </span><br>    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">bfs</span>()) <span class="hljs-comment">// 当BFS可以构建分层图时  </span><br>        <span class="hljs-keyword">while</span>(flow = <span class="hljs-built_in">dfs</span>(S, INT))  <br>            r += flow; <span class="hljs-comment">// 通过DFS寻找增广路径并累加流量  </span><br>    <span class="hljs-keyword">return</span> r; <span class="hljs-comment">// 返回最大流  </span><br>&#125;  <br>  <br><span class="hljs-comment">// BFS用于分层图构建  </span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span></span>&#123;  <br>    queue&lt;<span class="hljs-type">int</span>&gt; q;  <br>    q.<span class="hljs-built_in">push</span>(S); <span class="hljs-comment">// 将源点加入队列  </span><br>    <span class="hljs-built_in">memset</span>(d, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> d);  <br>    d[S] = <span class="hljs-number">0</span>, cur[S] = h[S]; <span class="hljs-comment">// 源点的层次为0，初始化当前弧  </span><br>    <span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>())&#123;  <br>        <span class="hljs-type">int</span> t = q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">pop</span>();  <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = h[t]; ~i; i = ne[i])&#123; <span class="hljs-comment">// 遍历所有邻接边  </span><br>            <span class="hljs-type">int</span> ver = e[i]; <span class="hljs-comment">// 邻接边的终点  </span><br>            <span class="hljs-keyword">if</span>(d[ver] == <span class="hljs-number">-1</span> &amp;&amp; f[i])&#123; <span class="hljs-comment">// 如果终点未访问且正向边有容量  </span><br>                d[ver] = d[t] + <span class="hljs-number">1</span>; <span class="hljs-comment">// 更新终点层次  </span><br>                cur[ver] = h[ver]; <span class="hljs-comment">// 初始化当前弧  </span><br>                <span class="hljs-keyword">if</span>(ver == T) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 如果到达汇点，返回true  </span><br>                q.<span class="hljs-built_in">push</span>(ver); <span class="hljs-comment">// 将终点加入队列  </span><br>            &#125;  <br>        &#125;  <br>    &#125;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 如果无法到达汇点，返回false  </span><br>&#125;  <br>  <br><span class="hljs-comment">// DFS用于寻找增广路径  </span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> lim)</span></span>&#123;  <br>    <span class="hljs-keyword">if</span>(u == T) <span class="hljs-keyword">return</span> lim; <span class="hljs-comment">// 如果到达汇点，返回剩余流量  </span><br>    <span class="hljs-type">int</span> flow = <span class="hljs-number">0</span>; <span class="hljs-comment">// 初始化当前节点的流量为0  </span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = cur[u]; ~i &amp;&amp; flow &lt; lim; i = ne[i])&#123; <span class="hljs-comment">// 遍历当前节点所有邻接边  </span><br>        <span class="hljs-type">int</span> ver = e[i]; <span class="hljs-comment">// 邻接边的终点  </span><br>        cur[u] = i; <span class="hljs-comment">// 更新当前弧  </span><br>        <span class="hljs-keyword">if</span>(d[ver] == d[u] + <span class="hljs-number">1</span> &amp;&amp; f[i])&#123; <span class="hljs-comment">// 如果终点层次正确且正向边有容量  </span><br>            <span class="hljs-type">int</span> t = <span class="hljs-built_in">dfs</span>(ver, <span class="hljs-built_in">min</span>(f[i], lim - flow)); <span class="hljs-comment">// 递归寻找增广路径  </span><br>            <span class="hljs-keyword">if</span>(!t)  <br>                d[ver] = <span class="hljs-number">-1</span>; <span class="hljs-comment">// 如果无法增广，更新终点层次为-1  </span><br>            f[i] -= t, f[i^<span class="hljs-number">1</span>] += t, flow += t; <span class="hljs-comment">// 更新正向边和反向边的容量，累加流量  </span><br>        &#125;  <br>    &#125;  <br>    <span class="hljs-keyword">return</span> flow; <span class="hljs-comment">// 返回当前节点的流量  </span><br>&#125;<br></code></pre></td></tr></table></figure>
###### 匈牙利算法 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span>  </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;  <br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">555</span>;   <span class="hljs-comment">// 定义最大可能的节点数  </span><br>vector&lt;<span class="hljs-type">int</span>&gt; G[N];  <span class="hljs-comment">// 邻接表，用于存储每个男生的认识的女生的列表  </span><br><span class="hljs-type">int</span> match[N],vis[N];  <br><span class="hljs-comment">// match用于存储谁（i）和谁（match[i]）匹配  </span><br><span class="hljs-comment">// vis用于存储当前这一边搜索是否已经让某个男生找过增广路了  </span><br><span class="hljs-type">bool</span> used[N][N];   <span class="hljs-comment">// 用于标记某个男生和女生之间是否有边  </span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">hungary</span><span class="hljs-params">(<span class="hljs-type">int</span> p,<span class="hljs-type">int</span> op)</span></span>;  <br>  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;  <br>    <span class="hljs-type">int</span> n,m,e,a,b; <span class="hljs-comment">// n男生数 m女生数 e边数 a男生编号 b女生编号  </span><br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;e);  <br>    <span class="hljs-keyword">while</span>(e--)&#123;  <br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;a,&amp;b); <span class="hljs-comment">//a范围1~n b范围1~m  </span><br>        <span class="hljs-keyword">if</span>(used[a][b]) <span class="hljs-comment">//判重边  </span><br>            <span class="hljs-keyword">continue</span>;  <br>        used[a][b]=<span class="hljs-literal">true</span>;  <br>        G[a].<span class="hljs-built_in">push_back</span>(b);  <br>    &#125;  <br>    <span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;  <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)  <br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">hungary</span>(i,i))    <span class="hljs-comment">// 第i个男生，同时也是第i次搜寻  </span><br>            ans++;  <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,ans);  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;  <br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">hungary</span><span class="hljs-params">(<span class="hljs-type">int</span> p,<span class="hljs-type">int</span> op)</span></span>&#123;  <span class="hljs-comment">// p表示第几个男生，op表示第几趟匹配  </span><br>    <span class="hljs-keyword">if</span>(vis[p]==op) <span class="hljs-comment">// 如果当前男生在当前轮次已经找过增广路径，返回false  </span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <br>    vis[p]=op;  <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i:G[p])&#123;    <span class="hljs-comment">// 对于每个男生p，遍历一遍他认识的女生  </span><br>        <span class="hljs-keyword">if</span>(!match[i]||<span class="hljs-built_in">hungary</span>(match[i],op))&#123;  <br>            <span class="hljs-comment">// 如果当前的女生没被匹配到，自然可以直接让她与当前的男生p进行匹配  </span><br>            <span class="hljs-comment">// 如果已经被匹配过，则尝试让匹配她的那个男生去再找找看其他女生（开始套娃），  </span><br>            <span class="hljs-comment">// 如果返回true也可以正常匹配  </span><br>            match[i]=p;  <br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <br>        &#125;  <br>    &#125;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <br>&#125;<br></code></pre></td></tr></table></figure></p>
<h5 id="最小生成树">最小生成树</h5>
<h6 id="prim-朴素版">prim-朴素版</h6>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span>  </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;  <br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">2005</span>,M = <span class="hljs-number">5005</span>,INF = <span class="hljs-number">0x3f3f3f3f</span>;  <br><span class="hljs-comment">// N最大节点数 M最大边数 INF无穷大  </span><br><span class="hljs-type">int</span> n,m;  <br><span class="hljs-type">int</span> g[N][N]; <span class="hljs-comment">// g为图的邻接矩阵，存储所有节点之间的边权重  </span><br><span class="hljs-type">int</span> dist[N]; <span class="hljs-comment">// dist存储从已选节点集合到未选节点集合的最小距离  </span><br><span class="hljs-type">bool</span> used[N];<span class="hljs-comment">// used标记节点是否已被添加到最小生成树中  </span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">prim</span><span class="hljs-params">()</span></span>;  <br>  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;  <br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m); <span class="hljs-comment">// 读取节点数和边数  </span><br>    <span class="hljs-comment">//重要  </span><br>    <span class="hljs-built_in">memset</span>(g,<span class="hljs-number">0x3f</span>,<span class="hljs-built_in">sizeof</span>(g));  <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; m; i++)&#123;  <br>        <span class="hljs-type">int</span> u,v,w; <span class="hljs-comment">// 读取边(u, v)的权重w  </span><br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;u,&amp;v,&amp;w);  <br>        g[u][v] = g[v][u] = <span class="hljs-built_in">min</span>(g[u][v],w); <span class="hljs-comment">// 更新邻接矩阵，保证是无向图且权重最小  </span><br>    &#125;  <br>  <br>    <span class="hljs-type">int</span> r = <span class="hljs-built_in">prim</span>(); <span class="hljs-comment">// 调用prim函数计算最小生成树的权重和  </span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,r);  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;  <br>  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">prim</span><span class="hljs-params">()</span></span>&#123; <span class="hljs-comment">// 返回最小生成树的权重和  </span><br>    <span class="hljs-built_in">memset</span>(dist,<span class="hljs-number">0x3f</span>,<span class="hljs-keyword">sizeof</span> dist);  <br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>; <span class="hljs-comment">// res用于存储最小生成树的权重和  </span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++)&#123;  <br>        <span class="hljs-type">int</span> t = <span class="hljs-number">-1</span>; <span class="hljs-comment">// t用于存储当前未选节点中距离已选节点集合最近的节点  </span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j &lt;= n; j++)&#123;  <br>            <span class="hljs-keyword">if</span>((!used[j]) &amp;&amp; (t == <span class="hljs-number">-1</span> || dist[t] &gt; dist[j]))  <br>                t = j;  <br>        &#125;  <br>        used[t] = <span class="hljs-literal">true</span>;  <br>        <span class="hljs-comment">// 如果不是第一个节点且距离为无穷大，说明图不连通，返回无穷大  </span><br>        <span class="hljs-keyword">if</span>(i &amp;&amp; dist[t] == INF) <span class="hljs-keyword">return</span> INF;  <br>        <span class="hljs-keyword">if</span>(i)res += dist[t]; <span class="hljs-comment">// 如果不是第一个节点，累加到res中  </span><br>  <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j &lt;= n;j++)&#123; <span class="hljs-comment">// 更新未选节点的距离  </span><br>            <span class="hljs-keyword">if</span>(!used[j])  <br>                dist[j] = <span class="hljs-built_in">min</span>(dist[j],g[t][j]);  <br>        &#125;  <br>    &#125;  <br>    <span class="hljs-keyword">return</span> res;  <br>&#125;<br></code></pre></td></tr></table></figure>
<h6 id="prim-堆优化">prim-堆优化</h6>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span>  </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;  <br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INF 2147483647  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N (100000+10)  </span><br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;pii;  <br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">cmp</span>&#123;  <br>    <span class="hljs-comment">//自定义排序方法 因为我定义的优先队列里，边权和是第二个元素，如果直接greater，它会默认按第一个元素排序  </span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(pii &amp;a,pii &amp;b)</span></span>&#123;  <br>        <span class="hljs-keyword">return</span> a.second&gt;b.second;  <br>    &#125;  <br>&#125;;  <br>vector&lt;pii&gt;e[N]; <span class="hljs-comment">// 邻接表，e[i] 存储与节点 i 相连的边和对应的权重  </span><br><span class="hljs-type">int</span> d[N],vis[N],cnt,sum,n,m;  <br><span class="hljs-comment">// d存储最小距离，vis标记节点是否已访问，cnt计数，sum总权重，n节点数，m边数  </span><br>priority_queue &lt;pii,vector&lt;pii&gt;,cmp &gt; q; <span class="hljs-comment">// 优先队列，用于存储和获取最小边  </span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add_edge</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> z)</span></span>;  <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>;  <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">prim</span><span class="hljs-params">()</span></span>;  <br>  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;  <br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m); <span class="hljs-comment">// 节点数n 边数m  </span><br>    <span class="hljs-built_in">init</span>(n);  <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=m; i++)&#123;  <br>        <span class="hljs-type">int</span> x,y,z; <span class="hljs-comment">// 边(x, y)的权重z  </span><br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;x,&amp;y,&amp;z);  <br>        <span class="hljs-built_in">add_edge</span>(x,y,z);  <br>    &#125;  <br>    <span class="hljs-built_in">prim</span>(); <span class="hljs-comment">// 调用prim函数计算最小生成树的权重和  </span><br>    <span class="hljs-keyword">if</span> (cnt==n) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,sum); <span class="hljs-comment">// 有最小生成树  </span><br>    <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;orz&quot;</span>); <span class="hljs-comment">// 否则输出&quot;orz&quot;，表示图不连通  </span><br>&#125;  <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add_edge</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> z)</span></span>&#123;  <span class="hljs-comment">//邻接表存图  </span><br>    e[x].<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">make_pair</span>(y, z));  <br>    e[y].<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">make_pair</span>(x, z)); <span class="hljs-comment">// 无向图，添加边(y, x)权重z  </span><br>&#125;  <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>&#123; <span class="hljs-comment">//初始化  </span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) e[i].<span class="hljs-built_in">clear</span>();  <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) d[i] = INF;  <br>&#125;  <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">prim</span><span class="hljs-params">()</span></span>&#123;  <br>    d[<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>; <span class="hljs-comment">// 从节点1开始，将其距离设为0  </span><br>    q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_pair</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>)); <span class="hljs-comment">// 将节点1和距离0加入优先队列  </span><br>    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>() &amp;&amp; cnt&lt;n)&#123; <span class="hljs-comment">// 当队列不为空且处理过的节点数小于n时  </span><br>        <span class="hljs-type">int</span> now=q.<span class="hljs-built_in">top</span>().first; <span class="hljs-comment">// 当前处理的节点  </span><br>        <span class="hljs-type">int</span> dis=q.<span class="hljs-built_in">top</span>().second; <span class="hljs-comment">// 当前节点的最小距离  </span><br>        q.<span class="hljs-built_in">pop</span>(); <span class="hljs-comment">// 弹出当前节点  </span><br>        <span class="hljs-keyword">if</span>(vis[now]) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// 如果当前节点已访问，跳过  </span><br>        cnt++; <span class="hljs-comment">// 计数增加  </span><br>        sum += dis; <span class="hljs-comment">// 累加到总权重  </span><br>        vis[now] = <span class="hljs-number">1</span>; <span class="hljs-comment">// 标记当前节点为已访问  </span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;e[now].<span class="hljs-built_in">size</span>(); i++)&#123; <span class="hljs-comment">// 遍历当前节点的所有邻接边  </span><br>            <span class="hljs-type">int</span> v=e[now][i].first; <span class="hljs-comment">// 邻接节点  </span><br>            <span class="hljs-keyword">if</span>(d[v]&gt;e[now][i].second)&#123; <span class="hljs-comment">// 如果找到更小的距离  </span><br>                d[v]=e[now][i].second; <span class="hljs-comment">// 更新最小距离  </span><br>                q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_pair</span>(v,d[v])); <span class="hljs-comment">// 将新距离和节点加入优先队列  </span><br>            &#125;  <br>        &#125;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure>
<h6 id="kruskal">kruskal</h6>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> V_MAX 300005 <span class="hljs-comment">// 定义最大顶点数  </span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> E_MAX 500005 <span class="hljs-comment">// 定义最大边数  </span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;  <br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;  <br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span> &#123;  <br>    <span class="hljs-type">int</span> x, y, w;    <span class="hljs-comment">// 起点 终点 权重  </span><br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> Edge &amp;b) <span class="hljs-type">const</span> &#123; <span class="hljs-keyword">return</span> w &lt; b.w; &#125;  <br>&#125; e[E_MAX];  <br><span class="hljs-type">int</span> v[V_MAX]; <span class="hljs-comment">// 并查集数组，用于存储每个顶点的父节点  </span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>; <span class="hljs-comment">// 查找元素x所在集合的代表元素  </span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isUnion</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span>; <span class="hljs-comment">// 判断两个元素是否在同一个集合中  </span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Union</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span>; <span class="hljs-comment">// 合并两个集合  </span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">makeSet</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>; <span class="hljs-comment">// 初始化并查集  </span><br>  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;  <br>    <span class="hljs-type">int</span> n, m;  <br>    cin &gt;&gt; n &gt;&gt; m; <span class="hljs-comment">// n为顶点数，m为边数  </span><br>    <span class="hljs-built_in">makeSet</span>(n);  <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)  <br>        cin &gt;&gt; e[i].x &gt;&gt; e[i].y &gt;&gt; e[i].w;  <br>    <span class="hljs-built_in">sort</span>(e, e + m); <span class="hljs-comment">// 按权重从小到大对边进行排序  </span><br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>; <span class="hljs-comment">// 已加入最小生成树的边数  </span><br>    ll sum = <span class="hljs-number">0</span>; <span class="hljs-comment">// 最小生成树的总权重  </span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; cnt &lt; n - <span class="hljs-number">1</span>; i++)&#123; <span class="hljs-comment">// 循环直到找到n-1条边  </span><br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isUnion</span>(e[i].x, e[i].y)) <span class="hljs-comment">// 如果两个顶点已经在同一个集合中，跳过这条边  </span><br>            <span class="hljs-keyword">continue</span>;  <br>        cnt++;  <br>        sum += e[i].w;  <br>        <span class="hljs-built_in">Union</span>(e[i].x, e[i].y); <br>    &#125;  <br>    cout &lt;&lt; sum; <span class="hljs-comment">// 输出最小生成树的总权重  </span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;  <br>  <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">makeSet</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123; <span class="hljs-comment">// 初始化并查集，每个顶点自成一个集合  </span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)  <br>        v[i] = i; <span class="hljs-comment">// 初始化顶点i的父节点为自身  </span><br>&#125;  <br>  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123; <span class="hljs-comment">// 查找x所在集合的代表元素，并进行路径压缩  </span><br>    <span class="hljs-keyword">if</span> (v[x] == x)  <span class="hljs-comment">// 如果x是代表元素，直接返回  </span><br>        <span class="hljs-keyword">return</span> x;  <br>    <span class="hljs-keyword">return</span> v[x] = <span class="hljs-built_in">Find</span>(v[x]); <span class="hljs-comment">// 否则递归查找并路径压缩  </span><br>&#125;  <br>  <br><span class="hljs-comment">// 判断两个元素是否在同一个集合中  </span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isUnion</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">Find</span>(x) == <span class="hljs-built_in">Find</span>(y); &#125;  <br><span class="hljs-comment">// 合并两个集合，将y所在集合的代表元素指向x所在集合的代表元素  </span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Union</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123; v[<span class="hljs-built_in">Find</span>(y)] = <span class="hljs-built_in">Find</span>(x); &#125;<br></code></pre></td></tr></table></figure>
<h5 id="傅里叶变换">傅里叶变换</h5>
<p>最高次数为n，次数界可以为n, n+1, n+2, 2n 对于次数界为n的多项式 <span
class="math inline">\(A(x) = \sum\limits_{j=0}^{n-1}a_{j}x^{j}\)</span>
，dft求的是 <span class="math inline">\(y_{k} =
A(\omega_{n}^{k})=\sum\limits_{j=0}^{n-1}a_{j}\omega_{n}^{kj}\)</span>
即 <span class="math inline">\(y = DFT_{n}(a)\)</span> 其中 <span
class="math inline">\(ω=cos\frac{2π}{2^{n}}+i\
sin\frac{2π}{2^{n}}\)</span> ###### 多项式乘法-普通版 时间复杂度 <span
class="math inline">\(\Theta(nlgn)\)</span> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span>  </span><br>  <br><span class="hljs-type">const</span> <span class="hljs-type">double</span> Pi = <span class="hljs-built_in">acos</span>(<span class="hljs-number">-1</span>);  <br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX = <span class="hljs-number">4000005</span>;  <span class="hljs-comment">// 字符串最大长度</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;  <br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;  <br>  <br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Complex</span> &#123;  <br>	<span class="hljs-type">double</span> x, y; <span class="hljs-comment">// 实部和虚部</span><br>	Complex <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> Complex &amp;b) <span class="hljs-type">const</span> &#123;  <br>		<span class="hljs-keyword">return</span> &#123;x + b.x, y + b.y&#125;;  <br>	&#125;  <br>	  <br>	Complex <span class="hljs-keyword">operator</span>-(<span class="hljs-type">const</span> Complex &amp;b) <span class="hljs-type">const</span> &#123;  <br>		<span class="hljs-keyword">return</span> &#123;x - b.x, y - b.y&#125;;  <br>	&#125;  <br>	  <br>	Complex <span class="hljs-keyword">operator</span>*(<span class="hljs-type">const</span> Complex &amp;b) <span class="hljs-type">const</span> &#123;  <br>		<span class="hljs-keyword">return</span> &#123;x * b.x - y * b.y, x * b.y + y * b.x&#125;;  <br>	&#125;  <br>&#125; f[MAX], p[MAX], sav[MAX];  <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dft</span><span class="hljs-params">(Complex *f, <span class="hljs-type">int</span> len)</span></span>;  <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">idft</span><span class="hljs-params">(Complex *f, <span class="hljs-type">int</span> len)</span></span>;  <br>  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;  <br>	<span class="hljs-type">int</span> n, m;  <br>	cin &gt;&gt; n &gt;&gt; m;  <span class="hljs-comment">// 第一个多项式最多n次，第二个最多m次</span><br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++)  <br>		cin &gt;&gt; f[i].x;  <span class="hljs-comment">// 读入第一个多项式的系数</span><br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= m; i++)  <br>		cin &gt;&gt; p[i].x;  <span class="hljs-comment">// 读入第二个多项式的系数</span><br>	<span class="hljs-keyword">for</span> (m += n, n = <span class="hljs-number">1</span>; n &lt;= m; n &lt;&lt;= <span class="hljs-number">1</span>);  <span class="hljs-comment">// 相乘最多n+m位</span><br>	<span class="hljs-built_in">dft</span>(f, n); <span class="hljs-comment">// 对第一个多项式进行DFT</span><br>	<span class="hljs-built_in">dft</span>(p, n); <span class="hljs-comment">// 对第二个多项式进行DFT</span><br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)  <br>		f[i] = f[i] * p[i]; <span class="hljs-comment">// 点乘得到乘积的DFT</span><br>	<span class="hljs-built_in">idft</span>(f, n); <span class="hljs-comment">// 对结果进行逆DFT</span><br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= m; i++)  <br>		cout &lt;&lt; (<span class="hljs-type">int</span>) (f[i].x / n + <span class="hljs-number">0.49</span>) &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;  <span class="hljs-comment">// 四舍五入</span><br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;  <br>  <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dft</span><span class="hljs-params">(Complex *f, <span class="hljs-type">int</span> len)</span> </span>&#123;  <br>	<span class="hljs-keyword">if</span> (len == <span class="hljs-number">1</span>)  <br>		<span class="hljs-keyword">return</span>;  <br>	Complex *fl = f, *fr = f + len / <span class="hljs-number">2</span>; <span class="hljs-comment">// 分治法，将数组分为两部分</span><br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; len; k++)  <br>		sav[k] = f[k]; <span class="hljs-comment">// 备份原数组</span><br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; len / <span class="hljs-number">2</span>; k++) &#123;  <br>		fl[k] = sav[k &lt;&lt; <span class="hljs-number">1</span>]; <span class="hljs-comment">// 分配偶数次的系数到左子数组</span><br>		fr[k] = sav[k &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>]; <span class="hljs-comment">// 分配奇数次的系数到右子数组</span><br>	&#125;  <br>	<span class="hljs-built_in">dft</span>(fl, len / <span class="hljs-number">2</span>);  <br>	<span class="hljs-built_in">dft</span>(fr, len / <span class="hljs-number">2</span>);  <br>	Complex tG = &#123;<span class="hljs-built_in">cos</span>(<span class="hljs-number">2</span> * Pi / len), <span class="hljs-built_in">sin</span>(<span class="hljs-number">2</span> * Pi / len)&#125;;  <span class="hljs-comment">// omega_n单位根</span><br>	Complex buf = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;;  <span class="hljs-comment">// omega初始化旋转因子</span><br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; len / <span class="hljs-number">2</span>; k++) &#123;  <br>		sav[k] = fl[k] + buf * fr[k]; <span class="hljs-comment">// 合并结果</span><br>		sav[k + len / <span class="hljs-number">2</span>] = fl[k] - buf * fr[k];  <br>		buf = buf * tG;  <span class="hljs-comment">// omega = omega*omega_n更新旋转因子</span><br>	&#125;  <br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; len; k++)  <br>		f[k] = sav[k];  <br>&#125;  <br>  <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">idft</span><span class="hljs-params">(Complex *f, <span class="hljs-type">int</span> len)</span> </span>&#123;  <br>	<span class="hljs-keyword">if</span> (len == <span class="hljs-number">1</span>)  <br>		<span class="hljs-keyword">return</span>;  <br>	Complex *fl = f, *fr = f + len / <span class="hljs-number">2</span>;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; len; k++)  <br>		sav[k] = f[k];<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; len / <span class="hljs-number">2</span>; k++) &#123;  <br>		fl[k] = sav[k &lt;&lt; <span class="hljs-number">1</span>];  <br>		fr[k] = sav[k &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>];  <br>	&#125;  <br>	<span class="hljs-built_in">idft</span>(fl, len / <span class="hljs-number">2</span>);  <br>	<span class="hljs-built_in">idft</span>(fr, len / <span class="hljs-number">2</span>);  <br>	Complex tG = &#123;<span class="hljs-built_in">cos</span>(<span class="hljs-number">2</span> * Pi / len), -<span class="hljs-built_in">sin</span>(<span class="hljs-number">2</span> * Pi / len)&#125;; <span class="hljs-comment">// 与dft唯一的区别</span><br>	Complex buf = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;;  <br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; len / <span class="hljs-number">2</span>; k++) &#123;  <br>		sav[k] = fl[k] + buf * fr[k];  <br>		sav[k + len / <span class="hljs-number">2</span>] = fl[k] - buf * fr[k];  <br>		buf = buf * tG;  <br>	&#125;  <br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; len; k++)  <br>		f[k] = sav[k];  <br>&#125;<br></code></pre></td></tr></table></figure></p>
<h6 id="多项式乘法-高效版位逆序版">多项式乘法-高效版/位逆序版</h6>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span>  </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;  <br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">1000000</span> + <span class="hljs-number">7</span>;  <br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PI acos(-1)  </span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Complex</span> &#123;  <br>    <span class="hljs-type">double</span> x, y; <span class="hljs-comment">// 实部和虚部  </span><br>    Complex <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> Complex &amp;b) <span class="hljs-type">const</span> &#123;  <br>        <span class="hljs-keyword">return</span> &#123;x + b.x, y + b.y&#125;;  <br>    &#125;  <br>  <br>    Complex <span class="hljs-keyword">operator</span>-(<span class="hljs-type">const</span> Complex &amp;b) <span class="hljs-type">const</span> &#123;  <br>        <span class="hljs-keyword">return</span> &#123;x - b.x, y - b.y&#125;;  <br>    &#125;  <br>  <br>    Complex <span class="hljs-keyword">operator</span>*(<span class="hljs-type">const</span> Complex &amp;b) <span class="hljs-type">const</span> &#123;  <br>        <span class="hljs-keyword">return</span> &#123;x * b.x - y * b.y, x * b.y + y * b.x&#125;;  <br>    &#125;  <br>&#125;;  <br>  <br><span class="hljs-type">int</span> n,m; <span class="hljs-comment">// 两个多项式的次数  </span><br>Complex a[maxn*<span class="hljs-number">3</span>], b[maxn*<span class="hljs-number">3</span>]; <span class="hljs-comment">// 存储多项式的系数  </span><br><span class="hljs-type">int</span> pos[maxn*<span class="hljs-number">3</span>]; <span class="hljs-comment">// 定义位置数组，用于FFT中的位置交换  </span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">FFT</span><span class="hljs-params">(Complex*A, <span class="hljs-type">int</span> len, <span class="hljs-type">int</span> type)</span></span>;  <br>  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;  <br>    <span class="hljs-type">int</span> x;pos[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;  <br>    <span class="hljs-type">int</span> maxLen = <span class="hljs-number">1</span>, l = <span class="hljs-number">0</span>; <span class="hljs-comment">// maxLen为FFT的长度，l为log2(maxLen)  </span><br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);  <br>    <span class="hljs-keyword">while</span>(maxLen &lt; n+m+<span class="hljs-number">1</span>)&#123;  <br>        maxLen&lt;&lt;=<span class="hljs-number">1</span>;  <br>        l++;  <br>    &#125;  <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;=n;i++)&#123; <span class="hljs-comment">// 第一个多项式的系数  </span><br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lf&quot;</span>,&amp;a[i].x);  <br>    &#125;  <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;=m;i++)&#123; <span class="hljs-comment">// 读取第二个多项式的系数  </span><br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lf&quot;</span>,&amp;b[i].x);  <br>    &#125;  <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;maxLen;i++)&#123; <span class="hljs-comment">// 求最后交换的位置（奇数特殊处理）  </span><br>        pos[i] = (pos[i&gt;&gt;<span class="hljs-number">1</span>]&gt;&gt;<span class="hljs-number">1</span>)|((i&amp;<span class="hljs-number">1</span>)&lt;&lt;(l<span class="hljs-number">-1</span>));  <br>        <span class="hljs-comment">// 计算每个索引i的位逆序位置(将一个数的二进制位顺序颠倒011-&gt;110)  </span><br>        <span class="hljs-comment">// i&gt;&gt;1 将i的二进制位右移一位，即去掉最低位  </span><br>        <span class="hljs-comment">// pos[i&gt;&gt;1]&gt;&gt;1 取i的前面所有位（去掉最低位）的位逆序，然后再右移一位  </span><br>        <span class="hljs-comment">// (i&amp;1)&lt;&lt;(l-1) 取i的最低位，并将其左移到最高位的位置  </span><br>        <span class="hljs-comment">// 通过|操作将两部分合并，得到i的位逆序  </span><br>    &#125;  <br>  <br>    <span class="hljs-built_in">FFT</span>(a,maxLen,<span class="hljs-number">1</span>);  <br>    <span class="hljs-built_in">FFT</span>(b,maxLen,<span class="hljs-number">1</span>);  <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;maxLen;i++)  <br>        a[i] = a[i]*b[i];  <br>  <br>    <span class="hljs-built_in">FFT</span>(a,maxLen,<span class="hljs-number">-1</span>); <span class="hljs-comment">// 对结果进行IDFT  </span><br>  <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;n+m+<span class="hljs-number">1</span>; i++)&#123;  <br>        <span class="hljs-keyword">if</span>(i!=<span class="hljs-number">0</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; &quot;</span>);  <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,(<span class="hljs-type">int</span>)(a[i].x+<span class="hljs-number">0.49</span>));  <br>    &#125;  <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;  <br><span class="hljs-comment">// A为输入数组，len为长度，type为1表示DFT，-1表示IDFT  </span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">FFT</span><span class="hljs-params">(Complex*A, <span class="hljs-type">int</span> len, <span class="hljs-type">int</span> type)</span></span>&#123;  <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;len; i++)&#123;<span class="hljs-comment">//将数组A中的元素按照位逆序的位置进行交换  </span><br>        <span class="hljs-keyword">if</span>(i&lt;pos[i])<span class="hljs-comment">// 如果i已经小于其逆序位置pos[i]，则说明这一对已经交换过  </span><br>            <span class="hljs-built_in">swap</span>(A[i], A[pos[i]]);<span class="hljs-comment">//保证每对只交换一次  </span><br>    &#125;  <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> L=<span class="hljs-number">2</span>; L&lt;=len; L&lt;&lt;=<span class="hljs-number">1</span>)&#123;<span class="hljs-comment">//循环合并的区间长度  </span><br>        <span class="hljs-type">int</span> HLen = L/<span class="hljs-number">2</span>;<span class="hljs-comment">//区间的一半  </span><br>        Complex Wn = &#123;<span class="hljs-built_in">cos</span>(<span class="hljs-number">2.0</span>*PI/L), type*<span class="hljs-built_in">sin</span>(<span class="hljs-number">2.0</span>*PI/L)&#125;; <span class="hljs-comment">// 计算单位根  </span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> R=<span class="hljs-number">0</span>; R&lt;len; R+=L)&#123;<span class="hljs-comment">//每个小区间的起点  </span><br>            Complex w = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;; <span class="hljs-comment">// 初始化旋转因子  </span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>; k&lt;HLen; k++, w=w*Wn)&#123;<span class="hljs-comment">//求该区间下的值  </span><br>                Complex Buf = A[R+k];<span class="hljs-comment">//蝴蝶操作，去掉odd和even数组，使变化原地进行  </span><br>                A[R+k] =  A[R+k] + w*A[R+k+HLen];  <br>                A[R+k+HLen] = Buf - w*A[R+k+HLen];  <br>            &#125;  <br>        &#125;  <br>    &#125;  <br>    <span class="hljs-keyword">if</span> (type == <span class="hljs-number">-1</span>) &#123;  <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;  <br>            A[i].x /= len;  <br>            A[i].y /= len;  <br>        &#125;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 位逆序代码</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span>  </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;  <br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">1000000</span> + <span class="hljs-number">7</span>;  <br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PI acos(-1)  </span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Complex</span> &#123;  <br>    <span class="hljs-type">int</span> x, y; <span class="hljs-comment">// 实部和虚部  </span><br>    Complex <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> Complex &amp;b) <span class="hljs-type">const</span> &#123;  <br>        <span class="hljs-keyword">return</span> &#123;x + b.x, y + b.y&#125;;  <br>    &#125;  <br>    Complex <span class="hljs-keyword">operator</span>-(<span class="hljs-type">const</span> Complex &amp;b) <span class="hljs-type">const</span> &#123;  <br>        <span class="hljs-keyword">return</span> &#123;x - b.x, y - b.y&#125;;  <br>    &#125;  <br>    Complex <span class="hljs-keyword">operator</span>*(<span class="hljs-type">const</span> Complex &amp;b) <span class="hljs-type">const</span> &#123;  <br>        <span class="hljs-keyword">return</span> &#123;x * b.x - y * b.y, x * b.y + y * b.x&#125;;  <br>    &#125;  <br>&#125;;  <br>  <br><span class="hljs-type">int</span> n,m; <span class="hljs-comment">// 两个多项式的次数  </span><br>Complex a[maxn*<span class="hljs-number">3</span>], b[maxn*<span class="hljs-number">3</span>]; <span class="hljs-comment">// 存储多项式的系数  </span><br><span class="hljs-type">int</span> pos[maxn*<span class="hljs-number">3</span>]; <span class="hljs-comment">// 定义位置数组，用于FFT中的位置交换  </span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">FFT</span><span class="hljs-params">(Complex*A, <span class="hljs-type">int</span> len, <span class="hljs-type">int</span> type)</span></span>;  <br>  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;  <br>    <span class="hljs-type">int</span> x;pos[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;  <br>    <span class="hljs-type">int</span> maxLen = <span class="hljs-number">1</span>, l = <span class="hljs-number">0</span>; <span class="hljs-comment">// maxLen为FFT的长度，l为log2(maxLen)  </span><br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);  <br>    <span class="hljs-keyword">while</span>(maxLen &lt; n)&#123;  <br>        maxLen&lt;&lt;=<span class="hljs-number">1</span>;  <br>        l++;  <br>    &#125;  <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;n;i++)&#123; <span class="hljs-comment">// 第一个多项式的系数  </span><br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i].x);  <br>    &#125;  <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;n;i++)&#123; <span class="hljs-comment">// 求最后交换的位置（奇数特殊处理）  </span><br>        pos[i] = (pos[i&gt;&gt;<span class="hljs-number">1</span>]&gt;&gt;<span class="hljs-number">1</span>)|((i&amp;<span class="hljs-number">1</span>)&lt;&lt;(l<span class="hljs-number">-1</span>));  <br>        <span class="hljs-comment">// 计算每个索引i的位逆序位置(将一个数的二进制位顺序颠倒011-&gt;110)  </span><br>        <span class="hljs-comment">// i&gt;&gt;1 将i的二进制位右移一位，即去掉最低位  </span><br>        <span class="hljs-comment">// pos[i&gt;&gt;1]&gt;&gt;1 取i的前面所有位（去掉最低位）的位逆序，然后再右移一位  </span><br>        <span class="hljs-comment">// (i&amp;1)&lt;&lt;(l-1) 取i的最低位，并将其左移到最高位的位置  </span><br>        <span class="hljs-comment">// 通过|操作将两部分合并，得到i的位逆序  </span><br>    &#125;  <br>    <span class="hljs-built_in">FFT</span>(a,maxLen,<span class="hljs-number">1</span>);  <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;n; i++)&#123;  <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, a[i].x);  <br>    &#125;  <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;  <br><span class="hljs-comment">// A为输入数组，len为长度，type为1表示DFT，-1表示IDFT  </span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">FFT</span><span class="hljs-params">(Complex*A, <span class="hljs-type">int</span> len, <span class="hljs-type">int</span> type)</span></span>&#123;  <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;len; i++)&#123;<span class="hljs-comment">//将数组A中的元素按照位逆序的位置进行交换  </span><br>        <span class="hljs-keyword">if</span>(i&lt;pos[i])<span class="hljs-comment">// 如果i已经小于其逆序位置pos[i]，则说明这一对已经交换过  </span><br>            <span class="hljs-built_in">swap</span>(A[i], A[pos[i]]);<span class="hljs-comment">//保证每对只交换一次  </span><br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure>
<h6 id="高精度乘法">高精度乘法</h6>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span>  </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;  <br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">1000000</span> + <span class="hljs-number">7</span>;  <br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PI acos(-1)  </span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Complex</span> &#123;  <br>    <span class="hljs-type">double</span> x, y; <span class="hljs-comment">// 实部和虚部  </span><br>    Complex <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> Complex &amp;b) <span class="hljs-type">const</span> &#123;  <br>        <span class="hljs-keyword">return</span> &#123;x + b.x, y + b.y&#125;;  <br>    &#125;  <br>  <br>    Complex <span class="hljs-keyword">operator</span>-(<span class="hljs-type">const</span> Complex &amp;b) <span class="hljs-type">const</span> &#123;  <br>        <span class="hljs-keyword">return</span> &#123;x - b.x, y - b.y&#125;;  <br>    &#125;  <br>  <br>    Complex <span class="hljs-keyword">operator</span>*(<span class="hljs-type">const</span> Complex &amp;b) <span class="hljs-type">const</span> &#123;  <br>        <span class="hljs-keyword">return</span> &#123;x * b.x - y * b.y, x * b.y + y * b.x&#125;;  <br>    &#125;  <br>&#125;;  <br>  <br><span class="hljs-type">int</span> n,m; <span class="hljs-comment">// 两个多项式的次数  </span><br>Complex a[maxn*<span class="hljs-number">3</span>], b[maxn*<span class="hljs-number">3</span>]; <span class="hljs-comment">// 存储多项式的系数  </span><br><span class="hljs-type">long</span> <span class="hljs-type">long</span> ans[maxn*<span class="hljs-number">3</span>];  <br><span class="hljs-type">int</span> pos[maxn*<span class="hljs-number">3</span>]; <span class="hljs-comment">// 定义位置数组，用于FFT中的位置交换  </span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">FFT</span><span class="hljs-params">(Complex*A, <span class="hljs-type">int</span> len, <span class="hljs-type">int</span> type)</span></span>;  <br>  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;  <br>    <span class="hljs-type">int</span> t;  <br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;t);  <br>    <span class="hljs-keyword">while</span>(t--)&#123;  <br>        <span class="hljs-type">int</span> x;pos[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;  <br>        <span class="hljs-type">int</span> maxLen = <span class="hljs-number">1</span>, l = <span class="hljs-number">0</span>; <span class="hljs-comment">// maxLen为FFT的长度，l为log2(maxLen)  </span><br>        <span class="hljs-type">char</span> str1[maxn], str2[maxn];  <br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot; %s %s&quot;</span>, str1, str2); <span class="hljs-comment">// 读取两个大数  </span><br>        n = <span class="hljs-built_in">strlen</span>(str1);  <br>        m = <span class="hljs-built_in">strlen</span>(str2);  <br>        <span class="hljs-keyword">while</span>(maxLen &lt; n+m+<span class="hljs-number">1</span>)&#123;  <br>            maxLen&lt;&lt;=<span class="hljs-number">1</span>;  <br>            l++;  <br>        &#125;  <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;=maxLen; i++)&#123;  <br>            a[i].y = a[i].x = b[i].y = b[i].x = ans[i] = <span class="hljs-number">0</span>;  <br>        &#125;  <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123; <span class="hljs-comment">// 将第一个大数的字符转换为数字，并倒序存储  </span><br>            a[i].x = str1[n - i - <span class="hljs-number">1</span>] - <span class="hljs-string">&#x27;0&#x27;</span>;  <br>        &#125;  <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;  <br>            b[i].x = str2[m - i - <span class="hljs-number">1</span>] - <span class="hljs-string">&#x27;0&#x27;</span>;  <br>        &#125;  <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;maxLen;i++)&#123; <span class="hljs-comment">// 求最后交换的位置（奇数特殊处理）  </span><br>            pos[i] = (pos[i&gt;&gt;<span class="hljs-number">1</span>]&gt;&gt;<span class="hljs-number">1</span>)|((i&amp;<span class="hljs-number">1</span>)&lt;&lt;(l<span class="hljs-number">-1</span>));  <br>            <span class="hljs-comment">// 计算每个索引i的位逆序位置(将一个数的二进制位顺序颠倒011-&gt;110)  </span><br>            <span class="hljs-comment">// i&gt;&gt;1 将i的二进制位右移一位，即去掉最低位  </span><br>            <span class="hljs-comment">// pos[i&gt;&gt;1]&gt;&gt;1 取i的前面所有位（去掉最低位）的位逆序，然后再右移一位  </span><br>            <span class="hljs-comment">// (i&amp;1)&lt;&lt;(l-1) 取i的最低位，并将其左移到最高位的位置  </span><br>            <span class="hljs-comment">// 通过|操作将两部分合并，得到i的位逆序  </span><br>        &#125;  <br>  <br>        <span class="hljs-built_in">FFT</span>(a,maxLen,<span class="hljs-number">1</span>);  <br>        <span class="hljs-built_in">FFT</span>(b,maxLen,<span class="hljs-number">1</span>);  <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;maxLen;i++)  <br>            a[i] = a[i]*b[i];  <br>        <span class="hljs-built_in">FFT</span>(a,maxLen,<span class="hljs-number">-1</span>); <span class="hljs-comment">// 对结果进行IDFT  </span><br>  <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; maxLen; i++)&#123;  <br>            ans[i] += <span class="hljs-built_in">round</span>(a[i].x);  <br>            ans[i + <span class="hljs-number">1</span>] += ans[i] / <span class="hljs-number">10</span>; <span class="hljs-comment">// 如果是8进制就换成8  </span><br>            ans[i] %= <span class="hljs-number">10</span>; <span class="hljs-comment">// 如果是8进制就换成8  </span><br>        &#125;  <br>        <span class="hljs-type">int</span> t1 = maxLen;  <br>        <span class="hljs-keyword">while</span> (ans[t1] == <span class="hljs-number">0</span> &amp;&amp; t1 &gt; <span class="hljs-number">0</span>)  <br>            t1--; <span class="hljs-comment">// 去除结果数组末尾的零  </span><br>        <span class="hljs-keyword">while</span> (t1 &gt;= <span class="hljs-number">0</span>)  <br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld&quot;</span>, ans[t1--]);  <br>        cout &lt;&lt; endl;  <br>    &#125;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;  <br><span class="hljs-comment">// A为输入数组，len为长度，type为1表示DFT，-1表示IDFT  </span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">FFT</span><span class="hljs-params">(Complex*A, <span class="hljs-type">int</span> len, <span class="hljs-type">int</span> type)</span></span>&#123;  <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;len; i++)&#123;<span class="hljs-comment">//将数组A中的元素按照位逆序的位置进行交换  </span><br>        <span class="hljs-keyword">if</span>(i&lt;pos[i])<span class="hljs-comment">// 如果i已经小于其逆序位置pos[i]，则说明这一对已经交换过  </span><br>            <span class="hljs-built_in">swap</span>(A[i], A[pos[i]]);<span class="hljs-comment">//保证每对只交换一次  </span><br>    &#125;  <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> L=<span class="hljs-number">2</span>; L&lt;=len; L&lt;&lt;=<span class="hljs-number">1</span>)&#123;<span class="hljs-comment">//循环合并的区间长度  </span><br>        <span class="hljs-type">int</span> HLen = L/<span class="hljs-number">2</span>;<span class="hljs-comment">//区间的一半  </span><br>        Complex Wn = &#123;<span class="hljs-built_in">cos</span>(<span class="hljs-number">2.0</span>*PI/L), type*<span class="hljs-built_in">sin</span>(<span class="hljs-number">2.0</span>*PI/L)&#125;; <span class="hljs-comment">// 计算单位根  </span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> R=<span class="hljs-number">0</span>; R&lt;len; R+=L)&#123;<span class="hljs-comment">//每个小区间的起点  </span><br>            Complex w = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;; <span class="hljs-comment">// 初始化旋转因子  </span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>; k&lt;HLen; k++, w=w*Wn)&#123;<span class="hljs-comment">//求该区间下的值  </span><br>                Complex Buf = A[R+k];<span class="hljs-comment">//蝴蝶操作，去掉odd和even数组，使变化原地进行  </span><br>                A[R+k] =  A[R+k] + w*A[R+k+HLen];  <br>                A[R+k+HLen] = Buf - w*A[R+k+HLen];  <br>            &#125;  <br>        &#125;  <br>    &#125;  <br>    <span class="hljs-keyword">if</span> (type == <span class="hljs-number">-1</span>) &#123; <span class="hljs-comment">// 归一化  </span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;  <br>            A[i].x /= len;  <br>            A[i].y /= len;  <br>        &#125;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="最大公约数欧几里得算法">最大公约数：欧几里得算法</h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">euclid</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span>&#123;<br>	<span class="hljs-keyword">if</span>(b == <span class="hljs-number">0</span>)&#123;<br>		<span class="hljs-keyword">return</span> a;<br>	&#125;<span class="hljs-keyword">else</span>&#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-built_in">euclid</span>(b, a%b);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="欧几里得算法的扩展形式">欧几里得算法的扩展形式</h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 法1</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span>  </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> d, x, y;  <br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">extendedEuclid</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span>&#123;  <br>    <span class="hljs-keyword">if</span>(b == <span class="hljs-number">0</span>)&#123;  <br>        d = a, x = <span class="hljs-number">1</span>, y = <span class="hljs-number">0</span>;  <br>    &#125;<span class="hljs-keyword">else</span>&#123;  <br>        <span class="hljs-built_in">extendedEuclid</span>(b, a%b);  <br>        <span class="hljs-type">int</span> tempX = x;  <br>        x = y, y = tempX-(<span class="hljs-type">int</span>)<span class="hljs-built_in">floor</span>(a/b)*y;  <br>    &#125;  <br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;  <br>    <span class="hljs-type">int</span> a, b;  <br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);  <br>    <span class="hljs-built_in">extendedEuclid</span>(a, b);  <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d = gcd(%d, %d) = %d*%d+%d*%d&quot;</span>, d, a, b, a, x, b, y);  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="同余方程-ax-b-mod-m">同余方程 <span class="math inline">\(ax ≡ b
(mod\ m)\)</span></h5>
<p><span class="math inline">\(ax ≡ b (mod\ m)\)</span> 即 <span
class="math inline">\(ax - b = km\)</span> 1.
<strong>通解形式</strong>：线性同余方程 <code>ax ≡ b (mod m)</code>
的通解可以表示为 <code>x = x0 + km/d</code>，其中 <code>x0</code>
是一个特解，<code>k</code> 是任意整数，<code>d = gcd(a, m)</code>。 2.
<strong>遍历所有解</strong>：解的周期性为
<code>d</code>，我们可以通过遍历 <code>k</code> 从 <code>0</code> 到
<code>d-1</code> 来找到所有可能的解。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 计算同余方程的所有解  </span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> a,<span class="hljs-type">long</span> <span class="hljs-type">long</span> b,<span class="hljs-type">long</span> <span class="hljs-type">long</span> m)</span></span>&#123;  <br>    <span class="hljs-built_in">extendedEuclid</span>(a,m);  <br>    <span class="hljs-keyword">if</span>(b%d) <span class="hljs-comment">// 同余方程有解的前提是b是d（a和m的最大公约数的倍数）  </span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<span class="hljs-comment">//无解  </span><br>    x=x*(b/d)%m; <span class="hljs-comment">// 一个特解  </span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=d; i++)&#123; <span class="hljs-comment">// 遍历所有解的可能  </span><br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> tempAns = (x+(i<span class="hljs-number">-1</span>)*m/d)%m;  <br>        <span class="hljs-keyword">while</span>(tempAns&lt;<span class="hljs-number">0</span>)&#123; <span class="hljs-comment">// 确保解为正数  </span><br>            tempAns += m;  <br>        &#125;  <br>        <span class="hljs-keyword">if</span>(tempAns &lt; ans)&#123; <span class="hljs-comment">// 更新解为最小的解  </span><br>            ans = tempAns;  <br>        &#125;  <br>    &#125;  <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld&quot;</span>, ans);  <br>&#125;<br></code></pre></td></tr></table></figure></p>
<h5 id="字符串匹配">字符串匹配</h5>
<h6 id="rabin-karp算法-双哈希">Rabin-Karp算法 双哈希</h6>
<p>预处理时间 <span
class="math inline">\(\Theta(m)\)</span>，最坏运行时间 <span
class="math inline">\(\Theta((n-m+1)m)\)</span>，期望运行时间 <span
class="math inline">\(O(n)+O(m(v+\frac{n}{q}))\)</span>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span>  </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;  <br>  <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Rabin_Karp_search</span><span class="hljs-params">(<span class="hljs-type">const</span> string &amp;T, <span class="hljs-type">const</span> string &amp;P, <span class="hljs-type">int</span> d, <span class="hljs-type">int</span> q1, <span class="hljs-type">int</span> q2)</span></span>;  <br>  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;  <br>    string T = <span class="hljs-string">&quot;Rabin–Karp string search algorithm: Rabin-Karp&quot;</span>;  <span class="hljs-comment">// 文本字符串  </span><br>    string P = <span class="hljs-string">&quot;Rabin&quot;</span>;  <span class="hljs-comment">// 模式字符串  </span><br>    <span class="hljs-type">int</span> q1 = <span class="hljs-number">101</span>; <span class="hljs-comment">// 第一个质数，用于取模运算  </span><br>    <span class="hljs-type">int</span> q2 = <span class="hljs-number">103</span>; <span class="hljs-comment">// 第二个质数，用于取模运算  </span><br>    <span class="hljs-type">int</span> d = <span class="hljs-number">52</span>; <span class="hljs-comment">// a到z 大小写  </span><br>    <span class="hljs-built_in">Rabin_Karp_search</span>(T, P, d, q1, q2);  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;  <br>  <br><span class="hljs-comment">// T文本字符串 P模式字符串 字符集的大小 两个用于取模运算的质数  </span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Rabin_Karp_search</span><span class="hljs-params">(<span class="hljs-type">const</span> string &amp;T, <span class="hljs-type">const</span> string &amp;P, <span class="hljs-type">int</span> d, <span class="hljs-type">int</span> q1, <span class="hljs-type">int</span> q2)</span></span>&#123;  <br>    <span class="hljs-type">int</span> m = P.<span class="hljs-built_in">length</span>(); <span class="hljs-comment">// 模式字符串的长度  </span><br>    <span class="hljs-type">int</span> n = T.<span class="hljs-built_in">length</span>(); <span class="hljs-comment">// 文本字符串的长度  </span><br>    <span class="hljs-type">int</span> i, j;  <br>    <span class="hljs-type">int</span> p1 = <span class="hljs-number">0</span>, p2 = <span class="hljs-number">0</span>; <span class="hljs-comment">// 模式字符串的双哈希值  </span><br>    <span class="hljs-type">int</span> t1 = <span class="hljs-number">0</span>, t2 = <span class="hljs-number">0</span>; <span class="hljs-comment">// 文本字符串的双哈希值  </span><br>    <span class="hljs-type">int</span> h1 = <span class="hljs-number">1</span>, h2 = <span class="hljs-number">1</span>; <span class="hljs-comment">// 用于计算哈希值的基数  </span><br>  <br>    <span class="hljs-comment">// h的值将是&quot;d的(m-1)次方对q取模&quot;  </span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; m<span class="hljs-number">-1</span>; i++)&#123;  <br>        h1 = (h1*d)%q1;  <br>        h2 = (h2*d)%q2;  <br>    &#125;  <br>    <span class="hljs-comment">// 计算模式字符串和文本字符串第一个窗口的总哈希值  </span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;  <br>        p1 = (d*p1 + P[i])%q1;  <br>        p2 = (d*p2 + P[i])%q2;  <br>        t1 = (d*t1 + T[i])%q1;  <br>        t2 = (d*t2 + T[i])%q2;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">// 逐个将模式字符串在文本字符串上滑动  </span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt;= n - m; i++) &#123;  <br>        <span class="hljs-comment">// 检查当前窗口的文本字符串和模式字符串的双哈希值  </span><br>        <span class="hljs-comment">// 如果双哈希值匹配，则逐个字符检查  </span><br>        <span class="hljs-keyword">if</span> ( p1 == t1 &amp;&amp; p2 == t2 ) &#123;  <br>            <span class="hljs-comment">/* 逐个字符检查 */</span>            <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; m; j++)  <br>                <span class="hljs-keyword">if</span> (T[i+j] != P[j])  <br>                    <span class="hljs-keyword">break</span>;  <br>            <span class="hljs-keyword">if</span> (j == m) <span class="hljs-comment">// 如果哈希值匹配且字符也完全匹配  </span><br>                cout&lt;&lt;<span class="hljs-string">&quot;Pattern found at index :&quot;</span>&lt;&lt;i&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;  <br>        &#125;  <br>  <br>        <span class="hljs-comment">// 为下一个窗口的文本字符串计算哈希值：移除首位数字，添加末位数字  </span><br>        <span class="hljs-keyword">if</span> ( i &lt; n-m )&#123;  <br>            t1 = (d*(t1 - T[i]*h1) + T[i+m])%q1;  <br>            t2 = (d*(t2 - T[i]*h2) + T[i+m])%q2;  <br>            <span class="hljs-comment">// 如果t为负值，则将其转换为正值  </span><br>            <span class="hljs-keyword">if</span>(t1 &lt; <span class="hljs-number">0</span>)  <br>                t1 = (t1 + q1);  <br>            <span class="hljs-keyword">if</span>(t2 &lt; <span class="hljs-number">0</span>)  <br>                t2 = (t2 + q2);  <br>        &#125;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure></p>
<h6 id="字符匹配有限自动机">字符匹配有限自动机</h6>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span>  </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;  <br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> total_chars 256 <span class="hljs-comment">// 字符集的总数，通常是256（ASCII字符集大小）  </span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> trans_func(i, j) (trans_func[(i) * (m+1) + (j)])</span><br><span class="hljs-comment">// 定义转换函数的宏，用于访问转换表  </span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">transition</span><span class="hljs-params">(<span class="hljs-type">int</span>* trans_func, string &amp;pattern)</span></span>;  <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">FSA</span><span class="hljs-params">(string &amp;pattern, string &amp;text)</span></span>;  <br>  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;  <br>    string pattern = <span class="hljs-string">&quot;abc&quot;</span>; <span class="hljs-comment">// 模式字符串  </span><br>    string text = <span class="hljs-string">&quot;abcabcdefghabc&quot;</span>; <span class="hljs-comment">// 文本字符串  </span><br>    <span class="hljs-built_in">FSA</span>(pattern, text);  <br>&#125;  <br>  <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">FSA</span><span class="hljs-params">(string &amp;pattern, string &amp;text)</span> </span>&#123;  <br>    <span class="hljs-type">int</span> m = pattern.<span class="hljs-built_in">length</span>();  <br>    <span class="hljs-type">int</span> n = text.<span class="hljs-built_in">length</span>();  <br>    <span class="hljs-type">int</span>* trans_func = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[total_chars * m]; <span class="hljs-comment">// 分配转换表的空间  </span><br>    <span class="hljs-built_in">transition</span>(trans_func, pattern); <span class="hljs-comment">// 构建转换表  </span><br>    <span class="hljs-type">int</span> q = <span class="hljs-number">0</span>; <span class="hljs-comment">// 状态机的当前状态  </span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;  <br>        q = <span class="hljs-built_in">trans_func</span>(text[i], q); <span class="hljs-comment">// 根据当前字符和状态更新状态  </span><br>        <span class="hljs-keyword">if</span> (q == m) &#123; <span class="hljs-comment">// 如果达到最终状态（模式匹配成功）  </span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Pattern found at index :%d &quot;</span>, i-m+<span class="hljs-number">1</span>);  <br>            q = <span class="hljs-number">0</span>; <span class="hljs-comment">// 重置状态  </span><br>        &#125;  <br>    &#125;  <br>    <span class="hljs-comment">// 输出一个表格，i,j表示如果第j个字符是i，会匹配跳转到哪里  </span><br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> ans = <span class="hljs-number">0</span>;  <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;total_chars; j++)&#123;  <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = (m+<span class="hljs-number">1</span>)*j+<span class="hljs-number">0</span>; i &lt; (m+<span class="hljs-number">1</span>)*j+m+<span class="hljs-number">1</span>; i++) &#123;  <br><span class="hljs-comment">//            printf(&quot;%d &quot;, trans_func[i]);  </span><br>            ans += trans_func[i];  <br>        &#125;  <br><span class="hljs-comment">//        puts(&quot;&quot;);  </span><br>    &#125;  <br><span class="hljs-comment">//    printf(&quot;%lld&quot;, ans);  </span><br>&#125;  <br>  <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">transition</span><span class="hljs-params">(<span class="hljs-type">int</span>* trans_func, string &amp;pattern)</span> </span>&#123;  <br>    <span class="hljs-type">int</span> m = pattern.<span class="hljs-built_in">length</span>();  <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; total_chars; i++) &#123; <span class="hljs-comment">// 初始化转换表的第一列  </span><br>        <span class="hljs-keyword">if</span> (i == pattern[<span class="hljs-number">0</span>]) &#123; <span class="hljs-comment">// 如果字符匹配模式的第一个字符  </span><br>            <span class="hljs-built_in">trans_func</span>(i, <span class="hljs-number">0</span>) = <span class="hljs-number">1</span>;  <br>        &#125; <span class="hljs-keyword">else</span> &#123;  <br>            <span class="hljs-built_in">trans_func</span>(i, <span class="hljs-number">0</span>) = <span class="hljs-number">0</span>;  <br>        &#125;  <br>    &#125;  <br>    <span class="hljs-type">int</span> X = <span class="hljs-number">0</span>; <span class="hljs-comment">// 失败函数，记录了pattern的前j个字符中最长相同前后缀  </span><br>    <span class="hljs-comment">// 例如，对于模式字符串&quot;ABABAC&quot;，其部分匹配表为[0, 0, 1, 2, 3, 0]。  </span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; m; j++) &#123; <span class="hljs-comment">// 构建转换表的其余部分  </span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; total_chars; i++) &#123;  <br>            <span class="hljs-keyword">if</span> (pattern[j] == i) &#123; <span class="hljs-comment">// 如果字符匹配模式的当前字符  </span><br>                <span class="hljs-built_in">trans_func</span>(i, j) = j + <span class="hljs-number">1</span>; <span class="hljs-comment">// 状态转移到下一个  </span><br>            &#125; <span class="hljs-keyword">else</span> &#123;  <br>                <span class="hljs-built_in">trans_func</span>(i, j) = <span class="hljs-built_in">trans_func</span>(i, X);  <br>            &#125;  <br>        &#125;  <br>        X = <span class="hljs-built_in">trans_func</span>(pattern[j], X);  <br>    &#125;  <br>    <span class="hljs-comment">// 转换表的最后一列  </span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; total_chars; i++) &#123;  <br>        <span class="hljs-keyword">if</span> (pattern[X] == i) &#123;  <br>            <span class="hljs-built_in">trans_func</span>(i, m) = X + <span class="hljs-number">1</span>;  <br>        &#125; <span class="hljs-keyword">else</span> &#123;  <br>            <span class="hljs-built_in">trans_func</span>(i, m) = <span class="hljs-built_in">trans_func</span>(i, X);  <br>        &#125;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure>
<h6 id="kmp算法">KMP算法</h6>
<p>时间复杂度 <span class="math inline">\(O(m+n)\)</span>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span>  </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;  <br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">prefix</span><span class="hljs-params">(string str)</span></span>;  <br>  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;  <br>    string text;  <br>    string key;  <br>    cin &gt;&gt; text; <span class="hljs-comment">// 文本字符串  </span><br>    cin &gt;&gt; key;  <span class="hljs-comment">// 模式字符串  </span><br>    <span class="hljs-type">int</span> kl = key.<span class="hljs-built_in">length</span>();  <br>    vector&lt;<span class="hljs-type">int</span>&gt; kmp = <span class="hljs-built_in">prefix</span>(key); <span class="hljs-comment">// 计算模式字符串的KMP前缀表即π</span><br>    <span class="hljs-type">int</span> k = <span class="hljs-number">0</span>;  <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; text.<span class="hljs-built_in">length</span>(); i++)&#123;  <br>        <span class="hljs-comment">// 当匹配长度大于0且当前字符不匹配时，回退到前缀表的相应位置  </span><br>        <span class="hljs-keyword">while</span> (k &amp;&amp; key[k] != text[i])  <br>            k = kmp[k - <span class="hljs-number">1</span>];  <br>        <span class="hljs-comment">// 如果当前字符匹配，增加匹配长度  </span><br>        <span class="hljs-keyword">if</span>(text[i] == key[k])  <br>            k++;  <br>        <span class="hljs-comment">// 如果匹配长度等于模式字符串的长度，输出匹配的位置  </span><br>        <span class="hljs-keyword">if</span>(k == kl)  <br>            cout &lt;&lt; i - k + <span class="hljs-number">2</span> &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;  <br>    &#125;  <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> x: kmp) <span class="hljs-comment">// 输出KMP前缀表即π的每个值  </span><br>        cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;  <br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">prefix</span><span class="hljs-params">(string str)</span></span>&#123;  <br>    <span class="hljs-type">int</span> l = (<span class="hljs-type">int</span>) str.<span class="hljs-built_in">length</span>();  <br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">pre</span><span class="hljs-params">(l)</span></span>; <span class="hljs-comment">// 创建一个长度为l的向量来存储前缀表  </span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; l; i++)&#123;  <br>        <span class="hljs-type">int</span> j = pre[i - <span class="hljs-number">1</span>];     <span class="hljs-comment">// i-1的最大的前缀==后缀  </span><br>        <span class="hljs-comment">// 如果 j&gt;0(防止死循环) 且当前字符与前缀的最后一个字符不匹配时，回退j的值  </span><br>        <span class="hljs-keyword">while</span> (j &amp;&amp; str[j] != str[i])  <br>            j = pre[j - <span class="hljs-number">1</span>];     <span class="hljs-comment">// ababaababab  </span><br>        <span class="hljs-keyword">if</span>(str[j] == str[i]) <span class="hljs-comment">// 如果当前字符与前缀的最后一个字符匹配，增加j的值  </span><br>            j++;  <br>        pre[i] = j; <span class="hljs-comment">// 设置当前字符的前缀表值  </span><br>    &#125;  <br>    <span class="hljs-keyword">return</span> pre;  <br>&#125;<br></code></pre></td></tr></table></figure></p>
<h5
id="确定连续线段是向左转还是向右转">确定连续线段是向左转还是向右转</h5>
<p>已知 <span class="math inline">\(\overrightarrow{p_{0}p_{1}},
\overrightarrow{p_{1}p_{2}}\)</span> 。计算 <span
class="math inline">\((p_{2}-p_{0})\times(p_{1}-p_{0}) =
(x_{2}-x_{0})(y_{1}-y_{0})-(y_{2}-y_{0})(x_{1}-x_{0})\)</span> + 结果
<span class="math inline">\(&lt;0\)</span> ，则在 <span
class="math inline">\(p_{1}\)</span> 左转 + 结果 <span
class="math inline">\(&gt;0\)</span> ，则在 <span
class="math inline">\(p_{1}\)</span> 右转 + 结果 <span
class="math inline">\(=0\)</span> ，则在 <span
class="math inline">\(p_{0}, p_{1}, p_{2}\)</span> 三者共线
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">dot</span>&#123;  <br>    <span class="hljs-type">int</span> x, y;  <br>&#125;;  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">direction</span><span class="hljs-params">(dot pi, dot pj, dot pk)</span></span>&#123;  <br>    <span class="hljs-comment">// 计算向量pi-pj和向量pk-pj的叉积，用于判断方向  </span><br>    <span class="hljs-comment">// 如果&lt;0，则pipj pjpk在pj左转  </span><br>    <span class="hljs-comment">// 如果&gt;0，则pipj pjpk在pj右转  </span><br>    <span class="hljs-comment">// 否则三者共线  </span><br>    <span class="hljs-keyword">return</span> ((pk.x-pi.x)*(pj.y-pi.y)-(pk.y-pi.y)*(pj.x-pi.x));  <br>&#125;<br></code></pre></td></tr></table></figure> ##### 判定两条线是否相交 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">dot</span>&#123;  <br>    <span class="hljs-type">int</span> x, y;  <br>&#125;;  <br><span class="hljs-comment">// 计算向量pi-pj和向量pk-pj的叉积，用于判断方向  </span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">direction</span><span class="hljs-params">(dot pi, dot pj, dot pk)</span></span>&#123;  <br>    <span class="hljs-keyword">return</span> ((pk.x-pi.x)*(pj.y-pi.y)-(pk.y-pi.y)*(pj.x-pi.x));  <br>&#125;  <br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">onSegment</span><span class="hljs-params">(dot pi, dot pj, dot pk)</span></span>&#123; <span class="hljs-comment">// 判断点pk是否在线段pi-pj上  </span><br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">min</span>(pi.x, pj.x) &lt;= pk.x &amp;&amp; <span class="hljs-built_in">max</span>(pi.x, pj.x) &gt;= pk.x &amp;&amp;  <br>            <span class="hljs-comment">// 判断pk的x坐标是否在pi和pj的x坐标之间  </span><br>            <span class="hljs-built_in">min</span>(pi.y, pj.y) &lt;= pk.y &amp;&amp; <span class="hljs-built_in">max</span>(pi.y, pj.y) &gt;= pk.y)&#123;  <br>            <span class="hljs-comment">// 判断pk的y坐标是否在pi和pj的y坐标之间  </span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <br>    &#125;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <br>&#125;  <br><span class="hljs-comment">//线段p1p2与p3p4是否相交  </span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">segmentsIntersect</span><span class="hljs-params">(dot p1, dot p2, dot p3, dot p4)</span></span>&#123;  <br>    <span class="hljs-type">int</span> d1 = <span class="hljs-built_in">direction</span>(p3, p4, p1);  <br>    <span class="hljs-type">int</span> d2 = <span class="hljs-built_in">direction</span>(p3, p4, p2);  <br>    <span class="hljs-type">int</span> d3 = <span class="hljs-built_in">direction</span>(p1, p2, p3);  <br>    <span class="hljs-type">int</span> d4 = <span class="hljs-built_in">direction</span>(p1, p2, p4);  <br>    <span class="hljs-keyword">if</span>(((d1&gt;<span class="hljs-number">0</span> &amp;&amp; d2&lt;<span class="hljs-number">0</span>)||(d1&lt;<span class="hljs-number">0</span> &amp;&amp; d2&gt;<span class="hljs-number">0</span>)) &amp;&amp; ((d3&gt;<span class="hljs-number">0</span> &amp;&amp; d4&lt;<span class="hljs-number">0</span>)||(d3&lt;<span class="hljs-number">0</span> &amp;&amp; d4&gt;<span class="hljs-number">0</span>)))&#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 如果两线段在彼此的两侧，则相交  </span><br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(d1 == <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-built_in">onSegment</span>(p3, p4, p1))&#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 如果p1在p3p4上  </span><br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(d2 == <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-built_in">onSegment</span>(p3, p4, p2))&#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 如果p2在p3p4上  </span><br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(d3 == <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-built_in">onSegment</span>(p1, p2, p3))&#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 如果p3在p1p2上  </span><br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(d4 == <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-built_in">onSegment</span>(p1, p2, p4))&#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 如果p4在p1p2上  </span><br>    &#125;<span class="hljs-keyword">else</span>&#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure></p>
<h5 id="确定任意一对线段是否相交">确定任意一对线段是否相交</h5>
<p><span class="math inline">\(O(n^2)\)</span> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span>  </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;  <br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Point</span> &#123;  <br>    <span class="hljs-type">int</span> x, y;  <br>    Point <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> Point &amp;b) <span class="hljs-type">const</span> &#123;  <br>        <span class="hljs-keyword">return</span> &#123;x + b.x, y + b.y&#125;;  <br>    &#125;  <br>    Point <span class="hljs-keyword">operator</span>-(<span class="hljs-type">const</span> Point &amp;b) <span class="hljs-type">const</span> &#123;  <br>        <span class="hljs-keyword">return</span> &#123;x - b.x, y - b.y&#125;;  <br>    &#125;  <br>    <span class="hljs-comment">// 重载乘法运算符，用于点与整数相乘  </span><br>    Point <span class="hljs-keyword">operator</span>*(<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;b) <span class="hljs-type">const</span> &#123;  <br>        <span class="hljs-keyword">return</span> &#123;x * b, y * b&#125;;  <br>    &#125;  <br>    <span class="hljs-comment">// 重载异或运算符，用于计算两个向量的叉积  </span><br>    <span class="hljs-type">int</span> <span class="hljs-keyword">operator</span>^(<span class="hljs-type">const</span> Point &amp;b) <span class="hljs-type">const</span> &#123;  <br>        <span class="hljs-keyword">return</span> x * b.y - y * b.x;  <br>    &#125;  <br>&#125;;  <br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Line</span> &#123; <span class="hljs-comment">// 定义线段结构体  </span><br>    Point p; <span class="hljs-comment">// 线段的起点  </span><br>    Point q; <span class="hljs-comment">// 线段的终点  </span><br>&#125;;  <br>vector&lt;Line&gt; lines;  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sgn</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>;  <br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">intersect</span><span class="hljs-params">(Line l1, Line l2)</span></span>;  <br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">onSegment</span><span class="hljs-params">(Point point, Line line)</span></span>;  <br>  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;  <br>    <span class="hljs-type">int</span> n, cnt = <span class="hljs-number">0</span>;  <br>    cin &gt;&gt; n; <span class="hljs-comment">// 线段数量  </span><br>    <span class="hljs-type">int</span> x1, y1, x2, y2;  <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;  <br>        cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2;  <br>        lines.<span class="hljs-built_in">push_back</span>(&#123;&#123;x1, y1&#125;, &#123;x2, y2&#125;&#125;); <span class="hljs-comment">// 将线段添加到数组中  </span><br>    &#125;  <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) <span class="hljs-comment">// 双重循环遍历所有线段对，判断是否相交  </span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++)  <br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">intersect</span>(lines[i], lines[j]))  <br>                cnt++; <span class="hljs-comment">// 如果相交，则计数器加一  </span><br>    cout &lt;&lt; cnt; <span class="hljs-comment">// 输出相交线段对数  </span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;  <br>  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sgn</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;  <br>    <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;  <br>    <span class="hljs-keyword">if</span> (x &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;  <br>  <br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">intersect</span><span class="hljs-params">(Line l1, Line l2)</span> </span>&#123;  <br>    <span class="hljs-type">int</span> d1 = <span class="hljs-built_in">sgn</span>((l1.q - l1.p) ^ (l2.p - l1.p));  <br>    <span class="hljs-type">int</span> d2 = <span class="hljs-built_in">sgn</span>((l1.q - l1.p) ^ (l2.q - l1.p));  <br>    <span class="hljs-type">int</span> d3 = <span class="hljs-built_in">sgn</span>((l2.q - l2.p) ^ (l1.p - l2.p));  <br>    <span class="hljs-type">int</span> d4 = <span class="hljs-built_in">sgn</span>((l2.q - l2.p) ^ (l1.q - l2.p));  <br>    <span class="hljs-comment">// 如果两线段在彼此的两侧，则相交  </span><br>    <span class="hljs-keyword">if</span> (d1 * d2 &lt; <span class="hljs-number">0</span> &amp;&amp; d3 * d4 &lt; <span class="hljs-number">0</span>)  <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <br>    <span class="hljs-comment">// 其中一个端点在另一条线段上，也视为相交  </span><br>    <span class="hljs-keyword">if</span> (d1 == <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-built_in">onSegment</span>(l2.p, l1))  <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <br>    <span class="hljs-keyword">if</span> (d2 == <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-built_in">onSegment</span>(l2.q, l1))  <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <br>    <span class="hljs-keyword">if</span> (d3 == <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-built_in">onSegment</span>(l1.p, l2))  <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <br>    <span class="hljs-keyword">if</span> (d4 == <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-built_in">onSegment</span>(l1.q, l2))  <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <br>&#125;  <br>  <br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">onSegment</span><span class="hljs-params">(Point point, Line line)</span> </span>&#123; <span class="hljs-comment">// 判断点是否在线段上  </span><br>    <span class="hljs-keyword">if</span> (point.x &gt;= <span class="hljs-built_in">min</span>(line.p.x, line.q.x) &amp;&amp;  <br>        point.x &lt;= <span class="hljs-built_in">max</span>(line.p.x, line.q.x) &amp;&amp;  <br>        point.y &gt;= <span class="hljs-built_in">min</span>(line.p.y, line.q.y) &amp;&amp;  <br>        point.y &lt;= <span class="hljs-built_in">max</span>(line.p.y, line.q.y))  <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <br>&#125;<br></code></pre></td></tr></table></figure></p>
<h5 id="寻找凸包graham扫描法">寻找凸包(Graham扫描法)</h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span>  </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;  <br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX = <span class="hljs-number">200005</span>;  <br><span class="hljs-type">const</span> <span class="hljs-type">double</span> eps = <span class="hljs-number">1e-7</span>;  <br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Point</span> &#123;  <br>    <span class="hljs-type">double</span> x, y;  <br>    Point <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> Point &amp;b) <span class="hljs-type">const</span> &#123;  <br>        <span class="hljs-keyword">return</span> &#123;x + b.x, y + b.y&#125;;  <br>    &#125;  <br>    Point <span class="hljs-keyword">operator</span>-(<span class="hljs-type">const</span> Point &amp;b) <span class="hljs-type">const</span> &#123;  <br>        <span class="hljs-keyword">return</span> &#123;x - b.x, y - b.y&#125;;  <br>    &#125;  <br>    <span class="hljs-comment">// 重载异或运算符，用于计算两个向量的叉积  </span><br>    <span class="hljs-type">double</span> <span class="hljs-keyword">operator</span>^(<span class="hljs-type">const</span> Point &amp;b) <span class="hljs-type">const</span> &#123;  <br>        <span class="hljs-keyword">return</span> x * b.y - y * b.x;  <br>    &#125;  <br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> Point &amp;b) <span class="hljs-type">const</span> &#123;  <br>        <span class="hljs-keyword">if</span> (x != b.x)  <br>            <span class="hljs-keyword">return</span> x &lt; b.x;  <br>        <span class="hljs-keyword">return</span> y &lt; b.y;  <br>    &#125;  <br>&#125;;  <br>Point p[MAX]; <span class="hljs-comment">// 存储所有点的数组  </span><br>Point s[MAX]; <span class="hljs-comment">// 用于构建凸包的栈  </span><br><span class="hljs-type">int</span> top; <span class="hljs-comment">// 栈顶指针  </span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">selMin</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>;  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">cmp</span><span class="hljs-params">(Point a, Point b)</span></span>;  <br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">equal</span><span class="hljs-params">(<span class="hljs-type">double</span> a, <span class="hljs-type">double</span> b)</span></span>;  <br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">dis</span><span class="hljs-params">(Point a, Point b)</span></span>;  <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">graham</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>;  <br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">s_sqr</span><span class="hljs-params">(Point a, Point b, Point c)</span></span>;  <br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">diameter</span><span class="hljs-params">()</span></span>;  <br>  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;  <br>    <span class="hljs-type">int</span> n;  <br>    cin &gt;&gt; n; <span class="hljs-comment">// 点的数量  </span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)  <br>        cin &gt;&gt; p[i].x &gt;&gt; p[i].y; <span class="hljs-comment">// 每个点的坐标  </span><br>    <span class="hljs-built_in">selMin</span>(n); <span class="hljs-comment">// 选择最小的点作为起点  </span><br>    <span class="hljs-built_in">sort</span>(p + <span class="hljs-number">1</span>, p + n, cmp); <span class="hljs-comment">// 根据极角排序  </span><br>    <span class="hljs-built_in">graham</span>(n); <span class="hljs-comment">// 执行Graham扫描算法构建凸包，凸包中的点在数组s中  </span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.6f&quot;</span>, <span class="hljs-built_in">sqrt</span>(<span class="hljs-built_in">diameter</span>())) ; <span class="hljs-comment">// 输出凸包的直径（开方后）  </span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;  <br>  <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">selMin</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;  <br>    Point Min = p[<span class="hljs-number">0</span>]; <span class="hljs-comment">// 初始化最小点  </span><br>    <span class="hljs-type">int</span> IDMin = <span class="hljs-number">0</span>; <span class="hljs-comment">// 最小点的索引  </span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)  <br>        <span class="hljs-keyword">if</span> (p[i] &lt; Min) &#123; <span class="hljs-comment">// 如果找到更小的点  </span><br>            Min = p[i];  <br>            IDMin = i;  <br>        &#125;  <br>    <span class="hljs-built_in">swap</span>(p[<span class="hljs-number">0</span>], p[IDMin]); <span class="hljs-comment">// 将最小点交换到数组第一个位置  </span><br>&#125;  <br>  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">cmp</span><span class="hljs-params">(Point a, Point b)</span> </span>&#123;  <br>    <span class="hljs-type">double</span> x = (a - p[<span class="hljs-number">0</span>]) ^ (b - p[<span class="hljs-number">0</span>]); <span class="hljs-comment">// 计算相对于起点的叉积  </span><br>    <span class="hljs-keyword">if</span> (x &gt; <span class="hljs-number">0</span>) <span class="hljs-comment">// 点a的极角大于点b的极角  </span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;  <br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">equal</span>(x, <span class="hljs-number">0</span>) &amp;&amp; (<span class="hljs-built_in">dis</span>(a, p[<span class="hljs-number">0</span>]) &lt; <span class="hljs-built_in">dis</span>(b, p[<span class="hljs-number">0</span>])))  <br>        <span class="hljs-comment">// 如点a和点b具有相同的极角且a离起点更近  </span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;  <br>  <br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">dis</span><span class="hljs-params">(Point a, Point b)</span> </span>&#123; <span class="hljs-comment">// 计算点a到点b距离  </span><br>    <span class="hljs-type">double</span> x = a.x - b.x;  <br>    <span class="hljs-type">double</span> y = a.y - b.y;  <br>    <span class="hljs-keyword">return</span> x * x + y * y;  <br>&#125;  <br>  <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">graham</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;    <span class="hljs-comment">// n点的个数  </span><br>    top = <span class="hljs-number">1</span>; <span class="hljs-comment">// 初始化栈顶指针  </span><br>    s[<span class="hljs-number">0</span>] = p[<span class="hljs-number">0</span>]; <span class="hljs-comment">// 起点入栈  </span><br>    s[<span class="hljs-number">1</span>] = p[<span class="hljs-number">1</span>]; <span class="hljs-comment">// 第二个点入栈  </span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt; n; i++) &#123;  <br>        <span class="hljs-comment">// 如果当前点与栈顶两个点构成的向量方向不是逆时针，则栈顶点出栈  </span><br>        <span class="hljs-keyword">while</span> (top &gt; <span class="hljs-number">1</span> &amp;&amp; ((p[i] - s[top]) ^ (s[top - <span class="hljs-number">1</span>] - s[top])) &lt;= <span class="hljs-number">0</span>)  <br>            top--;  <br>        s[++top] = p[i]; <span class="hljs-comment">// 当前点入栈  </span><br>    &#125;  <br>&#125;  <br>  <br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">s_sqr</span><span class="hljs-params">(Point a, Point b, Point c)</span> </span>&#123;<span class="hljs-comment">// 计算三角形abc的面积平方  </span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">fabs</span>((a - b) ^ (c - b));  <br>&#125;  <br>  <br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">diameter</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">// 计算凸包的直径（即最远点对距离）  </span><br>    <span class="hljs-type">double</span> diam = <span class="hljs-number">0</span>;  <br>    <span class="hljs-type">int</span> j = <span class="hljs-number">2</span>; <span class="hljs-comment">// 初始化另一个点的索引  </span><br>    s[++top] = s[<span class="hljs-number">0</span>]; <span class="hljs-comment">// 将凸包的起点再次加入栈中，以便于计算  </span><br>    <span class="hljs-keyword">if</span> (top &lt; <span class="hljs-number">3</span>) <span class="hljs-comment">// 如果凸包中的点少于3个，直接返回这两点间的距离  </span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dis</span>(s[<span class="hljs-number">0</span>], s[<span class="hljs-number">1</span>]);  <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; top - <span class="hljs-number">1</span>; i++) &#123;  <br>        <span class="hljs-comment">// 旋转卡壳算法，寻找以s[i]和s[i+1]为基线的最远点s[j]  </span><br>        <span class="hljs-keyword">while</span> (<span class="hljs-built_in">s_sqr</span>(s[i], s[i + <span class="hljs-number">1</span>], s[j]) &lt; <span class="hljs-built_in">s_sqr</span>(s[i], s[i + <span class="hljs-number">1</span>], s[(j + <span class="hljs-number">1</span>) % top]))  <br>            j = (j + <span class="hljs-number">1</span>) % top; <span class="hljs-comment">// 更新j的值，取模是为了循环遍历凸包上的点  </span><br>        <span class="hljs-comment">// 更新直径，取当前基线与最远点的最大距离  </span><br>        diam = <span class="hljs-built_in">max</span>(diam, <span class="hljs-built_in">max</span>(<span class="hljs-built_in">dis</span>(s[i], s[j]), <span class="hljs-built_in">dis</span>(s[i + <span class="hljs-number">1</span>], s[j])));  <br>    &#125;  <br>    <span class="hljs-keyword">return</span> diam;  <br>&#125;  <br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">equal</span><span class="hljs-params">(<span class="hljs-type">double</span> a, <span class="hljs-type">double</span> b)</span></span>&#123;<span class="hljs-comment">// 判断两个浮点数是否相等  </span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">fabs</span>(a - b) &lt; eps;  <br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="点向量相关">点、向量相关</h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//向量、点结构定义和操作</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">point</span>&#123;<br>	<span class="hljs-type">double</span> x,y;<br>	<span class="hljs-comment">//求点所在的象限</span><br>	<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">quad</span><span class="hljs-params">()</span></span>&#123;<br>		<span class="hljs-keyword">if</span>(x&gt;<span class="hljs-number">0</span>&amp;&amp;y&gt;=<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<span class="hljs-keyword">if</span>(x&lt;=<span class="hljs-number">0</span>&amp;&amp;y&gt;<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>		<span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">0</span>&amp;&amp;y&lt;=<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<span class="hljs-keyword">if</span>(x&gt;=<span class="hljs-number">0</span>&amp;&amp;y&lt;<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">4</span>;<br>	&#125;<br>&#125;;<br><span class="hljs-comment">//以x升序排列，其次以y升序排列  </span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">sortXupYup</span><span class="hljs-params">(point u,point v)</span></span>&#123;  <br>    <span class="hljs-keyword">if</span>(u.x!=v.x) <span class="hljs-keyword">return</span> u.x&lt;v.x;  <br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> u.y&lt;v.y;  <br>&#125;  <br><span class="hljs-comment">//以y升序排列，其次以x升序排列  </span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">sortYupXup</span><span class="hljs-params">(point u,point v)</span></span>&#123;  <br>    <span class="hljs-keyword">if</span>(u.y!=v.y) <span class="hljs-keyword">return</span> u.y&lt;v.y;  <br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> u.x&lt;v.x;  <br>&#125;  <br><span class="hljs-comment">//对点进行极角排序</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">sortPointAngle</span><span class="hljs-params">(point a,point b)</span></span>&#123;<br>	<span class="hljs-keyword">if</span>(a.<span class="hljs-built_in">quad</span>()!=b.<span class="hljs-built_in">quad</span>()) <span class="hljs-keyword">return</span> a.<span class="hljs-built_in">quad</span>()&lt;b.<span class="hljs-built_in">quad</span>();<br>	<span class="hljs-keyword">return</span> (a^b)&gt;<span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//向量取模</span><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">norm</span><span class="hljs-params">(point u)</span></span>&#123;<br>	<span class="hljs-keyword">return</span> <span class="hljs-built_in">sqrt</span>(u.x*u.x+u.y*u.y);<br>&#125;<br><span class="hljs-comment">//点到点的距离  </span><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">disPointPoint</span><span class="hljs-params">(point u,point v)</span></span>&#123;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">sqrt</span>((u.x-v.x)*(u.x-v.x)+(u.y-v.y)*(u.y-v.y));  <br>&#125;  <br><span class="hljs-comment">//向量的旋转  </span><br><span class="hljs-function">point <span class="hljs-title">SpinPoint</span><span class="hljs-params">(point u,<span class="hljs-type">double</span> zhita)</span></span>&#123;  <span class="hljs-comment">// 向量u绕原点旋转zhita角  </span><br>    <span class="hljs-comment">//逆时针旋转zhita角  </span><br>    <span class="hljs-type">double</span> r=<span class="hljs-built_in">sqrt</span>(u.x*u.x+u.y*u.y);  <br>    <span class="hljs-type">double</span> sinphi=u.y/r,cosinphi=u.x/r; <span class="hljs-comment">// 向量u的原始角度的正弦和余弦值  </span><br>    <span class="hljs-type">double</span> sinr=sinphi*<span class="hljs-built_in">cos</span>(zhita)+cosinphi*<span class="hljs-built_in">sin</span>(zhita); <span class="hljs-comment">// 旋转后角度的正弦值  </span><br>    <span class="hljs-type">double</span> cosr=cosinphi*<span class="hljs-built_in">cos</span>(zhita)-sinphi*<span class="hljs-built_in">sin</span>(zhita); <span class="hljs-comment">// 旋转后角度的余弦值  </span><br>    point v;  <br>    v.x=r*cosr;v.y=r*sinr;  <br>    <span class="hljs-keyword">return</span> v;  <br>&#125;  <br><span class="hljs-comment">// 求一组点中的最小距离 a为点的数组 size为数组大小 u,v表示这两个点 返回最小距离  </span><br><span class="hljs-comment">//分治法的入口,分治前需要排序  </span><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">mindisset1</span><span class="hljs-params">(point* a,<span class="hljs-type">int</span> size,<span class="hljs-type">int</span> &amp;u,<span class="hljs-type">int</span> &amp;v)</span></span>&#123;  <br>    <span class="hljs-comment">//函数起始入口  </span><br>    <span class="hljs-type">double</span> minn=<span class="hljs-number">1e18</span>; <span class="hljs-comment">// 初始化最小距离为一个非常大的数  </span><br>    <span class="hljs-built_in">sort</span>(a+<span class="hljs-number">1</span>,a+<span class="hljs-number">1</span>+size,sortXupYup); <span class="hljs-comment">// 对点集按照x坐标升序，y坐标升序进行排序  </span><br>    <span class="hljs-built_in">Nearestpoint</span>(a,<span class="hljs-number">1</span>,size,u,v,minn); <span class="hljs-comment">// 调用分治法函数求解最近点对  </span><br>    <span class="hljs-keyword">return</span> minn; <span class="hljs-comment">// 返回最小距离  </span><br>&#125;  <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Nearestpoint</span><span class="hljs-params">(point *a,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> &amp;u,<span class="hljs-type">int</span> &amp;v,<span class="hljs-type">double</span> &amp;d)</span></span>&#123;  <br>    <span class="hljs-comment">/*a点的数组 l左边界 r右边界 uv最近的两个点的index d最小距离  </span><br><span class="hljs-comment">      应当注意距离的定义形式，如果为平方的形式，      则代码中绝对值的部分也应当改为平方  </span><br><span class="hljs-comment">     */</span>    <span class="hljs-keyword">if</span>(l==r) <span class="hljs-keyword">return</span> ; <span class="hljs-comment">// 如果只有一个点，则没有最近点对，直接返回  </span><br>    <span class="hljs-keyword">if</span>(l+<span class="hljs-number">1</span>==r) &#123; <span class="hljs-comment">// 如果只有两个点，直接计算它们之间的距离  </span><br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">disPointPoint</span>(a[l],a[r])&lt;d) &#123; <span class="hljs-comment">// 这两个点的距离小于当前最小距离d  </span><br>            d = <span class="hljs-built_in">disPointPoint</span>(a[l], a[r]); <span class="hljs-comment">// 更新最小距离  </span><br>            u = l, v = r; <span class="hljs-comment">// 更新最近点对的索引  </span><br>        &#125;  <br>        <span class="hljs-keyword">return</span> ;  <br>    &#125;  <br>    <span class="hljs-type">int</span> mid=l+r&gt;&gt;<span class="hljs-number">1</span>,m=<span class="hljs-number">0</span>;  <br>    <span class="hljs-built_in">Nearestpoint</span>(a,l,mid,u,v,d),<span class="hljs-built_in">Nearestpoint</span>(a,mid+<span class="hljs-number">1</span>,r,u,v,d);  <br>    point b[r-l+<span class="hljs-number">10</span>]; <span class="hljs-comment">// 定义一个临时数组，用于存储中间区域附近的点  </span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=l;i&lt;=r;i++)&#123;  <br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">abs</span>(a[i].x-a[mid].x)&lt;d) <span class="hljs-comment">// 如果点a[i]到中间垂线的距离小于当前最小距离d  </span><br>            b[++m]=a[i]; <span class="hljs-comment">// 将点a[i]加入临时数组  </span><br>    &#125;  <br>    <span class="hljs-built_in">sort</span>(b+<span class="hljs-number">1</span>,b+<span class="hljs-number">1</span>+m,sortYupXup); <span class="hljs-comment">// 按照y坐标升序，x坐标升序对临时数组进行排序  </span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;  <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i+<span class="hljs-number">1</span>;j&lt;=m&amp;&amp;<span class="hljs-built_in">abs</span>(b[i].y-b[j].y)&lt;d;j++)&#123; <span class="hljs-comment">// 在临时数组中查找最近点对  </span><br>            <span class="hljs-keyword">if</span>(d&gt;<span class="hljs-built_in">disPointPoint</span>(b[i],b[j])) &#123; <span class="hljs-comment">// 找到更近的点对  </span><br>                d = <span class="hljs-built_in">disPointPoint</span>(b[i], b[j]); <span class="hljs-comment">// 更新最小距离  </span><br>                u = i, v = j; <span class="hljs-comment">// 更新最近点对的索引  </span><br>            &#125;  <br>        &#125;  <br>    &#125;  <br>    <span class="hljs-keyword">return</span> ;  <br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="maybe凸包相关">maybe凸包相关</h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//余弦定理 计算cosC ab为邻边 c为对边  </span><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">cosinesLaw</span><span class="hljs-params">(<span class="hljs-type">double</span> a,<span class="hljs-type">double</span> b,<span class="hljs-type">double</span> c)</span></span>&#123;  <br>    <span class="hljs-keyword">return</span> (a*a+b*b-c*c)/(<span class="hljs-number">2</span>*a*b);  <br>&#125;  <br><span class="hljs-comment">//求三角形面积  </span><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">triarea</span><span class="hljs-params">(point u,point v,point w)</span></span>&#123;  <br>    <span class="hljs-comment">//叉积方法  </span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">abs</span>((v-u)^(w-u))/<span class="hljs-number">2.0</span>;  <br>&#125;  <br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">triarea</span><span class="hljs-params">(<span class="hljs-type">double</span> a,<span class="hljs-type">double</span> b,<span class="hljs-type">double</span> c)</span></span>&#123; <span class="hljs-comment">// abc为三角形边长  </span><br>    <span class="hljs-comment">//海伦公式  </span><br>    <span class="hljs-type">double</span> p=(a+b+c)/<span class="hljs-number">2</span>;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">sqrt</span>(p*(p-a)*(p-b)*(p-c));  <br>&#125;  <br><span class="hljs-comment">//求多边形的面积  </span><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">polygonArea</span><span class="hljs-params">(point *u,<span class="hljs-type">int</span> size)</span></span>&#123;  <br>    <span class="hljs-type">double</span> area=<span class="hljs-number">0</span>;  <br>    point begin=u[<span class="hljs-number">0</span>];  <br>    <span class="hljs-comment">/*  </span><br><span class="hljs-comment">      由第一个点起始的顺序叉积，其中，点可以无序，  </span><br><span class="hljs-comment">      面积值为边之间连线的封闭部分，叉积能够计算容斥部分  </span><br><span class="hljs-comment">     */</span>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;size;i++) area+=((u[i<span class="hljs-number">-1</span>]-begin)^(u[i]-begin))/<span class="hljs-number">2</span>;  <br>    <span class="hljs-keyword">return</span> area;  <br>&#125;  <br><span class="hljs-comment">//判断一个点是否在多边形内 u需要判断的点 v多边形顶点数组 size多边形顶点数量  </span><br><span class="hljs-comment">// 多边形的顶点按照顺时针或逆时针顺序排列（先调用凸包中的sort和cmp按照极角给点排序）  </span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Isinside</span><span class="hljs-params">(point u,point *v,<span class="hljs-type">int</span> size)</span></span>&#123;  <br>    <span class="hljs-comment">// 检查点u是否在以v[1]为起点的两条边界线的同一侧，如果不在同一侧，则点u不在多边形内  </span><br>    <span class="hljs-keyword">if</span>(((v[size]-v[<span class="hljs-number">1</span>])^(u-v[<span class="hljs-number">1</span>]))&gt;<span class="hljs-number">0</span>||((v[<span class="hljs-number">2</span>]-v[<span class="hljs-number">1</span>])^(u-v[<span class="hljs-number">1</span>]))&lt;<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <br>    <span class="hljs-type">int</span> l=<span class="hljs-number">2</span>,r=size; <span class="hljs-comment">// 初始化二分查找的左右边界  </span><br>    <span class="hljs-keyword">while</span>(l&lt;=r)&#123; <span class="hljs-comment">// 进行二分查找，找到点u在多边形边界上的位置  </span><br>        <span class="hljs-type">int</span> mid=l+r&gt;&gt;<span class="hljs-number">1</span>;  <br>        <span class="hljs-comment">// 判断点u相对于以v[1]为起点的边界线的位置  </span><br>        <span class="hljs-keyword">if</span>(((v[mid]-v[<span class="hljs-number">1</span>])^(u-v[<span class="hljs-number">1</span>]))&lt;<span class="hljs-number">0</span>) l=mid+<span class="hljs-number">1</span>; <span class="hljs-comment">// 点u在边界线的左侧，调整左边界  </span><br>        <span class="hljs-keyword">else</span> r=mid<span class="hljs-number">-1</span>; <span class="hljs-comment">// 点u在边界线的右侧或在线上，调整右边界  </span><br>    &#125;  <br>    <span class="hljs-comment">// 检查点u是否在以v[r]和v[l]为端点的边界线的同一侧或线上，如果是，则点u在多边形内  </span><br>    <span class="hljs-keyword">if</span>(((v[r]-v[l])^(u-v[l]))&gt;=<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="直线相关">直线相关</h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//直线结构定义和直线的极角排序  </span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">line</span>&#123;  <br>    <span class="hljs-comment">//ax+by+c=0  </span><br>    <span class="hljs-type">double</span> a,b,c;  <br>    <span class="hljs-comment">//u为直线上一点，v为方向向量  </span><br>    point u,v;  <br>    <span class="hljs-built_in">line</span>()&#123;&#125;  <br>    <span class="hljs-comment">//两点确定的直线方程  </span><br>    <span class="hljs-built_in">line</span>(point p,point q)&#123;  <br>        a=p.y-q.y;b=q.x-p.x;c=p.x*q.y-q.x*p.y;<span class="hljs-comment">// 根据两点式求直线方程系数  </span><br>        <span class="hljs-comment">//保证u、v两点逆时针排列  </span><br>        <span class="hljs-keyword">if</span>((p^q)&lt;<span class="hljs-number">0</span>) <span class="hljs-built_in">swap</span>(p,q);  <br>        u=p;v=q-p;  <br>    &#125;  <br>&#125;;  <br><span class="hljs-comment">//对直线进行极角排序 极角是指直线方向向量与x轴正方向的夹角  </span><br><span class="hljs-comment">// 调用：sort(lines.begin(), lines.end(), sortLineAngle);  </span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">sortLineAngle</span><span class="hljs-params">(line a,line b)</span></span>&#123;  <br>    <span class="hljs-comment">// 首先比较两条直线的方向向量所在象限  </span><br>    <span class="hljs-keyword">if</span>(a.v.<span class="hljs-built_in">quad</span>()!=b.v.<span class="hljs-built_in">quad</span>()) <span class="hljs-keyword">return</span> a.v.<span class="hljs-built_in">quad</span>()&lt;b.v.<span class="hljs-built_in">quad</span>();  <br>    <span class="hljs-comment">// 如果方向向量在同一象限，则比较它们的叉积  </span><br>    <span class="hljs-keyword">else</span> <span class="hljs-built_in">return</span> (a.v^b.v)==<span class="hljs-number">0</span>?(a.v^(a.u-b.u))&gt;<span class="hljs-number">0</span>:(a.v^b.v)&gt;<span class="hljs-number">0</span>;  <br>&#125;  <br>  <br><span class="hljs-comment">//点、线运算  </span><br>  <br><span class="hljs-comment">//点u到直线l的距离  </span><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">disPointLine</span><span class="hljs-params">(point u,line l)</span></span>&#123;  <br>    <span class="hljs-type">double</span> length;  <br>    length = <span class="hljs-built_in">abs</span>(l.a*u.x+l.b*u.y+l.c)/(<span class="hljs-built_in">sqrt</span>(l.a*l.a+l.b*l.b));  <br>    <span class="hljs-keyword">return</span> length;  <br>&#125;  <br><span class="hljs-comment">//点u在直线l上的投影点 返回投影点v  </span><br><span class="hljs-function">point <span class="hljs-title">proPointLine</span><span class="hljs-params">(point u,line l)</span></span>&#123;  <br>    point v;  <br>    <span class="hljs-comment">// 计算投影点坐标的参数t  </span><br>    <span class="hljs-type">double</span> t=(-u.x*l.a-u.y*l.b-l.c)/(l.a*l.a+l.b*l.b);  <br>    <span class="hljs-comment">// 根据参数t和直线方程计算投影点坐标  </span><br>    v.x=u.x+l.a*t;  <br>    v.y=u.y+l.b*t;  <br>    <span class="hljs-keyword">return</span> v;  <br>&#125;  <br><span class="hljs-comment">// 点到线段的距离 点u到线段vw的距离 返回点到线段的距离  </span><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">disPointSeg</span><span class="hljs-params">(point u, point v, point w)</span> </span>&#123;  <br>    <span class="hljs-comment">// d1是向量uv在向量vw上的投影长度的平方  </span><br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> d1 = (u.x - v.x) * (w.x - v.x) + (u.y - v.y) * (w.y - v.y);  <br>    <span class="hljs-comment">// 如果投影长度小于等于0，说明点u在v点或v点延长线上，直接计算uv的距离  </span><br>    <span class="hljs-keyword">if</span> (d1 &lt;= <span class="hljs-number">0.0</span>) <span class="hljs-keyword">return</span> <span class="hljs-built_in">sqrt</span>((u.x - v.x) * (u.x - v.x) + (u.y - v.y) * (u.y - v.y));  <br>    <span class="hljs-comment">// d2是向量vw的长度的平方  </span><br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> d2 = (v.x - w.x) * (v.x - w.x) + (v.y - w.y) * (v.y - w.y);  <br>    <span class="hljs-comment">// 如果投影长度大于等于d2，说明点u在w点或w点延长线上，直接计算uw的距离  </span><br>    <span class="hljs-keyword">if</span> (d1 &gt;= d2) <span class="hljs-keyword">return</span> <span class="hljs-built_in">sqrt</span>((u.x - w.x) * (u.x - w.x) + (u.y - w.y) * (u.y - w.y));  <br>    <span class="hljs-comment">// 计算点u在vw上的投影点坐标  </span><br>    <span class="hljs-type">double</span> r = <span class="hljs-number">1.0</span> * d1 / d2;  <br>    <span class="hljs-type">double</span> px = v.x + (w.x - v.x) * r;  <br>    <span class="hljs-type">double</span> py = v.y + (w.y - v.y) * r;  <br>    <span class="hljs-comment">// 返回点u到其投影点的距离  </span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">sqrt</span>((u.x - px) * (u.x - px) + (u.y - py) * (u.y - py));  <br>&#125;  <br><span class="hljs-comment">// 求两直线的交点 线段l1l2 返回交点p  </span><br><span class="hljs-function">point <span class="hljs-title">itsLineLine</span><span class="hljs-params">(line l1, line l2)</span> </span>&#123;  <br>    point p;  <br>    <span class="hljs-comment">// k是两直线方程系数的行列式，用于判断两直线是否平行  </span><br>    <span class="hljs-type">double</span> k = l1.a * l2.b - l1.b * l2.a;  <br>    <span class="hljs-comment">// 计算交点坐标，使用克莱姆法则解线性方程组  </span><br>    p.x = -(l1.c * l2.b - l1.b * l2.c) / k;  <br>    p.y = -(l1.a * l2.c - l1.c * l2.a) / k;  <br>    <span class="hljs-keyword">return</span> p;  <br>&#125;  <br>  <br><span class="hljs-comment">// 计算多个半平面的交集，并返回交集区域的多边形顶点  </span><br><span class="hljs-type">const</span> line bd[<span class="hljs-number">4</span>] = &#123;<span class="hljs-comment">// 定义四个边界直线，形成一个无限大的矩形，用于限制半平面的范围  </span><br>        <span class="hljs-built_in">line</span>(point&#123;-INF,-INF&#125;,point&#123;INF,-INF&#125;),<span class="hljs-built_in">line</span>(point&#123;INF,-INF&#125;,point&#123;INF,INF&#125;),  <br>        <span class="hljs-built_in">line</span>(point&#123;INF,INF&#125;,point&#123;-INF,INF&#125;),<span class="hljs-built_in">line</span>(point&#123;-INF,INF&#125;,point&#123;-INF,-INF&#125;),  <br>&#125;;  <br><span class="hljs-function">vector&lt;point&gt; <span class="hljs-title">HalfPlaneInter</span><span class="hljs-params">(vector&lt;line&gt; k)</span></span>&#123; <span class="hljs-comment">// 计算多个半平面的交集，返回交集的多边形顶点  </span><br>    <span class="hljs-comment">// 将边界直线添加到半平面直线集合中  </span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) k.<span class="hljs-built_in">push_back</span>(bd[i]);  <br>    <span class="hljs-comment">// 按照直线的极角进行排序  </span><br>    <span class="hljs-built_in">sort</span>(k.<span class="hljs-built_in">begin</span>(), k.<span class="hljs-built_in">end</span>(), sortLineAngle);  <br>  <br>    deque&lt;line&gt; q; <span class="hljs-comment">// 存储当前考虑的直线  </span><br>    deque&lt;point&gt; c; <span class="hljs-comment">// 存储交点  </span><br>    vector&lt;point&gt; ans; <span class="hljs-comment">// 存储最终的多边形顶点  </span><br>    <span class="hljs-type">int</span> m = <span class="hljs-number">0</span>; <span class="hljs-comment">// 用于去除重复的直线  </span><br>    <span class="hljs-comment">// 去除方向向量相同的直线  </span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; k.<span class="hljs-built_in">size</span>(); i++) <span class="hljs-keyword">if</span> ((k[m].v ^ k[i].v) != <span class="hljs-number">0</span>) k[++m] = k[i];  <br>  <br>    <span class="hljs-comment">// 初始化队列  </span><br>    q.<span class="hljs-built_in">push_back</span>(k[<span class="hljs-number">0</span>]);  <br>    <span class="hljs-comment">// 遍历所有直线，构建半平面交集  </span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;  <br>        <span class="hljs-comment">// 维护队列，确保队列中的直线形成的多边形是有效的  </span><br>        <span class="hljs-keyword">while</span> (c.<span class="hljs-built_in">size</span>() &amp;&amp; ((c.<span class="hljs-built_in">back</span>() - k[i].u) ^ k[i].v) &gt;= <span class="hljs-number">0</span>) &#123;  <br>            q.<span class="hljs-built_in">pop_back</span>();  <br>            c.<span class="hljs-built_in">pop_back</span>();  <br>        &#125;  <br>        <span class="hljs-keyword">while</span> (c.<span class="hljs-built_in">size</span>() &amp;&amp; ((c.<span class="hljs-built_in">front</span>() - k[i].u) ^ k[i].v) &gt;= <span class="hljs-number">0</span>) &#123;  <br>            q.<span class="hljs-built_in">pop_front</span>();  <br>            c.<span class="hljs-built_in">pop_front</span>();  <br>        &#125;  <br>        <span class="hljs-comment">// 计算当前直线与队列中最后一条直线的交点，并添加到队列中  </span><br>        c.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">itsLineLine</span>(k[i], q.<span class="hljs-built_in">back</span>()));  <br>        q.<span class="hljs-built_in">push_back</span>(k[i]);  <br>    &#125;  <br>    <span class="hljs-comment">// 清理队列中的无效直线和交点  </span><br>    <span class="hljs-keyword">while</span> (c.<span class="hljs-built_in">size</span>() &amp;&amp; ((c.<span class="hljs-built_in">back</span>() - q.<span class="hljs-built_in">front</span>().u) ^ q.<span class="hljs-built_in">front</span>().v) &gt;= <span class="hljs-number">0</span>) &#123;  <br>        q.<span class="hljs-built_in">pop_back</span>();  <br>        c.<span class="hljs-built_in">pop_back</span>();  <br>    &#125;  <br>    <span class="hljs-comment">// 将交点添加到答案中  </span><br>    <span class="hljs-keyword">while</span> (c.<span class="hljs-built_in">size</span>()) &#123;  <br>        ans.<span class="hljs-built_in">push_back</span>(c.<span class="hljs-built_in">front</span>());  <br>        c.<span class="hljs-built_in">pop_front</span>();  <br>    &#125;  <br>    <span class="hljs-comment">// 如果队列中有多于一条直线，添加最后两条直线的交点  </span><br>    <span class="hljs-keyword">if</span> (q.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span>) ans.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">itsLineLine</span>(q.<span class="hljs-built_in">front</span>(), q.<span class="hljs-built_in">back</span>()));  <br>    <span class="hljs-keyword">return</span> ans;  <br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="圆相关">圆相关</h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//圆结构  </span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">circle</span>&#123;  <br>    <span class="hljs-comment">//圆心  </span><br>    point cc;  <br>    <span class="hljs-comment">//半径  </span><br>    <span class="hljs-type">double</span> radius;  <br>&#125;;  <br><span class="hljs-comment">//求三点uvw所确定的圆c  </span><br><span class="hljs-function">circle <span class="hljs-title">concyclic</span><span class="hljs-params">(point u, point v, point w)</span> </span>&#123;  <br>    circle c;  <br>    point o;  <br>    <span class="hljs-comment">// 计算圆心坐标的系数k  </span><br>    <span class="hljs-type">double</span> k = <span class="hljs-number">2</span> * (v.x - u.x) * (w.y - v.y) - <span class="hljs-number">2</span> * (v.y - u.y) * (w.x - v.x);  <br>    <span class="hljs-comment">// 计算圆心o的x坐标  </span><br>    o.x = (w.y - v.y) * (v.x * v.x + v.y * v.y - u.x * u.x - u.y * u.y) - (v.y - u.y) * (w.x * w.x + w.y * w.y - v.x * v.x - v.y * v.y);  <br>    <span class="hljs-comment">// 计算圆心o的y坐标  </span><br>    o.y = (v.x - u.x) * (w.x * w.x + w.y * w.y - v.x * v.x - v.y * v.y) - (w.x - v.x) * (v.x * v.x + v.y * v.y - u.x * u.x - u.y * u.y);  <br>    o.x /= k; o.y /= k; <span class="hljs-comment">// 除以系数k得到圆心坐标  </span><br>    c.cc = o; <span class="hljs-comment">// 设置圆心  </span><br>    c.radius = <span class="hljs-built_in">disPointPoint</span>(o, u); <span class="hljs-comment">// 计算半径并设置  </span><br>    <span class="hljs-keyword">return</span> c;  <br>&#125;  <br><span class="hljs-comment">//求圆c与直线l的交点ans  </span><br><span class="hljs-function">vector&lt;point&gt; <span class="hljs-title">itsStrCir</span><span class="hljs-params">(line l, circle c)</span> </span>&#123;  <br>    <span class="hljs-type">double</span> k = l.u * l.v; <span class="hljs-comment">// 计算直线与圆心的向量点积  </span><br>    <span class="hljs-type">double</span> a = <span class="hljs-built_in">norm</span>(l.u), b = <span class="hljs-built_in">norm</span>(l.v); <span class="hljs-comment">// 计算直线向量的模的平方  </span><br>    <span class="hljs-type">double</span> r = c.radius; <span class="hljs-comment">// 圆的半径  </span><br>    <span class="hljs-type">double</span> d = k * k - b * b * (a * a - r * r); <span class="hljs-comment">// 计算判别式  </span><br>    vector&lt;point&gt; ans;  <br>    <span class="hljs-comment">// 判别式为0，有一个交点  </span><br>    <span class="hljs-keyword">if</span> (d == <span class="hljs-number">0</span>) ans.<span class="hljs-built_in">push_back</span>(l.u + l.v * (-k / (b * b)));  <br>    <span class="hljs-comment">// 判别式大于0，有两个交点  </span><br>    <span class="hljs-keyword">else</span> &#123;  <br>        ans.<span class="hljs-built_in">push_back</span>(l.u + l.v * ((-k + d) / (b * b)));  <br>        ans.<span class="hljs-built_in">push_back</span>(l.u + l.v * ((-k - d) / (b * b)));  <br>    &#125;  <br>    <span class="hljs-comment">// 返回交点集合  </span><br>    <span class="hljs-keyword">return</span> ans;  <br>&#125;  <br><span class="hljs-comment">// 求两圆c1c2的交点ans  </span><br><span class="hljs-function">vector&lt;point&gt; <span class="hljs-title">itsCirCir</span><span class="hljs-params">(circle c1, circle c2)</span> </span>&#123;  <br>    vector&lt;point&gt; ans;  <br>    point o1 = c1.cc, o2 = c2.cc; <span class="hljs-comment">// 圆心o1和o2  </span><br>    point a = o2 - o1; <span class="hljs-comment">// 向量a从o1指向o2  </span><br>    point b; <span class="hljs-comment">// 向量b垂直于a  </span><br>    b.x = a.y; b.y = -a.x;  <br>    <span class="hljs-type">double</span> r1 = c1.radius, r2 = c2.radius; <span class="hljs-comment">// 两圆的半径  </span><br>    <span class="hljs-type">double</span> d = <span class="hljs-built_in">disPointPoint</span>(o1, o2); <span class="hljs-comment">// 圆心距离  </span><br>    <span class="hljs-type">double</span> S = <span class="hljs-built_in">triarea</span>(r1, r2, d); <span class="hljs-comment">// 两圆半径和圆心距离构成的三角形面积  </span><br>    <span class="hljs-type">double</span> h = <span class="hljs-number">2</span> * S / d; <span class="hljs-comment">// 交点连线的中垂线到圆心连线的距离  </span><br>    <span class="hljs-type">double</span> t = <span class="hljs-built_in">sqrt</span>(r1 * r1 - h * h);  <br>    <span class="hljs-keyword">if</span> (r1 * r1 + d * d &lt; r2 * r2) t = -t; <span class="hljs-comment">// 如果两圆内含，调整t的符号  </span><br>    <span class="hljs-comment">// 计算交点  </span><br>    <span class="hljs-keyword">if</span> (h == <span class="hljs-number">0</span>) &#123;  <br>        <span class="hljs-comment">// 如果h为0，两圆相切，只有一个交点  </span><br>        ans.<span class="hljs-built_in">push_back</span>(o1 + a * t / <span class="hljs-built_in">norm</span>(a));  <br>    &#125; <span class="hljs-keyword">else</span> &#123;  <br>        <span class="hljs-comment">// 否则有两组交点  </span><br>        ans.<span class="hljs-built_in">push_back</span>(o1 + a * t / <span class="hljs-built_in">norm</span>(a) + b * h / <span class="hljs-built_in">norm</span>(b));  <br>        ans.<span class="hljs-built_in">push_back</span>(o1 + a * t / <span class="hljs-built_in">norm</span>(a) - b * h / <span class="hljs-built_in">norm</span>(b));  <br>    &#125;  <br>    <span class="hljs-keyword">return</span> ans;  <br>&#125;  <br><span class="hljs-comment">// 求一点u与圆c的切线ans  </span><br><span class="hljs-function">vector&lt;line&gt; <span class="hljs-title">tlPointCircle</span><span class="hljs-params">(point u, circle c)</span> </span>&#123;  <br>    vector&lt;line&gt; ans;  <br>    <span class="hljs-comment">// 构造一个辅助圆，圆心为u和c.cc的中点，半径为u到c.cc距离的一半  </span><br>    circle o;  <br>    o.cc = (c.cc + u) / <span class="hljs-number">2</span>;  <br>    o.radius = <span class="hljs-built_in">disPointPoint</span>(c.cc, u) / <span class="hljs-number">2</span>;  <br>    <span class="hljs-comment">// 求辅助圆与原圆的交点  </span><br>    vector&lt;point&gt; p = <span class="hljs-built_in">itsCirCir</span>(o, c);  <br>    <span class="hljs-comment">// 如果只有一个交点，则切线只有一条  </span><br>    <span class="hljs-keyword">if</span> (p.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>) &#123;  <br>        point v;  <br>        v.x = (u - c.cc).y; v.y = -(u - c.cc).x;  <br>        ans.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">line</span>(u, u + v));  <br>    &#125;  <br>    <span class="hljs-comment">// 如果有两个交点，则切线有两条  </span><br>    <span class="hljs-keyword">if</span> (p.<span class="hljs-built_in">size</span>() == <span class="hljs-number">2</span>) &#123;  <br>        ans.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">line</span>(p[<span class="hljs-number">0</span>], u));  <br>        ans.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">line</span>(p[<span class="hljs-number">1</span>], u));  <br>    &#125;  <br>    <span class="hljs-keyword">return</span> ans;  <br>&#125;  <br><span class="hljs-comment">// 求两圆c1c2的公切线ans  </span><br><span class="hljs-function">vector&lt;line&gt; <span class="hljs-title">comTangent</span><span class="hljs-params">(circle c1, circle c2)</span> </span>&#123;  <br>    vector&lt;line&gt; ans, q;  <br>    <span class="hljs-type">int</span> r1 = c1.radius, r2 = c2.radius; <span class="hljs-comment">// 两圆的半径  </span><br>    <span class="hljs-type">int</span> d = <span class="hljs-built_in">disPointPoint</span>(c1.cc, c2.cc); <span class="hljs-comment">// 两圆心之间的距离  </span><br>    point u, v, a = c2.cc - c1.cc, t; <span class="hljs-comment">// 向量a从c1的圆心指向c2的圆心  </span><br>    <span class="hljs-comment">// 如果两圆半径相等，则有两条外公切线和两条内公切线  </span><br>    <span class="hljs-keyword">if</span> (r1 == r2) &#123;  <br>        u = c1.cc - c2.cc;  <br>        v.x = u.y; v.y = -u.x; <span class="hljs-comment">// v是u的垂直向量  </span><br>        <span class="hljs-comment">// 添加两条外公切线  </span><br>        ans.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">line</span>(c1.cc + v * r1 / <span class="hljs-built_in">norm</span>(v), c1.cc + v * r1 / <span class="hljs-built_in">norm</span>(v) + u));  <br>        ans.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">line</span>(c1.cc - v * r1 / <span class="hljs-built_in">norm</span>(v), c1.cc - v * r1 / <span class="hljs-built_in">norm</span>(v) + u));  <br>    &#125; <span class="hljs-keyword">else</span> &#123;  <br>        <span class="hljs-comment">// 内侧切线（内公切线）  </span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">triarea</span>(r1, r2, d) == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 如果两圆内切  </span><br>            t = c1.cc + a * r1 / r2; <span class="hljs-comment">// 计算切点  </span><br>            q = <span class="hljs-built_in">tlPointCircle</span>(t, c1); <span class="hljs-comment">// 求切线  </span><br>            <span class="hljs-keyword">while</span> (q.<span class="hljs-built_in">size</span>()) &#123; ans.<span class="hljs-built_in">push_back</span>(q.<span class="hljs-built_in">back</span>()); q.<span class="hljs-built_in">pop_back</span>(); &#125; <span class="hljs-comment">// 添加到答案中  </span><br>        &#125;  <br>        <span class="hljs-comment">// 外侧切线（外公切线）  </span><br>        t = c1.cc + a * r1 / (r1 - r2); <span class="hljs-comment">// 计算切点  </span><br>        q = <span class="hljs-built_in">tlPointCircle</span>(t, c1); <span class="hljs-comment">// 求切线  </span><br>        <span class="hljs-keyword">while</span> (q.<span class="hljs-built_in">size</span>()) &#123; ans.<span class="hljs-built_in">push_back</span>(q.<span class="hljs-built_in">back</span>()); q.<span class="hljs-built_in">pop_back</span>(); &#125; <span class="hljs-comment">// 添加到答案中  </span><br>    &#125;  <br>    <span class="hljs-keyword">return</span> ans;  <br>&#125;  <br><span class="hljs-comment">// 最小圆覆盖 给定点集u和点的数量size，求最小的圆c能够覆盖所有点  </span><br><span class="hljs-function">circle <span class="hljs-title">Smallestcir</span><span class="hljs-params">(point *u, <span class="hljs-type">int</span> size)</span> </span>&#123;  <br>    <span class="hljs-built_in">random_shuffle</span>(u + <span class="hljs-number">1</span>, u + <span class="hljs-number">1</span> + size); <span class="hljs-comment">// 随机打乱点集  </span><br>    point o = u[<span class="hljs-number">1</span>]; <span class="hljs-comment">// 初始圆心为第一个点  </span><br>    <span class="hljs-type">double</span> r = <span class="hljs-number">0</span>; <span class="hljs-comment">// 初始半径为0  </span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= size; i++) &#123;  <br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">disPointPoint</span>(o, u[i]) &lt;= r) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// 如果点在当前圆内，跳过  </span><br>        o = (u[i] + u[<span class="hljs-number">1</span>]) / <span class="hljs-number">2</span>; <span class="hljs-comment">// 更新圆心为i和1号点的中点  </span><br>        r = <span class="hljs-built_in">disPointPoint</span>(u[i], u[<span class="hljs-number">1</span>]) / <span class="hljs-number">2</span>; <span class="hljs-comment">// 更新半径为i和1号点距离的一半  </span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">2</span>; j &lt; i; j++) &#123;  <br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">disPointPoint</span>(u[j], o) &lt;= r) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// 如果点在当前圆内，跳过  </span><br>            o = (u[i] + u[j]) / <span class="hljs-number">2</span>; <span class="hljs-comment">// 更新圆心为i和j号点的中点  </span><br>            r = <span class="hljs-built_in">disPointPoint</span>(u[i], u[j]) / <span class="hljs-number">2</span>; <span class="hljs-comment">// 更新半径为i和j号点距离的一半  </span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k &lt; j; k++) &#123;  <br>                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">disPointPoint</span>(u[k], o) &lt;= r) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// 如果点在当前圆内，跳过  </span><br>                circle c = <span class="hljs-built_in">concyclic</span>(u[i], u[j], u[k]); <span class="hljs-comment">// 求通过i、j、k三点的圆  </span><br>                o = c.cc; r = c.radius; <span class="hljs-comment">// 更新圆心和半径  </span><br>            &#125;  <br>        &#125;  <br>    &#125;  <br>    circle c;  <br>    c.cc = o; c.radius = r;  <br>    <span class="hljs-keyword">return</span> c;  <br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="快速幂取余">快速幂取余</h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 快速幂取模函数 计算 (a^b) % m 的结果res  </span><br><span class="hljs-function">ll <span class="hljs-title">fast_pow_mod</span><span class="hljs-params">(ll a, ll b, ll m)</span></span>&#123;  <br>    a %= m; <span class="hljs-comment">// 对a取模，减少后续计算中的数值大小  </span><br>    ll res = <span class="hljs-number">1</span>; <span class="hljs-comment">// 初始化结果为1（任何数的0次幂都是1）  </span><br>    <span class="hljs-keyword">while</span> (b &gt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 当指数b大于0时，进行循环  </span><br>        <span class="hljs-comment">// 如果b的当前最低位为1，则将当前a乘到结果中  </span><br>        <span class="hljs-keyword">if</span> (b &amp; <span class="hljs-number">1</span>) res = res * a % m;  <br>        a = a * a % m; <span class="hljs-comment">// 将a平方，用于下一轮循环  </span><br>        b &gt;&gt;= <span class="hljs-number">1</span>; <span class="hljs-comment">// 将b右移一位，相当于除以2  </span><br>    &#125;  <br>    <span class="hljs-keyword">return</span> res;  <br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="快速打质数表">快速打质数表</h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 生成小于等于n的所有素数列表prime_list  </span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">generate_prime_list</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;  <br>    <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">2</span>) <span class="hljs-comment">// 如果n小于等于2，返回只包含2的列表  </span><br>        <span class="hljs-keyword">return</span> vector&lt;<span class="hljs-type">int</span>&gt;&#123;<span class="hljs-number">2</span>&#125;;  <br>    <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">3</span>) <span class="hljs-comment">// 如果n小于等于3，返回包含2和3的列表  </span><br>        <span class="hljs-keyword">return</span> vector&lt;<span class="hljs-type">int</span>&gt;&#123;<span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;  <br>    <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">5</span>) <span class="hljs-comment">// 如果n小于等于5，返回包含2、3和5的列表  </span><br>        <span class="hljs-keyword">return</span> vector&lt;<span class="hljs-type">int</span>&gt;&#123;<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>&#125;;  <br>    vector&lt;<span class="hljs-type">int</span>&gt; prime_list = &#123;<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>&#125;; <span class="hljs-comment">// 初始化素数列表，包含最小的三个素数2、3和5  </span><br>    <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; <span class="hljs-comment">// 初始化循环变量i  </span><br>    <span class="hljs-type">int</span> x;  <br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;  <br>        x = <span class="hljs-number">6</span> * i + <span class="hljs-number">1</span>; <span class="hljs-comment">// 计算6i+1，这是除了2和3之外素数的可能形式之一  </span><br>        <span class="hljs-keyword">if</span> (x &gt; n) <span class="hljs-comment">// 如果x大于n，则不再继续查找  </span><br>            <span class="hljs-keyword">break</span>;  <br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">is_prime</span>(x, prime_list)) <span class="hljs-comment">// 如果x是素数，则添加到素数列表中  </span><br>            prime_list.<span class="hljs-built_in">push_back</span>(x);  <br>  <br>        x = <span class="hljs-number">6</span> * i + <span class="hljs-number">5</span>; <span class="hljs-comment">// 计算6i+5，这是除了2和3之外素数的另一种可能形式  </span><br>        <span class="hljs-keyword">if</span> (x &gt; n) <span class="hljs-comment">// 如果x大于n，则不再继续查找  </span><br>            <span class="hljs-keyword">break</span>;  <br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">is_prime</span>(x, prime_list)) <span class="hljs-comment">// 如果x是素数，则添加到素数列表中  </span><br>            prime_list.<span class="hljs-built_in">push_back</span>(x);  <br>  <br>        i++; <span class="hljs-comment">// 增加i，用于下一轮计算  </span><br>    &#125;  <br>    <span class="hljs-keyword">return</span> prime_list;  <br>&#125;  <br>  <br><span class="hljs-comment">// 判断一个数x是否为素数，利用已知的素数列表prime_list进行判断  </span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">is_prime</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt; &amp;prime_list)</span> </span>&#123;  <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> u: prime_list)&#123; <span class="hljs-comment">// 遍历素数列表中的每个素数u  </span><br>        <span class="hljs-keyword">if</span>(x % u == <span class="hljs-number">0</span>) <span class="hljs-comment">// 如果x能被u整除，则x不是素数  </span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <br>        <span class="hljs-keyword">if</span>(u * u &gt; x) <span class="hljs-comment">// 如果u的平方大于x，则x是素数  </span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <br>    &#125;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 如果没有找到能整除x的素数，则x是素数  </span><br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="单调栈">单调栈</h5>
<ul>
<li><p>寻找<strong>左</strong>侧第一个比当前元素<strong>大</strong>的元素：从左到右遍历元素，构造<strong>单调递增栈</strong>（从栈顶到栈底递增）
一个元素左侧第一个比它大的元素就是将其「<strong>插入单调递增栈</strong>」时的栈顶元素。
如果插入时的栈为空，则说明左侧不存在比当前元素大的元素。</p></li>
<li><p>寻找<strong>左</strong>侧第一个比当前元素<strong>小</strong>的元素：从左到右遍历元素，构造<strong>单调递减栈</strong>（从栈顶到栈底递减）
一个元素左侧第一个比它小的元素就是将其「<strong>插入</strong>单调递减栈」时的栈顶元素。
如果插入时的栈为空，则说明左侧不存在比当前元素小的元素。</p></li>
<li><p>寻找<strong>右</strong>侧第一个比当前元素<strong>大</strong>的元素：从左到右遍历元素，构造<strong>单调递增栈</strong>（从栈顶到栈底递增）
一个元素右侧第一个比它大的元素就是将其「<strong>弹出</strong>单调递增栈」时即将插入的元素。
如果该元素没有被弹出栈，则说明右侧不存在比当前元素大的元素。</p></li>
<li><p>寻找<strong>右</strong>侧第一个比当前元素<strong>小</strong>的元素：从左到右遍历元素，构造<strong>单调递减栈</strong>（从栈顶到栈底递减）
一个元素右侧第一个比它小的元素就是将其「<strong>弹出</strong>单调递减栈」时即将插入的元素。
如果该元素没有被弹出栈，则说明右侧不存在比当前元素小的元素。</p></li>
<li><p>查找 <strong>「比当前元素大的元素」</strong> 就用
<strong>单调递增栈</strong>，查找
<strong>「比当前元素小的元素」</strong> 就用
<strong>单调递减栈</strong>。</p></li>
<li><p>从 <strong>「左侧」</strong> 查找就看 <strong>「插入栈」</strong>
时的栈顶元素，从 <strong>「右侧」</strong> 查找就看
<strong>「弹出栈」</strong> 时即将插入的元素。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX (300000+10)  </span><br>  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">monoIncreaseStack</span><span class="hljs-params">(<span class="hljs-type">int</span> height, <span class="hljs-type">int</span> id)</span></span>;  <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> height, <span class="hljs-type">long</span> <span class="hljs-type">long</span> id)</span></span>;  <br><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span></span>;  <br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">student</span>&#123;  <br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> id;  <br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> height;  <br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> leftBigId, rightBigId; <span class="hljs-comment">// 左侧第一个比当前元素的height大的数的id 右侧...  </span><br>&#125;;  <br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">student</span> stacks[MAX]; <span class="hljs-comment">// 栈  </span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">student</span> students[MAX]; <span class="hljs-comment">// 所有的学生  </span><br><span class="hljs-type">int</span> Top = <span class="hljs-number">-1</span>;<span class="hljs-comment">// 栈指针  </span><br>  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;  <br>    <span class="hljs-type">int</span> t;  <br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;t);  <br>    <span class="hljs-keyword">while</span> (t--)&#123;  <br>        <span class="hljs-type">int</span> n;  <br>        Top = <span class="hljs-number">-1</span>;  <br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);  <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123; <span class="hljs-comment">// 读取所有height，单调栈处理  </span><br>            <span class="hljs-type">long</span> <span class="hljs-type">long</span> height;  <br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>, &amp;height);  <br>            students[i].height = height;  <br>            students[i].id = i;  <br>            <span class="hljs-built_in">monoIncreaseStack</span>(height, i);  <br>        &#125;  <br>        <span class="hljs-keyword">while</span>(Top != <span class="hljs-number">-1</span>)&#123;  <br>            <span class="hljs-comment">// 现在还在栈里的数的右侧都没有比它大的数  </span><br>            students[stacks[Top].id].rightBigId = n;  <br>            <span class="hljs-built_in">pop</span>();  <br>        &#125;  <br>    &#125;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">monoIncreaseStack</span><span class="hljs-params">(<span class="hljs-type">int</span> height, <span class="hljs-type">int</span> id)</span></span>&#123; <span class="hljs-comment">// 当前元素大小height index为id  </span><br>    <span class="hljs-comment">// 弹出所有比当前元素小的元素  </span><br>    <span class="hljs-keyword">while</span>(Top!=<span class="hljs-number">-1</span> &amp;&amp; height&gt;=stacks[Top].height)&#123;  <br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> popId = <span class="hljs-built_in">pop</span>();  <br>        students[popId].rightBigId = id; <span class="hljs-comment">// id是popId右侧第一个比它大的元素  </span><br>    &#125;  <br>    <span class="hljs-keyword">if</span>(Top == <span class="hljs-number">-1</span>)&#123;  <br>        students[id].leftBigId = <span class="hljs-number">-1</span>; <span class="hljs-comment">// id左侧没有比它大的元素  </span><br>    &#125;<span class="hljs-keyword">else</span>&#123;  <br>        students[id].leftBigId = stacks[Top].id;  <br>    &#125;  <br>    <span class="hljs-built_in">push</span>(height, id); <span class="hljs-comment">// 入栈  </span><br>&#125;  <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> height, <span class="hljs-type">long</span> <span class="hljs-type">long</span> id)</span></span>&#123;  <br>    stacks[++Top].height = height;  <span class="hljs-comment">// 入栈成功  </span><br>    stacks[Top].id = id;  <br>&#125;  <br><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span></span>&#123;  <br>    <span class="hljs-keyword">return</span> stacks[Top--].id;    <span class="hljs-comment">// 出栈成功  </span><br>&#125;<br></code></pre></td></tr></table></figure></p></li>
</ul>
<h5 id="秦九韶算法horner-规则">秦九韶算法/Horner 规则</h5>
<p><span
class="math inline">\(A(x)=a_{n}x_{n}+a_{n−1}x_{n−1}+...+a_{1}x+a_{0}\)</span>
在 <span class="math inline">\(x_{0}\)</span> 处的值相当于 <span
class="math inline">\(a_0+x_0(a_{1}+...+x_{0}(a_{n−1}+x_{0}a_{n}))\)</span></p>
<h5 id="大数相乘">大数相乘</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java">#include &lt;stdio.h&gt;  <br>#include &lt;string.h&gt;  <br>  <br>#define MAX <span class="hljs-number">1000005</span>  <br><span class="hljs-type">char</span> s1[MAX], s2[MAX];  <br><span class="hljs-type">int</span> a1[MAX], a2[MAX], ans[MAX];  <br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-type">int</span> n;  <br>    scanf(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);  <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> z=<span class="hljs-number">0</span>; z&lt;n; z++)&#123;  <br>        <span class="hljs-type">int</span> i, j, len1, len2;  <br>        scanf(<span class="hljs-string">&quot;%s%s&quot;</span>, s1, s2);  <br>        len1 = strlen(s1);  <br>        len2 = strlen(s2);  <br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; len1; i++) &#123; <span class="hljs-comment">// 转化成数字后逆序存储</span><br>            a1[i] = s1[len1 - <span class="hljs-number">1</span> - i] - <span class="hljs-string">&#x27;0&#x27;</span>;  <br>        &#125;  <br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; len2; i++) &#123; <span class="hljs-comment">// 转化成数字后逆序存储</span><br>            a2[i] = s2[len2 - <span class="hljs-number">1</span> - i] - <span class="hljs-string">&#x27;0&#x27;</span>;  <br>        &#125;  <br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; len1; i++) &#123;  <br>            <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; len2; j++) &#123;  <br>                ans[i + j] += a1[i] * a2[j];  <br>            &#125;  <br>        &#125;  <br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; i &lt; len1 + len2; i++) &#123;  <br>            ans[i] += j;  <br>            j = ans[i] / <span class="hljs-number">10</span>; <span class="hljs-comment">// 8进制就把10换成8</span><br>            ans[i] %= <span class="hljs-number">10</span>; <span class="hljs-comment">// 8进制就把10换成8</span><br>        &#125;  <br>        <span class="hljs-type">int</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;  <br>        <span class="hljs-keyword">for</span> (; ans[i] == <span class="hljs-number">0</span>; i--)&#123; <span class="hljs-comment">//跳过前面的0  </span><br>            <span class="hljs-keyword">if</span>(i&lt;<span class="hljs-number">0</span>)&#123; <span class="hljs-comment">// 大数相乘结果本身就是0</span><br>                printf(<span class="hljs-string">&quot;0&quot;</span>);  <br>                puts(<span class="hljs-string">&quot;&quot;</span>);  <br>                flag = <span class="hljs-number">1</span>;  <br>                <span class="hljs-keyword">break</span>;  <br>            &#125;  <br>        &#125;       <br>        <span class="hljs-keyword">if</span>(flag == <span class="hljs-number">0</span>)&#123;  <br>            <span class="hljs-keyword">for</span> (; i &gt;= <span class="hljs-number">0</span>; i--) &#123; <span class="hljs-comment">// 逆序输出</span><br>                printf(<span class="hljs-string">&quot;%d&quot;</span>, ans[i]);  <br>                ans[i] = <span class="hljs-number">0</span>;  <br>            &#125;  <br>            puts(<span class="hljs-string">&quot;&quot;</span>);  <br>        &#125;  <br>    &#125;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="随机数">随机数</h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 生成0-99的随机数</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">Rand</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">rand</span>()%<span class="hljs-number">100</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="模逆元">模逆元</h5>
<p>模逆元：<span class="math inline">\(a×x≡1 (mod m)\)</span>
如果p是一个质数，a是任意整数，且a不是p的倍数，那么a的模逆元可以表示为：<span
class="math inline">\(a^{-1} \equiv a^{p-2} \ (\text{mod} \ p)\)</span>
即 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">qmi</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> mom, <span class="hljs-type">long</span> <span class="hljs-type">long</span> b, <span class="hljs-type">long</span> <span class="hljs-type">long</span> mod)</span></span>&#123; <span class="hljs-comment">// 快速幂函数</span><br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> res = <span class="hljs-number">1</span>;  <br>    <span class="hljs-keyword">while</span>(b)&#123;  <br>        <span class="hljs-keyword">if</span>(b &amp; <span class="hljs-number">1</span>) res = res * mom % mod;  <br>        b &gt;&gt;= <span class="hljs-number">1</span>;  <br>        mom = mom * mom % mod;  <br>    &#125;  <br>    <span class="hljs-keyword">return</span> res;  <br>&#125;<br>x = <span class="hljs-built_in">qmi</span>(a, MOD<span class="hljs-number">-2</span>, MOD); <span class="hljs-comment">//x是a在mod MOD下的逆元</span><br></code></pre></td></tr></table></figure></p>
<h5 id="more">MORE……</h5>
<ul>
<li>双指针 left 和 right</li>
</ul>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%BB%8F%E9%AA%8C/" class="category-chain-item">学习经验</a>
  
  
    <span>></span>
    
  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%BB%8F%E9%AA%8C/%E5%A4%A7%E4%BA%8C%E4%B8%8A/" class="category-chain-item">大二上</a>
  
  

  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E5%AD%A6%E4%B9%A0%E7%BB%8F%E9%AA%8C/" class="print-no-link">#学习经验</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>【学习经验】算法板子</div>
      <div>http://example.com/2025/01/10/LE-suanfabanzi/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>Author</div>
          <div>John Doe</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>Posted on</div>
          <div>January 10, 2025</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>Licensed under</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - Attribution">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2025/01/10/LE-OOP1/" title="【学习经验】OOP复习">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">【学习经验】OOP复习</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2024/10/25/jwsy-dianWeiCha/" title="【学习经验】电位差预习报告">
                        <span class="hidden-mobile">【学习经验】电位差预习报告</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>
  </div>
</div>





  



  



  



  



  


  
  









    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">Keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
    <!-- 备案信息 ICP for China -->
    <div class="beian">
  <span>
    <a href="http://beian.miit.gov.cn/" target="_blank" rel="nofollow noopener">
      京ICP备2024049620号
    </a>
  </span>
  
</div>

  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  
      <script>
        if (!window.MathJax) {
          window.MathJax = {
            tex    : {
              inlineMath: { '[+]': [['$', '$']] }
            },
            loader : {
              load: ['ui/lazy']
            },
            options: {
              renderActions: {
                insertedScript: [200, () => {
                  document.querySelectorAll('mjx-container').forEach(node => {
                    let target = node.parentNode;
                    if (target.nodeName.toLowerCase() === 'li') {
                      target.parentNode.classList.add('has-jax');
                    }
                  });
                }, '', false]
              }
            }
          };
        } else {
          MathJax.startup.document.state(0);
          MathJax.texReset();
          MathJax.typeset();
          MathJax.typesetPromise();
        }

        Fluid.events.registerRefreshCallback(function() {
          if ('MathJax' in window && MathJax.startup.document && typeof MathJax.startup.document.state === 'function') {
            MathJax.startup.document.state(0);
            MathJax.texReset();
            MathJax.typeset();
            MathJax.typesetPromise();
          }
        });
      </script>
    

  <script  src="https://lib.baomitu.com/mathjax/3.2.2/es5/tex-mml-chtml.js" ></script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="/js/leancloud.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">Blog works best with JavaScript enabled</div>
  </noscript>
</body>
</html>
