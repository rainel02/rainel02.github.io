

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/icon02.jpg">
  <link rel="icon" href="/img/icon02.jpg">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  
    <meta name="description" content="1 java基础 23 1.1 关键字和保留字  1.2 浅拷贝、深拷贝、引用  基本数据类型（如 int long long boolean ）都是深拷贝：复制内容 类的拷贝默认是浅拷贝（拷贝引用），需要深拷贝可以使用 clone() 方法、序列化机制或手动创建新的对象。  【输出】5  【输出】10  1.3 构造与垃圾回收 构造函数  特点：与类同名，无返回值（也">
<meta property="og:type" content="article">
<meta property="og:title" content="【学习经验】OOP复习">
<meta property="og:url" content="http://example.com/2025/01/10/LE-OOP1/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="1 java基础 23 1.1 关键字和保留字  1.2 浅拷贝、深拷贝、引用  基本数据类型（如 int long long boolean ）都是深拷贝：复制内容 类的拷贝默认是浅拷贝（拷贝引用），需要深拷贝可以使用 clone() 方法、序列化机制或手动创建新的对象。  【输出】5  【输出】10  1.3 构造与垃圾回收 构造函数  特点：与类同名，无返回值（也">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/img/LE-OOP1/1.png">
<meta property="og:image" content="http://example.com/img/LE-OOP1/2.png">
<meta property="og:image" content="http://example.com/img/LE-OOP1/4.png">
<meta property="og:image" content="http://example.com/img/LE-OOP1/5.png">
<meta property="og:image" content="http://example.com/img/LE-OOP1/6.png">
<meta property="og:image" content="http://example.com/img/LE-OOP1/8.png">
<meta property="og:image" content="http://example.com/img/LE-OOP1/11.png">
<meta property="og:image" content="http://example.com/img/LE-OOP1/12.png">
<meta property="og:image" content="http://example.com/img/LE-OOP1/14.png">
<meta property="og:image" content="http://example.com/img/LE-OOP1/16.png">
<meta property="og:image" content="http://example.com/img/LE-OOP1/17.png">
<meta property="og:image" content="http://example.com/img/LE-OOP1/18.png">
<meta property="og:image" content="http://example.com/img/LE-OOP1/19.png">
<meta property="og:image" content="http://example.com/img/LE-OOP1/20.png">
<meta property="og:image" content="http://example.com/img/LE-OOP1/21.png">
<meta property="og:image" content="http://example.com/img/LE-OOP1/23.png">
<meta property="og:image" content="http://example.com/img/LE-OOP1/24.png">
<meta property="og:image" content="http://example.com/img/LE-OOP1/25.png">
<meta property="og:image" content="http://example.com/img/LE-OOP1/26.png">
<meta property="og:image" content="http://example.com/img/LE-OOP1/27.png">
<meta property="og:image" content="http://example.com/img/LE-OOP1/28.png">
<meta property="og:image" content="http://example.com/img/LE-OOP1/29.png">
<meta property="og:image" content="http://example.com/img/LE-OOP1/42.png">
<meta property="og:image" content="http://example.com/img/LE-OOP1/43.png">
<meta property="og:image" content="http://example.com/img/LE-OOP1/44.png">
<meta property="og:image" content="http://example.com/img/LE-OOP1/45.png">
<meta property="og:image" content="http://example.com/img/LE-OOP1/46.png">
<meta property="og:image" content="http://example.com/img/LE-OOP1/47.png">
<meta property="og:image" content="http://example.com/img/LE-OOP1/48.png">
<meta property="og:image" content="http://example.com/img/LE-OOP1/49.png">
<meta property="og:image" content="http://example.com/img/LE-OOP1/51.png">
<meta property="og:image" content="http://example.com/img/LE-OOP1/52.png">
<meta property="og:image" content="http://example.com/img/LE-OOP1/53.png">
<meta property="og:image" content="http://example.com/img/LE-OOP1/54.png">
<meta property="og:image" content="http://example.com/img/LE-OOP1/55.png">
<meta property="og:image" content="http://example.com/img/LE-OOP1/56.png">
<meta property="og:image" content="http://example.com/img/LE-OOP1/57.png">
<meta property="og:image" content="http://example.com/img/LE-OOP1/58.png">
<meta property="og:image" content="http://example.com/img/LE-OOP1/59.png">
<meta property="og:image" content="http://example.com/img/LE-OOP1/60.png">
<meta property="og:image" content="http://example.com/img/LE-OOP1/61.png">
<meta property="og:image" content="http://example.com/img/LE-OOP1/62.png">
<meta property="og:image" content="http://example.com/img/LE-OOP1/63.png">
<meta property="og:image" content="http://example.com/img/LE-OOP1/65.png">
<meta property="og:image" content="http://example.com/img/LE-OOP1/66.png">
<meta property="og:image" content="http://example.com/img/LE-OOP1/67.png">
<meta property="og:image" content="http://example.com/img/LE-OOP1/68.png">
<meta property="og:image" content="http://example.com/img/LE-OOP1/69.png">
<meta property="og:image" content="http://example.com/img/LE-OOP1/70.png">
<meta property="og:image" content="http://example.com/img/LE-OOP1/71.png">
<meta property="og:image" content="http://example.com/img/LE-OOP1/72.png">
<meta property="og:image" content="http://example.com/img/LE-OOP1/73.png">
<meta property="og:image" content="http://example.com/img/LE-OOP1/74.png">
<meta property="og:image" content="http://example.com/img/LE-OOP1/75.png">
<meta property="og:image" content="http://example.com/img/LE-OOP1/76.png">
<meta property="og:image" content="http://example.com/img/LE-OOP1/77.png">
<meta property="og:image" content="http://example.com/img/LE-OOP1/78.png">
<meta property="og:image" content="http://example.com/img/LE-OOP1/79.png">
<meta property="og:image" content="http://example.com/img/LE-OOP1/80.png">
<meta property="og:image" content="http://example.com/img/LE-OOP1/81.png">
<meta property="og:image" content="http://example.com/img/LE-OOP1/82.png">
<meta property="og:image" content="http://example.com/img/LE-OOP1/83.png">
<meta property="og:image" content="http://example.com/img/LE-OOP1/85.png">
<meta property="og:image" content="http://example.com/img/LE-OOP1/86.png">
<meta property="og:image" content="http://example.com/img/LE-OOP1/88.png">
<meta property="og:image" content="http://example.com/img/LE-OOP1/89.png">
<meta property="og:image" content="http://example.com/img/LE-OOP1/90.png">
<meta property="og:image" content="http://example.com/img/LE-OOP1/91.png">
<meta property="og:image" content="http://example.com/img/LE-OOP1/93.png">
<meta property="og:image" content="http://example.com/img/LE-OOP1/96.png">
<meta property="og:image" content="http://example.com/img/LE-OOP1/97.png">
<meta property="og:image" content="http://example.com/img/LE-OOP1/98.png">
<meta property="og:image" content="http://example.com/img/LE-OOP1/100.png">
<meta property="og:image" content="http://example.com/img/LE-OOP1/101.png">
<meta property="og:image" content="http://example.com/img/LE-OOP1/102.png">
<meta property="og:image" content="http://example.com/img/LE-OOP1/103.png">
<meta property="og:image" content="http://example.com/img/LE-OOP1/104.png">
<meta property="og:image" content="http://example.com/img/LE-OOP1/105.png">
<meta property="og:image" content="http://example.com/img/LE-OOP1/106.png">
<meta property="og:image" content="http://example.com/img/LE-OOP1/107.png">
<meta property="og:image" content="http://example.com/img/LE-OOP1/108.png">
<meta property="og:image" content="http://example.com/img/LE-OOP1/109.png">
<meta property="og:image" content="http://example.com/img/LE-OOP1/111.png">
<meta property="og:image" content="http://example.com/img/LE-OOP1/112.png">
<meta property="og:image" content="http://example.com/img/LE-OOP1/113.png">
<meta property="og:image" content="http://example.com/img/LE-OOP1/114.png">
<meta property="og:image" content="http://example.com/img/LE-OOP1/117.png">
<meta property="og:image" content="http://example.com/img/LE-OOP1/119.png">
<meta property="og:image" content="http://example.com/img/LE-OOP1/121.png">
<meta property="og:image" content="http://example.com/img/LE-OOP1/122.png">
<meta property="og:image" content="http://example.com/img/LE-OOP1/123.png">
<meta property="og:image" content="http://example.com/img/LE-OOP1/124.png">
<meta property="og:image" content="http://example.com/img/LE-OOP1/126.png">
<meta property="og:image" content="http://example.com/img/LE-OOP1/127.png">
<meta property="article:published_time" content="2025-01-10T04:26:19.000Z">
<meta property="article:modified_time" content="2025-01-10T04:33:08.349Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="学习经验">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://example.com/img/LE-OOP1/1.png">
  
  
  
  <title>【学习经验】OOP复习 - Hexo</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.7","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"left","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.2.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Rainel</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>Home</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>Archives</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>Categories</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>Tags</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>About</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/" target="_self">
                <i class="iconfont icon-link-fill"></i>
                <span>Links</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/bg/p2.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="【学习经验】OOP复习"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-01-10 12:26" pubdate>
          January 10, 2025 pm
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          24k words
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          204 mins
        
      </span>
    

    
    
      
        <span id="leancloud-page-views-container" class="post-meta" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="leancloud-page-views"></span> views
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="padding-left: 2rem; margin-right: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>Table of Contents</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">【学习经验】OOP复习</h1>
            
            
              <div class="markdown-body">
                
                <h2 id="java基础-23">1 java基础 23</h2>
<h3 id="关键字和保留字">1.1 关键字和保留字</h3>
<p><img src="/img/LE-OOP1/1.png" srcset="/img/loading.gif" lazyload /></p>
<h3 id="浅拷贝深拷贝引用">1.2 浅拷贝、深拷贝、引用</h3>
<ul>
<li><strong>基本数据类型</strong>（如 <code>int</code>
<code>long long</code> <code>boolean</code>
）都是<strong>深拷贝</strong>：复制内容</li>
<li><strong>类</strong>的拷贝默认是<strong>浅拷贝</strong>（拷贝引用），需要深拷贝可以使用 <code>clone()</code> 方法、序列化机制或手动创建新的对象。
<img src="/img/LE-OOP1/2.png" srcset="/img/loading.gif" lazyload /> 【输出】5 <img
src="/img/LE-OOP1/3.png" srcset="/img/loading.gif" lazyload /> 【输出】10</li>
</ul>
<h3 id="构造与垃圾回收">1.3 构造与垃圾回收</h3>
<h5 id="构造函数">构造函数</h5>
<ul>
<li>特点：与类同名，无返回值（也不是 void）、多数情况要重载</li>
<li><strong>new</strong>
的作用：<strong>分配空间；调用构造；返回引用</strong></li>
</ul>
<h6 id="不带参数构造函数默认构造函数">不带参数构造函数/默认构造函数</h6>
<ul>
<li>如果类的定义者<strong>没有显式的定义任何构造方法</strong>，系统将自动提供一个<strong>默认的构造方法（无参无方法）</strong>；如果定义了构造函数，则不会创建默认构造方法。</li>
<li>无参构造函数创建对象时，成员变量的值被赋予了数据类型的<strong>隐含初值</strong>。</li>
</ul>
<h6 id="带参数构造函数">带参数构造函数</h6>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Teacher6</span> &#123;<br>	<span class="hljs-keyword">private</span> String name;	<span class="hljs-comment">// 教员姓名</span><br>	<span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;		<span class="hljs-comment">// 年龄   </span><br>	<span class="hljs-keyword">private</span> String education;	<span class="hljs-comment">// 学历</span><br>	<span class="hljs-keyword">private</span> String position;	<span class="hljs-comment">// 职位</span><br>	<span class="hljs-comment">// 带参数的构造方法</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-title function_">Teacher6</span><span class="hljs-params">(String pName,<span class="hljs-type">int</span> pAge,String pEducation,String pPosition)</span> &#123;<br>        name = pName;<br>        age = pAge;    <span class="hljs-comment">// 可以增加对age等属性的存取限制条件</span><br>        education = pEducation;<br>        position = pPosition;<br>    &#125;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">introduction</span><span class="hljs-params">()</span> &#123;<br>    	<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;大家好！我是&quot;</span> + name + <span class="hljs-string">&quot;，我今年&quot;</span> + age + <span class="hljs-string">&quot;岁，学历&quot;</span> + education + <span class="hljs-string">&quot;，目前职位是&quot;</span>+position;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Teacher6Test</span> &#123;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Teacher6</span> <span class="hljs-variable">teacher</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Teacher6</span>(<span class="hljs-string">&quot;Mary&quot;</span>, <span class="hljs-number">23</span>, <span class="hljs-string">&quot;本科&quot;</span>, <span class="hljs-string">&quot;咨询师&quot;</span>);<br>        System.out.println(teacher.introduction());<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="垃圾内存自动回收机制">垃圾内存自动回收机制</h5>
<ul>
<li>垃圾自动回收机制（Garbage Collection）：Java 虚拟机后台线程负责</li>
<li>System.gc() 和 Runtime.gc()</li>
<li>判断存储单元是否为垃圾的依据：<strong>引用计数为 0</strong></li>
</ul>
<h3 id="匿名对象">1.4 匿名对象</h3>
<ul>
<li>匿名对象：无管理者（无栈内存引用指向它）</li>
<li>使用场景：<strong>只需要进行一次方法调用</strong> /
<strong>作为参数</strong>传递给函数 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Student</span> <span class="hljs-variable">stu</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<span class="hljs-comment">//stu是对象，名字是stu</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<span class="hljs-comment">//这个也是一个对象，但是没有名字，称为匿名对象</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>().show(); <span class="hljs-comment">//匿名对象方法调用</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="类的定义">1.5 <span
style="background:rgba(140, 140, 140, 0.12)">类的定义</span></h3>
<h6 id="类的定义-1">类的定义</h6>
<ul>
<li>类的定义格式 <img src="/img/LE-OOP1/4.png" srcset="/img/loading.gif" lazyload /></li>
<li>访问控制符：<code>public</code>或默认（即没有访问控制符）
<code>public</code>类一般含有<code>main</code>方法</li>
<li>类型说明符：<code>final</code>和<code>abstract</code></li>
</ul>
<h6 id="成员变量定义">成员变量定义</h6>
<ul>
<li>定义格式：<code>[修饰符] 变量的数据类型 变量名[=初始值]</code></li>
<li>常用的修饰符：<code>this</code>、<code>static</code>、<code>public</code>、<code>private</code>、<code>protected</code>、默认</li>
</ul>
<h6 id="成员方法的定义">成员方法的定义</h6>
<ul>
<li>定义格式 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"> [修饰符] 返回值类型 方法名([形参说明])[thorws 例外名<span class="hljs-number">1</span>，例外名<span class="hljs-number">2.</span>..]&#123;<br>局部变量声明;<br>执行语句组;<br> &#125;<br></code></pre></td></tr></table></figure></li>
<li>常用的修饰符：<code>public</code>、<code>private</code>、<code>protected</code>、<code>static</code>、<code>final</code></li>
</ul>
<h6 id="成员变量vs局部变量">成员变量vs局部变量</h6>
<ul>
<li>初始化不同：<strong>自动初始化只用于成员变量</strong>；方法体中的局部变量不能被自动初始化，必须赋值后才能使用。</li>
<li>定义的位置不同：定义在类中的变量是成员变量；定义在方法中或者{}语句里面的变量是局部变量。</li>
<li>在内存中的位置不同：<strong>成员变量</strong>存储在<strong>堆</strong>内存的对象中；<strong>局部变量</strong>存储在<strong>栈</strong>内存的方法中。</li>
<li>声明周期不同：成员变量<strong>随着对象</strong>的出现而出现在堆中，随着对象的消失而从堆中消失；局部变量<strong>随着方法</strong>的运行而出现在栈中，随着方法的弹栈而消失。</li>
</ul>
<h6 id="方法的重载">方法的重载</h6>
<ol type="1">
<li>方法的重载是指一个类中可以定义有<strong>相同的名字</strong>，但<strong>参数不同</strong>的多个方法，调用时会根据不同的参数表选择对应的方法。</li>
<li>重载方法必须满足以下条件：
<ul>
<li>方法名相同。</li>
<li>方法的<strong>参数类型、个数、顺序</strong>至少有一项不相同。</li>
<li>方法的<strong>返回类型可以</strong>不相同。</li>
<li>方法的<strong>修饰符可以</strong>不相同。</li>
</ul></li>
<li>调用重载方法时，Java使用参数的类型和数量决定实际调用重载方法的哪个版本。</li>
</ol>
<h3 id="tostring方法">1.6 <span
style="background:rgba(140, 140, 140, 0.12)">toString()方法</span></h3>
<ul>
<li>在java中，所有对象都有默认的<code>toString()</code>这个方法</li>
<li>创建类时没有定义<code>toString()</code>方法，输出对象时会输出对象的哈希码值（<strong>对象的内存地址</strong>）</li>
<li>它通常只是为了方便输出，比如<code>System.out.println(xx)</code>，（xx是对象），括号里面的”xx”如果不是String类型的话，就自动调用xx的<code>toString()</code>方法</li>
<li><code>toString()</code>的定义格式 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span>&#123;<br>	<span class="hljs-keyword">return</span> 字符串;		<span class="hljs-comment">// 方法体</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="静态属性和静态方法">1.7 静态属性和静态方法</h3>
<p><img src="/img/LE-OOP1/5.png" srcset="/img/loading.gif" lazyload /> + 用 <code>static</code> 修饰 +
不创建具体对象也存在，此时可以通过 <code>类名.类变量</code> 或
<code>类名.类方法</code> + 静态方法与非静态方法的区别 +
静态方法是在类中使用staitc修饰的方法，在<strong>类定义</strong>的时候已经被<strong>装载和分配</strong>(早加载)。而非静态方法是不加static关键字的方法，在类定义时没有占用内存，只有在类被<strong>实例化成对象时</strong>，对象调用该方法才被<strong>分配内存</strong>（晚加载）。
+
<strong>静态方法</strong>中<strong>只能直接调用静态成员或者方法</strong>，不能直接调用非静态方法或者非静态成员（非静态方法要被实例化才能被静态方法调用），而非静态方法既可以调用静态成员或者方法又可以调用其他的非静态成员或者方法。</p>
<ul>
<li>静态代码块
<ul>
<li>静态代码块只能定义在类里面，它独立于任何方法，<strong>不能定义在方法里面</strong>。</li>
<li>静态代码块里面声明的变量都是局部变量，只在<strong>本块内有效</strong>。</li>
<li>静态代码块会在<strong>类被加载时自动执行</strong>，而无论加载者是JVM还是其他的类。</li>
<li>一个类中允许定义多个静态代码块，<strong>执行的顺序根据定义的顺序进行</strong>。</li>
<li>静态代码块只能访问类的<strong>静态成员</strong>，而不允许访问实例成员。</li>
</ul></li>
<li>静态代码块与非静态代码块的不同点：
<ul>
<li>静态代码块在非静态代码块之前执行：静态代码块—&gt;非静态代码块—&gt;构造方法</li>
<li>静态代码块<strong>只在第一次new执行一次</strong>，之后不再执行，而非静态代码块在每new一次就执行一次</li>
</ul></li>
</ul>
<h6 id="例静态方法">例：静态方法</h6>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br>	<span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span>&#123;    <span class="hljs-comment">// 非静态方法</span><br>		<span class="hljs-keyword">return</span> a+b;<br>	&#125;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>		<span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> (sum1, <span class="hljs-number">2</span>);    <span class="hljs-comment">// 静态方法调用非静态方法，报错</span><br>		System.out.println(<span class="hljs-string">&quot;result=&quot;</span>+result);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h6 id="例静态代码块">例：静态代码块</h6>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PuTong</span>&#123;<br>	<span class="hljs-keyword">public</span> <span class="hljs-title function_">PuTong</span><span class="hljs-params">()</span>&#123;<br>		System.out.println(<span class="hljs-string">&quot;默认构造方法！--&gt;&quot;</span>);<br>	&#125;<br>	<span class="hljs-comment">// 非静态代码块</span><br>	&#123;<br>		System.out.println(<span class="hljs-string">&quot;非静态代码块！--&gt;&quot;</span>);<br>	&#125;<br>	<span class="hljs-comment">// 静态代码块</span><br>	<span class="hljs-keyword">static</span>&#123;<br>		System.out.println(<span class="hljs-string">&quot;静态代码块！--&gt;&quot;</span>);<br>	&#125;<br>	<span class="hljs-comment">// 静态成员方法</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br>		System.out.println(<span class="hljs-string">&quot;普通方法中的代码块！--&gt;&quot;</span>);<br>	&#125;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>		<span class="hljs-type">PuTong</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PuTong</span>();<br>		c1.test();<br>		<span class="hljs-type">PuTong</span> <span class="hljs-variable">c2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PuTong</span>();<br>		c2.test();<br>	&#125;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">【输出】</span><br><span class="hljs-comment">静态代码块！--&gt;</span><br><span class="hljs-comment">非静态代码块！--&gt;</span><br><span class="hljs-comment">默认构造方法！--&gt;</span><br><span class="hljs-comment">普通方法中的代码块！--&gt;</span><br><span class="hljs-comment">非静态代码块！--&gt;</span><br><span class="hljs-comment">默认构造方法！--&gt;</span><br><span class="hljs-comment">普通方法中的代码块！--&gt;</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>
<h3 id="equals-和">1.8 <code>equals</code> 和 <code>==</code></h3>
<ul>
<li>比较<strong>对象</strong>的equals和==是等价的，判断<strong>是不是引用的同一个对象</strong>。</li>
<li><strong>String</strong>的<strong>equals</strong>只看<strong>字符串内容</strong>是否相等，而==还得看是不是<strong>同一个对象</strong>。（覆盖了Object类的equals()方法，java.io.File、java.util.Date、包装类（如java.lang.Integer和java.lang.Double类等）同理）
<img src="/img/LE-OOP1/6.png" srcset="/img/loading.gif" lazyload /></li>
</ul>
<blockquote>
<p><code>Integer a = 1;</code> <code>Integer b = 1;</code>
<code>System.out.println(a == b); // 输出 true</code>
这行输出 <code>true</code> 是因为 <code>Integer</code> 有一个缓存机制，对于 <code>-128</code> 到 <code>127</code> 之间的整数，<code>Integer</code> 会缓存这些值的实例。当你使用 <code>Integer a = 1;</code> 和 <code>Integer b = 1;</code> 这样的方式创建对象时，<code>a</code> 和 <code>b</code> 实际上指向了缓存中的同一个 <code>Integer</code> 实例。因此，<code>a == b</code> 比较的是同一个实例的引用，结果为 <code>true</code>。
1.
<strong>Byte</strong>：由于Byte的值范围在-128到127之间，所以所有的Byte值都被缓存。
2.
<strong>Short</strong>和<strong>Integer</strong>：这两个类的缓存机制类似，都有默认的缓存范围，通常是-128到127。但是这个范围是可以调整的，通过JVM参数可以设置缓存的最大值。
3.
<strong>Long</strong>：Long类型也有缓存机制，但是默认的缓存范围比较小，通常是-128到127。同样，这个范围也可以通过JVM参数进行调整。
4.
<strong>Character</strong>：Character类型缓存了ASCII字符，即0到127的字符。
5.
<strong>Boolean</strong>：Boolean类型比较特殊，它只有两个值true和false，这两个值都是缓存好的。
6.
<strong>Float</strong>和<strong>Double</strong>：这两个类型没有缓存机制，因为浮点数的取值范围非常大，缓存所有的值是不现实的
## 2 封装 4 ### 2.1 封装的含义</p>
</blockquote>
<ol type="1">
<li>一层含义是<strong>把对象的属性和行为看成为一个密不可分的整体</strong>，将这两者封装在一个不可分割的独立单位（即对象）中。</li>
<li>另一层含义指<strong>信息隐藏</strong>，把不需要让外界知道的信息隐藏起来，有些对象的属性及行为允许外界用户知道或使用，但不允许更改，而另一些属性和行为则不允许外界知晓或只允许使用对象的功能，而尽可能隐藏对象的功能实现细节。</li>
</ol>
<h3 id="信息隐藏的必要性">2.2 信息隐藏的必要性</h3>
<p>成员变量封装加上
<code>private</code>，对外提供公开的用于设置对象属性的
<code>public</code> 方法，并在方法中加上逻辑判断，过滤掉非法数据，从而：
+ <strong>隐藏了类的具体实现</strong> + <strong>操作简单</strong> +
<strong>提高对象数据的安全性</strong> +
<strong>减少了冗余代码</strong>，数据校验等写在方法里，可以复用</p>
<h3 id="访问控制修饰符">2.3 <span
style="background:#ff4d4f">访问控制修饰符</span></h3>
<p>访问控制分四种类别： + 公开 <code>public</code> 对外公开。 + 受保护
<code>protected</code>
向<strong>子类</strong>以及<strong>同一个包中的类</strong>公开。 + 默认
向<strong>同一个包中的类</strong>公开。 + 私有 <code>private</code>
只有类本身可以访问，不对外公开</p>
<table>
<thead>
<tr class="header">
<th>修饰符</th>
<th>同一个类</th>
<th>同一个包</th>
<th>子类</th>
<th>整体</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>private</code></td>
<td>yeah</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td><code>default</code></td>
<td>yeah</td>
<td>yeah</td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td><code>protected</code></td>
<td>yeah</td>
<td>yeah</td>
<td>yeah</td>
<td></td>
</tr>
<tr class="even">
<td><code>public</code></td>
<td>yeah</td>
<td>yeah</td>
<td>yeah</td>
<td>yeah</td>
</tr>
</tbody>
</table>
<h4 id="protected">2.3.1 <code>protected</code></h4>
<h6 id="包内可见">1 包内可见</h6>
<h6
id="子类可见子类和父类在同一个包通过自己访问通过父类访问在不同包仅可通过自己访问">2
子类可见（子类和父类在同一个包：通过自己访问、通过父类访问。在不同包：仅可通过自己访问。）</h6>
<p>若子类与父类<strong>不在同一包</strong>中，那么在子类中 +
<strong>子类实例</strong>可以访问其从父类继承而来的<code>protected</code>方法
+ 不能访问<strong>父类实例</strong>的<code>protected</code>方法 +
不能通过<strong>另一个子类引用</strong>访问共同基类的<code>protected</code>方法。
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 父类</span><br><span class="hljs-keyword">package</span> com.protectedaccess.parentpackage;  <br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Parent</span>&#123;  <br>	<span class="hljs-keyword">protected</span> <span class="hljs-type">String</span> <span class="hljs-variable">protect</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;protect field&quot;</span>;  <br>	<span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getMessages</span><span class="hljs-params">()</span>&#123;  <br>		System.out.println(<span class="hljs-string">&quot;i am parent&quot;</span>);  <br>	&#125;  <br>&#125;<br></code></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 不同包下，可以访问其从父类继承而来的`protected`方法</span><br><span class="hljs-keyword">package</span> com.protectedaccess.parentpackage.sonpackage1;  <br><span class="hljs-keyword">import</span> com.protectedaccess.parentpackage.Parent;  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">son1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Parent</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>        <span class="hljs-type">Son1</span> <span class="hljs-variable">son1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Son1</span>();  <br>        son1.getMessage();  <span class="hljs-comment">// 输出：i am parent  </span><br>    &#125;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">message</span><span class="hljs-params">()</span> &#123;  <br>        getMessage();  <span class="hljs-comment">// 如果子类重写了该方法，则输出重写方法中的内容  </span><br>        <span class="hljs-built_in">super</span>.getMessage();  <span class="hljs-comment">// 输出父类该方法中的内容  </span><br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 不同包下，不能访问**父类实例**的`protected`方法</span><br><span class="hljs-keyword">package</span> com.protectedaccess.parentpackage.sonpackage1;  <br><span class="hljs-keyword">import</span> com.protectedaccess.parentpackage.Parent;  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">son1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Parent</span> &#123;  <br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>		<span class="hljs-type">Parent</span> <span class="hljs-variable">parent1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Parent</span>();  <br>		<span class="hljs-comment">// parent1.getMessage(); // 错误  </span><br>		<span class="hljs-type">Parent</span> <span class="hljs-variable">parent2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Parent</span>();  <br>		<span class="hljs-comment">// parent2.getMessage(); // 错误  </span><br>	&#125;  <br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 不同包下，不能通过**另一个子类引用**访问共同基类的`protected`方法。</span><br><span class="hljs-keyword">package</span> com.protectedaccess.parentpackage.sonpackage2;  <br><span class="hljs-keyword">import</span> com.protectedaccess.parentpackage.Parent;  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">son2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Parent</span> &#123;  <br>  <br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.protectedaccess.parentpackage.sonpackage1;  <br><span class="hljs-keyword">import</span> com.protectedaccess.parentpackage.Parent;  <br><span class="hljs-keyword">import</span> com.protectedaccess.parentpackage.sonpackage2.Son2;  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">son1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Parent</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>        <span class="hljs-type">Son2</span> <span class="hljs-variable">son2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Son2</span>();  <br>        <span class="hljs-comment">// son2.getMessage();  // 错误  </span><br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure>
<h6 id="protected-的-static-成员对所有子类可见">3 protected 的 static
成员对所有子类可见。</h6>
<p>对于<code>protected</code>修饰的静态变量，无论是否同一个包，在子类中均可直接访问；在不同包的非子类中则不可访问。
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 父类</span><br><span class="hljs-keyword">package</span> com.protectedaccess.parentpackage;  <br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Parent</span>&#123;  <br>	<span class="hljs-keyword">protected</span> <span class="hljs-type">String</span> <span class="hljs-variable">protect</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;protect field&quot;</span>;  <br>	<span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getMessages</span><span class="hljs-params">()</span>&#123;  <br>		System.out.println(<span class="hljs-string">&quot;i am parent&quot;</span>);  <br>	&#125;  <br>&#125;<br></code></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 无论是否同一个包，在子类中均可直接访问</span><br><span class="hljs-keyword">package</span> com.protectedaccess.parentpackage.sonpackage1;  <br><span class="hljs-keyword">import</span> com.protectedaccess.parentpackage.Parent;  <br>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">son3</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Parent</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>        Parent.getMessage();    <span class="hljs-comment">// 输出：i am parent  </span><br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 在不同包的非子类中则不可访问</span><br><span class="hljs-keyword">package</span> com.protectedaccess.parentpackage.sonpackage1;  <br><span class="hljs-keyword">import</span> com.protectedaccess.parentpackage.Parent;  <br>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">son4</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>        <span class="hljs-comment">// Parent.getMessage();    // 错误  </span><br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="继承-5">3 继承 5</h2>
<ul>
<li><strong>定义</strong>:
继承是允许创建新的类（子类）来继承现有类（父类）的属性和行为的能力。</li>
<li><strong>目的</strong>:
<ul>
<li><strong>代码复用</strong>:
子类可以继承父类的所有属性和方法，无需重复编写代码，提高代码的可重用性。</li>
<li><strong>扩展功能</strong>:
子类可以添加新的属性和方法，或重写父类的方法，扩展父类的功能。</li>
<li><strong>层次结构</strong>:
继承可以创建类层次结构，清晰地表达类之间的关系，使代码更易于理解和维护。</li>
</ul></li>
<li><strong>类型</strong>:
<ul>
<li><strong>单继承</strong>: 一个子类只有一个父类。</li>
<li><strong>多继承</strong>: 一个子类可以有多个父类（Java
不支持多继承）。</li>
<li><strong>接口继承</strong>:
子接口可以继承父接口的方法，并添加新的方法。 <img
src="/img/LE-OOP1/7.png" srcset="/img/loading.gif" lazyload /> <img src="/img/LE-OOP1/8.png" srcset="/img/loading.gif" lazyload /> <img
src="/img/LE-OOP1/9.png" srcset="/img/loading.gif" lazyload /></li>
</ul></li>
</ul>
<h2 id="多态-6">4 多态 6</h2>
<ul>
<li><p><strong>定义</strong>:
多态是指同一个行为具有多个不同表现形式或形态的能力。</p></li>
<li><p><strong>目的</strong>:</p>
<ul>
<li><strong>灵活性</strong>:
允许以统一的方式处理不同类型的对象，提高代码的灵活性和可扩展性。</li>
<li><strong>抽象性</strong>:
可以隐藏对象的实际类型，只关注其共同的行为，提高代码的抽象性。</li>
</ul></li>
<li><p><strong>实现方式</strong>:</p>
<ul>
<li><strong>方法重载</strong>:
在同一个类中，可以有多个同名但参数类型或数量不同的方法。</li>
<li><strong>方法重写</strong>:
子类可以重写父类的方法，提供不同的实现。</li>
<li><strong>接口</strong>:
接口定义了一组方法，不同的类可以实现同一个接口，并提供不同的实现。 ###
4.1 多态</li>
</ul></li>
<li><p>多态：<strong>用相同的名称来表示不同的含义</strong></p></li>
<li><p><strong>静多态</strong>：在<strong>编译</strong>时决定调用哪个方法；<strong>方法重载、方法隐藏</strong></p>
<ul>
<li><strong>方法重载(Overloading)</strong>
<ul>
<li>方法名相同，<strong>参数个数</strong>、<strong>参数类型</strong>及<strong>参数顺序</strong>至少有一个不同</li>
<li>返回值类型与访问权限修饰符可以相同也可以不同 <img
src="/img/LE-OOP1/10.png" srcset="/img/loading.gif" lazyload /></li>
</ul></li>
<li><strong>方法隐藏</strong>：子类定义了一个与父类<strong>同名同参数列表</strong>的<strong>静态/私有</strong>方法（相当于一个新方法）
<img src="/img/LE-OOP1/11.png" srcset="/img/loading.gif" lazyload /></li>
</ul></li>
<li><p><strong>动多态</strong>：在<strong>运行</strong>时才能确定调用哪个方法；<strong>方法覆盖</strong></p>
<ul>
<li>3个条件：<strong>继承、覆盖、向上转型</strong>（必须由父类的引用指向派生类的实例，并且通过父类的引用调用被覆盖的方法）</li>
<li><strong>方法覆盖(Override)</strong>
<ul>
<li>方法名、参数个数、参数类型及参数顺序必须一致</li>
<li><strong>异常抛出范围</strong>：子类 <span
class="math inline">\(\le\)</span> 父类</li>
<li><strong>访问权限</strong>：子类 <span
class="math inline">\(\ge\)</span> 父类</li>
<li><strong>私有方法、静态方法不能被覆盖</strong>，如果在子类出现了同签名的方法，那是方法隐藏；</li>
</ul></li>
</ul></li>
<li><p><strong>多态中成员变量编译运行看左边，多态中成员方法编译看左边，运行看右边</strong>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// **多态中成员变量编译运行看左边**</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Parent</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Child</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Parent</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Parent</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child</span>();<br>        System.out.println(p.value); <span class="hljs-comment">// 输出 10，因为编译和运行时都看左边（Parent类）</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// **多态中成员方法编译看左边，运行看右边**</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Parent</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">display</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Parent display&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Child</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Parent</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">display</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Child display&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Parent</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child</span>();<br>        p.display(); <span class="hljs-comment">// 编译时看左边（Parent类），运行时看右边（Child类），输出 &quot;Child display&quot;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p></li>
<li><p>抽象类</p>
<ul>
<li><code>abstract</code> 语义为“尚未实现”</li>
<li>如果一个类继承自某个抽象父类，而没有具体实现抽象父类中的抽象方法，则必须定义为抽象类</li>
<li>抽象类引用：虽然<strong>不能实例化抽象类</strong>，但可以<strong>创建它的引用</strong>。因为Java支持多态性，允许通过父类引用来引用子类的对象。</li>
<li>如果一个类里有抽象的方法，则这个类就必须声明成抽象的。<strong>但一个抽象类中却可以没有抽象方法</strong>。</li>
</ul></li>
<li><p>抽象方法</p>
<ul>
<li>无函数体</li>
<li>必须在抽象类中</li>
<li>必须在子类中实现，除非子类也是抽象的</li>
<li>不能被<strong>private、final或static</strong>修饰。</li>
</ul></li>
</ul>
<h3 id="接口">4.2 接口</h3>
<h4 id="定义">4.2.1 定义</h4>
<ul>
<li>接口：不相关类的功能继承。
<ul>
<li>只包含<strong>常量</strong>（所有变量默认<code>public static final</code>）和<strong>方法</strong>（默认
<code>public abstract</code>）的定义，没有方法的实现。（但一般不包含变量）</li>
<li><strong>没有构造方法</strong></li>
<li>一个类可以实现多个接口；如果类没有实现接口的全部方法。需要被定义成
<code>abstract</code> 类</li>
<li>接口的方法体还可以由其他语言写，此时接口方法需要用
<code>native</code> 修饰</li>
<li>接口可以继承，而且可以多重继承
<ul>
<li>同一个函数只能实现一次</li>
<li>不同接口的同名变量相互隐藏</li>
<li>接口变量和类中成员同名时，存在作用域问题</li>
</ul></li>
</ul></li>
<li>关键词 <code>interface</code> <code>implements</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">[<span class="hljs-keyword">public</span>] [interface] 接口名称 [extends 父接口名列表]&#123;<br>	<span class="hljs-comment">// 静态常量</span><br>	[<span class="hljs-keyword">public</span>][<span class="hljs-keyword">static</span>][<span class="hljs-keyword">final</span>]数据类型 变量名=常量名；<br>	<span class="hljs-comment">//抽象方法</span><br>	[<span class="hljs-keyword">public</span>][<span class="hljs-keyword">abstract</span>][<span class="hljs-keyword">native</span>]返回值类型 方法名（参数列表）；<br>&#125;<br><br>[修饰符] class类名 [extends父类名] [implements接口A,接口B,…]&#123;<br>	类的成员变量和成员方法；<br>	为接口A中的所有方法编写方法体，实现接口A;<br>	为接口B中的所有方法编写方法体，实现接口B;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Flyer</span>&#123;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">takeOff</span><span class="hljs-params">()</span>;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">land</span><span class="hljs-params">()</span>;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fly</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Bird</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Flyer</span> &#123;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">takeOff</span><span class="hljs-params">()</span> &#123; <span class="hljs-comment">/* take- off implementation */</span> &#125;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">land</span><span class="hljs-params">()</span> &#123; <span class="hljs-comment">/* landing implementation */</span> &#125;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fly</span><span class="hljs-params">()</span> &#123; <span class="hljs-comment">/* fly implementation */</span> &#125;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">buildNest</span><span class="hljs-params">()</span> &#123; <span class="hljs-comment">/* nest building behavior */</span> &#125;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">layEggs</span><span class="hljs-params">()</span> &#123; <span class="hljs-comment">/* egg laying behavior */</span> &#125;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span> &#123; <span class="hljs-comment">/* override eating behavior */</span> &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 不同接口的同名变量相互隐藏</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">legs</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 假设动物默认没有腿</span><br>&#125;<br><br>interface 昆虫 &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">legs</span> <span class="hljs-operator">=</span> <span class="hljs-number">6</span>; <span class="hljs-comment">// 昆虫有6条腿</span><br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Spider</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Animal</span>,昆虫 &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printLegs</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Animal legs: &quot;</span> + Animal.legs); <span class="hljs-comment">// 调用Animal接口中的legs变量</span><br>        System.out.println(<span class="hljs-string">&quot;昆虫 legs: &quot;</span> +昆虫.legs); <span class="hljs-comment">// 调用昆虫接口中的legs变量</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Spider</span> <span class="hljs-variable">spider</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Spider</span>();<br>        spider.printLegs();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 接口变量和类中成员同名时，存在作用域问题</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Animal&quot;</span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Dog&quot;</span>; <span class="hljs-comment">// Dog类中定义了与接口同名的变量</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printName</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(name); <span class="hljs-comment">// 这将打印&quot;Dog&quot;</span><br>        System.out.println(Animal.name); <span class="hljs-comment">// 这将打印&quot;Animal&quot;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="使用接口">4.2.2 使用接口</h4>
<ul>
<li>接口用作类型
<ul>
<li>声明格式：<code>接口 变量名</code> (又称为引用)</li>
<li>接口做参数：如果一个方法的参数是接口类型，就可以将任何实现该接口的类的实例的引用传递给接口参数，那么接口参数就可以回调类实现的接口方法。</li>
</ul></li>
<li>接口回调
<ul>
<li>把实现某一接口的类创建的<strong>对象引用</strong>赋给该接口声明的<strong>接口变量</strong></li>
<li>该接口变量就可以<strong>调用被类实现的接口中的方法</strong>。</li>
<li>即： <code>接口变量 = 实现该接口的类所创建的对象；</code>
<code>接口变量.接口方法([参数列表])</code>；</li>
</ul></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Runner</span> &#123;<br>	<span class="hljs-comment">//接口１</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Swimmer</span> &#123;<br>	<span class="hljs-comment">//接口２</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swim</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runner</span>,Swimmer &#123; <span class="hljs-comment">//继承类，实现接口</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>		System.out.println(<span class="hljs-string">&quot;我是飞毛腿,跑步速度极快!&quot;</span>);<br>	&#125;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swim</span><span class="hljs-params">()</span>&#123;<br>		System.out.println(<span class="hljs-string">&quot;我游泳技术很好,会蛙泳、自由泳、仰泳、蝶泳...&quot;</span>);<br>	&#125;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span>&#123;<br>		System.out.println(<span class="hljs-string">&quot;我牙好胃好,吃啥都香!&quot;</span>);<br>	&#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InterfaceTest</span>&#123;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">m1</span><span class="hljs-params">(Runner r)</span> &#123; r.run(); &#125; <span class="hljs-comment">//接口作参数</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">m2</span><span class="hljs-params">(Swimmer s)</span> &#123;s.swim();&#125; <span class="hljs-comment">//接口作参数</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">m3</span><span class="hljs-params">(Animal a)</span> &#123;a.eat();&#125; <span class="hljs-comment">//抽象类引用</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String args[])</span>&#123;<br>		<span class="hljs-type">InterfaceTest</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterfaceTest</span>();<br>		<span class="hljs-type">Person</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>		t.m1(p); <span class="hljs-comment">//接口回调</span><br>		t.m2(p); <span class="hljs-comment">//接口回调</span><br>		t.m3(p); <span class="hljs-comment">//接口回调</span><br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="抽象类与接口">4.2.4 抽象类与接口</h4>
<ul>
<li>区别
<ul>
<li>接口中的成员<strong>变量和方法</strong>只能是 <code>public</code>
类型的，而抽象类中的成员变量和方法可以处于各种访问级别。</li>
<li>接口中的<strong>成员变量</strong>只能是
<code>public</code>、<code>static</code> 和 <code>final</code>
类型的，而在抽象类中可以定义各种类型的实例变量和静态变量。</li>
<li>接口中没有<strong>构造方法</strong>，抽象类中有构造方法。接口中所有方法都是抽象方法，抽象类中可以有，也可以没有抽象方法。抽象类比接口包含了更多的实现细节。</li>
<li>抽象类是某一类事物的一种抽象，而接口不是类，它<strong>只定义了某些行为</strong>；
例如，“生物”类虽然抽象，但有“狗”类的雏形，接口中的run方法可以由狗类实现，也可以由汽车实现。</li>
<li>在语义上，接口表示更高层次的抽象，声明系统对外提供的服务。而抽象类则是各种具体类型的抽象。</li>
</ul></li>
</ul>
<h4 id="native关键字">4.2.5 <span
style="background:rgba(92, 92, 92, 0.2)">Native关键字</span></h4>
<ul>
<li>Native用来声明一个方法是由机器相关的语言（如C/C++语言）实现的。通常，native方法用于一些比较消耗资源的方法，该方法用c或其他语言编写，可以提高速度。</li>
<li>native
定义符说明该方法是一个使用本地其他语言编写的非java类库的方法，它是调用的本地（也就是当前操作系统的方法或动态连接库）。最常见的就是c/c++封装的DLL里面的方法，这是java的
JNI技术。它在类中的声明和抽象方法一样没有方法体。</li>
</ul>
<h3 id="upcasting-和-downcasting">4.3 upcasting 和 downcasting</h3>
<h4 id="向上转型-upcasting">4.3.1 向上转型 upcasting</h4>
<ul>
<li><p>向上转型：当有<strong>子类对象赋值给一个父类引用</strong>时，便是向上转型，多态本身就是向上转型的过程。</p></li>
<li><p>使用格式： 父类类型 变量名 = new 子类类型(); 如：Person p = new
Student();</p></li>
<li><p>上转型对象的使用(父类有的就能访问，没有的不能访问，且儿子的优先级更高)</p>
<ul>
<li>上转型对象可以<strong>访问子类继承或隐藏的成员变量</strong>，也可以<strong>调用子类继承的方法或子类重写的实例方法</strong>。</li>
<li>如果子类重写了父类的某个实例方法后，当用上转型对象调用这个实例方法时一定是<strong>调用了子类重写的实例方法</strong>。</li>
<li>上转型对象<strong>不能操作子类新增</strong>的成员变量；<strong>不能调用子类新增</strong>的方法。</li>
</ul></li>
</ul>
<h4 id="向下转型-downcasting">4.3.2 向下转型 downcasting</h4>
<ul>
<li>向下转型(映射)：一个<strong>已经向上转型的子类对象</strong>可以使用强制类型转换的格式，<strong>将父类引用转为子类引用</strong>，这个过程是向下转型。</li>
<li>使用格式： <code>子类类型 变量名 = (子类类型) 父类类型的变量;</code>
如：Person p = new Student(); Student stu = (Student) p</li>
<li>如果是<strong>直接创建父类对象，是无法向下转型的</strong>
，能过编译，但运行时会产生异常 如：Person p = new Peron(); Student stu =
(Student) p</li>
</ul>
<h5 id="instanceof-操作符">instanceof 操作符</h5>
<ul>
<li><code>instanceof</code>
操作符用于判断一个引用类型所<strong>引用的对象是否是一个类的实例</strong>。<code>instanceof</code>
运算符是Java独有的双目运算符</li>
<li><code>instanceof</code>
操作符左边的操作元是一个引用类型的对象（可以是null），右边的操作元是一个类名或接口名。</li>
<li>形式如下：<code>obj instanceof ClassName</code> 或者
<code>obj instanceof InterfaceName</code></li>
<li><code>a instanceof X</code>，当 X 是
<strong>A类/A类的直接或间接父类/A类实现的接口</strong>时，表达式的值为true</li>
</ul>
<h2 id="object类最终类内部类匿名类-10">5
Object类、最终类、内部类、匿名类 10</h2>
<h3 id="object类">5.1 Object类</h3>
<ul>
<li>基于多态的特性，该类可以用来代表任何一个类，因此允许<strong>把任何类型的对象赋给
Object类型的变量</strong>，也可以作为方法的参数、方法的返回值</li>
</ul>
<h5
id="public-final-class-getclass"><code>public final Class&lt;?&gt; getClass()&#123;&#125;</code></h5>
<ul>
<li>该方法用于获取对象运行时的字节码类型，得到该对象的<strong>运行时的真实类型</strong>。</li>
<li>通常用于判断<strong>两个引用中实际存储对象类型</strong>是否一致。
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br>    <span class="hljs-comment">// 类的成员变量和方法</span><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AnotherClass</span> &#123;<br>    <span class="hljs-comment">// 另一个类的成员变量和方法</span><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TypeComparisonExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">MyClass</span> <span class="hljs-variable">obj1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyClass</span>();<br>        <span class="hljs-type">MyClass</span> <span class="hljs-variable">obj2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyClass</span>();<br>        <span class="hljs-type">AnotherClass</span> <span class="hljs-variable">obj3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AnotherClass</span>();<br><br>        <span class="hljs-comment">// 比较obj1和obj2是否指向相同类型的对象</span><br>        <span class="hljs-keyword">if</span> (obj1.getClass() == obj2.getClass()) &#123;<br>            System.out.println(<span class="hljs-string">&quot;obj1和obj2指向相同类型的对象&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;obj1和obj2指向不同类型的对象&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">// 比较obj1和obj3是否指向相同类型的对象</span><br>        <span class="hljs-keyword">if</span> (obj1.getClass() == obj3.getClass()) &#123;<br>            System.out.println(<span class="hljs-string">&quot;obj1和obj3指向相同类型的对象&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;obj1和obj3指向不同类型的对象&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// obj1和obj2指向相同类型的对象</span><br><span class="hljs-comment">// obj1和obj3指向不同类型的对象</span><br></code></pre></td></tr></table></figure></li>
<li>最主要应用：该方法属于Java的反射机制，其返回值是Class类型，例如
Class c = obj.getClass();。通过对象c，
<ul>
<li>获取所有<strong>成员方法</strong>，<strong>每个成员方法都是一个Method对象</strong>。
<code>Method[] methods = cls.getDeclaredMethods();</code></li>
<li>获取所有<strong>成员变量</strong>，<strong>每个成员变量都是一个Field对象</strong>。
<code>Field[] fields = cls.getDeclaredFields();</code></li>
<li>获取所有<strong>构造函数</strong>，<strong>构造函数则是一个Constructor对象</strong>。
<code>Constructor&lt;?&gt;[] constructors = cls.getDeclaredConstructors();</code>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 用getClass来获得该对象的类名、所有成员方法、所有成员变量、所有构造函数</span><br><span class="hljs-keyword">import</span> java.lang.reflect.Constructor;<br><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> myField;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyClass</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 默认构造函数</span><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyClass</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> &#123;<br>        <span class="hljs-comment">// 带参数的构造函数</span><br>        myField = value;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">myMethod</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 成员方法</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReflectionExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">MyClass</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyClass</span>();<br><br>        <span class="hljs-comment">// 获取Class对象</span><br>        Class&lt;?&gt; cls = obj.getClass();<br><br>        <span class="hljs-comment">// 获取类名</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">className</span> <span class="hljs-operator">=</span> cls.getName();<br>        System.out.println(<span class="hljs-string">&quot;类名: &quot;</span> + className);<br><br>        <span class="hljs-comment">// 获取所有成员方法</span><br>        Method[] methods = cls.getDeclaredMethods();<br>        System.out.println(<span class="hljs-string">&quot;成员方法:&quot;</span>);<br>        <span class="hljs-keyword">for</span> (Method method : methods) &#123;<br>            System.out.println(method.getName());<br>        &#125;<br><br>        <span class="hljs-comment">// 获取所有成员变量</span><br>        Field[] fields = cls.getDeclaredFields();<br>        System.out.println(<span class="hljs-string">&quot;成员变量:&quot;</span>);<br>        <span class="hljs-keyword">for</span> (Field field : fields) &#123;<br>            System.out.println(field.getName());<br>        &#125;<br><br>        <span class="hljs-comment">// 获取所有构造函数</span><br>        Constructor&lt;?&gt;[] constructors = cls.getDeclaredConstructors();<br>        System.out.println(<span class="hljs-string">&quot;构造函数:&quot;</span>);<br>        <span class="hljs-keyword">for</span> (Constructor&lt;?&gt; constructor : constructors) &#123;<br>            System.out.println(constructor.getName());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul></li>
</ul>
<h5 id="public-int-hashcode"><code>public int hashCode()&#123;&#125;</code></h5>
<ul>
<li>返回该对象的<strong>哈希码值</strong>。哈希值为根据对象的<strong>地址或字符串或数字</strong>使用hash算法计算出来的<strong>int</strong>类型的数值。</li>
<li>在Object类中，hashCode的默认实现通常会返回对象的<strong>内存地址的某种形式</strong>（不能完全将哈希值等价于地址），具体的实现依赖JVM。</li>
<li>提高具有哈希结构的容器的效率。</li>
<li>如果<strong>两个对象相等</strong>（即equals返回true），那么它们的<strong>hashCode值也必须相等</strong>。</li>
</ul>
<h5
id="public-boolean-equalsobject-obj"><code>public boolean equals(Object obj)</code></h5>
<ul>
<li>比较两个对象是否相等。仅当被比较的两个<strong>引用变量指向同一对象</strong>时（即两个对象地址相同，也即hashCode值相同），equals()方法返回true</li>
<li>可进行<strong>覆盖</strong>，<strong>比较两个对象的内容是否相同</strong>。</li>
</ul>
<h5
id="equals与hashcode"><code>equals()</code>与<code>hashCode</code></h5>
<p><strong>equals为true与hashCode相同的关系？</strong> +
如果两个对象的equals()结果为<strong>true</strong>，那么这两个对象的<strong>hashCode()一定相同</strong>；
+
两个对象的<strong>hashCode()结果相同</strong>，并<strong>不能代表</strong>两个对象的equals()一定为true（Hash散列值有冲突的情况，虽然概率很低，只能够说明这两个对象在一个散列存储结构中）</p>
<p><strong>为什么要重写hashCode和equals？</strong> + equals()
⽅法⽤于⽐较两个对象的内容是否相等。在Java中，默认实现是⽐较对象的引⽤，即⽐较两个对象是否指向内存中的相同位置。但<strong>通常，我们希望⽐较对象的内容是否相等</strong>。
+ 鉴于这种情况，Object类中 equals()
方法的默认实现是没有实⽤价值的，所以<strong>通常都要重写</strong>。 +
而由于hashCode()与equals()具有<strong>联动关系</strong>（如果两个对象相等，则它们必须有相同的哈希码），所以equals()方法重写时，通常也要将hashCode()进⾏重写，使得这两个方法始终保持⼀致性。</p>
<p><strong>重写equals一定要重写hashCode吗？</strong> +
如果仅仅是为了<strong>比较两个对象是否相等</strong>只重写<strong>equals</strong>就可以；
+
如果你使用了<strong>hashSet、hashMap</strong>等容器，为了避免加入重复元素，或者查找元素，就一定要同时重写两个方法。
+ 如果<strong>自定义对象作为 Map 的键</strong>，那么必须重写 hashCode 和
equals 。</p>
<h5
id="public-string-tostring"><code>public String toString()&#123;&#125;</code></h5>
<p>默认的 <code>toString()</code>
输出<strong>包名</strong>加<strong>类名</strong>和<strong>堆上的首地址</strong></p>
<h5 id="finalize方法"><code>finalize()方法</code></h5>
<p>不存在对该对象的其他引用时，由对象的垃圾器调用此方法</p>
<h5 id="线程中常用的方法">线程中常用的方法</h5>
<ul>
<li><code>public final void wait()</code>: 多线程中等待功能</li>
<li><code>public final native void notify()</code> :
多线程中唤醒功能</li>
<li><code>public final native void notifyAll()</code>:
多线程中唤醒所有等待线程的功能</li>
</ul>
<h5 id="例">例</h5>
<p><img src="/img/LE-OOP1/12.png" srcset="/img/loading.gif" lazyload /> <img
src="/img/LE-OOP1/13.png" srcset="/img/loading.gif" lazyload /></p>
<h5 id="objects-与-object-区别"><code>Objects</code> 与
<code>Object</code> 区别</h5>
<ul>
<li>Objects 【public final class Objects extends Object】是Object
的工具类，位于java.util包。它从jdk1.7开始才出现，被final修饰不能被继承，拥有私有的构造函数。此类包含static实用程序方法，用于<strong>操作对象或在操作前检查某些条件</strong>。
<ul>
<li><strong>null</strong> 或 null方法 ；</li>
<li>用于计算<strong>一堆对象的混合哈希代码</strong>；</li>
<li>返回对象的<strong>字符串</strong>（会对null进行处理）；</li>
<li>比较两个对象，以及检查索引或子范围值是否超出范围</li>
</ul></li>
</ul>
<h3 id="最终类最终方法常量">5.2 最终类、最终方法、常量</h3>
<h4 id="最终类最终方法">5.2.1 最终类、最终方法</h4>
<ul>
<li><p><strong>最终类</strong>：如果一个类<strong>没有必要再派生子类</strong>，通常可以用final关键字修饰，表明它是一个最终类</p></li>
<li><p><strong>最终方法</strong>：用关键字final修饰的方法称为最终方法。最终方法既不能被覆盖，也不能被重载，它是一个最终方法，其方法的定义永远不能改变</p></li>
<li><p>final类中的方法可以不声明为final方法，但实际上<strong>final类中的方法都是隐式的final方法</strong></p></li>
<li><p>final修饰的方法不一定要存在于final类中。</p></li>
<li><p>定义类头时，<strong>abstract和final不能同时使用</strong></p></li>
<li><p>访问权限为<strong>private的方法默认为final</strong>的</p></li>
</ul>
<h4 id="常量">5.2.2 常量</h4>
<ul>
<li><p>Java中的常量使用关键字 <code>final</code> 修饰。</p></li>
<li><p>final既可以修饰<strong>简单数据</strong>类型，也可以修饰<strong>复合数据</strong>类型。</p>
<ul>
<li>简单数据类型：值不能再变</li>
<li>符合数据类型：引用不能再变，值可以改变</li>
</ul></li>
<li><p>final常量可以在<strong>声明的同时赋初值</strong>，也可以在<strong>构造函数</strong>中</p></li>
<li><p>常量既可以是<strong>局部常量</strong>，也可以是<strong>类常量和实例常量</strong>。如果是类常量，在<strong>数据类型前加static修饰</strong>（由所有对象共享）。如果是实例常量，就<strong>不加static修饰</strong>。</p></li>
<li><p>常量名一般大写，多个单词之间用下划线连接。</p></li>
</ul>
<h5 id="局部常量类常量实例常量">局部常量、类常量、实例常量</h5>
<ol type="1">
<li><p>局部常量（Local
Constant）： 局部常量是在<strong>方法、构造器或代码块内部</strong>定义的常量。它们只在定义它们的代码块内部有效，一旦代码块执行完毕，局部常量就不再存在。局部常量通常使用 <code>final</code> 关键字来声明，表示其值在初始化后不能被改变。
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">myMethod</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">LOCAL_CONSTANT</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>; <span class="hljs-comment">// 局部常量</span><br>    <span class="hljs-comment">// 这里可以使用 LOCAL_CONSTANT</span><br>&#125;<br><span class="hljs-comment">// 这里不能使用 LOCAL_CONSTANT，因为它只在 myMethod 方法内部有效</span><br></code></pre></td></tr></table></figure></p></li>
<li><p>类常量（Class
Constant）： 类常量是在<strong>类的静态初始化块或静态成员变量</strong>中定义的常量。它们属于类本身，而不是类的实例。类常量也通常使用 <code>final</code> 关键字来声明，并且是 <code>static</code> 的，这意味着它们是类的所有实例共享的。
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">CLASS_CONSTANT</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>; <span class="hljs-comment">// 类常量</span><br>    <span class="hljs-comment">// 这里可以使用 CLASS_CONSTANT</span><br>&#125;<br></code></pre></td></tr></table></figure></p></li>
<li><p>实例常量（Instance
Constant）： 实例常量是在类的<strong>非静态成员变量</strong>中定义的常量。它们属于类的每个实例，每个实例都有自己的实例常量副本。实例常量同样使用 <code>final</code> 关键字来声明，表示一旦被初始化，其值就不能改变。
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">INSTANCE_CONSTANT</span> <span class="hljs-operator">=</span> <span class="hljs-number">30</span>; <span class="hljs-comment">// 实例常量</span><br>    <span class="hljs-comment">// 这里可以使用 INSTANCE_CONSTANT</span><br>&#125;<br></code></pre></td></tr></table></figure> <img src="/img/LE-OOP1/14.png" srcset="/img/loading.gif" lazyload /> <img
src="/img/LE-OOP1/15.png" srcset="/img/loading.gif" lazyload /></p></li>
</ol>
<h5 id="例-1">例</h5>
<p><img src="/img/LE-OOP1/16.png" srcset="/img/loading.gif" lazyload /> <img src="/img/LE-OOP1/17.png" srcset="/img/loading.gif" lazyload />
<img src="/img/LE-OOP1/18.png" srcset="/img/loading.gif" lazyload /> <strong>输出</strong> <figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">PersonNNNNNNNNNNNNNNNN</span><br><span class="hljs-attribute">StudentTTTTTTTTTTTTTTTTTTTTT</span><br><span class="hljs-attribute">PersonNNNNNNNNNNNNNNNN</span><br></code></pre></td></tr></table></figure>
<strong>解释</strong>
<code>p.priFinalMethod()</code> 和 <code>p2.priFinalMethod()</code> 调用的是 <code>Parent</code> 类的 <code>priFinalMethod</code> 方法，因为 <code>priFinalMethod</code> 是 <code>Parent</code> 类的<strong>私有方法</strong>，无法在 <code>Parent</code> 类的<strong>外部通过 <code>Parent</code> 类的引用调用 <code>Child</code> 类的 <code>priFinalMethod</code> 方法</strong>。
### 5.3 内部类</p>
<h4 id="内部类的基本语法">5.3.1 内部类的基本语法</h4>
<h5 id="内部类的分类">内部类的分类</h5>
<p><img src="/img/LE-OOP1/19.png" srcset="/img/loading.gif" lazyload /></p>
<h5 id="实例内部类">实例内部类</h5>
<h6 id="创建实例内部类的实例">创建实例内部类的实例</h6>
<p><strong>在创建实例内部类的实例时，外部类的实例必须已经存在</strong>，例如要创建InnerTool类的实例，必须先创建Outer外部类的实例
两种语法： +
<code>Outer.InnerTool tool=new Outer().new InnerTool();</code> +
<code>Outer outer=new Outer();</code>
<code>Outer.InnerTool tool =outer.new InnerTool();</code>
以下代码会导致编译错误：<code>Outer.InnerTool tool=new Outer.InnerTool();</code></p>
<h6 id="实例内部类访问外部类的成员">实例内部类访问外部类的成员</h6>
<ul>
<li>在内部类中，可以<strong>直接访问外部类的所有成员</strong>，包括成员变量和成员方法。</li>
<li>实例内部类的实例<strong>自动持有外部类的实例的引用</strong>。</li>
</ul>
<h5 id="静态内部类">静态内部类</h5>
<ul>
<li>静态内部类的实例<strong>不会自动持有外部类的特定实例的引用</strong></li>
<li>在创建内部类的实例时，<strong>不必创建外部类的实例</strong>。</li>
<li>客户类可以通过<strong>完整的类名直接访问静态内部类的静态成员</strong>。</li>
</ul>
<h5 id="局部内部类">局部内部类</h5>
<ul>
<li>局部内部类只能在<strong>当前方法</strong>中使用。</li>
<li>局部内部类和实例内部类一样，可以<strong>访问外部类的所有成员</strong></li>
<li>此外，局部内部类还可以访问<strong>函数中的最终变量或参数</strong>(final)</li>
</ul>
<h4 id="内部类的用途">5.3.2 内部类的用途</h4>
<ul>
<li>封装类型：如果<strong>一个类只能由系统中的某一个类访问</strong>，可以定义为该类的内部类。</li>
<li>直接访问外部类的成员</li>
<li>回调外部类的方法</li>
</ul>
<h5 id="内部类封装类型">5.3.2.1 内部类封装类型</h5>
<ul>
<li><p>顶层类只能处于<strong>public和默认</strong>访问级别</p></li>
<li><p>而成员内部类可以处于public、protected、默认和private四个访问级别。</p></li>
<li><p>此外，如果一个<strong>内部类仅仅为特定的方法提供服务</strong>，那么可以把这个<strong>内部类定义在方法之内</strong>。</p></li>
<li><p>虽然 <code>InnerTool</code> 是 <code>Test</code> 的私有内部类，但它仍然可以在 <code>Test</code> 类的内部被访问。在 <code>main</code> 方法中，<code>new Test().new InnerTool()</code> 是在 <code>Test</code> 类的内部创建 <code>InnerTool</code> 的实例，因此这是允许的。</p></li>
<li><p>在客户类中不能访问Outer.InnerTool类，但是可以通过Outer类的getTool()方法获得InnerTool的实例
##### 5.3.2.2 内部类访问外部类的成员</p></li>
<li><p>内部类的一个特点是能够<strong>访问外部类的各种访问级别的成员</strong>。</p></li>
<li><p>假定有类A和类B，类B的reset()方法负责重新设置类A的实例变量count的值。一种实现方式是把类A和类B都定义为外部类</p></li>
<li><p>假如需求中<strong>要求类A的count属性不允许被除类B以外的其他类读取或设置</strong>，那么以上实现方式就不能满足这一需求。</p></li>
<li><p>在这种情况下，把类B定义为内部类就可以解决这一问题，而且会使程序代码更加简洁</p></li>
</ul>
<h5 id="回调">5.3.2.3 回调</h5>
<p><img src="/img/LE-OOP1/20.png" srcset="/img/loading.gif" lazyload /> <img src="/img/LE-OOP1/21.png" srcset="/img/loading.gif" lazyload />
故考虑使用回调方法</p>
<p>回调实质上是指<strong>一个类(Sub)尽管实际上实现了某种功能(调节温度)，但是没有直接提供相应的接口，客户类可以通过这个类的内部类(Closure)的接口(Adjustable)来获得这种功能。而这个内部类本身并没有提供真正的实现，仅仅调用外部类的实现(adjustTemperature)</strong>。
可见，回调充分发挥了内部类具有访问外部类的实现细节的优势。 <img
src="/img/LE-OOP1/22.png" srcset="/img/loading.gif" lazyload /><img src="/img/LE-OOP1/23.png" srcset="/img/loading.gif" lazyload /></p>
<h4 id="内部类的文件命名">5.3.3 内部类的文件命名</h4>
<p>对于每个内部类，Java编译器会生成独立的.class文件。这些类文件的命名规则如下：
+ 成员内部类：外部类的名字$内部类的名字 +
局部内部类：外部类的名字$数字和内部类的名字 +
匿名类：外部类的名字$数字</p>
<h3 id="匿名类">5.4 匿名类</h3>
<ul>
<li>匿名类就是没有名字的类，是将类和类的方法定义在一个表达式范围里。</li>
<li>匿名类本身<strong>没有构造方法</strong>，但是会<strong>调用父类的构造方法</strong>。</li>
<li>匿名内部类将内部类的定义与生成实例的语句合在一起，并省去了类名以及关键字“class”,”extends”和“implements”等</li>
<li>匿名类必须继承自一个具体的<strong>类</strong>或实现一个<strong>接口</strong>。</li>
</ul>
<h2 id="其他-9-11-14">其他 9 11-14</h2>
<h3 id="异常处理-9">异常处理 9</h3>
<p><img src="/img/LE-OOP1/24.png" srcset="/img/loading.gif" lazyload /> #### 1 异常概述</p>
<ul>
<li>3类错误
<ul>
<li>编译错误</li>
<li>逻辑错误</li>
<li><strong>运行时错误</strong>：在程序运行过程中如果发生了一个不可能执行的操作，就会出现运行时错误。</li>
</ul></li>
<li><strong>异常</strong>：一个<strong>可以正确运行</strong>的程序在<strong>运行中</strong>可能发生的错误。</li>
<li>异常特点：偶然性、可预见性、严重性</li>
<li><strong>异常处理 ( Exception Handling
)</strong>：提出或者是研究一种机制，能够较好的处理程序不能正常运行的问题。</li>
</ul>
<h4 id="java异常类异常的层次结构">2 java异常类/异常的层次结构</h4>
<h5 id="java异常类">java异常类</h5>
<p><img src="/img/LE-OOP1/25.png" srcset="/img/loading.gif" lazyload /> +
Throwable：所有异常类的父类，是Object的直接子类。 +
Error：由Java虚拟机生成并抛出，Java程序不做处理 +
Exception：所有的Throwable类的子孙类所产生的对象都是异常 + Runtime
Exception：<strong>编译时不可监测的异常</strong>，由系统检测,
用户的Java程序可不做处理，系统将它们交给缺省的异常处理程序。 +
<strong>非Runtime
Exception</strong>：<strong>编译时可以监测的异常</strong>，Java编译器要求Java程序<strong>必须</strong>捕获或声明所有的非运行时异常，可以通过try-catch或throws处理。
+ throw：用户自己产生异常。</p>
<h5 id="常见的异常">常见的异常</h5>
<ol type="1">
<li>ArithmeticException</li>
<li>ArrayIndexOutOfBoundsException</li>
<li>ArrayStoreException</li>
<li>IOException</li>
<li>FileNotFoundException</li>
<li>NullPointerException</li>
<li>MalformedURLException</li>
<li>NumberFormatException</li>
<li>OutOfMemoryException</li>
</ol>
<h5 id="异常分类">异常分类</h5>
<ul>
<li>非受检异常 ( unchecked exception ) ：Runtime Exception
及其子类、Error 及其子类。
<ul>
<li>只能在程序执行时被检测到，<strong>不能在编译时被检测到</strong>；</li>
<li>程序可不处理，交由系统处理。</li>
</ul></li>
<li>受检异常 ( checked exception
)：除了非受检异常之外的异常（即其他的异常类都是可检测的类）
<ul>
<li>这些异常在<strong>编译时</strong>就能被java编译器所检测到异常。</li>
<li>必须采用 <strong>throws 语句</strong>或者 <strong>try-catch</strong>
方式处理异常</li>
</ul></li>
</ul>
<h4 id="java异常处理机制">3 java异常处理机制</h4>
<ul>
<li>抓抛模型
<ul>
<li>抛出(throw)异常：Java程序在正常的执行过程中，一旦出现异常，就会在异常代码处生成一个对应<strong>异常类的对象</strong>，并将此对象抛出，且其后代码就<strong>不再执行</strong>。
<ul>
<li>关于异常对象的产生
<ul>
<li>系统<strong>自动</strong>生成异常对象</li>
<li><strong>手动</strong>生成一个异常对象，并抛出（<strong>throw</strong>）</li>
</ul></li>
</ul></li>
<li>捕获(catch)异常：可以理解为异常处理方式。
<ul>
<li>try-catch-finally</li>
<li>throws</li>
</ul></li>
</ul></li>
<li>Java语言按照面向对象的思想来处理异常：
<ul>
<li>把各种不同类型的异常情况进行分类，用Java类来表示异常情况，这种类被称为异常类。</li>
<li>用throws语句在方法声明处声明抛出特定异常。（<strong>只抛出不处理，交给调用该方法的方法进行处理，若一直不处理，则交给系统处理</strong>）</li>
<li>用try-catch语句来捕获并处理异常。（<strong>处理</strong>）</li>
<li>用throw语句在方法中抛出具体的异常。（<strong>自定义异常</strong>）</li>
</ul></li>
</ul>
<h4 id="try-catch-finally">4 try-catch-finally</h4>
<h6
id="finally无条件执行的语句"><code>finally</code>：无条件执行的语句</h6>
<ul>
<li><code>try&#123;&#125;</code> 中执行 <code>return</code> ，<code>finally</code>
语句仍然执行，在 <code>return</code> 前执行</li>
<li><code>try&#123;&#125;</code> 中执行
<code>exist(0)</code>，<code>finally</code> 语句不执行</li>
</ul>
<h6 id="try-catch-finally-语句格式"><code>try-catch-finally</code>
语句格式</h6>
<ul>
<li><p>一个try一个catch可以，一个try一堆catch也可以，try-catch-finally也可以，try-fianlly也可以</p></li>
<li><p><code>try-catch-finally</code> 语句的语法格式</p>
<ul>
<li>一般 <code>finally</code>
写<strong>释放资源</strong>的部分（打开水龙头后无论水龙头能不能使最后都要关上水龙头）</li>
<li>如果一个异常类和其子类都出现在catch子句中，应把<strong>子类放在前面</strong>，否则将永远不会到达子类。
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>	<span class="hljs-comment">// 接受监视的程序块,在此区域内发生的异常,由catch中指定的程序处理;</span><br>&#125;<br><span class="hljs-keyword">catch</span> (ExceptionType1 e) &#123;<br>	<span class="hljs-comment">// 抛出ExceptionType1异常时要执行的代码</span><br>&#125;<br><span class="hljs-keyword">catch</span> (ExceptionType2 e) &#123;<br>	<span class="hljs-comment">// 抛出ExceptionType2异常时要执行的代码</span><br>&#125;……<br>[<span class="hljs-keyword">finally</span> &#123;<br>	<span class="hljs-comment">// 无条件执行的语句</span><br>&#125;]<br></code></pre></td></tr></table></figure></li>
</ul></li>
<li><p><code>try-finally</code> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//try-finally</span><br><span class="hljs-keyword">try</span>&#123;<br>	<span class="hljs-comment">// 对文件进行处理的程序</span><br>&#125;<br><span class="hljs-keyword">finally</span>&#123;<br>	<span class="hljs-comment">// 不论是否发生异常，都关闭文件</span><br>&#125;<br></code></pre></td></tr></table></figure></p></li>
<li><p><code>catch(异常名1|异常名2|异常名3 变量)</code> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span>&#123;<br><br>&#125;<span class="hljs-keyword">catch</span>(异常名<span class="hljs-number">1</span> |异常名<span class="hljs-number">2</span> |异常名<span class="hljs-number">3</span>… 变量）&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure>
方法虽简洁，但是也不是特别完美</p></li>
<li><p>上述异常必须是<strong>同级</strong>关系；</p></li>
<li><p><strong>处理方式是一样</strong>的（针对同类型的问题，给出同一个处理）</p></li>
</ul>
<h6 id="try-with-resourse"><code>try-with-resourse</code></h6>
<ul>
<li>资源：所有实现Closeable的类，如流操作，socket操作，httpclient等</li>
<li>打开的资源越多，finally中嵌套的将会越深，所以引入了
Try-with-resourse</li>
<li>带资源的try语句（try-with-resource）的最简形式为：
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span>(<span class="hljs-type">Resource</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> xxx)&#123; <span class="hljs-comment">// 可指定多个资源</span><br>	work with res<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li>处理规则
<ul>
<li>凡是实现了AutoCloseable接口的类，在try()里声明该类实例的时候，在try结束后，<strong>close方法都会被调用</strong>，这个动作会<strong>早于finally里调用的方法</strong>。</li>
<li>不管是否出现异常，try()里的实例都会被调用；</li>
<li>close方法<strong>越晚声明</strong>的对象，会<strong>越早被close</strong>掉。</li>
</ul></li>
</ul>
<h6 id="例1">例1</h6>
<p>先声明的后关闭 <img src="/img/LE-OOP1/26.png" srcset="/img/loading.gif" lazyload /> <figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">do</span> something<br><span class="hljs-keyword">do</span> other things<br>other resource <span class="hljs-keyword">is</span> closed<br><span class="hljs-keyword">some</span> resource <span class="hljs-keyword">is</span> closed<br></code></pre></td></tr></table></figure></p>
<h4 id="throws">5 Throws</h4>
<p>用于<strong>声明异常</strong>。 +
声明异常：一个方法<strong>不处理</strong>它产生的异常，而是<strong>沿着调用层次向上传递</strong>，由调用它的方法来处理这些异常，叫声明异常。若最终方法也没有处理异常，异常将<strong>交给系统处理</strong>
+
Throws语句用来表明一个方法可能抛出的各种异常，并说明该方法会<strong>抛出但不捕获</strong>异常</p>
<ul>
<li>声明异常的格式 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;访问权限修饰符&gt;&lt;返回值类型&gt;&lt;方法名&gt;(参数列表) <span class="hljs-keyword">throws</span> 异常列表&#123;&#125;<br></code></pre></td></tr></table></figure></li>
<li><strong>当父类中的方法没有throws，则子类重写此方法时也不可以throws</strong>。若重写方法中出异常，必须采用try结构处理。</li>
<li>重写方法不能抛出比被重写方法<strong>范围更大</strong>的异常类型，子类重写方法也<strong>可以不抛出</strong>异常。
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 方法**不处理**它产生的异常，而是**沿着调用层次向上传递**，由调用它的方法来处理这些异常</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ThrowsTest4</span> &#123;<br>    <span class="hljs-comment">// 声明异常，但不处理异常</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IllegalAccessException &#123;<br>        System.out.println(<span class="hljs-string">&quot;\n在 method 中抛出一个异常&quot;</span>);<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalAccessException</span>();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            method();<br>        &#125; <span class="hljs-keyword">catch</span> (IllegalAccessException e) &#123;<br>            System.out.println(<span class="hljs-string">&quot;在 main 中捕获异常：&quot;</span> + e);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 在 method 中抛出一个异常</span><br><span class="hljs-comment">// 在 main 中捕获异常：java.lang.IllegalAccessException</span><br></code></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 若最终方法也没有处理异常，异常将交给系统处理</span><br><span class="hljs-keyword">import</span> java.io.FileInputStream;  <br><span class="hljs-keyword">import</span> java.io.IOException;  <br>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;  <br>        <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;myfile.txt&quot;</span>);  <br>        <span class="hljs-type">int</span> b;  <br>        <span class="hljs-keyword">while</span> ((b = in.read()) != -<span class="hljs-number">1</span>) &#123;  <br>            System.out.print((<span class="hljs-type">char</span>) b);  <br>        &#125;  <br>        in.close();  <br>    &#125;  <br>&#125;<br><span class="hljs-comment">// Exception in thread &quot;main&quot; java.io.FileNotFoundException: myfile.txt (系统找不到指定的文件。)</span><br><span class="hljs-comment">//	at java.base/java.io.FileInputStream.open0(Native Method)</span><br><span class="hljs-comment">//	at java.base/java.io.FileInputStream.open(FileInputStream.java:213)</span><br><span class="hljs-comment">//	at java.base/java.io.FileInputStream.&lt;init&gt;(FileInputStream.java:152)</span><br><span class="hljs-comment">//	at java.base/java.io.FileInputStream.&lt;init&gt;(FileInputStream.java:106)</span><br><span class="hljs-comment">//	at Test.main(Test.java:6)</span><br></code></pre></td></tr></table></figure>
<h4 id="throw与创建自定义异常类">6 throw与创建自定义异常类</h4>
<ul>
<li>throw抛出<strong>用户自定义异常</strong>。</li>
<li>用户定义的异常必须由<strong>用户自己抛出</strong>
<code>&lt;throw&gt;&lt;异常对象&gt;</code>
<code>throw new MyException</code></li>
<li>程序会在throw语句处立即终止，转向 try…catch 寻找异常处理方法。</li>
<li>语句格式 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;class&gt;&lt;自定义异常名&gt;extends&lt;Exception&gt;&#123;<br>	<span class="hljs-keyword">public</span> String to <span class="hljs-title function_">string</span><span class="hljs-params">()</span>&#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;myException&quot;</span>;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<p><img src="/img/LE-OOP1/27.png" srcset="/img/loading.gif" lazyload /> <img src="/img/LE-OOP1/28.png" srcset="/img/loading.gif" lazyload />
<img src="/img/LE-OOP1/29.png" srcset="/img/loading.gif" lazyload /></p>
<h3 id="图形界面-11">图形界面 11</h3>
<p>看PPT去</p>
<h3 id="java-io-12">Java IO 12</h3>
<h5 id="scanner">scanner</h5>
<ul>
<li><p>Scanner的作用：通过分隔符模式将输入分解为标记，默认情况下该分隔符模式与空白匹配。</p></li>
<li><p>通过Scanner 类的 <code>next()</code> 与 <code>nextLine()</code>
方法获取输入的字符串，在读取前我们一般需要使用 <code>hasNext</code> 与
<code>hasNextLine</code> 判断是否还有输入的数据</p></li>
<li><p><strong>Scanner</strong> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);  <br><span class="hljs-keyword">while</span>(scanner.hasNextDouble())&#123;  <br>    <span class="hljs-type">double</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> scanner.nextDouble();  <br>&#125;<br></code></pre></td></tr></table></figure></p></li>
<li><p><strong>转换大小写</strong>： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">original</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello, World!&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">uppercase</span> <span class="hljs-operator">=</span> original.toUpperCase();<br><span class="hljs-type">String</span> <span class="hljs-variable">lowercase</span> <span class="hljs-operator">=</span> original.toLowerCase();<br></code></pre></td></tr></table></figure></p></li>
<li><p><strong>替换字符串</strong>： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">original</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello, World!&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">replaced</span> <span class="hljs-operator">=</span> original.replace(<span class="hljs-string">&quot;World&quot;</span>, <span class="hljs-string">&quot;Java&quot;</span>);<br></code></pre></td></tr></table></figure></p></li>
<li><p><strong>分割字符串</strong>： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">original</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;one,two,three&quot;</span>;<br>String[] parts = original.split(<span class="hljs-string">&quot;,&quot;</span>);<br></code></pre></td></tr></table></figure></p></li>
<li><p><strong>连接字符串</strong>： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">part1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello, &quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">part2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;World!&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">combined</span> <span class="hljs-operator">=</span> part1 + part2;<br></code></pre></td></tr></table></figure></p></li>
<li><p><strong>格式化字符串</strong>： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">number</span> <span class="hljs-operator">=</span> <span class="hljs-number">42</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">formatted</span> <span class="hljs-operator">=</span> String.format(<span class="hljs-string">&quot;The answer is %d&quot;</span>, number);<br></code></pre></td></tr></table></figure></p></li>
<li><p>输入流：输入数据流只能读,不能写</p>
<ul>
<li>字节流：Java中的输入数据流(字节流)都是抽象类<strong>InputStream</strong>的子类；</li>
<li>字符流：Java中的输入数据流(字符流)都是抽象类<strong>Reader</strong>的子类；</li>
</ul></li>
<li><p>输出流：输出数据流只能写,不能读</p>
<ul>
<li>字节流:java中的输出数据流(字节流)都是抽象类<strong>OutputStream</strong>的子类；</li>
<li>字符流:java中的输出数据流(字符流)都是抽象类<strong>Writer</strong>的子类；</li>
</ul></li>
<li><p>字节流可以操作所有类型的文件；</p></li>
<li><p>字符流只能操作<strong>纯文本文件</strong>；</p></li>
</ul>
<p><img src="/img/LE-OOP1/42.png" srcset="/img/loading.gif" lazyload /> <img src="/img/LE-OOP1/43.png" srcset="/img/loading.gif" lazyload />
<img src="/img/LE-OOP1/44.png" srcset="/img/loading.gif" lazyload /> <img src="/img/LE-OOP1/45.png" srcset="/img/loading.gif" lazyload /></p>
<h4 id="其他-io-nio-nio2">其他 IO NIO NIO2</h4>
<ul>
<li>IO流（同步、阻塞）</li>
<li>NIO（同步、非阻塞）:NIO(NEW IO)用到块，效率比IO高很多 三个组件：
<ul>
<li>Channels（通道）：<strong>流是单向的，Channel是双向的</strong>，既可以读又可以写，Channel可以进行异步的读写，对Channel的读写必须通过<strong>buffer</strong>对象</li>
<li>Buffer（缓冲区）</li>
<li>Selector（选择器）：Selector是一个对象，它可以注册到很多个Channel上，监听各个Channel上发生的事件，并且能够根据事件情况决定Channel读写。这样，通过一个线程管理多个Channel，就可以处理大量网络连接了</li>
</ul></li>
<li>NIO2(异步、非阻塞)：AIO(Asynchronous IO) ###### 同步与异步</li>
<li>同步:是一种可靠的有序运行机制，进行同步操作时，后续的任务须<strong>等待当前调用返回</strong>，才会进行下一步；</li>
<li>异步：后续任务<strong>不需要等待当前调用返回</strong>，通常依靠事件、回调等机制来实现任务间次序关系；
###### 阻塞与非阻塞</li>
<li>阻塞：在进行读写操作时，当前线程会处于阻塞状态，<strong>无法从事其他任务</strong>。只有当条件就绪才能继续；</li>
<li>非阻塞：不管IO操作是否结束，<strong>直接返回</strong>，相应操作在后台继续处理</li>
</ul>
<h4 id="字节流">字节流</h4>
<h5 id="inputstream">InputStream</h5>
<p><img src="/img/LE-OOP1/46.png" srcset="/img/loading.gif" lazyload /> <strong>简介</strong> +
InputStream是<strong>抽象类</strong>，所以不能通过“new
InputStream()”的方法构造InputStream的实例。但它声明了输入流的基本操作，<strong>包括读取数据(read)、关闭输入流(close)、获取流中可读的字节数(available)、移动读取指针(skip)、标记流中的位置(mark)和重置读取指针(reset)</strong>
等,它的子类一般都重写这些方法。 +
通过构造InputStream子类的实例方式可以获得InputStream类型的实例。</p>
<p><strong>相关函数介绍</strong> +
方法read()提供了三种从流中读数据的方法. + int
read():一次只能读一个字节,抽象方法。 + int read(byte
b[]):一次读多个字节到数组中 + int read(byte[],int off,int len); +
一般available和read()混合使用，这样在读操作前可以知道有多少字符需要读入。
+ mark通常与reset()方法配合使用，可重复读取输入流所指定的字节数据。</p>
<p><strong>分类</strong> +
FileInputStream：用于<strong>从本地文件</strong>中读出数据。 +
ObjectInputStream：用来读取<strong>对象</strong>；要保证对象是<strong>串行化</strong>(Serializable)的（指<strong>对象</strong>通过把自己<strong>转化为一系列字节</strong>，记录字节的<strong>状态数据</strong>，以便再次利用的这个过程；<strong>对不希望串行化的对象要用关键字transient修饰</strong>）
+
PipedIntputStream：用于管道输入/输出时从<strong>管道</strong>中读取数据；管道数据流的两个类一定是<strong>成对</strong>的，<strong>同时使用并相互连接</strong>的，这样才形成一个数据通信管道；管道数据流主要用于<strong>线程间的通信</strong>。
+
SequencedInputStream：用来把<strong>两个或更多</strong>的InputStream输入流对象转换为单个inputStream输入流对象使用。
+
FilterInputStream：提供<strong>将流连接在一起</strong>的能力；<strong>某一时刻只能一个线程访问</strong>它；其子类PushbackInputStream(<strong>读过的一个或几个字节数据退回到输入流中</strong>/<strong>回压别的字节数据</strong>)和BufferedInputStream读取数据时可以对数据进行<strong>缓冲</strong>，这样可以<strong>提高效率</strong>和<strong>增加特殊功能</strong>。
+
DataInputStream实现了java.io包中的DataInput接口，读取数据的同时，可以对数据进行<strong>格式处理</strong>。因此，能用来读取java中的<strong>基本数据类型</strong>。
+ ByteArrayInputStream：包含一个内存缓冲区，用于从内存中读取数据。 +
AudioInputStream：Audio的输入输出 <img src="/img/LE-OOP1/47.png" srcset="/img/loading.gif" lazyload />
##### OutputStream</p>
<p><img src="/img/LE-OOP1/48.png" srcset="/img/loading.gif" lazyload /></p>
<p><strong>简介</strong>
OutputStream是抽象类，所以不能通过“newOutputStream()”的方法构造OutputStream的实例。但它声明了输出流的基本操作，<strong>包括输出数据(write)、关闭输出流(close)、清空缓冲区(flush)等</strong></p>
<p><strong>分类</strong> +
FileOutputStream：用于向<strong>本地文件</strong>中写入数据。 +
PipedOutputStream：用于管道输入/输出时把数据向<strong>管道</strong>输出
+ DataOutputStream：提供了对java的<strong>基本数据类型</strong>的支持 +
PrintStream：提供了<strong>向屏幕输出有格式数据</strong>的很多方法；<strong>System.out</strong>
<strong>为什么PrintStream适合做打印流？</strong> +
它提供了更多的输出成员方法，输出的数据<strong>不必先转换成字符串类型或其它类型</strong>。
+ PrintStream的成员方法一般<strong>不会抛出异常</strong>； +
PrintStream具有<strong>自动强制输出(flush)功能</strong>，即当输出回车换行时，在缓存中的数据会全部自动写入指定的文件或在标准输出窗口中显示</p>
<h4 id="字符流">字符流</h4>
<p><img src="/img/LE-OOP1/49.png" srcset="/img/loading.gif" lazyload /> <img
src="/img/LE-OOP1/50.png" srcset="/img/loading.gif" lazyload /></p>
<ul>
<li>Reader类和Writer类中的大部分方法与InputStream类和OutputStream类中的对应方法名称相同，只是读取或写入的数据是<strong>字符、字符数组和字符串</strong>等。</li>
<li>如果程序读到的数据是不同国家的语言，其编码不同，那么程序应使用Reader和Writer流。
##### InputStreamReader类和OutputStreamWriter类</li>
<li>InputStreamReader类继承自Reader类，通过其read方法从字节输入流中读取一个或多个<strong>字节数据转换为字符数据</strong>，它不是一个缓冲流，因此其<strong>转换的效率并不高</strong>。</li>
<li>OutputStreamWriter类继承自Writer类，其作用是<strong>转变字符输出流为字节流输出</strong>。</li>
<li>InputStreamReader类和OutputStreamWriter类都可以<strong>接一个缓冲流来提高效率</strong>
##### FileReader和FileWriter
FileReader和FileWriter类分别是Reader和Writer子类，他们分别用来从<strong>字符文件读取字符</strong>和<strong>向字符文件输出字符数据</strong>。</li>
</ul>
<h3 id="多线程-13">多线程 13</h3>
<p><img src="/img/LE-OOP1/51.png" srcset="/img/loading.gif" lazyload /> <img src="/img/LE-OOP1/52.png" srcset="/img/loading.gif" lazyload />
#### 1 进程的概念</p>
<ul>
<li><p><strong>程序</strong>（program）：静态的<strong>代码</strong>。</p></li>
<li><p><strong>进程</strong>（process）是程序的一次<strong>执行过程</strong>。</p></li>
<li><p>程序是静态的，进程是动态的。</p></li>
<li><p>不同进程所<strong>占用的系统资源相对独立</strong>；</p></li>
<li><p>属于同一进程的所有线程<strong>共享该进程的系统资源</strong>；</p></li>
<li><p>线程本身既没有入口，也没有出口，其自身也<strong>不能独立运行</strong>，完成其任务后，自动终止，也可以由进程使之强制终止。</p></li>
</ul>
<p>当多线程程序执行时<strong>具有并发执行的多个线程</strong>；</p>
<h5 id="为什么用多线程">为什么用多线程？</h5>
<ul>
<li>速度快：线程之间<strong>共享相同的内存单元</strong>(代码和数据)，因此在线程间切换，不需要很大的系统开销，所以线程之间的<strong>切换速度远远比进程之间快</strong>，线程之间的通信也比进程通信快的多。</li>
<li>CPU利用率高：多个线程轮流抢占CPU资源而运行时，从微观上讲，一个时间里只能有一个作业被执行，在宏观上可使多个作业被同时执行，即等同于要让多台计算机同时工作，使系统资源特别是<strong>CPU的利用率得到提高</strong>，从而可以提高<strong>整个程序的执行效率</strong>。</li>
</ul>
<h4 id="线程的运行">2 线程的运行</h4>
<p>每个线程都有一个独立的程序计数器和方法调用栈（method invocation
stack）： + 栈存简单局部变量，堆存类对象 +
线程运行中需要的资源：CPU、方法区的代码、堆区的数据、栈区的方法调用栈</p>
<h4 id="线程的调度">3 线程的调度</h4>
<h5 id="线程的调度-1">线程的调度</h5>
<ul>
<li>在Java中，线程调度通常是<strong>抢占式</strong>(即哪一个线程先抢到CPU资源则先运行)，而不是<strong>分时间片式</strong>。</li>
<li>一旦一个线程获得执行权，这个线程将<strong>持续运行下去</strong>，直到它运行结束或因为某种原因而阻塞，或者有另一个高优先级线程就绪（这种情况称为<strong>低优先级线程被高优先级线程所抢占</strong>）。</li>
<li>所有被阻塞的线程按次序排列，组成一个<strong>阻塞队列</strong>。</li>
<li>所有就绪但没有运行的线程则根据其优先级排入一个<strong>就绪队列</strong>。</li>
<li>当CPU空闲时，如果就绪队列不空，就绪队列中第一个具有最高优先级的线程将运行。</li>
<li>当一个线程被抢占而停止运行时，它的运行态被改变并放到就绪队列的队尾；</li>
<li>一个被阻塞（可能因为睡眠或等待I/O设备）的线程就绪后通常也放到就绪队列的队尾</li>
</ul>
<h5 id="优先级">优先级</h5>
<p>线程的调度是按： 1. 其优先级的高低顺序执行的； 2.
同样优先级的线程遵循“先到先执行的原则”</p>
<p><strong>线程优先级</strong> + 范围 1~10 （10 级）。数值越大，级别越高
+ Thread 类定义的 3 个常数： + MIN_PRIORITY 最低(小)优先级（值为1） +
MAX_PRIORITY 最高(大)优先级（值为10） + NORM_PRIORITY
默认优先级（值为5） + 线程创建时，<strong>继承父线程的优先级</strong>。
+ 常用方法： + getPriority( )：获得线程的优先级 + setPriority(
)：设置线程的优先级</p>
<h5 id="主线程">主线程</h5>
<ul>
<li>main( ) 方法：每当用java命令启动一个Java虚拟机进程（ Application
应用程序），Java虚拟机就会创建一个主线程，该线程<strong>从程序入口main()方法开始执行</strong>。</li>
<li>当在主线程中创建 Thread
类或其子类对象时，就创建了一个线程对象。主线程就是<strong>上述创建线程的父线程</strong>。</li>
<li>Programmer可以控制线程的启动、挂起与终止。</li>
</ul>
<h5 id="线程的状态">线程的状态</h5>
<p>新建、就绪、运行、阻塞、终止 + 新建：当一个 Thread
类或其子类对象<strong>被创建时</strong>，新产生的线程处于新建状态，此时它已经有了<strong>相应的内存空间和其他资源</strong>。
+ 就绪：调用 <strong>start( )</strong>
方法来启动处于新建状态的线程后，将进入线程队列排队等待 CPU
服务，此时它已经具备了运行的条件，<strong>一旦轮到它来享用 CPU
资源时，就可以脱离创建它的主线程，开始自己的生命周期</strong>。 +
运行：当就绪状态的线程被调度并获得处理器资源时，便进入运行状态。 +
每一个 Thread 类及其子类的对象都有一个重要的 run( )
方法，当线程对象被调用执行时，它将自动调用本对象的 run(
)方法，从第一句开始顺序执行。 + <strong>run( )</strong>
方法定义了这个线程的操作和功能。 +
阻塞：一个正在执行的线程暂停自己的执行而进入的状态。引起线程由运行状态进入阻塞状态的可能情况：
+ 该线程正在等待 I/O 操作的完成：<strong>等待 I/O
操作完成或回到就绪状态</strong> + 网络操作 + 为了获取锁而进入阻塞操作 +
调用了该线程的 sleep( )
方法：等待其指定的休眠事件结束后，<strong>自动脱离阻塞状态</strong>，回到就绪状态
+ 调用了 wait( ) 方法：调用 <strong>notify</strong>( )或
<strong>notifyAll</strong>( ) 方法； +
让处于运行状态的线程调用另一个线程的join()方法 + 终止： +
自然终止：线程完成了自己的全部工作 +
强制终止：在线程执行完之前，调用stop( ) 或 destroy( ) 方法终止线程</p>
<h4 id="创建和启动线程">4 创建和启动线程</h4>
<p>Java中实现多线程有三种方法： + 一种是继承Thread类； +
第二种是实现Runnable接口； + 第三种是实现Callable接口；</p>
<h5 id="thread构造方法">Thread构造方法</h5>
<p><img src="/img/LE-OOP1/53.png" srcset="/img/loading.gif" lazyload /> +
一个线程的创建肯定是由另一个线程完成的； +
被创建线程的父线程是创建它的线程； +
main线程由JVM创建，而main线程又可以成为其他线程的父线程； +
如果一个线程创建的时候没有指定ThreadGroup，那么将会和父线程同一个ThreadGroup。main线程所在的ThreadGroup称为main；</p>
<h5 id="thread常用方法">Thread常用方法</h5>
<p><img src="/img/LE-OOP1/54.png" srcset="/img/loading.gif" lazyload /> <img src="/img/LE-OOP1/55.png" srcset="/img/loading.gif" lazyload />
<img src="/img/LE-OOP1/56.png" srcset="/img/loading.gif" lazyload /></p>
<h5 id="tips">tips</h5>
<p>因为Java线程的调度不是分时的，所以你必须确保你的代码中的线程会<strong>不时地给另外一个线程运行的机会</strong>。有三种方法可以做到一点：
+ 让处于运行状态的线程调用 <strong>Thread.sleep()</strong> 方法。 +
让处于运行状态的线程调用 <strong>Thread.yield()</strong> 方法。 +
让处于运行状态的线程调用另一个线程的 <strong>join()</strong> 方法。
###### sleep与yield + 这两个方法都是静态的实例方法。 +
sleep()会有<strong>中断异常抛出</strong>，而yiled()不抛出任何异常。 +
sleep()方法具有更好的<strong>可移植性</strong>，因为yield()的实现还取决于底层的操作系统对线程的调度策略。
+
对于yield()的主要用途是在<strong>测试阶段</strong>，<strong>人为的提高程序的并发性能，以帮助发现一些隐藏的并发错误</strong>，当程序正常运行时，则不能依靠yield方法提高程序的并发行能。
###### wait与sleep +
所以，wait,notify和notifyAll都是与同步相关联的方法,只有在synchronized方法中才可以用。在不同步的方法或代码中则使用sleep()方法使线程暂时停止运行
###### join
作用：使当前正在运行的线程暂停下来，<strong>等待指定的时间后</strong>或<strong>等待调用该方法的线程结束后</strong>，再恢复运行
##### 应用线程类Thread创建线程 +
将一个类定义为Thread的子类,那么这个类就可以用来创建线程。 +
这个类中有一个至关重要的方法——<code>public void run</code>，这个方法称为<strong>线程体</strong>，它是整个线程的<strong>核心</strong>，线程所要完成任务的代码都定义在<strong>线程体</strong>中，实际上<strong>不同功能的线程之间的区别就在于它们线程体的不同</strong>
<img src="/img/LE-OOP1/57.png" srcset="/img/loading.gif" lazyload /> ##### 应用Runnable接口创建线程 +
Runnable是Java中用以实现线程的接口，从根本上讲，任何实现线程功能的类都必须实现该接口。
+ Thread(Runnable target); + Thread(Runnable target, String name); +
Runnable接口中只定义了一个方法就是run()方法，也就是线程体 ######
适用于采用实现Runnable接口方法的情况 +
避免<strong>单继承</strong>的局限：因为Java只允许单继承，如果一个类已经继承了Thread，就不能再继承其他类。
+
特别是在除了<strong>run()方法</strong>以外,并不打算重写Thread类的其它方法的情况下,以实现Runnable接口的方式生成新线程就显得更加合理了。
+ 涉及到数据共享的时候； ##### 终止线程 +
当线程执行完run()方法，它将自然终止运行。 +
Thread有一个stop()方法，可以强制结束线程，但这种方法是不安全的。因此，在stop()方法已经被废弃。
+
实际编程中，一般是定义一个标志变量，然后通过程序来改变标志变量的值，从而控制线程从run()方法中自然退出</p>
<h5 id="总结创建用户多线程的步骤">总结：创建用户多线程的步骤</h5>
<p>法1 <img src="/img/LE-OOP1/58.png" srcset="/img/loading.gif" lazyload /></p>
<p>法2 <img src="/img/LE-OOP1/59.png" srcset="/img/loading.gif" lazyload /></p>
<p>法3 <img src="/img/LE-OOP1/60.png" srcset="/img/loading.gif" lazyload /></p>
<ul>
<li>在程序开发中只要是多线程<strong>尽量以实现Runnable接口为主</strong>，因为实现Runnable接口相比继承Thread类有如下好处：
<ul>
<li>避免单继承的局限，一个类可以实现多个接口。</li>
<li>适合于资源的共享</li>
</ul></li>
<li>Runnable的局限性
<ul>
<li><code>run()</code> 方法的返回值是void</li>
<li>不允许抛出任何已检查的异常（编译时捕获的异常）</li>
</ul></li>
</ul>
<h5 id="callable接口">Callable接口</h5>
<h6 id="实现callable接口的步骤">实现callable接口的步骤</h6>
<p><img src="/img/LE-OOP1/61.png" srcset="/img/loading.gif" lazyload /> <img src="/img/LE-OOP1/62.png" srcset="/img/loading.gif" lazyload />
###### callable接口的特点 <img src="/img/LE-OOP1/63.png" srcset="/img/loading.gif" lazyload /> +
运行Callable任务可以拿到一个Future对象，表示异步计算的结果。它提供了检查计算是否完成的方法，以等待计算的完成，并检索计算的结果。通过Future对象<strong>可以了解任务执行情况</strong>，可取消任务的执行，还可获取执行结果。</p>
<h6 id="线程池">线程池</h6>
<p>日常开发中，推荐使用<strong>线程池</strong>的方式来使用。最开始创建一堆线程放在池子里，用的时候拿出来用，不用就放回去，能够减少线程的启动和灭亡</p>
<h5 id="实际工作中如何选择">实际工作中如何选择</h5>
<ul>
<li>取舍的基本原则就是需不需要<strong>返回值</strong>，如果不需要返回值，那直接就选
Runnable。如果有返回值的话，使用Callable。</li>
<li>另外一点就是是否需要<strong>抛出异常</strong>，
Runnable是不接受抛出异常的，Callable可以抛出异常。</li>
<li>Runnable适合那种纯异步的处理逻辑。比如每天定时计算报表，将报表存储到数据库或者其他地方，只是要计算，<strong>不需要马上展示</strong>，展示内容是在其他的方法中单独获取的。（比如那些非核心的功能，当核心流程执行完毕后，非核心功能就自己去执行）</li>
<li>Callable适用于那些需要返回值或者需要抛出checked
exception的情况，比如对某个任务的计算结果进行处理。在Java中，常常使用callable来实现异步任务的处理，以提高系统的吞吐量和响应速度</li>
</ul>
<h3 id="网络编程-14">网络编程 14</h3>
<h6 id="计算机网络工作模式">计算机网络工作模式</h6>
<ul>
<li>客户机/服务器模式(Client/Server C/S) 一共两种
<ul>
<li><strong>数据库服务器端</strong>，客户端<strong>通过数据库连接访问服务器端的数据</strong>；</li>
<li>（本讲内容）<strong>Socket服务器端</strong>，服务器端的程序通过Socket与客户端的程序通信。另，socket服务器端为“<strong>传输层</strong>”，BS模式为“应用层”</li>
</ul></li>
<li>浏览器/服务器模式（Browser/Server）</li>
</ul>
<h6 id="网络通信协议与接口">网络通信协议与接口</h6>
<ul>
<li>网络通信协议：计算机网络中实现通信必须有一些约定</li>
<li>网络通信接口：为了使两个结点之间能进行对话，必须在他们之间建立通信工具(即<strong>接口</strong>)，使彼此之间能进行信息交换，接口包括两部分：
<ul>
<li>硬件装置:实现结点之间的信息传递。</li>
<li>软件装置:规定双方进行通信的约定协议。 <img
src="/img/LE-OOP1/64.png" srcset="/img/loading.gif" lazyload /></li>
</ul></li>
</ul>
<h6 id="uri-包含-url-和-urn">URI 包含 URL 和 URN</h6>
<p><strong>URI</strong>（Uniform Resource
Identifier，统一资源<strong>标识</strong>符）用于唯一地<strong>标识</strong>资源，无论是通过名称、位置还是两者兼有。
<strong>URL</strong>（Uniform Resource
Locator，统一资源<strong>定位</strong>符）是URI的一个子集，它提供了资源的<strong>定位</strong>信息，即如何访问资源，但不直接提供资源的名称。
<strong>URN</strong>（Uniform Resource
Name）是URI的另一个子集，它提供了资源的<strong>名称</strong>，但不提供如何定位或访问资源的信息。URN是持久的、与位置无关的标识符。</p>
<h6 id="tcpip">TCP/IP</h6>
<p><img src="/img/LE-OOP1/65.png" srcset="/img/loading.gif" lazyload /></p>
<h6 id="tcp和udp">TCP和UDP</h6>
<p><img src="/img/LE-OOP1/66.png" srcset="/img/loading.gif" lazyload /></p>
<p><img src="/img/LE-OOP1/67.png" srcset="/img/loading.gif" lazyload /> <img src="/img/LE-OOP1/68.png" srcset="/img/loading.gif" lazyload />
<img src="/img/LE-OOP1/69.png" srcset="/img/loading.gif" lazyload /> <img src="/img/LE-OOP1/70.png" srcset="/img/loading.gif" lazyload /></p>
<h2 id="设计原则7个-7">设计原则(7个) 7</h2>
<p>SOLID合成复用 1. S <strong>Single Responsibility Principle
(单一职责原则)</strong> ：每个类只干一件事 2. O <strong>Open/Closed
Principle (开闭原则)</strong> ：用抽象类和接口而不是if-else 3. L
<strong>Liskov Substitution Principle (里氏代换原则)</strong>
：子类不能改变父类的方法 4. I <strong>Interface Segregation Principle
(接口隔离原则)</strong>
：把总接口拆分成多个接口（防止有的类不需要某个功能但被迫实现） 5. D
<strong>Dependency Inversion Principle (依赖倒转原则)</strong>
：细节(更具体的东西，如email通信)实现抽象(更抽象的东西，如通信)而不是抽象拥有细节
6.
<strong>迪米特法则</strong>：一个软件实体尽量少的与其他实体发生相互作用（找中介）
7. <strong>合成复用原则</strong>：少用继承，用组合/聚合代替继承</p>
<p><img src="/img/LE-OOP1/71.png" srcset="/img/loading.gif" lazyload /> <img src="/img/LE-OOP1/72.png" srcset="/img/loading.gif" lazyload />
<img src="/img/LE-OOP1/73.png" srcset="/img/loading.gif" lazyload /></p>
<h6 id="开闭">开闭</h6>
<p>在Java中，开闭原则可以通过抽象类和接口来实现，这样可以在不修改现有代码的情况下扩展功能。以下是一个简单的Java例子，展示了如何遵循开闭原则。
<strong>不符合开闭原则的例子：</strong> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Rectangle</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">draw</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Drawing a rectangle&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">draw</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Drawing a circle&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GraphicEditor</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">drawShape</span><span class="hljs-params">(Object shape)</span> &#123;<br>        <span class="hljs-keyword">if</span> (shape <span class="hljs-keyword">instanceof</span> Rectangle) &#123;<br>            ((Rectangle) shape).draw();<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (shape <span class="hljs-keyword">instanceof</span> Circle) &#123;<br>            ((Circle) shape).draw();<br>        &#125;<br>        <span class="hljs-comment">// 如果要添加新的图形，比如三角形，需要修改这个方法</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">GraphicEditor</span> <span class="hljs-variable">editor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GraphicEditor</span>();<br>        editor.drawShape(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Rectangle</span>());<br>        editor.drawShape(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Circle</span>());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
在这个例子中，<code>GraphicEditor</code> 类的 <code>drawShape</code>
方法依赖于具体的图形类。如果我们要添加一个新的图形类，比如三角形，我们需要修改
<code>GraphicEditor</code> 类，这违反了开闭原则。
<strong>符合开闭原则的例子：</strong> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Shape</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">draw</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Rectangle</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Shape</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">draw</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Drawing a rectangle&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Shape</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">draw</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Drawing a circle&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GraphicEditor</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">drawShape</span><span class="hljs-params">(Shape shape)</span> &#123;<br>        shape.draw();<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Triangle</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Shape</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">draw</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Drawing a triangle&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">GraphicEditor</span> <span class="hljs-variable">editor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GraphicEditor</span>();<br>        editor.drawShape(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Rectangle</span>());<br>        editor.drawShape(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Circle</span>());<br>        <span class="hljs-comment">// 添加新的图形时，不需要修改GraphicEditor类</span><br>        editor.drawShape(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Triangle</span>());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
在这个改进的例子中，我们定义了一个 <code>Shape</code>
接口，所有的图形类都实现这个接口。<code>GraphicEditor</code> 类的
<code>drawShape</code> 方法现在接受一个 <code>Shape</code>
接口类型的参数，而不是具体的图形类。这样，当我们需要添加新的图形类（如
<code>Triangle</code>）时，我们只需要创建一个新的类实现
<code>Shape</code> 接口，而不需要修改 <code>GraphicEditor</code>
类。这符合开闭原则，因为我们对扩展是开放的，对修改是关闭的。</p>
<h6 id="合成复用1">合成复用1</h6>
<p>当然可以。下面是一个更简单的例子，用于说明合成复用原则：
<strong>场景</strong>：我们有一个表示汽车的类，汽车可以有不同的引擎。而不是通过继承来创建不同类型的汽车，我们使用组合来复用引擎的行为。
<strong>不使用合成复用原则的例子（使用继承）：</strong> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Engine</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Engine starts&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CarWithPetrolEngine</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Engine</span> &#123;<br>    <span class="hljs-comment">// 使用汽油引擎的汽车</span><br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CarWithDieselEngine</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Engine</span> &#123;<br>    <span class="hljs-comment">// 使用柴油引擎的汽车</span><br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">CarWithPetrolEngine</span> <span class="hljs-variable">petrolCar</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CarWithPetrolEngine</span>();<br>        petrolCar.start(); <span class="hljs-comment">// Engine starts</span><br>        <span class="hljs-type">CarWithDieselEngine</span> <span class="hljs-variable">dieselCar</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CarWithDieselEngine</span>();<br>        dieselCar.start(); <span class="hljs-comment">// Engine starts</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
在这个例子中，我们通过继承来创建不同类型的汽车，但这可能导致不必要的复杂性，尤其是当引擎类型增多时。
<strong>使用合成复用原则的例子（使用组合）：</strong> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Engine</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">PetrolEngine</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Engine</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Petrol engine starts&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DieselEngine</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Engine</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Diesel engine starts&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span> &#123;<br>    <span class="hljs-keyword">private</span> Engine engine;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Car</span><span class="hljs-params">(Engine engine)</span> &#123;<br>        <span class="hljs-built_in">this</span>.engine = engine;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">()</span> &#123;<br>        engine.start();<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Car</span> <span class="hljs-variable">petrolCar</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Car</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PetrolEngine</span>());<br>        petrolCar.start(); <span class="hljs-comment">// Petrol engine starts</span><br>        <span class="hljs-type">Car</span> <span class="hljs-variable">dieselCar</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Car</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">DieselEngine</span>());<br>        dieselCar.start(); <span class="hljs-comment">// Diesel engine starts</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
在这个改进的例子中，我们定义了一个 <code>Engine</code> 接口和两个实现类
<code>PetrolEngine</code> 和 <code>DieselEngine</code>。<code>Car</code>
类有一个 <code>Engine</code>
类型的成员变量，并在构造函数中注入具体的引擎。这样，我们可以通过组合不同的引擎来创建不同类型的汽车，而不是通过继承。
这种方法的好处是，如果将来我们有新的引擎类型（例如电动引擎），我们只需要添加一个新的实现类，而不需要修改
<code>Car</code>
类或其子类。这提高了代码的复用性、灵活性和可维护性。</p>
<h6 id="合成复用2">合成复用2</h6>
<p>合成复用原则（Composite Reuse
Principle）是面向对象设计的原则之一，它建议在设计中要尽量使用对象组合，而不是继承来达到复用的目的。该原则强调通过组合不同的对象来获得新的功能，而不是通过继承来扩展类的功能。这样可以减少系统的复杂性，提高灵活性和可维护性。
以下是一个Java例子，展示了如何应用合成复用原则：
<strong>不使用合成复用原则的例子（使用继承）：</strong> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bird</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fly</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Bird is flying&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Sparrow</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Bird</span> &#123;<br>    <span class="hljs-comment">// Sparrow继承了Bird的fly方法</span><br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Penguin</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Bird</span> &#123;<br>    <span class="hljs-comment">// Penguin继承了Bird的fly方法，但企鹅不会飞，这导致了不合理的设计</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fly</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnsupportedOperationException</span>(<span class="hljs-string">&quot;Penguin cannot fly&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Sparrow</span> <span class="hljs-variable">sparrow</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Sparrow</span>();<br>        sparrow.fly(); <span class="hljs-comment">// 合理</span><br>        <span class="hljs-type">Penguin</span> <span class="hljs-variable">penguin</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Penguin</span>();<br>        penguin.fly(); <span class="hljs-comment">// 不合理，抛出异常</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
在这个例子中，<code>Penguin</code> 类继承了 <code>Bird</code>
类，但企鹅不会飞，所以继承导致了不合理的设计。我们需要重写
<code>fly</code> 方法来抛出异常，这违反了合成复用原则。
<strong>使用合成复用原则的例子（使用组合）：</strong> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Flyable</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">fly</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bird</span> &#123;<br>    <span class="hljs-keyword">private</span> Flyable flyable;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Bird</span><span class="hljs-params">(Flyable flyable)</span> &#123;<br>        <span class="hljs-built_in">this</span>.flyable = flyable;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">performFly</span><span class="hljs-params">()</span> &#123;<br>        flyable.fly();<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Sparrow</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Bird</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Sparrow</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">super</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Flyable</span>() &#123;<br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fly</span><span class="hljs-params">()</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;Sparrow is flying&quot;</span>);<br>            &#125;<br>        &#125;);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Penguin</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Bird</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Penguin</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">super</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Flyable</span>() &#123;<br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fly</span><span class="hljs-params">()</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;Penguin cannot fly&quot;</span>);<br>            &#125;<br>        &#125;);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">FlyWithWings</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Flyable</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fly</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Flying with wings&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">NoFly</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Flyable</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fly</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Cannot fly&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Sparrow</span> <span class="hljs-variable">sparrow</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Sparrow</span>();<br>        sparrow.performFly(); <span class="hljs-comment">// 合理</span><br>        <span class="hljs-type">Penguin</span> <span class="hljs-variable">penguin</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Penguin</span>();<br>        penguin.performFly(); <span class="hljs-comment">// 合理，输出&quot;Penguin cannot fly&quot;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
在这个改进的例子中，我们定义了一个 <code>Flyable</code>
接口，表示飞行的能力。<code>Bird</code> 类有一个 <code>Flyable</code>
类型的成员变量，并在构造函数中注入飞行行为。<code>Sparrow</code> 和
<code>Penguin</code>
类通过构造函数分别注入了不同的飞行行为。这样，我们通过组合而不是继承来实现了复用，符合合成复用原则。
通过这种方式，我们可以更容易地添加新的飞行行为或者修改现有的行为，而无需修改
<code>Bird</code>
类或其子类的代码，从而提高了系统的灵活性和可维护性。</p>
<h6 id="依赖倒转">依赖倒转</h6>
<p><strong>依赖倒转原则</strong>（Dependency Inversion
Principle，DIP）是面向对象设计原则之一，也是SOLID原则中的“D”。它主张：
1. 高层模块不应该依赖低层模块，两者都应该依赖抽象。 2.
抽象不应该依赖细节，细节应该依赖抽象。
<strong>简单例子</strong>：假设我们有一个通知系统，最初只通过邮件发送通知。
<strong>违反依赖倒转原则的代码</strong>： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">EmailService</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sendEmail</span><span class="hljs-params">(String message, String recipient)</span> &#123;<br>        <span class="hljs-comment">// 发送邮件的实现</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">NotificationService</span> &#123;<br>    <span class="hljs-keyword">private</span> EmailService emailService;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">NotificationService</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.emailService = <span class="hljs-keyword">new</span> <span class="hljs-title class_">EmailService</span>();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">notify</span><span class="hljs-params">(String message, String recipient)</span> &#123;<br>        emailService.sendEmail(message, recipient);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
在这个例子中，<code>NotificationService</code> 直接依赖于
<code>EmailService</code> 的具体实现，这违反了依赖倒转原则。
<strong>遵循依赖倒转原则的改进代码</strong>： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">NotificationService</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">notify</span><span class="hljs-params">(String message, String recipient)</span>;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">EmailService</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">NotificationService</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">notify</span><span class="hljs-params">(String message, String recipient)</span> &#123;<br>        <span class="hljs-comment">// 发送邮件的实现</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SMSService</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">NotificationService</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">notify</span><span class="hljs-params">(String message, String recipient)</span> &#123;<br>        <span class="hljs-comment">// 发送短信的实现</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">NotificationController</span> &#123;<br>    <span class="hljs-keyword">private</span> NotificationService notificationService;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">NotificationController</span><span class="hljs-params">(NotificationService notificationService)</span> &#123;<br>        <span class="hljs-built_in">this</span>.notificationService = notificationService;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sendNotification</span><span class="hljs-params">(String message, String recipient)</span> &#123;<br>        notificationService.notify(message, recipient);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
在这个改进的例子中，我们引入了 <code>NotificationService</code>
接口，作为抽象。<code>EmailService</code> 和 <code>SMSService</code>
都实现了这个接口。<code>NotificationController</code> 类依赖于
<code>NotificationService</code> 接口，而不是具体的实现。
这样，如果将来我们需要添加新的通知方式（如微信、推送通知等），我们只需要创建新的实现类即可，而不需要修改
<code>NotificationController</code>。这提高了代码的灵活性和可维护性。
<strong>总结</strong>：依赖倒转原则通过依赖抽象而不是具体实现，降低了模块间的耦合度，使得系统更易于扩展和维护。</p>
<h6 id="接口隔离原则">接口隔离原则</h6>
<p>假设我们有一个用于打印文档的接口 <code>Printer</code>，它包含以下方法：
- <code>printDocument()</code> - <code>scanDocument()</code> -
<code>faxDocument()</code> - <code>printPhoto()</code>
现在，我们有几个不同的类实现了这个接口： 1.
<strong>SimplePrinter</strong>：一个基本的打印机，只能打印文档。 2.
<strong>MultiFunctionPrinter</strong>：一个多功能打印机，可以打印、扫描、传真和打印照片。</p>
<p>根据接口隔离原则，<code>SimplePrinter</code> 类不应该被迫实现 <code>scanDocument()</code>、<code>faxDocument()</code> 和 <code>printPhoto()</code> 这些它不需要的方法。这样做会导致 <code>SimplePrinter</code> 类包含冗余的、不相关的代码。</p>
<p>应用接口隔离原则后的改进：
我们可以将 <code>Printer</code> 接口拆分成更小的接口： -
<code>PrintDocumentInterface</code>：包含 <code>printDocument()</code> 方法。
-
<code>ScanDocumentInterface</code>：包含 <code>scanDocument()</code> 方法。
-
<code>FaxDocumentInterface</code>：包含 <code>faxDocument()</code> 方法。
-
<code>PrintPhotoInterface</code>：包含 <code>printPhoto()</code> 方法。
然后，我们的类可以按需实现这些接口： 1.
<strong>SimplePrinter</strong>：实现 <code>PrintDocumentInterface</code>。
2.
<strong>MultiFunctionPrinter</strong>：实现 <code>PrintDocumentInterface</code>、<code>ScanDocumentInterface</code>、<code>FaxDocumentInterface</code> 和 <code>PrintPhotoInterface</code>。</p>
<h6 id="迪米特法则">迪米特法则</h6>
<p>在Java中，迪米特法则（Law of
Demeter）同样强调减少类之间的直接交互，以降低耦合度。以下是一个简单的Java例子，用于说明如何应用迪米特法则。
<strong>场景：</strong>
假设我们有一个订单处理系统，其中包含<code>Order</code>（订单）、<code>Customer</code>（客户）和<code>Payment</code>（支付）等类。
<strong>不符合迪米特法则的设计：</strong> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Order</span> &#123;<br>    <span class="hljs-keyword">private</span> Customer customer;<br>    <span class="hljs-keyword">private</span> Payment payment;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">process</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// Order类直接与Customer和Payment类交互</span><br>        customer.verify();<br>        payment.pay();<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Customer</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">verify</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 客户验证逻辑</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Payment</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pay</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 支付逻辑</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
在这个例子中，<code>Order</code> 类直接调用了 <code>Customer</code> 和
<code>Payment</code> 类的方法，这意味着 <code>Order</code> 类需要了解
<code>Customer</code> 和 <code>Payment</code>
类的内部实现。这违反了迪米特法则。
<strong>符合迪米特法则的设计：</strong>
为了遵守迪米特法则，我们可以引入一个中介者类，例如<code>OrderProcessor</code>，来处理订单处理的逻辑：
我们还可以进一步封装 <code>Order</code> 类，使其不直接暴露
<code>Customer</code> 和 <code>Payment</code>
对象。通过这种方式，我们进一步限制了 <code>Order</code>
类与其他类的直接交互，使得类之间的关系更加清晰，符合迪米特法则。
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Order</span> &#123;<br>    <span class="hljs-keyword">private</span> Customer customer;<br>    <span class="hljs-keyword">private</span> Payment payment;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">process</span><span class="hljs-params">(OrderProcessor processor)</span> &#123;<br>        processor.process(<span class="hljs-built_in">this</span>);<br>    &#125;<br>    <span class="hljs-comment">// 私有方法，用于OrderProcessor访问</span><br>    <span class="hljs-keyword">private</span> Customer <span class="hljs-title function_">getCustomer</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> customer;<br>    &#125;<br>    <span class="hljs-comment">// 私有方法，用于OrderProcessor访问</span><br>    <span class="hljs-keyword">private</span> Payment <span class="hljs-title function_">getPayment</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> payment;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Customer</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">verify</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 客户验证逻辑</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Payment</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pay</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 支付逻辑</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderProcessor</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">process</span><span class="hljs-params">(Order order)</span> &#123;<br>        <span class="hljs-comment">// OrderProcessor负责处理订单，与Customer和Payment类交互</span><br>        order.getCustomer().verify();<br>        order.getPayment().pay();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure> 在这个改进后的设计中，<code>Order</code> 类不再直接与
<code>Customer</code> 和 <code>Payment</code> 类交互，而是通过
<code>OrderProcessor</code> 类来进行。这样，<code>Order</code>
类不需要了解 <code>Customer</code> 和 <code>Payment</code>
类的内部实现，从而减少了类之间的耦合。
迪米特法则的应用有助于创建松耦合、高内聚的类设计，从而提高代码的可维护性和可扩展性。然而，也需要注意不要过度应用，以免导致代码过于复杂或难以理解。</p>
<h6 id="里氏代换原则">里氏代换原则</h6>
<p>里氏代换原则（Liskov Substitution
Principle，LSP）是面向对象设计中的五大原则之一，由芭芭拉·利斯科夫（Barbara
Liskov）在1987年提出。该原则的核心思想是：子类对象应该能够替换其父类对象，而不会导致程序的业务逻辑出现异常。
里氏代换原则强调的是子类和父类之间的兼容性，即子类应该继承父类的所有属性和行为，并且可以在此基础上进行扩展，但不能改变父类原有的行为。这样，在程序中，我们可以放心地使用父类对象的地方替换为子类对象，而不会影响程序的正确性。
以下是一个Java例子，用于说明里氏代换原则： <strong>场景：</strong>
假设我们有一个表示鸟的基类<code>Bird</code>，以及两个子类<code>Sparrow</code>（麻雀）和<code>Ostrich</code>（鸵鸟）。
<strong>不符合里氏代换原则的设计：</strong> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bird</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fly</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;This bird can fly.&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Sparrow</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Bird</span> &#123;<br>    <span class="hljs-comment">// Sparrow继承了Bird的fly方法，可以飞行</span><br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Ostrich</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Bird</span> &#123;<br>    <span class="hljs-comment">// Ostrich也继承了Bird的fly方法，但鸵鸟实际上不会飞</span><br>    <span class="hljs-comment">// 这违反了里氏代换原则，因为Ostrich不能替换Bird而不改变程序的预期行为</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fly</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnsupportedOperationException</span>(<span class="hljs-string">&quot;Ostrich cannot fly.&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Bird</span> <span class="hljs-variable">bird</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Sparrow</span>();<br>        bird.fly(); <span class="hljs-comment">// 正常运行</span><br>        bird = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Ostrich</span>();<br>        bird.fly(); <span class="hljs-comment">// 这里会抛出异常，违反了里氏代换原则</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
在这个例子中，<code>Ostrich</code> 类继承了 <code>Bird</code> 类的
<code>fly</code> 方法，但实际上鸵鸟是不会飞的。当我们尝试用
<code>Ostrich</code> 对象替换 <code>Bird</code> 对象时，调用
<code>fly</code> 方法会抛出异常，这违反了里氏代换原则。
<strong>符合里氏代换原则的设计：</strong>
为了遵守里氏代换原则，我们不应该让 <code>Ostrich</code> 继承
<code>Bird</code> 的 <code>fly</code>
方法。我们可以通过提取接口或使用组合的方式来解决这个问题：
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Flyable</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">fly</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bird</span> &#123;<br>    <span class="hljs-comment">// Bird类不再包含fly方法</span><br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Sparrow</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Bird</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Flyable</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fly</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Sparrow can fly.&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Ostrich</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Bird</span> &#123;<br>    <span class="hljs-comment">// Ostrich不再继承fly方法，因此不会违反里氏代换原则</span><br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Flyable</span> <span class="hljs-variable">flyableBird</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Sparrow</span>();<br>        flyableBird.fly(); <span class="hljs-comment">// 正常运行</span><br>        <span class="hljs-type">Bird</span> <span class="hljs-variable">bird</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Ostrich</span>();<br>        <span class="hljs-comment">// 鸵鸟没有fly方法，但我们也没有期望它能够飞行</span><br>        <span class="hljs-comment">// 这符合里氏代换原则，因为Ostrich可以替换Bird而不改变程序的预期行为</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure> 在这个改进后的设计中，我们引入了 <code>Flyable</code>
接口，只有会飞的鸟（如
<code>Sparrow</code>）才实现这个接口。<code>Ostrich</code> 类不再继承
<code>fly</code>
方法，因此不会违反里氏代换原则。这样，我们可以确保在程序中替换父类对象为子类对象时，不会影响程序的正确性。
里氏代换原则是面向对象设计中的重要原则，它有助于我们设计出更加灵活、可扩展和可维护的代码。通过遵守这个原则，我们可以确保子类和父类之间的兼容性，避免在程序运行时出现意外行为。</p>
<h2 id="设计模式-7">设计模式 7</h2>
<p><img src="/img/LE-OOP1/74.png" srcset="/img/loading.gif" lazyload />
<strong>工厂方法模式</strong>的核心是把类的<strong>实例化延迟到其子类</strong>
被造的东西有个接口、工厂有个接口，被造的东西和工厂分别实现这两个接口，然后工厂类
<code>public Vehicle createVehicle() &#123;  return new Car();&#125;</code>
<strong>适配器模式</strong>的核心是将一个类的接口<strong>转换</strong>成客户希望的另外一个接口
两个接口：原来的东西和新加的东西。类来实现新加的东西的接口。Adapter实现原来的东西的接口，同时拥有新加的东西的接口。
<strong>装饰模式</strong>的核心是<strong>动态</strong>地给对象添加一些额外的职责。
具体组件继承抽象组件；抽象装饰继承抽象组件，同时拥有抽象组件；具体装饰继承抽象装饰，有装饰函数；调用时
<code>Bird bird = new Sparrow; bird = new birdDecorator(bird)</code>
<strong>外观模式</strong>的核心是通过为多个复杂的子系统提供一个<strong>一致的接口</strong>，而使这些子系统<strong>更加容易被访问</strong>的模式。
外观角色拥有子系统123；客户角色依赖外观角色。
<strong>策略模式</strong>的核心是定义<strong>一系列算法</strong>,把它们一个个<strong>封装</strong>起来,并且使它们可<strong>相互替换</strong>。本模式使得算法可独立于使用它的客户而变化。
上下文拥有抽象策略，同时在方法体内调用策略的算法；具体策略实现抽象策略
<strong>访问者模式</strong>的核心是在<strong>不改变各个元素的类</strong>的前提下定义作用于这些元素的<strong>新操作</strong>。
元素、访问者接口；具体元素实现元素接口；具体访问者实现访问者接口；具体元素和集体访问者相互关联
<strong>责任链模式</strong>的关键是将用户的请求<strong>分派给许多对象</strong>。
处理者接口规定具体处理者<strong>处理用户的请求的方法</strong>以及具体处理者<strong>设置后继对象</strong>的方法；具体处理者实现处理者接口；使用时先设置后继对象在调用第一个处理者
<strong>观察者模式</strong>的核心是当一个对象改变状态时，所有依赖于它的对象都会得到通知并自动更新。
被观察者存了一个list表示观察者，观察者存了自己观察的对象。当被观察者发生变化时，通知观察者，观察者更新数据并展示出来
### 单例模式 -
<strong>饿汉式</strong>：类加载时就创建实例，像是一个饥饿的人急于吃东西。
-
<strong>懒汉式</strong>：使用时才创建实例，像是一个懒惰的人等到需要时才行动。
<img src="/img/LE-OOP1/75.png" srcset="/img/loading.gif" lazyload /> <img src="/img/LE-OOP1/76.png" srcset="/img/loading.gif" lazyload />
###### 饿汉式 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;  <br>    <span class="hljs-comment">// 静态的。保留自身的引用，类加载时就初始化  </span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">test</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();  <br>    <span class="hljs-comment">// 必须是私有的构造函数  </span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;&#125;  <br>    <span class="hljs-comment">// 公共的静态方法  </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> test;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure> ###### 懒汉式 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;  <br>    <span class="hljs-comment">// 静态的。保留自身的引用  </span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">test</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;  <br>    <span class="hljs-comment">// 必须是私有的构造函数  </span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;&#125;  <br>    <span class="hljs-comment">// 公共的静态方法  </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">if</span>(test == <span class="hljs-literal">null</span>) &#123;  <br>            test = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();  <br>        &#125;  <br>        <span class="hljs-keyword">return</span> test;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure> ######
多线程安全的懒汉式 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 修改上述代码避免多线程中的安全问题</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">test</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;&#125;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">if</span>(test == <span class="hljs-literal">null</span>) &#123;  <br>	        <span class="hljs-keyword">synchronized</span>(Singleton.class)&#123;<br>		        <span class="hljs-keyword">if</span>(test == <span class="hljs-literal">null</span>)&#123;<br>		            test = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();  <br>		        &#125;<br>	        &#125;<br>        &#125;  <br>        <span class="hljs-keyword">return</span> test;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure> ### 工厂模式
简单工厂：<strong>一个工厂类</strong>，由一<strong>个工厂类根据传入的参数</strong>决定创建哪一种产品类的实例。
工厂方法：<strong>一个工厂接口，一堆工厂类（每种产品都有一个类），一条产品线（产出不同种类的东西）</strong>。工厂方法模式定义了一个创建对象的接口，但<strong>由子类决定要实例化的类是哪一个</strong>。工厂方法模式让类的实例化推迟到子类。
抽象工厂：<strong>一个工厂接口，一堆工厂类（每种产品都有一个类），一堆产品线（每条产品线能产出不同种类的东西）</strong>，提供了一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类。这种模式通常用于系统中有多个<strong>产品族</strong>，且每个产品族都有多个产品等级的情况。</p>
<p>工厂模式（Factory
Pattern）是Java中最常用的设计模式之一。这种模式提供了一种创建对象的最佳方式，通过使用工厂模式，我们可以将对象的创建逻辑与使用逻辑分离，使得客户端代码不依赖于具体类的实现，而是依赖于抽象接口或类。这样，当需要更换或增加新的产品类时，不需要修改客户端代码，提高了代码的可扩展性和可维护性。
工厂模式主要有三种形式： 1. 简单工厂模式（Simple Factory Pattern） 2.
工厂方法模式（Factory Method Pattern） 3. 抽象工厂模式（Abstract Factory
Pattern）
下面以简单工厂模式和工厂方法模式为例，介绍工厂模式在Java中的实现。 #####
简单工厂模式 <img src="/img/LE-OOP1/77.png" srcset="/img/loading.gif" lazyload /> <strong>示例：</strong>
假设我们需要创建不同类型的交通工具，如汽车和自行车。 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 交通工具接口</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Vehicle</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">drive</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-comment">// 汽车类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Vehicle</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">drive</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Driving a car&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 自行车类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bicycle</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Vehicle</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">drive</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Riding a bicycle&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 简单工厂类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">VehicleFactory</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Vehicle <span class="hljs-title function_">createVehicle</span><span class="hljs-params">(String type)</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;car&quot;</span>.equals(type)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Car</span>();<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;bicycle&quot;</span>.equals(type)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bicycle</span>();<br>        &#125;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Unknown vehicle type&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 客户端代码</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SimpleFactoryDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Vehicle</span> <span class="hljs-variable">car</span> <span class="hljs-operator">=</span> VehicleFactory.createVehicle(<span class="hljs-string">&quot;car&quot;</span>);<br>        car.drive();<br>        <span class="hljs-type">Vehicle</span> <span class="hljs-variable">bicycle</span> <span class="hljs-operator">=</span> VehicleFactory.createVehicle(<span class="hljs-string">&quot;bicycle&quot;</span>);<br>        bicycle.drive();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
##### 工厂方法模式 <img src="/img/LE-OOP1/78.png" srcset="/img/loading.gif" lazyload />
<strong>示例：</strong>
继续使用交通工具的例子，但这次我们将工厂类抽象化，并为每种交通工具提供一个具体的工厂类。
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 交通工具接口</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Vehicle</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">drive</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-comment">// 汽车类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Vehicle</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">drive</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Driving a car&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 自行车类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bicycle</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Vehicle</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">drive</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Riding a bicycle&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 工厂接口</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">VehicleFactory</span> &#123;<br>    Vehicle <span class="hljs-title function_">createVehicle</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-comment">// 汽车工厂类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CarFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">VehicleFactory</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Vehicle <span class="hljs-title function_">createVehicle</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Car</span>();<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 自行车工厂类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BicycleFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">VehicleFactory</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Vehicle <span class="hljs-title function_">createVehicle</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bicycle</span>();<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 客户端代码</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FactoryMethodDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">VehicleFactory</span> <span class="hljs-variable">carFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CarFactory</span>();<br>        <span class="hljs-type">Vehicle</span> <span class="hljs-variable">car</span> <span class="hljs-operator">=</span> carFactory.createVehicle();<br>        car.drive();<br>        <span class="hljs-type">VehicleFactory</span> <span class="hljs-variable">bicycleFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BicycleFactory</span>();<br>        <span class="hljs-type">Vehicle</span> <span class="hljs-variable">bicycle</span> <span class="hljs-operator">=</span> bicycleFactory.createVehicle();<br>        bicycle.drive();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure> 在这个例子中，我们定义了一个 <code>VehicleFactory</code>
接口和两个实现该接口的工厂类 <code>CarFactory</code> 和
<code>BicycleFactory</code>。每个工厂类负责创建一种类型的交通工具。客户端代码通过具体的工厂类来创建对象，这样当需要添加新的交通工具时，只需要添加新的工厂类和产品类，而不需要修改现有的代码。
工厂模式在Java中的应用非常广泛，它可以帮助我们更好地组织代码，实现解耦和灵活的对象创建。通过使用工厂模式，我们可以提高代码的可扩展性、可维护性和可测试性。
##### 抽象工厂 <img src="/img/LE-OOP1/79.png" srcset="/img/loading.gif" lazyload />
要将上述代码改写成抽象工厂模式，我们需要定义一个抽象工厂接口，该接口不仅负责创建交通工具，还可能负责创建与交通工具相关的其他产品，比如轮胎（Tire）或引擎（Engine）。这样，每个具体工厂就能创建一个产品家族，而不仅仅是一个产品。
以下是一个简单的示例，展示如何将代码改写成抽象工厂模式： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 交通工具接口</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Vehicle</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">drive</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-comment">// 汽车类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Vehicle</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">drive</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Driving a car&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 自行车类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bicycle</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Vehicle</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">drive</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Riding a bicycle&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 轮胎接口</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Tire</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">roll</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-comment">// 汽车轮胎类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CarTire</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Tire</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">roll</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Car tire rolling&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 自行车轮胎类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BicycleTire</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Tire</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">roll</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Bicycle tire rolling&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 抽象工厂接口</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">VehicleFactory</span> &#123;<br>    Vehicle <span class="hljs-title function_">createVehicle</span><span class="hljs-params">()</span>;<br>    Tire <span class="hljs-title function_">createTire</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-comment">// 汽车工厂类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CarFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">VehicleFactory</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Vehicle <span class="hljs-title function_">createVehicle</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Car</span>();<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Tire <span class="hljs-title function_">createTire</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CarTire</span>();<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 自行车工厂类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BicycleFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">VehicleFactory</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Vehicle <span class="hljs-title function_">createVehicle</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bicycle</span>();<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Tire <span class="hljs-title function_">createTire</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BicycleTire</span>();<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 客户端代码</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractFactoryDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">VehicleFactory</span> <span class="hljs-variable">carFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CarFactory</span>();<br>        <span class="hljs-type">Vehicle</span> <span class="hljs-variable">car</span> <span class="hljs-operator">=</span> carFactory.createVehicle();<br>        <span class="hljs-type">Tire</span> <span class="hljs-variable">carTire</span> <span class="hljs-operator">=</span> carFactory.createTire();<br>        car.drive();<br>        carTire.roll();<br>        <span class="hljs-type">VehicleFactory</span> <span class="hljs-variable">bicycleFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BicycleFactory</span>();<br>        <span class="hljs-type">Vehicle</span> <span class="hljs-variable">bicycle</span> <span class="hljs-operator">=</span> bicycleFactory.createVehicle();<br>        <span class="hljs-type">Tire</span> <span class="hljs-variable">bicycleTire</span> <span class="hljs-operator">=</span> bicycleFactory.createTire();<br>        bicycle.drive();<br>        bicycleTire.roll();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
在这个改写后的例子中，<code>VehicleFactory</code>
接口现在有两个方法：<code>createVehicle</code> 和
<code>createTire</code>。每个具体工厂（<code>CarFactory</code> 和
<code>BicycleFactory</code>）都实现了这两个方法，分别用于创建交通工具和对应的轮胎。这样，每个工厂都能创建一个产品家族，而客户端代码可以通过抽象工厂接口来获取这些相关产品的实例。
抽象工厂模式的关键在于提供一个接口，用于创建多个相关或依赖对象的家族，而不需要明确指定具体类。这样，客户端代码就可以与具体类的实现细节解耦。</p>
<h3 id="原型模式">原型模式</h3>
<p><strong>原型模式（Prototype Pattern）</strong>
在Java中通常用于创建对象的一个副本，而不是通过构造函数重新创建。
<strong>主要角色：</strong> 1.
<strong>Prototype（原型接口）</strong>：声明一个克隆自己的方法。 2.
<strong>ConcretePrototype（具体原型类）</strong>：实现原型接口，实现克隆方法。
3. <strong>Client（客户端）</strong>：使用原型实例来创建新的对象。</p>
<h5 id="示例文档编辑器中的文档复制">示例：文档编辑器中的文档复制</h5>
<p>假设我们有一个文档编辑器，用户可以创建文档，并希望能够复制现有的文档以创建新的文档。这里，文档对象就是一个原型。
1. 定义原型接口 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">DocumentPrototype</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Cloneable</span> &#123;<br>    DocumentPrototype <span class="hljs-title function_">clone</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">setContent</span><span class="hljs-params">(String content)</span>;<br>    String <span class="hljs-title function_">getContent</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure> 2. 实现具体原型类 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TextDocument</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">DocumentPrototype</span> &#123;<br>    <span class="hljs-keyword">private</span> String content;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">TextDocument</span><span class="hljs-params">(String content)</span> &#123;<br>        <span class="hljs-built_in">this</span>.content = content;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> DocumentPrototype <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> (TextDocument) <span class="hljs-built_in">super</span>.clone();<br>        &#125; <span class="hljs-keyword">catch</span> (CloneNotSupportedException e) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setContent</span><span class="hljs-params">(String content)</span> &#123;<br>        <span class="hljs-built_in">this</span>.content = content;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getContent</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> content;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure> 3.
客户端代码使用原型 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DocumentEditor</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 创建一个初始文档</span><br>        <span class="hljs-type">TextDocument</span> <span class="hljs-variable">originalDocument</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TextDocument</span>(<span class="hljs-string">&quot;Hello, World!&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;Original Document Content: &quot;</span> + originalDocument.getContent());<br>        <span class="hljs-comment">// 复制文档</span><br>        <span class="hljs-type">TextDocument</span> <span class="hljs-variable">copiedDocument</span> <span class="hljs-operator">=</span> (TextDocument) originalDocument.clone();<br>        System.out.println(<span class="hljs-string">&quot;Copied Document Content: &quot;</span> + copiedDocument.getContent());<br>        <span class="hljs-comment">// 修改复制后的文档内容</span><br>        copiedDocument.setContent(<span class="hljs-string">&quot;Hello, Prototype Pattern!&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;Modified Copied Document Content: &quot;</span> + copiedDocument.getContent());<br>        <span class="hljs-comment">// 原始文档内容保持不变</span><br>        System.out.println(<span class="hljs-string">&quot;Original Document Content after copy modification: &quot;</span> + originalDocument.getContent());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure> ##### 输出： <figure class="highlight erlang-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs erlang-repl">Original Document Content: Hello, World!<br>Copied Document Content: Hello, World!<br>Modified Copied Document Content: Hello, Prototype Pattern!<br>Original Document Content after copy modification: Hello, World!<br></code></pre></td></tr></table></figure> #####
说明： - <strong>DocumentPrototype</strong>
接口定义了克隆方法，所有具体的文档类都需要实现这个接口。 -
<strong>TextDocument</strong> 类实现了
<strong>DocumentPrototype</strong>
接口，并提供了具体的克隆实现。这里使用了Java的 <code>clone()</code>
方法，它执行的是深拷贝。 - 在 <strong>DocumentEditor</strong>
类中，我们创建了一个文档对象，并使用原型模式复制了这个对象。修改复制后的文档不会影响原始文档。
这个例子展示了如何使用原型模式来复制对象，从而避免了通过构造函数重新创建对象的成本。</p>
<h3 id="适配器模式">适配器模式</h3>
<p><img src="/img/LE-OOP1/80.png" srcset="/img/loading.gif" lazyload /> +
<strong>目标</strong>（Target）：目标是一个接口，该接口是<strong>客户想使用的接口</strong>。
+
<strong>被适配者</strong>（Adaptee）：被适配者是一个已经存在的<strong>接口或抽象类</strong>，这个接口或抽象类需要适配。
+
<strong>适配器</strong>（Adapter）：适配器是一个类，该类实现了目标接口并包含有被适配者的引用，即<strong>适配器的职责是对被适配者接口（抽象类）与目标接口进行适配</strong>。</p>
<h4 id="例1-1">例1</h4>
<p>在Java中，适配器模式通常用于将一个类的接口转换成客户期望的另一个接口，使原本接口不兼容的类可以合作无间。下面通过一个具体的例子来介绍适配器模式的应用。
##### 场景描述
假设我们有一个<code>MediaPlayer</code>接口，它有一个<code>play</code>方法，用于播放音乐文件。目前它只能播放<code>mp3</code>格式的文件。现在我们需要扩展功能，使其能够播放<code>mp4</code>和<code>vlc</code>格式的文件。但是，我们已经有了一些可以播放这些格式的类（<code>Mp4Player</code>和<code>VlcPlayer</code>），它们的接口与<code>MediaPlayer</code>不兼容。这时，我们可以使用适配器模式来解决这个问题。
+ 目标： <code>MediaPlayer</code> + 被适配者：
<code>AdvancedMediaPlayer</code> + 适配器：
<code>MediaAdapter</code></p>
<h5 id="类图">类图</h5>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">+-------------------+       +-------------------+       +-------------------+<br>|<span class="hljs-string"> MediaPlayer       </span>|<span class="hljs-string">       </span>|<span class="hljs-string"> MediaAdapter      </span>|<span class="hljs-string">       </span>|<span class="hljs-string"> AdvancedMediaPlayer</span>|<br>+-------------------+       +-------------------+       +-------------------+<br>|<span class="hljs-string"> +play(String,     </span>|<span class="hljs-string">&lt;&gt;----&gt;</span>|<span class="hljs-string"> -advancedMusicPlayer </span>|<span class="hljs-string">&lt;&gt;----&gt;</span>|<span class="hljs-string"> +playVlc(String)  </span>|<br>|<span class="hljs-string">  String)          </span>|<span class="hljs-string">       </span>|<span class="hljs-string">                    </span>|<span class="hljs-string">       </span>|<span class="hljs-string"> +playMp4(String)  </span>|<br>+-------------------+       +-------------------+       +-------------------+<br>                             |<span class="hljs-string"> +play(String,     </span>|<br>                             |<span class="hljs-string">  String)          </span>|<br>                             +-------------------+<br></code></pre></td></tr></table></figure>
<h5 id="代码实现">代码实现</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// MediaPlayer.java  </span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">MediaPlayer</span> &#123; <span class="hljs-comment">// 目标  </span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">play</span><span class="hljs-params">(String audioType, String fileName)</span>;  <br>&#125;  <br><span class="hljs-comment">// AdvancedMediaPlayer.java  </span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">AdvancedMediaPlayer</span> &#123; <span class="hljs-comment">// 被适配者  </span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">playVlc</span><span class="hljs-params">(String fileName)</span>;  <br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">playMp4</span><span class="hljs-params">(String fileName)</span>;  <br>&#125;  <br><span class="hljs-comment">// Mp4Player.java  </span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Mp4Player</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">AdvancedMediaPlayer</span> &#123; <span class="hljs-comment">// 被适配者的具体类  </span><br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">playVlc</span><span class="hljs-params">(String fileName)</span> &#123;  <br>        <span class="hljs-comment">// Do nothing  </span><br>    &#125;  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">playMp4</span><span class="hljs-params">(String fileName)</span> &#123;  <br>        System.out.println(<span class="hljs-string">&quot;Playing mp4 file. Name: &quot;</span> + fileName);  <br>    &#125;  <br>&#125;  <br><span class="hljs-comment">// VlcPlayer.java  </span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">VlcPlayer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">AdvancedMediaPlayer</span> &#123; <span class="hljs-comment">// 被适配者的具体类  </span><br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">playVlc</span><span class="hljs-params">(String fileName)</span> &#123;  <br>        System.out.println(<span class="hljs-string">&quot;Playing vlc file. Name: &quot;</span> + fileName);  <br>    &#125;  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">playMp4</span><span class="hljs-params">(String fileName)</span> &#123;  <br>        <span class="hljs-comment">// Do nothing  </span><br>    &#125;  <br>&#125;  <br><span class="hljs-comment">// MediaAdapter.java  </span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MediaAdapter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MediaPlayer</span> &#123; <span class="hljs-comment">// 适配器  </span><br>    AdvancedMediaPlayer advancedMusicPlayer;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MediaAdapter</span><span class="hljs-params">()</span> &#123;&#125;  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">play</span><span class="hljs-params">(String audioType, String fileName)</span> &#123;  <br>        <span class="hljs-comment">// Inbuilt support to play mp3 music files  </span><br>        <span class="hljs-keyword">if</span> (audioType.equalsIgnoreCase(<span class="hljs-string">&quot;mp3&quot;</span>)) &#123;  <br>            System.out.println(<span class="hljs-string">&quot;Playing mp3 file. Name: &quot;</span> + fileName);  <br>        &#125;  <br>        <span class="hljs-comment">// MediaAdapter is providing support to play other file formats  </span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (audioType.equalsIgnoreCase(<span class="hljs-string">&quot;vlc&quot;</span>)) &#123;  <br>            advancedMusicPlayer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">VlcPlayer</span>();  <br>            advancedMusicPlayer.playVlc(fileName);  <br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (audioType.equalsIgnoreCase(<span class="hljs-string">&quot;mp4&quot;</span>)) &#123;  <br>            advancedMusicPlayer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Mp4Player</span>();  <br>            advancedMusicPlayer.playMp4(fileName);  <br>        &#125; <span class="hljs-keyword">else</span> &#123;  <br>            System.out.println(<span class="hljs-string">&quot;Invalid media. &quot;</span> + audioType + <span class="hljs-string">&quot; format not supported&quot;</span>);  <br>        &#125;  <br>    &#125;  <br>&#125;  <br>  <br><span class="hljs-comment">// Main.java  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>        <span class="hljs-type">MediaAdapter</span> <span class="hljs-variable">audioPlayer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MediaAdapter</span>();  <br>        audioPlayer.play(<span class="hljs-string">&quot;mp3&quot;</span>, <span class="hljs-string">&quot;beyond the horizon.mp3&quot;</span>);  <br>        audioPlayer.play(<span class="hljs-string">&quot;mp4&quot;</span>, <span class="hljs-string">&quot;alone.mp4&quot;</span>);  <br>        audioPlayer.play(<span class="hljs-string">&quot;vlc&quot;</span>, <span class="hljs-string">&quot;far far away.vlc&quot;</span>);  <br>        audioPlayer.play(<span class="hljs-string">&quot;avi&quot;</span>, <span class="hljs-string">&quot;mind me.avi&quot;</span>);  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="输出">输出</h5>
<figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs delphi">Playing mp3 <span class="hljs-keyword">file</span>. <span class="hljs-keyword">Name</span>: beyond the horizon.mp3<br>Playing mp4 <span class="hljs-keyword">file</span>. <span class="hljs-keyword">Name</span>: alone.mp4<br>Playing vlc <span class="hljs-keyword">file</span>. <span class="hljs-keyword">Name</span>: <span class="hljs-keyword">far</span> <span class="hljs-keyword">far</span> away.vlc<br>Invalid media. avi format <span class="hljs-keyword">not</span> supported<br></code></pre></td></tr></table></figure>
<p>在这个例子中，<code>AudioPlayer</code>类实现了<code>MediaPlayer</code>接口，可以播放<code>mp3</code>文件。对于<code>mp4</code>和<code>vlc</code>文件，它使用了一个<code>MediaAdapter</code>来适配<code>AdvancedMediaPlayer</code>接口，从而实现了播放不同格式文件的功能。这样，我们就通过适配器模式实现了接口的转换，使得原本不兼容的类可以一起工作。</p>
<h3 id="装饰模式">装饰模式</h3>
<p><img src="/img/LE-OOP1/81.png" srcset="/img/loading.gif" lazyload /> +
抽象组件（Component）：抽象组件（是抽象类）定义了需要进行装饰的方法。抽象组件就<strong>是“被装饰者”角色</strong>。
+ 具体组件（ConcreteComponent）：具体组件是抽象组件的一个子类。 +
装饰（Decorator）：该角色是抽象组件的一个子类，<strong>是“装饰者”角色</strong>，其作用是装饰具体组件。Decorator角色需要<strong>包含抽象组件的引用</strong>。
+
具体装饰（ConcreteDecotator）：具体装饰是Decorator角色的一个非抽象子类</p>
<p><img src="/img/LE-OOP1/82.png" srcset="/img/loading.gif" lazyload /></p>
<p>抽象组件 <img src="/img/LE-OOP1/83.png" srcset="/img/loading.gif" lazyload /> 具体组件 <img
src="/img/LE-OOP1/84.png" srcset="/img/loading.gif" lazyload /> 装饰 <img src="/img/LE-OOP1/85.png" srcset="/img/loading.gif" lazyload />
具体装饰 <img src="/img/LE-OOP1/86.png" srcset="/img/loading.gif" lazyload /> 模式的使用 <img
src="/img/LE-OOP1/87.png" srcset="/img/loading.gif" lazyload /> <img src="/img/LE-OOP1/88.png" srcset="/img/loading.gif" lazyload />
最后的<code>bird</code> <img src="/img/LE-OOP1/89.png" srcset="/img/loading.gif" lazyload /></p>
<h3 id="外观模式门面模式">外观模式（门面模式）</h3>
<p><img src="/img/LE-OOP1/90.png" srcset="/img/loading.gif" lazyload /> +
外观（Facade）模式又叫作门面模式，是一种通过为多个复杂的子系统提供一个<strong>一致的接口</strong>，而使这些子系统<strong>更加容易被访问</strong>的模式。
+
该模式对外有一个统一接口，外部应用程序不用关心内部子系统的具体细节，这样会大大降低应用程序的复杂度，降低其与子系统的耦合，提高了程序的可维护性。
+ 是“<strong>迪米特法则</strong>”的典型应用 迪米特法则:
一个软件实体应当尽可能少地与其他实体发生相互作用</p>
<p><img src="/img/LE-OOP1/91.png" srcset="/img/loading.gif" lazyload /> <img
src="/img/LE-OOP1/92.png" srcset="/img/loading.gif" lazyload /></p>
<h3 id="策略模式">策略模式</h3>
<p><img src="/img/LE-OOP1/93.png" srcset="/img/loading.gif" lazyload /> +
<strong>策略</strong>（Strategy）：策略是一个<strong>接口</strong>，该接口定义若干个算法标识，即<strong>定义了若干个抽象方法</strong>。<font color="#ff0000">核心就是将类中经常需要变化的部分分割出来，并将每种可能的变化对应地交给抽象类的一个子类或实现接口的一个类去负责，从而让类的设计者不去关心具体实现，避免所设计的类依赖于具体的实现。</font>
+
<strong>上下文</strong>（Context）：上下文是依赖于策略接口的<strong>类</strong>（是面向策略设计的类），即上下文<strong>包含有用策略声明的变量</strong>。上下文中提供一个<strong>方法</strong>，该方<strong>法委托策略变量调用具体策略所实现的策略接口中的方法</strong>。
+
<strong>具体策略</strong>（ConcreteStrategy）：具体策略是<strong>实现策略接口的类</strong>。具体策略实现策略接口所定义的抽象方法，即<strong>给出算法标识的具体算法</strong>。</p>
<p>问题：在多个裁判负责打分的比赛中，每位裁判给选手一个得分，选手的最后得分是根据全体裁判的得分计算出来的。请给出几种计算选手得分的评分方案（策略），对于某次比赛，可以从你的方案中选择一种方案作为本次比赛的评分方案。
+
在这里我们把策略接口命名为：<code>Strategy</code>。在具体应用中，这个角色的名字可以根据具体问题来命名。
+ 在本问题中将上下文命名为 <code>AverageScore</code>，即让
<code>AverageScore</code> 类依赖于 <code>Strategy</code> 接口。 +
每个具体策略负责一系列算法中的一个。</p>
<ul>
<li>策略（ <code>Strategy</code> ） <img
src="/img/LE-OOP1/94.png" srcset="/img/loading.gif" lazyload /></li>
<li>上下文（ <code>Context</code> ） <img
src="/img/LE-OOP1/95.png" srcset="/img/loading.gif" lazyload /></li>
<li>具体策略StrategyA.java <img src="/img/LE-OOP1/96.png" srcset="/img/loading.gif" lazyload /></li>
<li>具体策略StrategyB.java <img src="/img/LE-OOP1/97.png" srcset="/img/loading.gif" lazyload /></li>
<li>模式的使用 <img src="/img/LE-OOP1/98.png" srcset="/img/loading.gif" lazyload /> <img
src="/img/LE-OOP1/99.png" srcset="/img/loading.gif" lazyload /> <img src="/img/LE-OOP1/100.png" srcset="/img/loading.gif" lazyload /></li>
</ul>
<h3 id="访问者模式">访问者模式</h3>
<ul>
<li><strong>模式优点</strong>：在不改变一个集合中的元素的类的情况下，可以增加新的施加于该元素上的新操作。保持一定的扩展性。</li>
<li><strong>使用场景</strong>：需要对集合中的对象进行很多不同的并且不相关的操作，而我们又不想修改对象的类，就可以使用访问者模式。访问者模式可以在Visitor类中集中定义一些关于集合中对象的操作。</li>
</ul>
<p><img src="/img/LE-OOP1/101.png" srcset="/img/loading.gif" lazyload /> +
抽象元素（Element）：一个抽象类，该类定义了接收访问者的accept操作。 +
具体元素（Concrete Element）：Element的子类。 +
抽象访问者（Visitor）：一个接口，该接口定义操作具体元素的方法。 +
具体访问者（Concrete Visitor）：实现Visitor接口的类。</p>
<ul>
<li><p><strong>门诊部</strong>是一个类似于<strong>访问者的对象</strong>，它可以<strong>访问不同类型的病人对象</strong>，例如普通病人、急诊病人、儿科病人等。</p></li>
<li><p><strong>不同类型的病人对象可以有不同的处理方法</strong>，例如看病、输液、检查等。</p></li>
<li><p>门诊部可以对不同类型的病人对象进行不同的操作，而不需要改变病人对象的类层次结构。</p></li>
<li><p>抽象访问者 <img src="/img/LE-OOP1/102.png" srcset="/img/loading.gif" lazyload /></p></li>
<li><p>具体访问者 <img src="/img/LE-OOP1/103.png" srcset="/img/loading.gif" lazyload /></p></li>
<li><p>抽象元素 <img src="/img/LE-OOP1/104.png" srcset="/img/loading.gif" lazyload /></p></li>
<li><p>具体元素 <img src="/img/LE-OOP1/105.png" srcset="/img/loading.gif" lazyload /></p></li>
<li><p>结构对象 <img src="/img/LE-OOP1/106.png" srcset="/img/loading.gif" lazyload /></p></li>
<li><p>测试案例 <img src="/img/LE-OOP1/107.png" srcset="/img/loading.gif" lazyload /></p></li>
</ul>
<h3 id="责任链模式">责任链模式</h3>
<p>责任链模式是使用多个对象处理用户请求的成熟模式，责任链模式的关键是将用户的请求分派给许多对象。</p>
<p><img src="/img/LE-OOP1/108.png" srcset="/img/loading.gif" lazyload /> +
处理者（Handler）：处理者是一个接口，负责规定具体处理者<strong>处理用户的请求的方法</strong>以及具体处理者<strong>设置后继对象</strong>的方法。
+
具体处理者（ConcreteHandler）：具体处理者是实现处理者接口的类的实例。具体处理者通过调用处理者接口规定的方法处理用户的请求，即在接到用户的请求后，处理者将调用接口规定的方法，在执行该方法的过程中，<strong>如果发现能处理用户的请求，就处理有关数据，否则就反馈无法处理的信息给用户，然后将用户的请求传递给自己的后继对象</strong>。</p>
<p><img src="/img/LE-OOP1/109.png" srcset="/img/loading.gif" lazyload /> <img
src="/img/LE-OOP1/110.png" srcset="/img/loading.gif" lazyload /></p>
<p>抽象处理者：领导类 <img src="/img/LE-OOP1/111.png" srcset="/img/loading.gif" lazyload />
具体处理者1：班主任类 <img src="/img/LE-OOP1/112.png" srcset="/img/loading.gif" lazyload />
具体处理者2：系主任类 <img src="/img/LE-OOP1/113.png" srcset="/img/loading.gif" lazyload />
具体处理者：院长类 <img src="/img/LE-OOP1/114.png" srcset="/img/loading.gif" lazyload /> 测试类 <img
src="/img/LE-OOP1/115.png" srcset="/img/loading.gif" lazyload /> dlc：具体处理者4：教务处长类 <img
src="/img/LE-OOP1/116.png" srcset="/img/loading.gif" lazyload /></p>
<h3 id="观察者模式">观察者模式</h3>
<p>被观察者存了一个list表示观察者，观察者存了自己观察的对象
当被观察者发生变化时，通知观察者，观察者更新数据并展示出来</p>
<p>观察者模式（Observer
Pattern）是一种行为设计模式，它定义了对象之间的一对多依赖关系，当一个对象改变状态时，所有依赖于它的对象都会得到通知并自动更新。这种模式在Java中经常用于实现事件处理系统、消息订阅和发布等场景。</p>
<h5 id="场景描述">场景描述</h5>
<p>假设我们有一个天气数据类（<code>WeatherData</code>），它包含了温度、湿度等天气信息。我们希望当天气数据更新时，能够通知多个显示天气信息的界面（如当前天气状况显示、天气统计信息显示等）进行更新。这里可以使用观察者模式来实现。</p>
<h5 id="类图-1">类图</h5>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">+-------------------+       +-------------------+       +-------------------+<br>|<span class="hljs-string"> Observer          </span>|<span class="hljs-string">       </span>|<span class="hljs-string"> Subject           </span>|<span class="hljs-string">       </span>|<span class="hljs-string"> ConcreteObserver  </span>|<br>+-------------------+       +-------------------+       +-------------------+<br>|<span class="hljs-string"> +update()         </span>|<span class="hljs-string">&lt;&gt;----&gt;</span>|<span class="hljs-string"> +registerObserver()</span>|<span class="hljs-string">       </span>|<span class="hljs-string"> +update()         </span>|<br>+-------------------+       |<span class="hljs-string"> +removeObserver()  </span>|<span class="hljs-string">       +-------------------+</span><br><span class="hljs-string">                             </span>|<span class="hljs-string"> +notifyObservers() </span>|<br>                             +-------------------+<br>                                          ^<br>                                          |<span class="hljs-string"></span><br><span class="hljs-string">+-------------------+       +-------------------+</span><br><span class="hljs-string"></span>|<span class="hljs-string"> ConcreteObserver  </span>|<span class="hljs-string">       </span>|<span class="hljs-string"> WeatherData       </span>|<br>+-------------------+       +-------------------+<br>|<span class="hljs-string"> +update()         </span>|<span class="hljs-string">       </span>|<span class="hljs-string"> -observers        </span>|<br>+-------------------+       |<span class="hljs-string"> -temperature      </span>|<br>                             |<span class="hljs-string"> -humidity         </span>|<br>                             |<span class="hljs-string"> -pressure         </span>|<br>                             |<span class="hljs-string"> + measurementsChanged()</span>|<br>                             |<span class="hljs-string"> + registerObserver()  </span>|<br>                             |<span class="hljs-string"> + removeObserver()    </span>|<br>                             |<span class="hljs-string"> + notifyObservers()   </span>|<br>                             +-------------------+<br></code></pre></td></tr></table></figure>
<h5 id="代码实现-1">代码实现</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Observer.java 观察者</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Observer</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(<span class="hljs-type">float</span> temperature, <span class="hljs-type">float</span> humidity, <span class="hljs-type">float</span> pressure)</span>;<br>&#125;<br><span class="hljs-comment">// Subject.java 被观察者</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Subject</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerObserver</span><span class="hljs-params">(Observer o)</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeObserver</span><span class="hljs-params">(Observer o)</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">notifyObservers</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-comment">// DisplayElement.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">DisplayElement</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">display</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-comment">// WeatherData.java 被观察者——天气</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WeatherData</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Subject</span> &#123;<br>    <span class="hljs-keyword">private</span> List&lt;Observer&gt; observers;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">float</span> temperature;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">float</span> humidity;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">float</span> pressure;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">WeatherData</span><span class="hljs-params">()</span> &#123;<br>        observers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerObserver</span><span class="hljs-params">(Observer o)</span> &#123;<br>        observers.add(o);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeObserver</span><span class="hljs-params">(Observer o)</span> &#123;<br>        observers.remove(o);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">notifyObservers</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> (Observer observer : observers) &#123;<br>            observer.update(temperature, humidity, pressure);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">measurementsChanged</span><span class="hljs-params">()</span> &#123;<br>        notifyObservers();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setMeasurements</span><span class="hljs-params">(<span class="hljs-type">float</span> temperature, <span class="hljs-type">float</span> humidity, <span class="hljs-type">float</span> pressure)</span> &#123;<br>        <span class="hljs-built_in">this</span>.temperature = temperature;<br>        <span class="hljs-built_in">this</span>.humidity = humidity;<br>        <span class="hljs-built_in">this</span>.pressure = pressure;<br>        measurementsChanged();<br>    &#125;<br>    <span class="hljs-comment">// Other WeatherData methods here.</span><br>&#125;<br><span class="hljs-comment">// CurrentConditionsDisplay.java 观察者，实现展示功能</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CurrentConditionsDisplay</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Observer</span>, DisplayElement &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">float</span> temperature;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">float</span> humidity;<br>    <span class="hljs-keyword">private</span> Subject weatherData;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">CurrentConditionsDisplay</span><span class="hljs-params">(Subject weatherData)</span> &#123;<br>        <span class="hljs-built_in">this</span>.weatherData = weatherData;<br>        weatherData.registerObserver(<span class="hljs-built_in">this</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(<span class="hljs-type">float</span> temperature, <span class="hljs-type">float</span> humidity, <span class="hljs-type">float</span> pressure)</span> &#123;<br>        <span class="hljs-built_in">this</span>.temperature = temperature;<br>        <span class="hljs-built_in">this</span>.humidity = humidity;<br>        display();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">display</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Current conditions: &quot;</span> + temperature + <span class="hljs-string">&quot;F degrees and &quot;</span> + humidity + <span class="hljs-string">&quot;% humidity&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">// Main.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">WeatherData</span> <span class="hljs-variable">weatherData</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeatherData</span>();<br>        <span class="hljs-type">CurrentConditionsDisplay</span> <span class="hljs-variable">currentDisplay</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CurrentConditionsDisplay</span>(weatherData);<br>        weatherData.setMeasurements(<span class="hljs-number">80</span>, <span class="hljs-number">65</span>, <span class="hljs-number">30.4f</span>);<br>        weatherData.setMeasurements(<span class="hljs-number">82</span>, <span class="hljs-number">70</span>, <span class="hljs-number">29.2f</span>);<br>        weatherData.setMeasurements(<span class="hljs-number">78</span>, <span class="hljs-number">90</span>, <span class="hljs-number">29.2f</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="输出-1">输出</h5>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Current</span> conditions: <span class="hljs-number">80</span>.<span class="hljs-number">0</span>F degrees and <span class="hljs-number">65</span>.<span class="hljs-number">0</span>% humidity<br><span class="hljs-attribute">Current</span> conditions: <span class="hljs-number">82</span>.<span class="hljs-number">0</span>F degrees and <span class="hljs-number">70</span>.<span class="hljs-number">0</span>% humidity<br><span class="hljs-attribute">Current</span> conditions: <span class="hljs-number">78</span>.<span class="hljs-number">0</span>F degrees and <span class="hljs-number">90</span>.<span class="hljs-number">0</span>% humidity<br></code></pre></td></tr></table></figure>
<p>在这个例子中，<code>WeatherData</code>类实现了<code>Subject</code>接口，它有一个观察者列表，用于注册、移除和通知观察者。<code>CurrentConditionsDisplay</code>类实现了<code>Observer</code>和<code>DisplayElement</code>接口，它注册为<code>WeatherData</code>的观察者，并在数据更新时接收通知并显示当前天气状况。
当<code>WeatherData</code>的<code>setMeasurements</code>方法被调用时，它会更新天气数据并调用<code>measurementsChanged</code>方法，后者会通知所有注册的观察者。观察者接收到通知后，会调用它们的<code>update</code>方法来获取新的数据并更新显示。
这样，我们就通过观察者模式实现了当天气数据变化时，自动通知</p>
<h2 id="uml图-7">UML图 7</h2>
<p><img src="/img/LE-OOP1/117.png" srcset="/img/loading.gif" lazyload /> <img
src="/img/LE-OOP1/118.png" srcset="/img/loading.gif" lazyload /></p>
<h2 id="java集合框架-8">Java集合框架 8</h2>
<p><img src="/img/LE-OOP1/119.png" srcset="/img/loading.gif" lazyload /> <img
src="/img/LE-OOP1/120.png" srcset="/img/loading.gif" lazyload /></p>
<p><strong>普通数组的定义</strong>：
<code>int[] a = new int[10];</code></p>
<p><strong>ArrayList</strong>：无序，可重复，长度可变，<strong>遍历元素和随机访问元素效率较高</strong>
<img src="/img/LE-OOP1/121.png" srcset="/img/loading.gif" lazyload /> 数组大小：
<code>site.size()</code></p>
<p><strong>LinkedList</strong>：无序，可重复，FIFO，<strong>插入删除元素效率较高</strong>
<img src="/img/LE-OOP1/122.png" srcset="/img/loading.gif" lazyload /> <img src="/img/LE-OOP1/123.png" srcset="/img/loading.gif" lazyload />
<img src="/img/LE-OOP1/124.png" srcset="/img/loading.gif" lazyload /></p>
<p><strong>HashSet</strong>：无序，不可重复 <img
src="/img/LE-OOP1/125.png" srcset="/img/loading.gif" lazyload /></p>
<p><strong>HashMap</strong>：无序，键（Key）不能重复，值（Value）可以重复
<img src="/img/LE-OOP1/126.png" srcset="/img/loading.gif" lazyload /></p>
<p><strong>重写排序</strong> 如果 <code>a</code> 是 list：
<code>Collection.sort(a)</code> 如果 <code>a</code> 是普通数组：
<code>Arrays.sort(a)</code> <img src="/img/LE-OOP1/127.png" srcset="/img/loading.gif" lazyload /> <img
src="/img/LE-OOP1/128.png" srcset="/img/loading.gif" lazyload /></p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%BB%8F%E9%AA%8C/" class="category-chain-item">学习经验</a>
  
  
    <span>></span>
    
  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%BB%8F%E9%AA%8C/%E5%A4%A7%E4%BA%8C%E4%B8%8A/" class="category-chain-item">大二上</a>
  
  

  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E5%AD%A6%E4%B9%A0%E7%BB%8F%E9%AA%8C/" class="print-no-link">#学习经验</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>【学习经验】OOP复习</div>
      <div>http://example.com/2025/01/10/LE-OOP1/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>Author</div>
          <div>John Doe</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>Posted on</div>
          <div>January 10, 2025</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>Licensed under</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - Attribution">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2025/01/10/LE-ThirdSemester/" title="软院大二上复习资料">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">软院大二上复习资料</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/01/10/LE-suanfabanzi/" title="【学习经验】算法板子">
                        <span class="hidden-mobile">【学习经验】算法板子</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>
  </div>
</div>





  



  



  



  



  


  
  









    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">Keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
    <!-- 备案信息 ICP for China -->
    <div class="beian">
  <span>
    <a href="http://beian.miit.gov.cn/" target="_blank" rel="nofollow noopener">
      京ICP备2024049620号
    </a>
  </span>
  
</div>

  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  
      <script>
        if (!window.MathJax) {
          window.MathJax = {
            tex    : {
              inlineMath: { '[+]': [['$', '$']] }
            },
            loader : {
              load: ['ui/lazy']
            },
            options: {
              renderActions: {
                insertedScript: [200, () => {
                  document.querySelectorAll('mjx-container').forEach(node => {
                    let target = node.parentNode;
                    if (target.nodeName.toLowerCase() === 'li') {
                      target.parentNode.classList.add('has-jax');
                    }
                  });
                }, '', false]
              }
            }
          };
        } else {
          MathJax.startup.document.state(0);
          MathJax.texReset();
          MathJax.typeset();
          MathJax.typesetPromise();
        }

        Fluid.events.registerRefreshCallback(function() {
          if ('MathJax' in window && MathJax.startup.document && typeof MathJax.startup.document.state === 'function') {
            MathJax.startup.document.state(0);
            MathJax.texReset();
            MathJax.typeset();
            MathJax.typesetPromise();
          }
        });
      </script>
    

  <script  src="https://lib.baomitu.com/mathjax/3.2.2/es5/tex-mml-chtml.js" ></script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="/js/leancloud.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">Blog works best with JavaScript enabled</div>
  </noscript>
</body>
</html>
